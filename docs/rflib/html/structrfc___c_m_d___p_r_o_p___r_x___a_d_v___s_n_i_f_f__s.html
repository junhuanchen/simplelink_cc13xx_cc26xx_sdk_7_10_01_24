<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>rflib: rfc_CMD_PROP_RX_ADV_SNIFF_s Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">rflib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">rfc_CMD_PROP_RX_ADV_SNIFF_s Struct Reference<div class="ingroups"><a class="el" href="group__rfc.html">Rfc</a> &raquo; <a class="el" href="group__prop__cmd.html">Prop_cmd</a> &raquo; <a class="el" href="group___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f.html">CMD_PROP_RX_ADV_SNIFF</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Proprietary Mode Advanced Receive Command with Sniff Mode.  
 <a href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cc13x2__cc26x2_2driverlib_2rf__prop__cmd_8h_source.html">rf_prop_cmd.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for rfc_CMD_PROP_RX_ADV_SNIFF_s:</div>
<div class="dyncontent">
<div class="center"><img src="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s__coll__graph.png" border="0" usemap="#rfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s_coll__map" alt="Collaboration graph"/></div>
<map name="rfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s_coll__map" id="rfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s_coll__map">
<area shape="rect" id="node2" href="structdata_queue__t.html" title="Type definition for a data queue. " alt="" coords="5,5,111,32"/>
<area shape="rect" id="node3" href="structrfc__radio_op__s.html" title="rfc_radioOp_s" alt="" coords="135,5,245,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a780a2f78b32302a566d209f56bd18c8d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a780a2f78b32302a566d209f56bd18c8d">commandNo</a></td></tr>
<tr class="memdesc:a780a2f78b32302a566d209f56bd18c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command ID number 0x3809.  <a href="#a780a2f78b32302a566d209f56bd18c8d">More...</a><br /></td></tr>
<tr class="separator:a780a2f78b32302a566d209f56bd18c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61454a3aba4b2bc4516a7b30187d6aaf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a61454a3aba4b2bc4516a7b30187d6aaf">status</a></td></tr>
<tr class="memdesc:a61454a3aba4b2bc4516a7b30187d6aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer telling the status of the command. This value is updated by the radio CPU during operation and may be read by the system CPU at any time.  <a href="#a61454a3aba4b2bc4516a7b30187d6aaf">More...</a><br /></td></tr>
<tr class="separator:a61454a3aba4b2bc4516a7b30187d6aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7db04e40fe8de3400bc8f960321c0be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common__cmd.html#gae7da987ce1d7df565772441645da8279">rfc_radioOp_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab7db04e40fe8de3400bc8f960321c0be">pNextOp</a></td></tr>
<tr class="memdesc:ab7db04e40fe8de3400bc8f960321c0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the next operation to run after this operation is done.  <a href="#ab7db04e40fe8de3400bc8f960321c0be">More...</a><br /></td></tr>
<tr class="separator:ab7db04e40fe8de3400bc8f960321c0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b14251995c0ae3dc12dd12c2b50ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cc13x2__cc26x2_2driverlib_2rf__mailbox_8h.html#af9975defb67093aa9e6235d578cb60ca">ratmr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a50b14251995c0ae3dc12dd12c2b50ff2">startTime</a></td></tr>
<tr class="memdesc:a50b14251995c0ae3dc12dd12c2b50ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute or relative start time (depending on the value of <code>startTrigger</code>)  <a href="#a50b14251995c0ae3dc12dd12c2b50ff2">More...</a><br /></td></tr>
<tr class="separator:a50b14251995c0ae3dc12dd12c2b50ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb0f347de7d7063f9435ecc2217d74"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:ac51bc2204199049a6a1eb0f8e9c891fe"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:ac51bc2204199049a6a1eb0f8e9c891fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#ac51bc2204199049a6a1eb0f8e9c891fe">More...</a><br /></td></tr>
<tr class="separator:ac51bc2204199049a6a1eb0f8e9c891fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1053c154e39e88cd98d4cb9ffedc3e8e"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:a1053c154e39e88cd98d4cb9ffedc3e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#a1053c154e39e88cd98d4cb9ffedc3e8e">More...</a><br /></td></tr>
<tr class="separator:a1053c154e39e88cd98d4cb9ffedc3e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199db7c89a8b39b6e6a352007b01f5e0"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:a199db7c89a8b39b6e6a352007b01f5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#a199db7c89a8b39b6e6a352007b01f5e0">More...</a><br /></td></tr>
<tr class="separator:a199db7c89a8b39b6e6a352007b01f5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37084e62e4606d1f6268aa09a05ecc64"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:a37084e62e4606d1f6268aa09a05ecc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#a37084e62e4606d1f6268aa09a05ecc64">More...</a><br /></td></tr>
<tr class="separator:a37084e62e4606d1f6268aa09a05ecc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb0f347de7d7063f9435ecc2217d74"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aabbb0f347de7d7063f9435ecc2217d74">startTrigger</a></td></tr>
<tr class="memdesc:aabbb0f347de7d7063f9435ecc2217d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identification of the trigger that starts the operation.  <a href="#aabbb0f347de7d7063f9435ecc2217d74">More...</a><br /></td></tr>
<tr class="separator:aabbb0f347de7d7063f9435ecc2217d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b0d0d44e854d4c96c251d1e4c6381b"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a47fdacd11fca4cc7e4fc7592dfdc0e06"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aa59d74dae7674df9b2532d58285c566b">rule</a>:4</td></tr>
<tr class="memdesc:a47fdacd11fca4cc7e4fc7592dfdc0e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition for running next command: Rule for how to proceed.  <a href="#a47fdacd11fca4cc7e4fc7592dfdc0e06">More...</a><br /></td></tr>
<tr class="separator:a47fdacd11fca4cc7e4fc7592dfdc0e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60335e03f6301d203a485eca445c24bf"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a5ad36e9c1e0f9c0cef3c0e790feea6b6">nSkip</a>:4</td></tr>
<tr class="memdesc:a60335e03f6301d203a485eca445c24bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of skips + 1 if the rule involves skipping. 0: same, 1: next, 2: skip next, ...  <a href="#a60335e03f6301d203a485eca445c24bf">More...</a><br /></td></tr>
<tr class="separator:a60335e03f6301d203a485eca445c24bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b0d0d44e854d4c96c251d1e4c6381b"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a85b0d0d44e854d4c96c251d1e4c6381b">condition</a></td></tr>
<tr class="separator:a85b0d0d44e854d4c96c251d1e4c6381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade526d4632e9cb030205956fcedcc4b0"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a3ef448526f2f1ac9ff8ee37b11e28916"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aa3b72c20793ac88643060f8672ebfa7f">bFsOff</a>:1</td></tr>
<tr class="memdesc:a3ef448526f2f1ac9ff8ee37b11e28916"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Keep frequency synth on after command<br />
 1: Turn frequency synth off after command  <a href="#a3ef448526f2f1ac9ff8ee37b11e28916">More...</a><br /></td></tr>
<tr class="separator:a3ef448526f2f1ac9ff8ee37b11e28916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754eee6f185243b37ac10d44b7cb50ab"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a0156620ef69f6629f540c3112ebcb670">bRepeatOk</a>:1</td></tr>
<tr class="memdesc:a754eee6f185243b37ac10d44b7cb50ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: End operation after receiving a packet correctly<br />
 1: Go back to sync search after receiving a packet correctly  <a href="#a754eee6f185243b37ac10d44b7cb50ab">More...</a><br /></td></tr>
<tr class="separator:a754eee6f185243b37ac10d44b7cb50ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0263e698642574d2bbf0f74dedca4788"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a1979c03d4a811da55d5cf9746413fafd">bRepeatNok</a>:1</td></tr>
<tr class="memdesc:a0263e698642574d2bbf0f74dedca4788"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: End operation after receiving a packet with CRC error<br />
 1: Go back to sync search after receiving a packet with CRC error  <a href="#a0263e698642574d2bbf0f74dedca4788">More...</a><br /></td></tr>
<tr class="separator:a0263e698642574d2bbf0f74dedca4788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700129065a7b52720ff4595fd81c4bfa"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#adebe09804ad8162bb96b98756a16363b">bUseCrc</a>:1</td></tr>
<tr class="memdesc:a700129065a7b52720ff4595fd81c4bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not check CRC<br />
 1: Check CRC  <a href="#a700129065a7b52720ff4595fd81c4bfa">More...</a><br /></td></tr>
<tr class="separator:a700129065a7b52720ff4595fd81c4bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5a77ddc1dda9df3af1c9895bf5cfd6"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab2144281d339b13b3f97d57f11ea38d1">bCrcIncSw</a>:1</td></tr>
<tr class="memdesc:a4e5a77ddc1dda9df3af1c9895bf5cfd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not include sync word in CRC calculation<br />
 1: Include sync word in CRC calculation  <a href="#a4e5a77ddc1dda9df3af1c9895bf5cfd6">More...</a><br /></td></tr>
<tr class="separator:a4e5a77ddc1dda9df3af1c9895bf5cfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8415bd5866bd017262eb8450b4721d6"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a8ee33601aeed12e19dc269aa87e58f76">bCrcIncHdr</a>:1</td></tr>
<tr class="memdesc:af8415bd5866bd017262eb8450b4721d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not include header in CRC calculation <br />
 1: Include header in CRC calculation  <a href="#af8415bd5866bd017262eb8450b4721d6">More...</a><br /></td></tr>
<tr class="separator:af8415bd5866bd017262eb8450b4721d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af931b0b5f834ba9593fd83dd4fcd5bf3"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53ad841c5844389e2088157f70826de5">endType</a>:1</td></tr>
<tr class="memdesc:af931b0b5f834ba9593fd83dd4fcd5bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Packet is received to the end if end trigger happens after sync is obtained<br />
 1: Packet reception is stopped if end trigger happens  <a href="#af931b0b5f834ba9593fd83dd4fcd5bf3">More...</a><br /></td></tr>
<tr class="separator:af931b0b5f834ba9593fd83dd4fcd5bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfbe315befae6427a066d1af7883ea3"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab08631f5ab63f0eedbc10d67bc159c86">filterOp</a>:1</td></tr>
<tr class="memdesc:abdfbe315befae6427a066d1af7883ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Stop receiver and restart sync search on address mismatch<br />
 1: Receive packet and mark it as ignored on address mismatch  <a href="#abdfbe315befae6427a066d1af7883ea3">More...</a><br /></td></tr>
<tr class="separator:abdfbe315befae6427a066d1af7883ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade526d4632e9cb030205956fcedcc4b0"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ade526d4632e9cb030205956fcedcc4b0">pktConf</a></td></tr>
<tr class="separator:ade526d4632e9cb030205956fcedcc4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82625a8adc04638c77e20383d49eac10"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:abc3752b3e3c1bf3eb68a1427ffd81978"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a2f8ddae97fa0cc09ea320654b692ca23">bAutoFlushIgnored</a>:1</td></tr>
<tr class="memdesc:abc3752b3e3c1bf3eb68a1427ffd81978"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, automatically discard ignored packets from RX queue.  <a href="#abc3752b3e3c1bf3eb68a1427ffd81978">More...</a><br /></td></tr>
<tr class="separator:abc3752b3e3c1bf3eb68a1427ffd81978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1fe4ffecc17f861689556ac9bc6762"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a442426db9645c114c905b9e61abefba1">bAutoFlushCrcErr</a>:1</td></tr>
<tr class="memdesc:a7c1fe4ffecc17f861689556ac9bc6762"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, automatically discard packets with CRC error from RX queue.  <a href="#a7c1fe4ffecc17f861689556ac9bc6762">More...</a><br /></td></tr>
<tr class="separator:a7c1fe4ffecc17f861689556ac9bc6762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d743a578ba4add6296e46ed45696d8"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab0f0c71d27a518d18c88a29e8c1fd472">__pad0__</a>:1</td></tr>
<tr class="separator:ac4d743a578ba4add6296e46ed45696d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cb817e30a491b67be72e44ebc99614"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aecb8b5223791639e625ba23bf453dbee">bIncludeHdr</a>:1</td></tr>
<tr class="memdesc:af5cb817e30a491b67be72e44ebc99614"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, include the received header or length byte in the stored packet; otherwise discard it.  <a href="#af5cb817e30a491b67be72e44ebc99614">More...</a><br /></td></tr>
<tr class="separator:af5cb817e30a491b67be72e44ebc99614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd7717f94a603ad24d6fd42406ecaa7"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9e4bc1b2c4ed275cfbac07fe18744c5e">bIncludeCrc</a>:1</td></tr>
<tr class="memdesc:a8bd7717f94a603ad24d6fd42406ecaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, include the received CRC field in the stored packet; otherwise discard it.  <a href="#a8bd7717f94a603ad24d6fd42406ecaa7">More...</a><br /></td></tr>
<tr class="separator:a8bd7717f94a603ad24d6fd42406ecaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124ad2898aae8fdec1f9100b61628b6d"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a0fad36a02f5fc16f268c51aaf7640452">bAppendRssi</a>:1</td></tr>
<tr class="memdesc:a124ad2898aae8fdec1f9100b61628b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append an RSSI byte to the packet in the RX queue.  <a href="#a124ad2898aae8fdec1f9100b61628b6d">More...</a><br /></td></tr>
<tr class="separator:a124ad2898aae8fdec1f9100b61628b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7bd03fa1816524e2f0209b649f997b"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a19bb1b401988126e5003e387c173dd94">bAppendTimestamp</a>:1</td></tr>
<tr class="memdesc:a7b7bd03fa1816524e2f0209b649f997b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append a timestamp to the packet in the RX queue.  <a href="#a7b7bd03fa1816524e2f0209b649f997b">More...</a><br /></td></tr>
<tr class="separator:a7b7bd03fa1816524e2f0209b649f997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa17d9a46c7eea3d681bc574923fdd2"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9ad0c999cd156711854615d2e8005269">bAppendStatus</a>:1</td></tr>
<tr class="memdesc:a0aa17d9a46c7eea3d681bc574923fdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append a status byte to the packet in the RX queue.  <a href="#a0aa17d9a46c7eea3d681bc574923fdd2">More...</a><br /></td></tr>
<tr class="separator:a0aa17d9a46c7eea3d681bc574923fdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82625a8adc04638c77e20383d49eac10"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a82625a8adc04638c77e20383d49eac10">rxConf</a></td></tr>
<tr class="memdesc:a82625a8adc04638c77e20383d49eac10"><td class="mdescLeft">&#160;</td><td class="mdescRight">RX configuration.  <a href="#a82625a8adc04638c77e20383d49eac10">More...</a><br /></td></tr>
<tr class="separator:a82625a8adc04638c77e20383d49eac10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bbc98cc7ea0f3d2a51f4bcf83b9669"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a35bbc98cc7ea0f3d2a51f4bcf83b9669">syncWord0</a></td></tr>
<tr class="memdesc:a35bbc98cc7ea0f3d2a51f4bcf83b9669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync word to listen for.  <a href="#a35bbc98cc7ea0f3d2a51f4bcf83b9669">More...</a><br /></td></tr>
<tr class="separator:a35bbc98cc7ea0f3d2a51f4bcf83b9669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b0a4d4bea7d2de6b73286a62f65a71"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a10b0a4d4bea7d2de6b73286a62f65a71">syncWord1</a></td></tr>
<tr class="memdesc:a10b0a4d4bea7d2de6b73286a62f65a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative sync word if non-zero.  <a href="#a10b0a4d4bea7d2de6b73286a62f65a71">More...</a><br /></td></tr>
<tr class="separator:a10b0a4d4bea7d2de6b73286a62f65a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdc3b4642c4282c918498dd2604e4e2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abbdc3b4642c4282c918498dd2604e4e2">maxPktLen</a></td></tr>
<tr class="memdesc:abbdc3b4642c4282c918498dd2604e4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet length for fixed length, maximum packet length for variable length<br />
 0: Unlimited or unknown length.  <a href="#abbdc3b4642c4282c918498dd2604e4e2">More...</a><br /></td></tr>
<tr class="separator:abbdc3b4642c4282c918498dd2604e4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a60e7aef1e0ae382c3c39f16c1ce193"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a6dce120cb2c38833c0d3af4ffcf584f3"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a7de41278abecaac6668aab1a3e59e346">numHdrBits</a>:6</td></tr>
<tr class="memdesc:a6dce120cb2c38833c0d3af4ffcf584f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in header (0&ndash;32)  <a href="#a6dce120cb2c38833c0d3af4ffcf584f3">More...</a><br /></td></tr>
<tr class="separator:a6dce120cb2c38833c0d3af4ffcf584f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8155b01d702212e83835701738307158"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab5685f661080993f42590731a9a73993">lenPos</a>:5</td></tr>
<tr class="memdesc:a8155b01d702212e83835701738307158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of length field in header (0&ndash;31)  <a href="#a8155b01d702212e83835701738307158">More...</a><br /></td></tr>
<tr class="separator:a8155b01d702212e83835701738307158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbe3f4a79d185e74eef2203b1277524"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a15d6b90fce01507c0bc111a383dd255b">numLenBits</a>:5</td></tr>
<tr class="memdesc:afdbe3f4a79d185e74eef2203b1277524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in length field (0&ndash;16)  <a href="#afdbe3f4a79d185e74eef2203b1277524">More...</a><br /></td></tr>
<tr class="separator:afdbe3f4a79d185e74eef2203b1277524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a60e7aef1e0ae382c3c39f16c1ce193"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a4a60e7aef1e0ae382c3c39f16c1ce193">hdrConf</a></td></tr>
<tr class="separator:a4a60e7aef1e0ae382c3c39f16c1ce193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1127a2fc190c69daa1063cd0bedafce"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:ab134892cc1e5710cd239b5d19faa4abb"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a4accfa3276ca4f6d18f4dec423ca8f61">addrType</a>:1</td></tr>
<tr class="memdesc:ab134892cc1e5710cd239b5d19faa4abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Address after header<br />
 1: Address in header  <a href="#ab134892cc1e5710cd239b5d19faa4abb">More...</a><br /></td></tr>
<tr class="separator:ab134892cc1e5710cd239b5d19faa4abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6fda93baa6fb917c1e66a73a371e5d"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a20707407480014d01e40cacb2fa024de">addrSize</a>:5</td></tr>
<tr class="memdesc:aec6fda93baa6fb917c1e66a73a371e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>addrType</code> = 0: Address size in bytes<br />
 If <code>addrType</code> = 1: Address size in bits.  <a href="#aec6fda93baa6fb917c1e66a73a371e5d">More...</a><br /></td></tr>
<tr class="separator:aec6fda93baa6fb917c1e66a73a371e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48816185d17e925037569362904bf7d"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9d82ed63316ea4201d9da6f2a2c4ed76">addrPos</a>:5</td></tr>
<tr class="memdesc:af48816185d17e925037569362904bf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>addrType</code> = 1: Bit position of address in header<br />
 If <code>addrType</code> = 0: Non-zero to extend address with sync word identifier.  <a href="#af48816185d17e925037569362904bf7d">More...</a><br /></td></tr>
<tr class="separator:af48816185d17e925037569362904bf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a4620235554f10d5b7bf66185ed40a"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#affa8163eb8016f21069970d97278a118">numAddr</a>:5</td></tr>
<tr class="memdesc:aa4a4620235554f10d5b7bf66185ed40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of addresses in address list.  <a href="#aa4a4620235554f10d5b7bf66185ed40a">More...</a><br /></td></tr>
<tr class="separator:aa4a4620235554f10d5b7bf66185ed40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1127a2fc190c69daa1063cd0bedafce"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae1127a2fc190c69daa1063cd0bedafce">addrConf</a></td></tr>
<tr class="separator:ae1127a2fc190c69daa1063cd0bedafce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf8662d7e203be38e7409a4b0b2f3c8"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a4cf8662d7e203be38e7409a4b0b2f3c8">lenOffset</a></td></tr>
<tr class="memdesc:a4cf8662d7e203be38e7409a4b0b2f3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed value to add to length field.  <a href="#a4cf8662d7e203be38e7409a4b0b2f3c8">More...</a><br /></td></tr>
<tr class="separator:a4cf8662d7e203be38e7409a4b0b2f3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac4dd38abd2ec0ec1cfc01ee4393ad5"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a99f60ca2657fb4a0936370267b225806"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:a99f60ca2657fb4a0936370267b225806"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#a99f60ca2657fb4a0936370267b225806">More...</a><br /></td></tr>
<tr class="separator:a99f60ca2657fb4a0936370267b225806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ae71ffeb004f4445524e225de14de"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:a831ae71ffeb004f4445524e225de14de"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#a831ae71ffeb004f4445524e225de14de">More...</a><br /></td></tr>
<tr class="separator:a831ae71ffeb004f4445524e225de14de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab392b89f088fad327488b3e18e1a2c61"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:ab392b89f088fad327488b3e18e1a2c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#ab392b89f088fad327488b3e18e1a2c61">More...</a><br /></td></tr>
<tr class="separator:ab392b89f088fad327488b3e18e1a2c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9802d9312620c3c916e08cb3a9b35e61"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:a9802d9312620c3c916e08cb3a9b35e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#a9802d9312620c3c916e08cb3a9b35e61">More...</a><br /></td></tr>
<tr class="separator:a9802d9312620c3c916e08cb3a9b35e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac4dd38abd2ec0ec1cfc01ee4393ad5"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a5ac4dd38abd2ec0ec1cfc01ee4393ad5">endTrigger</a></td></tr>
<tr class="memdesc:a5ac4dd38abd2ec0ec1cfc01ee4393ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger classifier for ending the operation.  <a href="#a5ac4dd38abd2ec0ec1cfc01ee4393ad5">More...</a><br /></td></tr>
<tr class="separator:a5ac4dd38abd2ec0ec1cfc01ee4393ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9cf11ae0f02c8607d13651eae413cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cc13x2__cc26x2_2driverlib_2rf__mailbox_8h.html#af9975defb67093aa9e6235d578cb60ca">ratmr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#afd9cf11ae0f02c8607d13651eae413cf">endTime</a></td></tr>
<tr class="memdesc:afd9cf11ae0f02c8607d13651eae413cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time used together with <code>endTrigger</code> for ending the operation.  <a href="#afd9cf11ae0f02c8607d13651eae413cf">More...</a><br /></td></tr>
<tr class="separator:afd9cf11ae0f02c8607d13651eae413cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932af7ffb66ab4e775e782ed7e280e95"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a932af7ffb66ab4e775e782ed7e280e95">pAddr</a></td></tr>
<tr class="memdesc:a932af7ffb66ab4e775e782ed7e280e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to address list.  <a href="#a932af7ffb66ab4e775e782ed7e280e95">More...</a><br /></td></tr>
<tr class="separator:a932af7ffb66ab4e775e782ed7e280e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba857caba01de75cf29f2ad803e6edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdata_queue__t.html">dataQueue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a8ba857caba01de75cf29f2ad803e6edd">pQueue</a></td></tr>
<tr class="memdesc:a8ba857caba01de75cf29f2ad803e6edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to receive queue.  <a href="#a8ba857caba01de75cf29f2ad803e6edd">More...</a><br /></td></tr>
<tr class="separator:a8ba857caba01de75cf29f2ad803e6edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5804226e78914769cb4e2cafc365a972"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a5804226e78914769cb4e2cafc365a972">pOutput</a></td></tr>
<tr class="memdesc:a5804226e78914769cb4e2cafc365a972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to output structure.  <a href="#a5804226e78914769cb4e2cafc365a972">More...</a><br /></td></tr>
<tr class="separator:a5804226e78914769cb4e2cafc365a972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9650868ca016735221a7c91c3f418b10"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a15c042940bdda52cd5394098c776481f"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae3deaeececcd74404ce8f2de4ed9adaa">bEnaRssi</a>:1</td></tr>
<tr class="memdesc:a15c042940bdda52cd5394098c776481f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, enable RSSI as a criterion.  <a href="#a15c042940bdda52cd5394098c776481f">More...</a><br /></td></tr>
<tr class="separator:a15c042940bdda52cd5394098c776481f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58846bad6cd29a777848f65252eb468c"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a417f68ec3738c24a422274bb16cf03b8">bEnaCorr</a>:1</td></tr>
<tr class="memdesc:a58846bad6cd29a777848f65252eb468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, enable correlation as a criterion.  <a href="#a58846bad6cd29a777848f65252eb468c">More...</a><br /></td></tr>
<tr class="separator:a58846bad6cd29a777848f65252eb468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faf0df56c13e8883a8f91780384da22"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae9728056d9b6de9580744dd92719c65e">operation</a>:1</td></tr>
<tr class="memdesc:a6faf0df56c13e8883a8f91780384da22"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Busy if either RSSI or correlation indicates Busy<br />
 1: Busy if both RSSI and correlation indicates Busy  <a href="#a6faf0df56c13e8883a8f91780384da22">More...</a><br /></td></tr>
<tr class="separator:a6faf0df56c13e8883a8f91780384da22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1df9c4fd567be5183c4ad3ee5b82e1a"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a1aeb4fa3d9b9d914e536331616ee558d">busyOp</a>:1</td></tr>
<tr class="memdesc:aa1df9c4fd567be5183c4ad3ee5b82e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Continue carrier sense on channel Busy<br />
 1: End carrier sense on channel Busy<br />
 For an RX command, the receiver will continue when carrier sense ends, but it will then not end if channel goes Idle  <a href="#aa1df9c4fd567be5183c4ad3ee5b82e1a">More...</a><br /></td></tr>
<tr class="separator:aa1df9c4fd567be5183c4ad3ee5b82e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716e1b486b067d68ecf627fb5a1f95b2"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a577185137282ed5a1c263a0033894c20">idleOp</a>:1</td></tr>
<tr class="memdesc:a716e1b486b067d68ecf627fb5a1f95b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Continue on channel Idle<br />
 1: End on channel Idle  <a href="#a716e1b486b067d68ecf627fb5a1f95b2">More...</a><br /></td></tr>
<tr class="separator:a716e1b486b067d68ecf627fb5a1f95b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be78d15bd624c7c2a52ace7de57421"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a2c58df74a9a931cfb71f6ddf611a224b">timeoutRes</a>:1</td></tr>
<tr class="memdesc:a33be78d15bd624c7c2a52ace7de57421"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Timeout with channel state Invalid treated as Busy<br />
 1: Timeout with channel state Invalid treated as Idle  <a href="#a33be78d15bd624c7c2a52ace7de57421">More...</a><br /></td></tr>
<tr class="separator:a33be78d15bd624c7c2a52ace7de57421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9650868ca016735221a7c91c3f418b10"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9650868ca016735221a7c91c3f418b10">csConf</a></td></tr>
<tr class="separator:a9650868ca016735221a7c91c3f418b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4df2ff058bbbf10b8eac49e5cbcef9"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abf4df2ff058bbbf10b8eac49e5cbcef9">rssiThr</a></td></tr>
<tr class="memdesc:abf4df2ff058bbbf10b8eac49e5cbcef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSSI threshold.  <a href="#abf4df2ff058bbbf10b8eac49e5cbcef9">More...</a><br /></td></tr>
<tr class="separator:abf4df2ff058bbbf10b8eac49e5cbcef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37606136585736cb722a31ade828164d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a37606136585736cb722a31ade828164d">numRssiIdle</a></td></tr>
<tr class="memdesc:a37606136585736cb722a31ade828164d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of consecutive RSSI measurements below the threshold needed before the channel is declared Idle.  <a href="#a37606136585736cb722a31ade828164d">More...</a><br /></td></tr>
<tr class="separator:a37606136585736cb722a31ade828164d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bcf9305442d5c6edd6d5a547686d3a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a86bcf9305442d5c6edd6d5a547686d3a">numRssiBusy</a></td></tr>
<tr class="memdesc:a86bcf9305442d5c6edd6d5a547686d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of consecutive RSSI measurements above the threshold needed before the channel is declared Busy.  <a href="#a86bcf9305442d5c6edd6d5a547686d3a">More...</a><br /></td></tr>
<tr class="separator:a86bcf9305442d5c6edd6d5a547686d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52edb79d6758cc8ef4f18a9b681348a9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a52edb79d6758cc8ef4f18a9b681348a9">corrPeriod</a></td></tr>
<tr class="memdesc:a52edb79d6758cc8ef4f18a9b681348a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of RAT ticks for a correlation observation periods.  <a href="#a52edb79d6758cc8ef4f18a9b681348a9">More...</a><br /></td></tr>
<tr class="separator:a52edb79d6758cc8ef4f18a9b681348a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8353ffb3d6de3ddb4fe3992fc2db558c"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a4a0e7566b41faae88c4b7c892b3b870b"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a330eb55a91308a71e063b928cc776d82">numCorrInv</a>:4</td></tr>
<tr class="memdesc:a4a0e7566b41faae88c4b7c892b3b870b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of subsequent correlation tops with maximum <code>corrPeriod</code> RAT ticks between them needed to go from Idle to Invalid.  <a href="#a4a0e7566b41faae88c4b7c892b3b870b">More...</a><br /></td></tr>
<tr class="separator:a4a0e7566b41faae88c4b7c892b3b870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1592b8bdcc3ec6829caba4b89575a94a"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abfe6cb16f99cc4283b40735288150853">numCorrBusy</a>:4</td></tr>
<tr class="memdesc:a1592b8bdcc3ec6829caba4b89575a94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of subsequent correlation tops with maximum <code>corrPeriod</code> RAT ticks between them needed to go from Invalid to Busy.  <a href="#a1592b8bdcc3ec6829caba4b89575a94a">More...</a><br /></td></tr>
<tr class="separator:a1592b8bdcc3ec6829caba4b89575a94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8353ffb3d6de3ddb4fe3992fc2db558c"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a8353ffb3d6de3ddb4fe3992fc2db558c">corrConfig</a></td></tr>
<tr class="separator:a8353ffb3d6de3ddb4fe3992fc2db558c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbc81d15bcea5820a5277149994c871"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a2484fbdecb3a9bb46e920e21f64e5938"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:a2484fbdecb3a9bb46e920e21f64e5938"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#a2484fbdecb3a9bb46e920e21f64e5938">More...</a><br /></td></tr>
<tr class="separator:a2484fbdecb3a9bb46e920e21f64e5938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec3cd350473d9037d7860e5ea350ceb"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:a4ec3cd350473d9037d7860e5ea350ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#a4ec3cd350473d9037d7860e5ea350ceb">More...</a><br /></td></tr>
<tr class="separator:a4ec3cd350473d9037d7860e5ea350ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f12301f7c9d5942891171c0c310da1"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:a55f12301f7c9d5942891171c0c310da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#a55f12301f7c9d5942891171c0c310da1">More...</a><br /></td></tr>
<tr class="separator:a55f12301f7c9d5942891171c0c310da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e04b6fa350776831e99c3447ea64f0"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:a65e04b6fa350776831e99c3447ea64f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#a65e04b6fa350776831e99c3447ea64f0">More...</a><br /></td></tr>
<tr class="separator:a65e04b6fa350776831e99c3447ea64f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbc81d15bcea5820a5277149994c871"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9cbc81d15bcea5820a5277149994c871">csEndTrigger</a></td></tr>
<tr class="memdesc:a9cbc81d15bcea5820a5277149994c871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger classifier for ending the carrier sense.  <a href="#a9cbc81d15bcea5820a5277149994c871">More...</a><br /></td></tr>
<tr class="separator:a9cbc81d15bcea5820a5277149994c871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4011697ce7cc992786e1aaf67f73b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cc13x2__cc26x2_2driverlib_2rf__mailbox_8h.html#af9975defb67093aa9e6235d578cb60ca">ratmr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#af4011697ce7cc992786e1aaf67f73b57">csEndTime</a></td></tr>
<tr class="memdesc:af4011697ce7cc992786e1aaf67f73b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time used together with <code>csEndTrigger</code> for ending the operation.  <a href="#af4011697ce7cc992786e1aaf67f73b57">More...</a><br /></td></tr>
<tr class="separator:af4011697ce7cc992786e1aaf67f73b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929eeccb001793c0059414d6a90e00d5"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a4da1a916d64c47ce1ad9d8c395ca9981"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:a4da1a916d64c47ce1ad9d8c395ca9981"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#a4da1a916d64c47ce1ad9d8c395ca9981">More...</a><br /></td></tr>
<tr class="separator:a4da1a916d64c47ce1ad9d8c395ca9981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cb4781d7a72fe72c95ac950e173847"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:ab7cb4781d7a72fe72c95ac950e173847"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#ab7cb4781d7a72fe72c95ac950e173847">More...</a><br /></td></tr>
<tr class="separator:ab7cb4781d7a72fe72c95ac950e173847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5fa7c756c30b42ae5f8f967a67aad8"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:a2c5fa7c756c30b42ae5f8f967a67aad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#a2c5fa7c756c30b42ae5f8f967a67aad8">More...</a><br /></td></tr>
<tr class="separator:a2c5fa7c756c30b42ae5f8f967a67aad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf14a2872519bea12ca0a5487e447da2"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:aaf14a2872519bea12ca0a5487e447da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#aaf14a2872519bea12ca0a5487e447da2">More...</a><br /></td></tr>
<tr class="separator:aaf14a2872519bea12ca0a5487e447da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929eeccb001793c0059414d6a90e00d5"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a929eeccb001793c0059414d6a90e00d5">startTrigger</a></td></tr>
<tr class="memdesc:a929eeccb001793c0059414d6a90e00d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identification of the trigger that starts the operation.  <a href="#a929eeccb001793c0059414d6a90e00d5">More...</a><br /></td></tr>
<tr class="separator:a929eeccb001793c0059414d6a90e00d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b15c41b5e2845c0b7d8c5e16d4ebaf1"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:af8ac8dc4c1008a9ac03985d1366786d5"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aa59d74dae7674df9b2532d58285c566b">rule</a>:4</td></tr>
<tr class="memdesc:af8ac8dc4c1008a9ac03985d1366786d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition for running next command: Rule for how to proceed.  <a href="#af8ac8dc4c1008a9ac03985d1366786d5">More...</a><br /></td></tr>
<tr class="separator:af8ac8dc4c1008a9ac03985d1366786d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c1f9d412fdfd145e47a7abae14057a"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a5ad36e9c1e0f9c0cef3c0e790feea6b6">nSkip</a>:4</td></tr>
<tr class="memdesc:a31c1f9d412fdfd145e47a7abae14057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of skips + 1 if the rule involves skipping. 0: same, 1: next, 2: skip next, ...  <a href="#a31c1f9d412fdfd145e47a7abae14057a">More...</a><br /></td></tr>
<tr class="separator:a31c1f9d412fdfd145e47a7abae14057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b15c41b5e2845c0b7d8c5e16d4ebaf1"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9b15c41b5e2845c0b7d8c5e16d4ebaf1">condition</a></td></tr>
<tr class="separator:a9b15c41b5e2845c0b7d8c5e16d4ebaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bda0f76a143924bb02b96d4847c3a0a"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:ac36a292e1545f598233b30e2702819b3"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aa3b72c20793ac88643060f8672ebfa7f">bFsOff</a>:1</td></tr>
<tr class="memdesc:ac36a292e1545f598233b30e2702819b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Keep frequency synth on after command<br />
 1: Turn frequency synth off after command  <a href="#ac36a292e1545f598233b30e2702819b3">More...</a><br /></td></tr>
<tr class="separator:ac36a292e1545f598233b30e2702819b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a8ab56fe2daf45578edb3a69b32b4c"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a0156620ef69f6629f540c3112ebcb670">bRepeatOk</a>:1</td></tr>
<tr class="memdesc:af8a8ab56fe2daf45578edb3a69b32b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: End operation after receiving a packet correctly<br />
 1: Go back to sync search after receiving a packet correctly  <a href="#af8a8ab56fe2daf45578edb3a69b32b4c">More...</a><br /></td></tr>
<tr class="separator:af8a8ab56fe2daf45578edb3a69b32b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790a17bdfa8f49eaeda825e6a5988a81"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a1979c03d4a811da55d5cf9746413fafd">bRepeatNok</a>:1</td></tr>
<tr class="memdesc:a790a17bdfa8f49eaeda825e6a5988a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: End operation after receiving a packet with CRC error<br />
 1: Go back to sync search after receiving a packet with CRC error  <a href="#a790a17bdfa8f49eaeda825e6a5988a81">More...</a><br /></td></tr>
<tr class="separator:a790a17bdfa8f49eaeda825e6a5988a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06768561ee480615ccd6ed8cd0c2e662"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#adebe09804ad8162bb96b98756a16363b">bUseCrc</a>:1</td></tr>
<tr class="memdesc:a06768561ee480615ccd6ed8cd0c2e662"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not check CRC<br />
 1: Check CRC  <a href="#a06768561ee480615ccd6ed8cd0c2e662">More...</a><br /></td></tr>
<tr class="separator:a06768561ee480615ccd6ed8cd0c2e662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7b0ee4cbbf73974d1410a54dfd4595"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab2144281d339b13b3f97d57f11ea38d1">bCrcIncSw</a>:1</td></tr>
<tr class="memdesc:a5b7b0ee4cbbf73974d1410a54dfd4595"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not include sync word in CRC calculation<br />
 1: Include sync word in CRC calculation  <a href="#a5b7b0ee4cbbf73974d1410a54dfd4595">More...</a><br /></td></tr>
<tr class="separator:a5b7b0ee4cbbf73974d1410a54dfd4595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25a6f09aa961f295a58ea0d52cd7ec4"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a8ee33601aeed12e19dc269aa87e58f76">bCrcIncHdr</a>:1</td></tr>
<tr class="memdesc:aa25a6f09aa961f295a58ea0d52cd7ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not include header in CRC calculation <br />
 1: Include header in CRC calculation  <a href="#aa25a6f09aa961f295a58ea0d52cd7ec4">More...</a><br /></td></tr>
<tr class="separator:aa25a6f09aa961f295a58ea0d52cd7ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3ca5bd79356a42bcfc28fa0b33f3c0"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53ad841c5844389e2088157f70826de5">endType</a>:1</td></tr>
<tr class="memdesc:ada3ca5bd79356a42bcfc28fa0b33f3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Packet is received to the end if end trigger happens after sync is obtained<br />
 1: Packet reception is stopped if end trigger happens  <a href="#ada3ca5bd79356a42bcfc28fa0b33f3c0">More...</a><br /></td></tr>
<tr class="separator:ada3ca5bd79356a42bcfc28fa0b33f3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae87c18c80ac31e876d06a353d639f1"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab08631f5ab63f0eedbc10d67bc159c86">filterOp</a>:1</td></tr>
<tr class="memdesc:abae87c18c80ac31e876d06a353d639f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Stop receiver and restart sync search on address mismatch<br />
 1: Receive packet and mark it as ignored on address mismatch  <a href="#abae87c18c80ac31e876d06a353d639f1">More...</a><br /></td></tr>
<tr class="separator:abae87c18c80ac31e876d06a353d639f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bda0f76a143924bb02b96d4847c3a0a"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a2bda0f76a143924bb02b96d4847c3a0a">pktConf</a></td></tr>
<tr class="separator:a2bda0f76a143924bb02b96d4847c3a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63996ff20fb50141fc4bb2c5a09645cb"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a0a6610c7e6f6c5981fa2da2dca263aa7"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a2f8ddae97fa0cc09ea320654b692ca23">bAutoFlushIgnored</a>:1</td></tr>
<tr class="memdesc:a0a6610c7e6f6c5981fa2da2dca263aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, automatically discard ignored packets from RX queue.  <a href="#a0a6610c7e6f6c5981fa2da2dca263aa7">More...</a><br /></td></tr>
<tr class="separator:a0a6610c7e6f6c5981fa2da2dca263aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758fe58f2ddc291c848fbffc17d3880d"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a442426db9645c114c905b9e61abefba1">bAutoFlushCrcErr</a>:1</td></tr>
<tr class="memdesc:a758fe58f2ddc291c848fbffc17d3880d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, automatically discard packets with CRC error from RX queue.  <a href="#a758fe58f2ddc291c848fbffc17d3880d">More...</a><br /></td></tr>
<tr class="separator:a758fe58f2ddc291c848fbffc17d3880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdaf30ec941f019a73b488ea042b91e"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab0f0c71d27a518d18c88a29e8c1fd472">__pad0__</a>:1</td></tr>
<tr class="separator:a1cdaf30ec941f019a73b488ea042b91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aaa8bcf69ebf0903cae33f9c60379a"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aecb8b5223791639e625ba23bf453dbee">bIncludeHdr</a>:1</td></tr>
<tr class="memdesc:a21aaa8bcf69ebf0903cae33f9c60379a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, include the received header or length byte in the stored packet; otherwise discard it.  <a href="#a21aaa8bcf69ebf0903cae33f9c60379a">More...</a><br /></td></tr>
<tr class="separator:a21aaa8bcf69ebf0903cae33f9c60379a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37c57979f6308579b23ff4ec065067a"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9e4bc1b2c4ed275cfbac07fe18744c5e">bIncludeCrc</a>:1</td></tr>
<tr class="memdesc:aa37c57979f6308579b23ff4ec065067a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, include the received CRC field in the stored packet; otherwise discard it.  <a href="#aa37c57979f6308579b23ff4ec065067a">More...</a><br /></td></tr>
<tr class="separator:aa37c57979f6308579b23ff4ec065067a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480479712e8def60dab8e0822b7dbf1f"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a0fad36a02f5fc16f268c51aaf7640452">bAppendRssi</a>:1</td></tr>
<tr class="memdesc:a480479712e8def60dab8e0822b7dbf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append an RSSI byte to the packet in the RX queue.  <a href="#a480479712e8def60dab8e0822b7dbf1f">More...</a><br /></td></tr>
<tr class="separator:a480479712e8def60dab8e0822b7dbf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfced8b07395091e580c7f2b553169d"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a19bb1b401988126e5003e387c173dd94">bAppendTimestamp</a>:1</td></tr>
<tr class="memdesc:acdfced8b07395091e580c7f2b553169d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append a timestamp to the packet in the RX queue.  <a href="#acdfced8b07395091e580c7f2b553169d">More...</a><br /></td></tr>
<tr class="separator:acdfced8b07395091e580c7f2b553169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe590dcc1138691930937a7a1e3972"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9ad0c999cd156711854615d2e8005269">bAppendStatus</a>:1</td></tr>
<tr class="memdesc:adcbe590dcc1138691930937a7a1e3972"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append a status byte to the packet in the RX queue.  <a href="#adcbe590dcc1138691930937a7a1e3972">More...</a><br /></td></tr>
<tr class="separator:adcbe590dcc1138691930937a7a1e3972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63996ff20fb50141fc4bb2c5a09645cb"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a63996ff20fb50141fc4bb2c5a09645cb">rxConf</a></td></tr>
<tr class="memdesc:a63996ff20fb50141fc4bb2c5a09645cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">RX configuration.  <a href="#a63996ff20fb50141fc4bb2c5a09645cb">More...</a><br /></td></tr>
<tr class="separator:a63996ff20fb50141fc4bb2c5a09645cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce004617de27a474dffc827e3864fb"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:ae8ba762a3d98e1bcfec0cf5eb4f435e4"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a7de41278abecaac6668aab1a3e59e346">numHdrBits</a>:6</td></tr>
<tr class="memdesc:ae8ba762a3d98e1bcfec0cf5eb4f435e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in header (0&ndash;32)  <a href="#ae8ba762a3d98e1bcfec0cf5eb4f435e4">More...</a><br /></td></tr>
<tr class="separator:ae8ba762a3d98e1bcfec0cf5eb4f435e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba6b2ed400008622b6a34b22258d8b8"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab5685f661080993f42590731a9a73993">lenPos</a>:5</td></tr>
<tr class="memdesc:afba6b2ed400008622b6a34b22258d8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of length field in header (0&ndash;31)  <a href="#afba6b2ed400008622b6a34b22258d8b8">More...</a><br /></td></tr>
<tr class="separator:afba6b2ed400008622b6a34b22258d8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7eb61d7dba8e1855bf5de51dab852f"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a15d6b90fce01507c0bc111a383dd255b">numLenBits</a>:5</td></tr>
<tr class="memdesc:a5e7eb61d7dba8e1855bf5de51dab852f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in length field (0&ndash;16)  <a href="#a5e7eb61d7dba8e1855bf5de51dab852f">More...</a><br /></td></tr>
<tr class="separator:a5e7eb61d7dba8e1855bf5de51dab852f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce004617de27a474dffc827e3864fb"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a40ce004617de27a474dffc827e3864fb">hdrConf</a></td></tr>
<tr class="separator:a40ce004617de27a474dffc827e3864fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf41d86f3170b9b39ac0ad7b95391673"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:abc6c3b4cf7eac1b342a651588c3bfa2b"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a4accfa3276ca4f6d18f4dec423ca8f61">addrType</a>:1</td></tr>
<tr class="memdesc:abc6c3b4cf7eac1b342a651588c3bfa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Address after header<br />
 1: Address in header  <a href="#abc6c3b4cf7eac1b342a651588c3bfa2b">More...</a><br /></td></tr>
<tr class="separator:abc6c3b4cf7eac1b342a651588c3bfa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a3e49dde07d81b1a9e47889b8db2c6"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a20707407480014d01e40cacb2fa024de">addrSize</a>:5</td></tr>
<tr class="memdesc:ad9a3e49dde07d81b1a9e47889b8db2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>addrType</code> = 0: Address size in bytes<br />
 If <code>addrType</code> = 1: Address size in bits.  <a href="#ad9a3e49dde07d81b1a9e47889b8db2c6">More...</a><br /></td></tr>
<tr class="separator:ad9a3e49dde07d81b1a9e47889b8db2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d18531483c76d709a97f18b5c0681"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9d82ed63316ea4201d9da6f2a2c4ed76">addrPos</a>:5</td></tr>
<tr class="memdesc:acd8d18531483c76d709a97f18b5c0681"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>addrType</code> = 1: Bit position of address in header<br />
 If <code>addrType</code> = 0: Non-zero to extend address with sync word identifier.  <a href="#acd8d18531483c76d709a97f18b5c0681">More...</a><br /></td></tr>
<tr class="separator:acd8d18531483c76d709a97f18b5c0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2566567ff9db5bf1cc0d0711962c5580"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#affa8163eb8016f21069970d97278a118">numAddr</a>:5</td></tr>
<tr class="memdesc:a2566567ff9db5bf1cc0d0711962c5580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of addresses in address list.  <a href="#a2566567ff9db5bf1cc0d0711962c5580">More...</a><br /></td></tr>
<tr class="separator:a2566567ff9db5bf1cc0d0711962c5580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf41d86f3170b9b39ac0ad7b95391673"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#acf41d86f3170b9b39ac0ad7b95391673">addrConf</a></td></tr>
<tr class="separator:acf41d86f3170b9b39ac0ad7b95391673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563740dc5b2075f4bf9f573300dc1f9b"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a7d2e17842c9f3df3c61a4eb15deb15bc"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:a7d2e17842c9f3df3c61a4eb15deb15bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#a7d2e17842c9f3df3c61a4eb15deb15bc">More...</a><br /></td></tr>
<tr class="separator:a7d2e17842c9f3df3c61a4eb15deb15bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be4f445c7eedfb65be02fe60b605d85"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:a7be4f445c7eedfb65be02fe60b605d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#a7be4f445c7eedfb65be02fe60b605d85">More...</a><br /></td></tr>
<tr class="separator:a7be4f445c7eedfb65be02fe60b605d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43745f62acc3fd8ee66dde5d60f8ee2f"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:a43745f62acc3fd8ee66dde5d60f8ee2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#a43745f62acc3fd8ee66dde5d60f8ee2f">More...</a><br /></td></tr>
<tr class="separator:a43745f62acc3fd8ee66dde5d60f8ee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b3ec2955574b16681230af1ee898f3"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:a04b3ec2955574b16681230af1ee898f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#a04b3ec2955574b16681230af1ee898f3">More...</a><br /></td></tr>
<tr class="separator:a04b3ec2955574b16681230af1ee898f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563740dc5b2075f4bf9f573300dc1f9b"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a563740dc5b2075f4bf9f573300dc1f9b">endTrigger</a></td></tr>
<tr class="memdesc:a563740dc5b2075f4bf9f573300dc1f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger classifier for ending the operation.  <a href="#a563740dc5b2075f4bf9f573300dc1f9b">More...</a><br /></td></tr>
<tr class="separator:a563740dc5b2075f4bf9f573300dc1f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0745fcfdc2908b3198f7dde7a48d65fb"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a14e0ed71e432bd512c3dfa764f3e5cda"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae3deaeececcd74404ce8f2de4ed9adaa">bEnaRssi</a>:1</td></tr>
<tr class="memdesc:a14e0ed71e432bd512c3dfa764f3e5cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, enable RSSI as a criterion.  <a href="#a14e0ed71e432bd512c3dfa764f3e5cda">More...</a><br /></td></tr>
<tr class="separator:a14e0ed71e432bd512c3dfa764f3e5cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de4338673ebbbd2676cb58898145924"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a417f68ec3738c24a422274bb16cf03b8">bEnaCorr</a>:1</td></tr>
<tr class="memdesc:a9de4338673ebbbd2676cb58898145924"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, enable correlation as a criterion.  <a href="#a9de4338673ebbbd2676cb58898145924">More...</a><br /></td></tr>
<tr class="separator:a9de4338673ebbbd2676cb58898145924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4463a05a5fdd8c6e44425c500c01304"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae9728056d9b6de9580744dd92719c65e">operation</a>:1</td></tr>
<tr class="memdesc:ae4463a05a5fdd8c6e44425c500c01304"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Busy if either RSSI or correlation indicates Busy<br />
 1: Busy if both RSSI and correlation indicates Busy  <a href="#ae4463a05a5fdd8c6e44425c500c01304">More...</a><br /></td></tr>
<tr class="separator:ae4463a05a5fdd8c6e44425c500c01304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d623c9dd22b7852733a9a612717768"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a1aeb4fa3d9b9d914e536331616ee558d">busyOp</a>:1</td></tr>
<tr class="memdesc:aa9d623c9dd22b7852733a9a612717768"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Continue carrier sense on channel Busy<br />
 1: End carrier sense on channel Busy<br />
 For an RX command, the receiver will continue when carrier sense ends, but it will then not end if channel goes Idle  <a href="#aa9d623c9dd22b7852733a9a612717768">More...</a><br /></td></tr>
<tr class="separator:aa9d623c9dd22b7852733a9a612717768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7ceb4828bbbe31c61c878b2b9ded36"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a577185137282ed5a1c263a0033894c20">idleOp</a>:1</td></tr>
<tr class="memdesc:a9c7ceb4828bbbe31c61c878b2b9ded36"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Continue on channel Idle<br />
 1: End on channel Idle  <a href="#a9c7ceb4828bbbe31c61c878b2b9ded36">More...</a><br /></td></tr>
<tr class="separator:a9c7ceb4828bbbe31c61c878b2b9ded36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a389f5b792d8e403a27fff040c64db"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a2c58df74a9a931cfb71f6ddf611a224b">timeoutRes</a>:1</td></tr>
<tr class="memdesc:a41a389f5b792d8e403a27fff040c64db"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Timeout with channel state Invalid treated as Busy<br />
 1: Timeout with channel state Invalid treated as Idle  <a href="#a41a389f5b792d8e403a27fff040c64db">More...</a><br /></td></tr>
<tr class="separator:a41a389f5b792d8e403a27fff040c64db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0745fcfdc2908b3198f7dde7a48d65fb"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a0745fcfdc2908b3198f7dde7a48d65fb">csConf</a></td></tr>
<tr class="separator:a0745fcfdc2908b3198f7dde7a48d65fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad373c7de6a25960c0f7c1e28e4a189ea"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a6b75d939102d4e512eac7189dc81a7d3"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a330eb55a91308a71e063b928cc776d82">numCorrInv</a>:4</td></tr>
<tr class="memdesc:a6b75d939102d4e512eac7189dc81a7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of subsequent correlation tops with maximum <code>corrPeriod</code> RAT ticks between them needed to go from Idle to Invalid.  <a href="#a6b75d939102d4e512eac7189dc81a7d3">More...</a><br /></td></tr>
<tr class="separator:a6b75d939102d4e512eac7189dc81a7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd838b150079aa9a33ddc75018a68a9"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abfe6cb16f99cc4283b40735288150853">numCorrBusy</a>:4</td></tr>
<tr class="memdesc:a0bd838b150079aa9a33ddc75018a68a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of subsequent correlation tops with maximum <code>corrPeriod</code> RAT ticks between them needed to go from Invalid to Busy.  <a href="#a0bd838b150079aa9a33ddc75018a68a9">More...</a><br /></td></tr>
<tr class="separator:a0bd838b150079aa9a33ddc75018a68a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad373c7de6a25960c0f7c1e28e4a189ea"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ad373c7de6a25960c0f7c1e28e4a189ea">corrConfig</a></td></tr>
<tr class="separator:ad373c7de6a25960c0f7c1e28e4a189ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc921e07a692640e3de3d1020713a334"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:af46fd563bb9ad4a2be3f1cca2db928f1"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:af46fd563bb9ad4a2be3f1cca2db928f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#af46fd563bb9ad4a2be3f1cca2db928f1">More...</a><br /></td></tr>
<tr class="separator:af46fd563bb9ad4a2be3f1cca2db928f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ca56fbc708a139cc2aa784bf1cad29"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:a35ca56fbc708a139cc2aa784bf1cad29"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#a35ca56fbc708a139cc2aa784bf1cad29">More...</a><br /></td></tr>
<tr class="separator:a35ca56fbc708a139cc2aa784bf1cad29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15b745ee44f3cd1e806934e3c983642"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:af15b745ee44f3cd1e806934e3c983642"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#af15b745ee44f3cd1e806934e3c983642">More...</a><br /></td></tr>
<tr class="separator:af15b745ee44f3cd1e806934e3c983642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32293b45dd41b24494106d45d949557f"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:a32293b45dd41b24494106d45d949557f"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#a32293b45dd41b24494106d45d949557f">More...</a><br /></td></tr>
<tr class="separator:a32293b45dd41b24494106d45d949557f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc921e07a692640e3de3d1020713a334"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abc921e07a692640e3de3d1020713a334">csEndTrigger</a></td></tr>
<tr class="memdesc:abc921e07a692640e3de3d1020713a334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger classifier for ending the carrier sense.  <a href="#abc921e07a692640e3de3d1020713a334">More...</a><br /></td></tr>
<tr class="separator:abc921e07a692640e3de3d1020713a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa0604b238436d3ab010e0fc50d8e43"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a056b87cca8c3d7537d3df4904a5fa678"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:a056b87cca8c3d7537d3df4904a5fa678"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#a056b87cca8c3d7537d3df4904a5fa678">More...</a><br /></td></tr>
<tr class="separator:a056b87cca8c3d7537d3df4904a5fa678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837dc45ad6a797c6a8325054d84b7b28"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:a837dc45ad6a797c6a8325054d84b7b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#a837dc45ad6a797c6a8325054d84b7b28">More...</a><br /></td></tr>
<tr class="separator:a837dc45ad6a797c6a8325054d84b7b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a38e9253b000f93ae460d88cbaa2c61"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:a1a38e9253b000f93ae460d88cbaa2c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#a1a38e9253b000f93ae460d88cbaa2c61">More...</a><br /></td></tr>
<tr class="separator:a1a38e9253b000f93ae460d88cbaa2c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eebbdd3a3cfe6dab780784c07777b5"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:ae4eebbdd3a3cfe6dab780784c07777b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#ae4eebbdd3a3cfe6dab780784c07777b5">More...</a><br /></td></tr>
<tr class="separator:ae4eebbdd3a3cfe6dab780784c07777b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa0604b238436d3ab010e0fc50d8e43"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9aa0604b238436d3ab010e0fc50d8e43">startTrigger</a></td></tr>
<tr class="memdesc:a9aa0604b238436d3ab010e0fc50d8e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identification of the trigger that starts the operation.  <a href="#a9aa0604b238436d3ab010e0fc50d8e43">More...</a><br /></td></tr>
<tr class="separator:a9aa0604b238436d3ab010e0fc50d8e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c64ff37de0b8a41b97041b64b3be627"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a7e454003b02e728e9d66bc32789dd872"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aa59d74dae7674df9b2532d58285c566b">rule</a>:4</td></tr>
<tr class="memdesc:a7e454003b02e728e9d66bc32789dd872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition for running next command: Rule for how to proceed.  <a href="#a7e454003b02e728e9d66bc32789dd872">More...</a><br /></td></tr>
<tr class="separator:a7e454003b02e728e9d66bc32789dd872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b23d4ea2ea747fc4b6c9c1e6db6ca4c"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a5ad36e9c1e0f9c0cef3c0e790feea6b6">nSkip</a>:4</td></tr>
<tr class="memdesc:a1b23d4ea2ea747fc4b6c9c1e6db6ca4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of skips + 1 if the rule involves skipping. 0: same, 1: next, 2: skip next, ...  <a href="#a1b23d4ea2ea747fc4b6c9c1e6db6ca4c">More...</a><br /></td></tr>
<tr class="separator:a1b23d4ea2ea747fc4b6c9c1e6db6ca4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c64ff37de0b8a41b97041b64b3be627"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9c64ff37de0b8a41b97041b64b3be627">condition</a></td></tr>
<tr class="separator:a9c64ff37de0b8a41b97041b64b3be627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b38761da5a279ab17ccb11a30703ecd"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a633f119471f2d96317806d6a49ece27f"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aa3b72c20793ac88643060f8672ebfa7f">bFsOff</a>:1</td></tr>
<tr class="memdesc:a633f119471f2d96317806d6a49ece27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Keep frequency synth on after command<br />
 1: Turn frequency synth off after command  <a href="#a633f119471f2d96317806d6a49ece27f">More...</a><br /></td></tr>
<tr class="separator:a633f119471f2d96317806d6a49ece27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749497e7979c2a92dcffcc7ceac224f0"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a0156620ef69f6629f540c3112ebcb670">bRepeatOk</a>:1</td></tr>
<tr class="memdesc:a749497e7979c2a92dcffcc7ceac224f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: End operation after receiving a packet correctly<br />
 1: Go back to sync search after receiving a packet correctly  <a href="#a749497e7979c2a92dcffcc7ceac224f0">More...</a><br /></td></tr>
<tr class="separator:a749497e7979c2a92dcffcc7ceac224f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8570dd82df7e955a127fff285d0c2a8b"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a1979c03d4a811da55d5cf9746413fafd">bRepeatNok</a>:1</td></tr>
<tr class="memdesc:a8570dd82df7e955a127fff285d0c2a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: End operation after receiving a packet with CRC error<br />
 1: Go back to sync search after receiving a packet with CRC error  <a href="#a8570dd82df7e955a127fff285d0c2a8b">More...</a><br /></td></tr>
<tr class="separator:a8570dd82df7e955a127fff285d0c2a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90a7e0387e2effd99e49334dc956c8c"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#adebe09804ad8162bb96b98756a16363b">bUseCrc</a>:1</td></tr>
<tr class="memdesc:ab90a7e0387e2effd99e49334dc956c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not check CRC<br />
 1: Check CRC  <a href="#ab90a7e0387e2effd99e49334dc956c8c">More...</a><br /></td></tr>
<tr class="separator:ab90a7e0387e2effd99e49334dc956c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1bf5a458365cda95a3c1236c05b3e8"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab2144281d339b13b3f97d57f11ea38d1">bCrcIncSw</a>:1</td></tr>
<tr class="memdesc:a5c1bf5a458365cda95a3c1236c05b3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not include sync word in CRC calculation<br />
 1: Include sync word in CRC calculation  <a href="#a5c1bf5a458365cda95a3c1236c05b3e8">More...</a><br /></td></tr>
<tr class="separator:a5c1bf5a458365cda95a3c1236c05b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9580a81a1b038ece3ae62e870545548"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a8ee33601aeed12e19dc269aa87e58f76">bCrcIncHdr</a>:1</td></tr>
<tr class="memdesc:ac9580a81a1b038ece3ae62e870545548"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Do not include header in CRC calculation <br />
 1: Include header in CRC calculation  <a href="#ac9580a81a1b038ece3ae62e870545548">More...</a><br /></td></tr>
<tr class="separator:ac9580a81a1b038ece3ae62e870545548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc72ad1099816c14f95a41d6d79f02b"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53ad841c5844389e2088157f70826de5">endType</a>:1</td></tr>
<tr class="memdesc:a2bc72ad1099816c14f95a41d6d79f02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Packet is received to the end if end trigger happens after sync is obtained<br />
 1: Packet reception is stopped if end trigger happens  <a href="#a2bc72ad1099816c14f95a41d6d79f02b">More...</a><br /></td></tr>
<tr class="separator:a2bc72ad1099816c14f95a41d6d79f02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a71757e5352e12368ff3978a939a1ed"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab08631f5ab63f0eedbc10d67bc159c86">filterOp</a>:1</td></tr>
<tr class="memdesc:a6a71757e5352e12368ff3978a939a1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Stop receiver and restart sync search on address mismatch<br />
 1: Receive packet and mark it as ignored on address mismatch  <a href="#a6a71757e5352e12368ff3978a939a1ed">More...</a><br /></td></tr>
<tr class="separator:a6a71757e5352e12368ff3978a939a1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b38761da5a279ab17ccb11a30703ecd"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a0b38761da5a279ab17ccb11a30703ecd">pktConf</a></td></tr>
<tr class="separator:a0b38761da5a279ab17ccb11a30703ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410869b0657acb62a919601e879c8366"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a7bff22f5031d51a34c76900acc76ab73"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a2f8ddae97fa0cc09ea320654b692ca23">bAutoFlushIgnored</a>:1</td></tr>
<tr class="memdesc:a7bff22f5031d51a34c76900acc76ab73"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, automatically discard ignored packets from RX queue.  <a href="#a7bff22f5031d51a34c76900acc76ab73">More...</a><br /></td></tr>
<tr class="separator:a7bff22f5031d51a34c76900acc76ab73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b541fc4034c9780a5725f0b8188a06"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a442426db9645c114c905b9e61abefba1">bAutoFlushCrcErr</a>:1</td></tr>
<tr class="memdesc:a30b541fc4034c9780a5725f0b8188a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, automatically discard packets with CRC error from RX queue.  <a href="#a30b541fc4034c9780a5725f0b8188a06">More...</a><br /></td></tr>
<tr class="separator:a30b541fc4034c9780a5725f0b8188a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9659ee2f774a4702883b5d8d0146457"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab0f0c71d27a518d18c88a29e8c1fd472">__pad0__</a>:1</td></tr>
<tr class="separator:aa9659ee2f774a4702883b5d8d0146457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6d0cfe7f5abb3653e734aee59abd21"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aecb8b5223791639e625ba23bf453dbee">bIncludeHdr</a>:1</td></tr>
<tr class="memdesc:a2f6d0cfe7f5abb3653e734aee59abd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, include the received header or length byte in the stored packet; otherwise discard it.  <a href="#a2f6d0cfe7f5abb3653e734aee59abd21">More...</a><br /></td></tr>
<tr class="separator:a2f6d0cfe7f5abb3653e734aee59abd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78eef00a0d494a0dd9fcab88bbc18c3"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9e4bc1b2c4ed275cfbac07fe18744c5e">bIncludeCrc</a>:1</td></tr>
<tr class="memdesc:ac78eef00a0d494a0dd9fcab88bbc18c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, include the received CRC field in the stored packet; otherwise discard it.  <a href="#ac78eef00a0d494a0dd9fcab88bbc18c3">More...</a><br /></td></tr>
<tr class="separator:ac78eef00a0d494a0dd9fcab88bbc18c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25dfe51c33f2964824c9dd0b6a0f3f0"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a0fad36a02f5fc16f268c51aaf7640452">bAppendRssi</a>:1</td></tr>
<tr class="memdesc:ab25dfe51c33f2964824c9dd0b6a0f3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append an RSSI byte to the packet in the RX queue.  <a href="#ab25dfe51c33f2964824c9dd0b6a0f3f0">More...</a><br /></td></tr>
<tr class="separator:ab25dfe51c33f2964824c9dd0b6a0f3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb577181d2886bd35928b77423f5b6e"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a19bb1b401988126e5003e387c173dd94">bAppendTimestamp</a>:1</td></tr>
<tr class="memdesc:a8bb577181d2886bd35928b77423f5b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append a timestamp to the packet in the RX queue.  <a href="#a8bb577181d2886bd35928b77423f5b6e">More...</a><br /></td></tr>
<tr class="separator:a8bb577181d2886bd35928b77423f5b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ceaac5792bcacb0cc8477c1425d6c1"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9ad0c999cd156711854615d2e8005269">bAppendStatus</a>:1</td></tr>
<tr class="memdesc:a71ceaac5792bcacb0cc8477c1425d6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, append a status byte to the packet in the RX queue.  <a href="#a71ceaac5792bcacb0cc8477c1425d6c1">More...</a><br /></td></tr>
<tr class="separator:a71ceaac5792bcacb0cc8477c1425d6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410869b0657acb62a919601e879c8366"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a410869b0657acb62a919601e879c8366">rxConf</a></td></tr>
<tr class="memdesc:a410869b0657acb62a919601e879c8366"><td class="mdescLeft">&#160;</td><td class="mdescRight">RX configuration.  <a href="#a410869b0657acb62a919601e879c8366">More...</a><br /></td></tr>
<tr class="separator:a410869b0657acb62a919601e879c8366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0997a58663233e1dbadb6cad3e59015"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:add345f14aae05fdf6d6b20a75dd350c9"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a7de41278abecaac6668aab1a3e59e346">numHdrBits</a>:6</td></tr>
<tr class="memdesc:add345f14aae05fdf6d6b20a75dd350c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in header (0&ndash;32)  <a href="#add345f14aae05fdf6d6b20a75dd350c9">More...</a><br /></td></tr>
<tr class="separator:add345f14aae05fdf6d6b20a75dd350c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c22e53e67e3faaf7dfbe15a4c84eb9c"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ab5685f661080993f42590731a9a73993">lenPos</a>:5</td></tr>
<tr class="memdesc:a5c22e53e67e3faaf7dfbe15a4c84eb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of length field in header (0&ndash;31)  <a href="#a5c22e53e67e3faaf7dfbe15a4c84eb9c">More...</a><br /></td></tr>
<tr class="separator:a5c22e53e67e3faaf7dfbe15a4c84eb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73ab4fe0ff8c43f043324f9c1bb1096"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a15d6b90fce01507c0bc111a383dd255b">numLenBits</a>:5</td></tr>
<tr class="memdesc:ab73ab4fe0ff8c43f043324f9c1bb1096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in length field (0&ndash;16)  <a href="#ab73ab4fe0ff8c43f043324f9c1bb1096">More...</a><br /></td></tr>
<tr class="separator:ab73ab4fe0ff8c43f043324f9c1bb1096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0997a58663233e1dbadb6cad3e59015"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae0997a58663233e1dbadb6cad3e59015">hdrConf</a></td></tr>
<tr class="separator:ae0997a58663233e1dbadb6cad3e59015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad909ab28abd12fe5c42a40317e06508f"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a9fb8c522d68a6ef52784626cffd47006"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a4accfa3276ca4f6d18f4dec423ca8f61">addrType</a>:1</td></tr>
<tr class="memdesc:a9fb8c522d68a6ef52784626cffd47006"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Address after header<br />
 1: Address in header  <a href="#a9fb8c522d68a6ef52784626cffd47006">More...</a><br /></td></tr>
<tr class="separator:a9fb8c522d68a6ef52784626cffd47006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a1c30fb1a3ffb581a690e863ebd6b1"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a20707407480014d01e40cacb2fa024de">addrSize</a>:5</td></tr>
<tr class="memdesc:a40a1c30fb1a3ffb581a690e863ebd6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>addrType</code> = 0: Address size in bytes<br />
 If <code>addrType</code> = 1: Address size in bits.  <a href="#a40a1c30fb1a3ffb581a690e863ebd6b1">More...</a><br /></td></tr>
<tr class="separator:a40a1c30fb1a3ffb581a690e863ebd6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e7befce99a402e358ac900d93ffdc1"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a9d82ed63316ea4201d9da6f2a2c4ed76">addrPos</a>:5</td></tr>
<tr class="memdesc:ab6e7befce99a402e358ac900d93ffdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>addrType</code> = 1: Bit position of address in header<br />
 If <code>addrType</code> = 0: Non-zero to extend address with sync word identifier.  <a href="#ab6e7befce99a402e358ac900d93ffdc1">More...</a><br /></td></tr>
<tr class="separator:ab6e7befce99a402e358ac900d93ffdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eb962ef23b7b39ae93c773d89ae8fb"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#affa8163eb8016f21069970d97278a118">numAddr</a>:5</td></tr>
<tr class="memdesc:ae8eb962ef23b7b39ae93c773d89ae8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of addresses in address list.  <a href="#ae8eb962ef23b7b39ae93c773d89ae8fb">More...</a><br /></td></tr>
<tr class="separator:ae8eb962ef23b7b39ae93c773d89ae8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad909ab28abd12fe5c42a40317e06508f"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ad909ab28abd12fe5c42a40317e06508f">addrConf</a></td></tr>
<tr class="separator:ad909ab28abd12fe5c42a40317e06508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4461c142a1b533ccd6c7a1ab7bb6b1e6"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:aeb456434ffa264ccbf56f40982f27523"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:aeb456434ffa264ccbf56f40982f27523"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#aeb456434ffa264ccbf56f40982f27523">More...</a><br /></td></tr>
<tr class="separator:aeb456434ffa264ccbf56f40982f27523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8526cdbbe81af94e66d9df8808bcce"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:a0e8526cdbbe81af94e66d9df8808bcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#a0e8526cdbbe81af94e66d9df8808bcce">More...</a><br /></td></tr>
<tr class="separator:a0e8526cdbbe81af94e66d9df8808bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0a98d7a00157384792be50969d61d6"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:a3c0a98d7a00157384792be50969d61d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#a3c0a98d7a00157384792be50969d61d6">More...</a><br /></td></tr>
<tr class="separator:a3c0a98d7a00157384792be50969d61d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4dae064993c635adac12f9ee06b9ae"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:aad4dae064993c635adac12f9ee06b9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#aad4dae064993c635adac12f9ee06b9ae">More...</a><br /></td></tr>
<tr class="separator:aad4dae064993c635adac12f9ee06b9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4461c142a1b533ccd6c7a1ab7bb6b1e6"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a4461c142a1b533ccd6c7a1ab7bb6b1e6">endTrigger</a></td></tr>
<tr class="memdesc:a4461c142a1b533ccd6c7a1ab7bb6b1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger classifier for ending the operation.  <a href="#a4461c142a1b533ccd6c7a1ab7bb6b1e6">More...</a><br /></td></tr>
<tr class="separator:a4461c142a1b533ccd6c7a1ab7bb6b1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb058330f9bf4d0c588680474264efb"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a58c27f15de0675e17ba247bdf41738c8"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae3deaeececcd74404ce8f2de4ed9adaa">bEnaRssi</a>:1</td></tr>
<tr class="memdesc:a58c27f15de0675e17ba247bdf41738c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, enable RSSI as a criterion.  <a href="#a58c27f15de0675e17ba247bdf41738c8">More...</a><br /></td></tr>
<tr class="separator:a58c27f15de0675e17ba247bdf41738c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db9b8d96a6df3df2d9c1448ad5cdc08"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a417f68ec3738c24a422274bb16cf03b8">bEnaCorr</a>:1</td></tr>
<tr class="memdesc:a3db9b8d96a6df3df2d9c1448ad5cdc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, enable correlation as a criterion.  <a href="#a3db9b8d96a6df3df2d9c1448ad5cdc08">More...</a><br /></td></tr>
<tr class="separator:a3db9b8d96a6df3df2d9c1448ad5cdc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9648a5e669d06f01acadf69039d19e"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae9728056d9b6de9580744dd92719c65e">operation</a>:1</td></tr>
<tr class="memdesc:a8c9648a5e669d06f01acadf69039d19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Busy if either RSSI or correlation indicates Busy<br />
 1: Busy if both RSSI and correlation indicates Busy  <a href="#a8c9648a5e669d06f01acadf69039d19e">More...</a><br /></td></tr>
<tr class="separator:a8c9648a5e669d06f01acadf69039d19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeb85919a385ac9583b5ff51bcf813f"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a1aeb4fa3d9b9d914e536331616ee558d">busyOp</a>:1</td></tr>
<tr class="memdesc:a0aeb85919a385ac9583b5ff51bcf813f"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Continue carrier sense on channel Busy<br />
 1: End carrier sense on channel Busy<br />
 For an RX command, the receiver will continue when carrier sense ends, but it will then not end if channel goes Idle  <a href="#a0aeb85919a385ac9583b5ff51bcf813f">More...</a><br /></td></tr>
<tr class="separator:a0aeb85919a385ac9583b5ff51bcf813f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8169fae93ae8b7ee21fd12027b330b7b"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a577185137282ed5a1c263a0033894c20">idleOp</a>:1</td></tr>
<tr class="memdesc:a8169fae93ae8b7ee21fd12027b330b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Continue on channel Idle<br />
 1: End on channel Idle  <a href="#a8169fae93ae8b7ee21fd12027b330b7b">More...</a><br /></td></tr>
<tr class="separator:a8169fae93ae8b7ee21fd12027b330b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bec3bb3570d9c08a683970c9b6bd6f9"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a2c58df74a9a931cfb71f6ddf611a224b">timeoutRes</a>:1</td></tr>
<tr class="memdesc:a0bec3bb3570d9c08a683970c9b6bd6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: Timeout with channel state Invalid treated as Busy<br />
 1: Timeout with channel state Invalid treated as Idle  <a href="#a0bec3bb3570d9c08a683970c9b6bd6f9">More...</a><br /></td></tr>
<tr class="separator:a0bec3bb3570d9c08a683970c9b6bd6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb058330f9bf4d0c588680474264efb"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#aadb058330f9bf4d0c588680474264efb">csConf</a></td></tr>
<tr class="separator:aadb058330f9bf4d0c588680474264efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96eec3cd3b2049ece71850fee4ef263b"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:ae302d9bc923a0ed89a6be23e7be91ed7"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a330eb55a91308a71e063b928cc776d82">numCorrInv</a>:4</td></tr>
<tr class="memdesc:ae302d9bc923a0ed89a6be23e7be91ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of subsequent correlation tops with maximum <code>corrPeriod</code> RAT ticks between them needed to go from Idle to Invalid.  <a href="#ae302d9bc923a0ed89a6be23e7be91ed7">More...</a><br /></td></tr>
<tr class="separator:ae302d9bc923a0ed89a6be23e7be91ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e8a40ebedd1b25aa6723931e37d272"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abfe6cb16f99cc4283b40735288150853">numCorrBusy</a>:4</td></tr>
<tr class="memdesc:a39e8a40ebedd1b25aa6723931e37d272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of subsequent correlation tops with maximum <code>corrPeriod</code> RAT ticks between them needed to go from Invalid to Busy.  <a href="#a39e8a40ebedd1b25aa6723931e37d272">More...</a><br /></td></tr>
<tr class="separator:a39e8a40ebedd1b25aa6723931e37d272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96eec3cd3b2049ece71850fee4ef263b"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a96eec3cd3b2049ece71850fee4ef263b">corrConfig</a></td></tr>
<tr class="separator:a96eec3cd3b2049ece71850fee4ef263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae421d55c2ab08a2c64c67e678544a700"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a7c1fc6799105d849f521ab30a778759b"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a53b90a619c64ac7eaf4ed0886585ccf5">triggerType</a>:4</td></tr>
<tr class="memdesc:a7c1fc6799105d849f521ab30a778759b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of trigger.  <a href="#a7c1fc6799105d849f521ab30a778759b">More...</a><br /></td></tr>
<tr class="separator:a7c1fc6799105d849f521ab30a778759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133fae29630b62e1029cb28aa83aca8d"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#a924e75c2adcae6beb9935f5129cf51bf">bEnaCmd</a>:1</td></tr>
<tr class="memdesc:a133fae29630b62e1029cb28aa83aca8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger  <a href="#a133fae29630b62e1029cb28aa83aca8d">More...</a><br /></td></tr>
<tr class="separator:a133fae29630b62e1029cb28aa83aca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2759512de186f54d80ec4a7e90386adb"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#abedd621f6a8028b0599b3dc51994d0c1">triggerNo</a>:2</td></tr>
<tr class="memdesc:a2759512de186f54d80ec4a7e90386adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trigger number of the CMD_TRIGGER command that triggers this action.  <a href="#a2759512de186f54d80ec4a7e90386adb">More...</a><br /></td></tr>
<tr class="separator:a2759512de186f54d80ec4a7e90386adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b3013d4650c373323e40b6f7a4ce05"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ac3461aa70a6e2179cf34577106de121f">pastTrig</a>:1</td></tr>
<tr class="memdesc:a69b3013d4650c373323e40b6f7a4ce05"><td class="mdescLeft">&#160;</td><td class="mdescRight">0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible  <a href="#a69b3013d4650c373323e40b6f7a4ce05">More...</a><br /></td></tr>
<tr class="separator:a69b3013d4650c373323e40b6f7a4ce05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae421d55c2ab08a2c64c67e678544a700"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfc___c_m_d___p_r_o_p___r_x___a_d_v___s_n_i_f_f__s.html#ae421d55c2ab08a2c64c67e678544a700">csEndTrigger</a></td></tr>
<tr class="memdesc:ae421d55c2ab08a2c64c67e678544a700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger classifier for ending the carrier sense.  <a href="#ae421d55c2ab08a2c64c67e678544a700">More...</a><br /></td></tr>
<tr class="separator:ae421d55c2ab08a2c64c67e678544a700"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Proprietary Mode Advanced Receive Command with Sniff Mode. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a780a2f78b32302a566d209f56bd18c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780a2f78b32302a566d209f56bd18c8d">&sect;&nbsp;</a></span>commandNo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::commandNo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The command ID number 0x3809. </p>

</div>
</div>
<a id="a61454a3aba4b2bc4516a7b30187d6aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61454a3aba4b2bc4516a7b30187d6aaf">&sect;&nbsp;</a></span>status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::status</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integer telling the status of the command. This value is updated by the radio CPU during operation and may be read by the system CPU at any time. </p>

</div>
</div>
<a id="ab7db04e40fe8de3400bc8f960321c0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7db04e40fe8de3400bc8f960321c0be">&sect;&nbsp;</a></span>pNextOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common__cmd.html#gae7da987ce1d7df565772441645da8279">rfc_radioOp_t</a> * rfc_CMD_PROP_RX_ADV_SNIFF_s::pNextOp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the next operation to run after this operation is done. </p>

</div>
</div>
<a id="a50b14251995c0ae3dc12dd12c2b50ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b14251995c0ae3dc12dd12c2b50ff2">&sect;&nbsp;</a></span>startTime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cc13x2__cc26x2_2driverlib_2rf__mailbox_8h.html#af9975defb67093aa9e6235d578cb60ca">ratmr_t</a> rfc_CMD_PROP_RX_ADV_SNIFF_s::startTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Absolute or relative start time (depending on the value of <code>startTrigger</code>) </p>

</div>
</div>
<a id="a53b90a619c64ac7eaf4ed0886585ccf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b90a619c64ac7eaf4ed0886585ccf5">&sect;&nbsp;</a></span>triggerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::triggerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of trigger. </p>

</div>
</div>
<a id="a924e75c2adcae6beb9935f5129cf51bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924e75c2adcae6beb9935f5129cf51bf">&sect;&nbsp;</a></span>bEnaCmd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bEnaCmd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: No alternative trigger command<br />
 1: CMD_TRIGGER can be used as an alternative trigger </p>

</div>
</div>
<a id="abedd621f6a8028b0599b3dc51994d0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedd621f6a8028b0599b3dc51994d0c1">&sect;&nbsp;</a></span>triggerNo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::triggerNo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The trigger number of the CMD_TRIGGER command that triggers this action. </p>

</div>
</div>
<a id="ac3461aa70a6e2179cf34577106de121f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3461aa70a6e2179cf34577106de121f">&sect;&nbsp;</a></span>pastTrig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::pastTrig</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: A trigger in the past is never triggered, or for start of commands, give an error<br />
 1: A trigger in the past is triggered as soon as possible </p>

</div>
</div>
<a id="aabbb0f347de7d7063f9435ecc2217d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbb0f347de7d7063f9435ecc2217d74">&sect;&nbsp;</a></span>startTrigger <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::startTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identification of the trigger that starts the operation. </p>

</div>
</div>
<a id="aa59d74dae7674df9b2532d58285c566b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59d74dae7674df9b2532d58285c566b">&sect;&nbsp;</a></span>rule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::rule</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Condition for running next command: Rule for how to proceed. </p>

</div>
</div>
<a id="a5ad36e9c1e0f9c0cef3c0e790feea6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad36e9c1e0f9c0cef3c0e790feea6b6">&sect;&nbsp;</a></span>nSkip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::nSkip</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of skips + 1 if the rule involves skipping. 0: same, 1: next, 2: skip next, ... </p>

</div>
</div>
<a id="a85b0d0d44e854d4c96c251d1e4c6381b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b0d0d44e854d4c96c251d1e4c6381b">&sect;&nbsp;</a></span>condition <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::condition</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b72c20793ac88643060f8672ebfa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b72c20793ac88643060f8672ebfa7f">&sect;&nbsp;</a></span>bFsOff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bFsOff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Keep frequency synth on after command<br />
 1: Turn frequency synth off after command </p>

</div>
</div>
<a id="a0156620ef69f6629f540c3112ebcb670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0156620ef69f6629f540c3112ebcb670">&sect;&nbsp;</a></span>bRepeatOk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bRepeatOk</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: End operation after receiving a packet correctly<br />
 1: Go back to sync search after receiving a packet correctly </p>

</div>
</div>
<a id="a1979c03d4a811da55d5cf9746413fafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1979c03d4a811da55d5cf9746413fafd">&sect;&nbsp;</a></span>bRepeatNok</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bRepeatNok</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: End operation after receiving a packet with CRC error<br />
 1: Go back to sync search after receiving a packet with CRC error </p>

</div>
</div>
<a id="adebe09804ad8162bb96b98756a16363b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebe09804ad8162bb96b98756a16363b">&sect;&nbsp;</a></span>bUseCrc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bUseCrc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Do not check CRC<br />
 1: Check CRC </p>

</div>
</div>
<a id="ab2144281d339b13b3f97d57f11ea38d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2144281d339b13b3f97d57f11ea38d1">&sect;&nbsp;</a></span>bCrcIncSw</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bCrcIncSw</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Do not include sync word in CRC calculation<br />
 1: Include sync word in CRC calculation </p>

</div>
</div>
<a id="a8ee33601aeed12e19dc269aa87e58f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee33601aeed12e19dc269aa87e58f76">&sect;&nbsp;</a></span>bCrcIncHdr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bCrcIncHdr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Do not include header in CRC calculation <br />
 1: Include header in CRC calculation </p>

</div>
</div>
<a id="a53ad841c5844389e2088157f70826de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ad841c5844389e2088157f70826de5">&sect;&nbsp;</a></span>endType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::endType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Packet is received to the end if end trigger happens after sync is obtained<br />
 1: Packet reception is stopped if end trigger happens </p>

</div>
</div>
<a id="ab08631f5ab63f0eedbc10d67bc159c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08631f5ab63f0eedbc10d67bc159c86">&sect;&nbsp;</a></span>filterOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::filterOp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Stop receiver and restart sync search on address mismatch<br />
 1: Receive packet and mark it as ignored on address mismatch </p>

</div>
</div>
<a id="ade526d4632e9cb030205956fcedcc4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade526d4632e9cb030205956fcedcc4b0">&sect;&nbsp;</a></span>pktConf <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::pktConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f8ddae97fa0cc09ea320654b692ca23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8ddae97fa0cc09ea320654b692ca23">&sect;&nbsp;</a></span>bAutoFlushIgnored</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bAutoFlushIgnored</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, automatically discard ignored packets from RX queue. </p>

</div>
</div>
<a id="a442426db9645c114c905b9e61abefba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442426db9645c114c905b9e61abefba1">&sect;&nbsp;</a></span>bAutoFlushCrcErr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bAutoFlushCrcErr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, automatically discard packets with CRC error from RX queue. </p>

</div>
</div>
<a id="ab0f0c71d27a518d18c88a29e8c1fd472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f0c71d27a518d18c88a29e8c1fd472">&sect;&nbsp;</a></span>__pad0__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::__pad0__</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aecb8b5223791639e625ba23bf453dbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb8b5223791639e625ba23bf453dbee">&sect;&nbsp;</a></span>bIncludeHdr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bIncludeHdr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, include the received header or length byte in the stored packet; otherwise discard it. </p>

</div>
</div>
<a id="a9e4bc1b2c4ed275cfbac07fe18744c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4bc1b2c4ed275cfbac07fe18744c5e">&sect;&nbsp;</a></span>bIncludeCrc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bIncludeCrc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, include the received CRC field in the stored packet; otherwise discard it. </p>

</div>
</div>
<a id="a0fad36a02f5fc16f268c51aaf7640452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fad36a02f5fc16f268c51aaf7640452">&sect;&nbsp;</a></span>bAppendRssi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bAppendRssi</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, append an RSSI byte to the packet in the RX queue. </p>

</div>
</div>
<a id="a19bb1b401988126e5003e387c173dd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bb1b401988126e5003e387c173dd94">&sect;&nbsp;</a></span>bAppendTimestamp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bAppendTimestamp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, append a timestamp to the packet in the RX queue. </p>

</div>
</div>
<a id="a9ad0c999cd156711854615d2e8005269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad0c999cd156711854615d2e8005269">&sect;&nbsp;</a></span>bAppendStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bAppendStatus</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, append a status byte to the packet in the RX queue. </p>

</div>
</div>
<a id="a82625a8adc04638c77e20383d49eac10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82625a8adc04638c77e20383d49eac10">&sect;&nbsp;</a></span>rxConf <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::rxConf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RX configuration. </p>

</div>
</div>
<a id="a35bbc98cc7ea0f3d2a51f4bcf83b9669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bbc98cc7ea0f3d2a51f4bcf83b9669">&sect;&nbsp;</a></span>syncWord0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rfc_CMD_PROP_RX_ADV_SNIFF_s::syncWord0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sync word to listen for. </p>

</div>
</div>
<a id="a10b0a4d4bea7d2de6b73286a62f65a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b0a4d4bea7d2de6b73286a62f65a71">&sect;&nbsp;</a></span>syncWord1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rfc_CMD_PROP_RX_ADV_SNIFF_s::syncWord1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative sync word if non-zero. </p>

</div>
</div>
<a id="abbdc3b4642c4282c918498dd2604e4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdc3b4642c4282c918498dd2604e4e2">&sect;&nbsp;</a></span>maxPktLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::maxPktLen</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packet length for fixed length, maximum packet length for variable length<br />
 0: Unlimited or unknown length. </p>

</div>
</div>
<a id="a7de41278abecaac6668aab1a3e59e346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de41278abecaac6668aab1a3e59e346">&sect;&nbsp;</a></span>numHdrBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::numHdrBits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits in header (0&ndash;32) </p>

</div>
</div>
<a id="ab5685f661080993f42590731a9a73993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5685f661080993f42590731a9a73993">&sect;&nbsp;</a></span>lenPos</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::lenPos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position of length field in header (0&ndash;31) </p>

</div>
</div>
<a id="a15d6b90fce01507c0bc111a383dd255b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d6b90fce01507c0bc111a383dd255b">&sect;&nbsp;</a></span>numLenBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::numLenBits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits in length field (0&ndash;16) </p>

</div>
</div>
<a id="a4a60e7aef1e0ae382c3c39f16c1ce193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a60e7aef1e0ae382c3c39f16c1ce193">&sect;&nbsp;</a></span>hdrConf <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::hdrConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4accfa3276ca4f6d18f4dec423ca8f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4accfa3276ca4f6d18f4dec423ca8f61">&sect;&nbsp;</a></span>addrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::addrType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Address after header<br />
 1: Address in header </p>

</div>
</div>
<a id="a20707407480014d01e40cacb2fa024de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20707407480014d01e40cacb2fa024de">&sect;&nbsp;</a></span>addrSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::addrSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>addrType</code> = 0: Address size in bytes<br />
 If <code>addrType</code> = 1: Address size in bits. </p>

</div>
</div>
<a id="a9d82ed63316ea4201d9da6f2a2c4ed76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d82ed63316ea4201d9da6f2a2c4ed76">&sect;&nbsp;</a></span>addrPos</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::addrPos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>addrType</code> = 1: Bit position of address in header<br />
 If <code>addrType</code> = 0: Non-zero to extend address with sync word identifier. </p>

</div>
</div>
<a id="affa8163eb8016f21069970d97278a118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa8163eb8016f21069970d97278a118">&sect;&nbsp;</a></span>numAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::numAddr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of addresses in address list. </p>

</div>
</div>
<a id="ae1127a2fc190c69daa1063cd0bedafce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1127a2fc190c69daa1063cd0bedafce">&sect;&nbsp;</a></span>addrConf <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::addrConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cf8662d7e203be38e7409a4b0b2f3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf8662d7e203be38e7409a4b0b2f3c8">&sect;&nbsp;</a></span>lenOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::lenOffset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed value to add to length field. </p>

</div>
</div>
<a id="a5ac4dd38abd2ec0ec1cfc01ee4393ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac4dd38abd2ec0ec1cfc01ee4393ad5">&sect;&nbsp;</a></span>endTrigger <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::endTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger classifier for ending the operation. </p>

</div>
</div>
<a id="afd9cf11ae0f02c8607d13651eae413cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9cf11ae0f02c8607d13651eae413cf">&sect;&nbsp;</a></span>endTime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cc13x2__cc26x2_2driverlib_2rf__mailbox_8h.html#af9975defb67093aa9e6235d578cb60ca">ratmr_t</a> rfc_CMD_PROP_RX_ADV_SNIFF_s::endTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time used together with <code>endTrigger</code> for ending the operation. </p>

</div>
</div>
<a id="a932af7ffb66ab4e775e782ed7e280e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932af7ffb66ab4e775e782ed7e280e95">&sect;&nbsp;</a></span>pAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * rfc_CMD_PROP_RX_ADV_SNIFF_s::pAddr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to address list. </p>

</div>
</div>
<a id="a8ba857caba01de75cf29f2ad803e6edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba857caba01de75cf29f2ad803e6edd">&sect;&nbsp;</a></span>pQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdata_queue__t.html">dataQueue_t</a> * rfc_CMD_PROP_RX_ADV_SNIFF_s::pQueue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to receive queue. </p>

</div>
</div>
<a id="a5804226e78914769cb4e2cafc365a972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5804226e78914769cb4e2cafc365a972">&sect;&nbsp;</a></span>pOutput</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * rfc_CMD_PROP_RX_ADV_SNIFF_s::pOutput</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to output structure. </p>

</div>
</div>
<a id="ae3deaeececcd74404ce8f2de4ed9adaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3deaeececcd74404ce8f2de4ed9adaa">&sect;&nbsp;</a></span>bEnaRssi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bEnaRssi</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, enable RSSI as a criterion. </p>

</div>
</div>
<a id="a417f68ec3738c24a422274bb16cf03b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417f68ec3738c24a422274bb16cf03b8">&sect;&nbsp;</a></span>bEnaCorr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::bEnaCorr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, enable correlation as a criterion. </p>

</div>
</div>
<a id="ae9728056d9b6de9580744dd92719c65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9728056d9b6de9580744dd92719c65e">&sect;&nbsp;</a></span>operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::operation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Busy if either RSSI or correlation indicates Busy<br />
 1: Busy if both RSSI and correlation indicates Busy </p>

</div>
</div>
<a id="a1aeb4fa3d9b9d914e536331616ee558d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aeb4fa3d9b9d914e536331616ee558d">&sect;&nbsp;</a></span>busyOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::busyOp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Continue carrier sense on channel Busy<br />
 1: End carrier sense on channel Busy<br />
 For an RX command, the receiver will continue when carrier sense ends, but it will then not end if channel goes Idle </p>

</div>
</div>
<a id="a577185137282ed5a1c263a0033894c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577185137282ed5a1c263a0033894c20">&sect;&nbsp;</a></span>idleOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::idleOp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Continue on channel Idle<br />
 1: End on channel Idle </p>

</div>
</div>
<a id="a2c58df74a9a931cfb71f6ddf611a224b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c58df74a9a931cfb71f6ddf611a224b">&sect;&nbsp;</a></span>timeoutRes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::timeoutRes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>0: Timeout with channel state Invalid treated as Busy<br />
 1: Timeout with channel state Invalid treated as Idle </p>

</div>
</div>
<a id="a9650868ca016735221a7c91c3f418b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9650868ca016735221a7c91c3f418b10">&sect;&nbsp;</a></span>csConf <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::csConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf4df2ff058bbbf10b8eac49e5cbcef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4df2ff058bbbf10b8eac49e5cbcef9">&sect;&nbsp;</a></span>rssiThr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::rssiThr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSSI threshold. </p>

</div>
</div>
<a id="a37606136585736cb722a31ade828164d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37606136585736cb722a31ade828164d">&sect;&nbsp;</a></span>numRssiIdle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::numRssiIdle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of consecutive RSSI measurements below the threshold needed before the channel is declared Idle. </p>

</div>
</div>
<a id="a86bcf9305442d5c6edd6d5a547686d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bcf9305442d5c6edd6d5a547686d3a">&sect;&nbsp;</a></span>numRssiBusy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::numRssiBusy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of consecutive RSSI measurements above the threshold needed before the channel is declared Busy. </p>

</div>
</div>
<a id="a52edb79d6758cc8ef4f18a9b681348a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52edb79d6758cc8ef4f18a9b681348a9">&sect;&nbsp;</a></span>corrPeriod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rfc_CMD_PROP_RX_ADV_SNIFF_s::corrPeriod</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of RAT ticks for a correlation observation periods. </p>

</div>
</div>
<a id="a330eb55a91308a71e063b928cc776d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330eb55a91308a71e063b928cc776d82">&sect;&nbsp;</a></span>numCorrInv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::numCorrInv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of subsequent correlation tops with maximum <code>corrPeriod</code> RAT ticks between them needed to go from Idle to Invalid. </p>

</div>
</div>
<a id="abfe6cb16f99cc4283b40735288150853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe6cb16f99cc4283b40735288150853">&sect;&nbsp;</a></span>numCorrBusy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfc_CMD_PROP_RX_ADV_SNIFF_s::numCorrBusy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of subsequent correlation tops with maximum <code>corrPeriod</code> RAT ticks between them needed to go from Invalid to Busy. </p>

</div>
</div>
<a id="a8353ffb3d6de3ddb4fe3992fc2db558c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8353ffb3d6de3ddb4fe3992fc2db558c">&sect;&nbsp;</a></span>corrConfig <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::corrConfig</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cbc81d15bcea5820a5277149994c871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbc81d15bcea5820a5277149994c871">&sect;&nbsp;</a></span>csEndTrigger <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::csEndTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger classifier for ending the carrier sense. </p>

</div>
</div>
<a id="af4011697ce7cc992786e1aaf67f73b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4011697ce7cc992786e1aaf67f73b57">&sect;&nbsp;</a></span>csEndTime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cc13x2__cc26x2_2driverlib_2rf__mailbox_8h.html#af9975defb67093aa9e6235d578cb60ca">ratmr_t</a> rfc_CMD_PROP_RX_ADV_SNIFF_s::csEndTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time used together with <code>csEndTrigger</code> for ending the operation. </p>

</div>
</div>
<a id="a929eeccb001793c0059414d6a90e00d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929eeccb001793c0059414d6a90e00d5">&sect;&nbsp;</a></span>startTrigger <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::startTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identification of the trigger that starts the operation. </p>

</div>
</div>
<a id="a9b15c41b5e2845c0b7d8c5e16d4ebaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b15c41b5e2845c0b7d8c5e16d4ebaf1">&sect;&nbsp;</a></span>condition <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::condition</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bda0f76a143924bb02b96d4847c3a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bda0f76a143924bb02b96d4847c3a0a">&sect;&nbsp;</a></span>pktConf <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::pktConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63996ff20fb50141fc4bb2c5a09645cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63996ff20fb50141fc4bb2c5a09645cb">&sect;&nbsp;</a></span>rxConf <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::rxConf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RX configuration. </p>

</div>
</div>
<a id="a40ce004617de27a474dffc827e3864fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ce004617de27a474dffc827e3864fb">&sect;&nbsp;</a></span>hdrConf <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::hdrConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf41d86f3170b9b39ac0ad7b95391673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf41d86f3170b9b39ac0ad7b95391673">&sect;&nbsp;</a></span>addrConf <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::addrConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a563740dc5b2075f4bf9f573300dc1f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563740dc5b2075f4bf9f573300dc1f9b">&sect;&nbsp;</a></span>endTrigger <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::endTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger classifier for ending the operation. </p>

</div>
</div>
<a id="a0745fcfdc2908b3198f7dde7a48d65fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0745fcfdc2908b3198f7dde7a48d65fb">&sect;&nbsp;</a></span>csConf <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::csConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad373c7de6a25960c0f7c1e28e4a189ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad373c7de6a25960c0f7c1e28e4a189ea">&sect;&nbsp;</a></span>corrConfig <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::corrConfig</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc921e07a692640e3de3d1020713a334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc921e07a692640e3de3d1020713a334">&sect;&nbsp;</a></span>csEndTrigger <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::csEndTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger classifier for ending the carrier sense. </p>

</div>
</div>
<a id="a9aa0604b238436d3ab010e0fc50d8e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa0604b238436d3ab010e0fc50d8e43">&sect;&nbsp;</a></span>startTrigger <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::startTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identification of the trigger that starts the operation. </p>

</div>
</div>
<a id="a9c64ff37de0b8a41b97041b64b3be627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c64ff37de0b8a41b97041b64b3be627">&sect;&nbsp;</a></span>condition <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::condition</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b38761da5a279ab17ccb11a30703ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b38761da5a279ab17ccb11a30703ecd">&sect;&nbsp;</a></span>pktConf <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::pktConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a410869b0657acb62a919601e879c8366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410869b0657acb62a919601e879c8366">&sect;&nbsp;</a></span>rxConf <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::rxConf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RX configuration. </p>

</div>
</div>
<a id="ae0997a58663233e1dbadb6cad3e59015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0997a58663233e1dbadb6cad3e59015">&sect;&nbsp;</a></span>hdrConf <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::hdrConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad909ab28abd12fe5c42a40317e06508f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad909ab28abd12fe5c42a40317e06508f">&sect;&nbsp;</a></span>addrConf <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::addrConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4461c142a1b533ccd6c7a1ab7bb6b1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4461c142a1b533ccd6c7a1ab7bb6b1e6">&sect;&nbsp;</a></span>endTrigger <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::endTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger classifier for ending the operation. </p>

</div>
</div>
<a id="aadb058330f9bf4d0c588680474264efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb058330f9bf4d0c588680474264efb">&sect;&nbsp;</a></span>csConf <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::csConf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96eec3cd3b2049ece71850fee4ef263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96eec3cd3b2049ece71850fee4ef263b">&sect;&nbsp;</a></span>corrConfig <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::corrConfig</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae421d55c2ab08a2c64c67e678544a700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae421d55c2ab08a2c64c67e678544a700">&sect;&nbsp;</a></span>csEndTrigger <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   rfc_CMD_PROP_RX_ADV_SNIFF_s::csEndTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger classifier for ending the carrier sense. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="cc13x2__cc26x2_2driverlib_2rf__prop__cmd_8h_source.html">cc13x2_cc26x2/driverlib/rf_prop_cmd.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
