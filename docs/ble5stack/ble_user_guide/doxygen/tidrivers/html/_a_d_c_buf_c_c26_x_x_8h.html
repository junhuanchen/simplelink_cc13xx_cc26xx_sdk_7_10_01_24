<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>API Documentation: ADCBufCC26XX.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API Documentation
   &#160;<span id="projectnumber">2.02.08.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7cbdeeebfd6c35dfb9f916d627233e4c.html">.build.ble5.cc13xx_cc26xx</a></li><li class="navelem"><a class="el" href="dir_b2f8c81104a2ac3484e8fd4e13690447.html">api-sources</a></li><li class="navelem"><a class="el" href="dir_f3b85fdd586b4d5305da1fbc937bb135.html">tidrivers</a></li><li class="navelem"><a class="el" href="dir_441a49e194f6815a0bbfd80143881040.html">source</a></li><li class="navelem"><a class="el" href="dir_fa51baead25b91abbb34fe63ff5bf27a.html">ti</a></li><li class="navelem"><a class="el" href="dir_a11f29ccc0b8753095dc31bd7d48d03d.html">drivers</a></li><li class="navelem"><a class="el" href="dir_e3ee222035625358d639f9a60560698a.html">adcbuf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ADCBufCC26XX.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ADCBuf driver implementation for a CC26XX analog-to-digital converter.  
<a href="#details">More...</a></p>

<p><a href="_a_d_c_buf_c_c26_x_x_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c_buf_c_c26_x_x___adc_channel_lut_entry.html">ADCBufCC26XX_AdcChannelLutEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table entry that maps a virtual adc channel to a dio and its corresponding internal analogue signal.  <a href="struct_a_d_c_buf_c_c26_x_x___adc_channel_lut_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c_buf_c_c26_x_x___h_w_attrs.html">ADCBufCC26XX_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADCBufCC26XX Hardware Attributes.  <a href="struct_a_d_c_buf_c_c26_x_x___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c_buf_c_c26_x_x___object.html">ADCBufCC26XX_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADCBufCC26XX Object.  <a href="struct_a_d_c_buf_c_c26_x_x___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html">ADCBufCC26XX_ParamsExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CC26XX specfic extension to <a class="el" href="struct_a_d_c_buf___params.html" title="ADCBuf parameters used with ADCBuf_open(). ">ADCBuf_Params</a>.  <a href="struct_a_d_c_buf_c_c26_x_x___params_extension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7445395fba5609c1fccae4b67c72f0cd"><td class="memItemLeft" align="right" valign="top"><a id="a7445395fba5609c1fccae4b67c72f0cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADCBufCC26XX_BYTES_PER_SAMPLE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a7445395fba5609c1fccae4b67c72f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a536e47b039d0f506a4245079af247e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c_buf___c_m_d.html#ga0a536e47b039d0f506a4245079af247e">ADCBufCC26XX_CMD_ACQUIRE_ADC_SEMAPHORE</a>&#160;&#160;&#160;<a class="el" href="group___a_d_c_buf___c_o_n_t_r_o_l.html#ga6d889e191027535ad318be0b9c3765d1">ADCBuf_CMD_RESERVED</a> + 1</td></tr>
<tr class="memdesc:ga0a536e47b039d0f506a4245079af247e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This control function acquires the semaphore that arbitrates access to the ADC between the CM3 and the sensor controller.  <a href="group___a_d_c_buf___c_m_d.html#ga0a536e47b039d0f506a4245079af247e">More...</a><br /></td></tr>
<tr class="separator:ga0a536e47b039d0f506a4245079af247e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830dac4199ded43c278e48bb1fe9725e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c_buf___c_m_d.html#ga830dac4199ded43c278e48bb1fe9725e">ADCBufCC26XX_CMD_KEEP_ADC_SEMAPHORE</a>&#160;&#160;&#160;<a class="el" href="group___a_d_c_buf___c_o_n_t_r_o_l.html#ga6d889e191027535ad318be0b9c3765d1">ADCBuf_CMD_RESERVED</a> + 2</td></tr>
<tr class="memdesc:ga830dac4199ded43c278e48bb1fe9725e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes the ADC driver keep the ADC semaphore until released.  <a href="group___a_d_c_buf___c_m_d.html#ga830dac4199ded43c278e48bb1fe9725e">More...</a><br /></td></tr>
<tr class="separator:ga830dac4199ded43c278e48bb1fe9725e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23015764922f21c49518aa1050d70c0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c_buf___c_m_d.html#ga23015764922f21c49518aa1050d70c0e">ADCBufCC26XX_CMD_KEEP_ADC_SEMAPHORE_DISABLE</a>&#160;&#160;&#160;<a class="el" href="group___a_d_c_buf___c_o_n_t_r_o_l.html#ga6d889e191027535ad318be0b9c3765d1">ADCBuf_CMD_RESERVED</a> + 3</td></tr>
<tr class="memdesc:ga23015764922f21c49518aa1050d70c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes the ADC driver no longer keep the ADC semaphore until released.  <a href="group___a_d_c_buf___c_m_d.html#ga23015764922f21c49518aa1050d70c0e">More...</a><br /></td></tr>
<tr class="separator:ga23015764922f21c49518aa1050d70c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacc1d31de8c38e71c351bc1fcd54340"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c_buf___c_m_d.html#gaaacc1d31de8c38e71c351bc1fcd54340">ADCBufCC26XX_CMD_RELEASE_ADC_SEMAPHORE</a>&#160;&#160;&#160;<a class="el" href="group___a_d_c_buf___c_o_n_t_r_o_l.html#ga6d889e191027535ad318be0b9c3765d1">ADCBuf_CMD_RESERVED</a> + 4</td></tr>
<tr class="memdesc:gaaacc1d31de8c38e71c351bc1fcd54340"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases the ADC semaphore.  <a href="group___a_d_c_buf___c_m_d.html#gaaacc1d31de8c38e71c351bc1fcd54340">More...</a><br /></td></tr>
<tr class="separator:gaaacc1d31de8c38e71c351bc1fcd54340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909590e3cb53a9e496ee7d706edad6cd"><td class="memItemLeft" align="right" valign="top"><a id="a909590e3cb53a9e496ee7d706edad6cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a909590e3cb53a9e496ee7d706edad6cd">ADCBufCC26XX_RESOLUTION</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:a909590e3cb53a9e496ee7d706edad6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolution in bits of the CC26XX ADC. <br /></td></tr>
<tr class="separator:a909590e3cb53a9e496ee7d706edad6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab389f772a18ecbc75003f454c938f548"><td class="memItemLeft" align="right" valign="top"><a id="ab389f772a18ecbc75003f454c938f548"></a>
typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___object.html">ADCBufCC26XX_Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ADCBufCC26XX_Handle</b></td></tr>
<tr class="separator:ab389f772a18ecbc75003f454c938f548"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a31a41d718712f3d4ff936bb566da0d0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">ADCBufCC26XX_Reference_Source</a> { <b>ADCBufCC26XX_FIXED_REFERENCE</b> = AUXADC_REF_FIXED, 
<b>ADCBufCC26XX_VDDS_REFERENCE</b> = AUXADC_REF_VDDS_REL
 }<tr class="memdesc:a31a41d718712f3d4ff936bb566da0d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source.  <a href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a31a41d718712f3d4ff936bb566da0d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95bf383dea0206b6708496a034a9fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">ADCBufCC26XX_Sampling_Duration</a> { <br />
&#160;&#160;<b>ADCBufCC26XX_SAMPLING_DURATION_2P7_US</b> = AUXADC_SAMPLE_TIME_2P7_US, 
<b>ADCBufCC26XX_SAMPLING_DURATION_5P3_US</b> = AUXADC_SAMPLE_TIME_5P3_US, 
<b>ADCBufCC26XX_SAMPLING_DURATION_10P6_US</b> = AUXADC_SAMPLE_TIME_10P6_US, 
<b>ADCBufCC26XX_SAMPLING_DURATION_21P3_US</b> = AUXADC_SAMPLE_TIME_21P3_US, 
<br />
&#160;&#160;<b>ADCBufCC26XX_SAMPLING_DURATION_42P6_US</b> = AUXADC_SAMPLE_TIME_42P6_US, 
<b>ADCBufCC26XX_SAMPLING_DURATION_85P3_US</b> = AUXADC_SAMPLE_TIME_85P3_US, 
<b>ADCBufCC26XX_SAMPLING_DURATION_170_US</b> = AUXADC_SAMPLE_TIME_170_US, 
<b>ADCBufCC26XX_SAMPLING_DURATION_341_US</b> = AUXADC_SAMPLE_TIME_341_US, 
<br />
&#160;&#160;<b>ADCBufCC26XX_SAMPLING_DURATION_682_US</b> = AUXADC_SAMPLE_TIME_682_US, 
<b>ADCBufCC26XX_SAMPLING_DURATION_1P37_MS</b> = AUXADC_SAMPLE_TIME_1P37_MS, 
<b>ADCBufCC26XX_SAMPLING_DURATION_2P73_MS</b> = AUXADC_SAMPLE_TIME_2P73_MS, 
<b>ADCBufCC26XX_SAMPLING_DURATION_5P46_MS</b> = AUXADC_SAMPLE_TIME_5P46_MS, 
<br />
&#160;&#160;<b>ADCBufCC26XX_SAMPLING_DURATION_10P9_MS</b> = AUXADC_SAMPLE_TIME_10P9_MS
<br />
 }<tr class="memdesc:a4a95bf383dea0206b6708496a034a9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of time the ADC spends sampling the analogue input.  <a href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4a95bf383dea0206b6708496a034a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816f299f98f8fc3cc1124cda74a18d10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">ADCBufCC26XX_Sampling_Mode</a> { <b>ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS</b>, 
<b>ADCBufCC26XX_SAMPING_MODE_ASYNCHRONOUS</b>
 }<tr class="memdesc:a816f299f98f8fc3cc1124cda74a18d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source.  <a href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a816f299f98f8fc3cc1124cda74a18d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab26fa75463dae8b7a8c9d7585735177a"><td class="memItemLeft" align="right" valign="top"><a id="ab26fa75463dae8b7a8c9d7585735177a"></a>
const <a class="el" href="struct_a_d_c_buf___fxn_table.html">ADCBuf_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ADCBufCC26XX_fxnTable</b></td></tr>
<tr class="separator:ab26fa75463dae8b7a8c9d7585735177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ADCBuf driver implementation for a CC26XX analog-to-digital converter. </p>
<hr/>
<h1>Driver include</h1>
<p>The ADCBuf header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_d_c_buf_8h.html">ti/drivers/ADCBuf.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ti/drivers/adc/ADCBufCC26XX.h&gt;</span></div></div><!-- fragment --><h1>Overview</h1>
<p>This is a CC26XX specific implementation of the generic TI-RTOS ADCBuf driver. The generic ADCBuf API specified in <a class="el" href="_a_d_c_buf_8h.html" title="Analog to Digital Conversion Buffer (ADCBuf) Input Driver. ">ti/drivers/ADCBuf.h</a> should be called by the application, not the device specific implementation in ti/drivers/adcbuf/ADCBufCC26XX. The board file defines the device specific configuration and casting in the general API ensures the correct device specific functions are called. You should specify an <a class="el" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html" title="CC26XX specfic extension to ADCBuf_Params. ">ADCBufCC26XX_ParamsExtension</a> in the custom field of the <a class="el" href="struct_a_d_c_buf___params.html" title="ADCBuf parameters used with ADCBuf_open(). ">ADCBuf_Params</a> that suits your application. The default settings work for many, but not all, use cases.</p>
<h1>General Behavior</h1>
<p>A timer and the DMA are used to trigger the ADC and fill a buffer in the background (in hardware) at a specified frequency. The application may execute other tasks while the hardware handles the conversions. In contrast to the standard ti/drivers/ADC driver, this driver allows for precise sampling of waveforms.</p>
<table class="doxtable">
<tr>
<th>Driver </th><th>Number of samples needed in one call  </th></tr>
<tr>
<td><a class="el" href="_a_d_c_8h.html" title="Analog to Digital Conversion (ADC) Input Driver. ">ADC.h</a> </td><td>1 </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html" title="Analog to Digital Conversion Buffer (ADCBuf) Input Driver. ">ADCBuf.h</a> </td><td>&gt; 1 </td></tr>
</table>
<p>This ADCBuf driver provides an API interface to using the analog-to-digital converter directly from the CM3 without going through the sensor controller. The sensor controller can still use the ADC, support for sharing the ADC resource between the sensor controller and the CM3 is built into the driver. There is a hardware semaphore that the driver must acquire before beginning any number of conversions. This same hardware semaphore also prevents the simultaneous use of this driver and the basic ADC driver.</p>
<p>The ADC drivers supports making between one and 1024 measurements once or continuous measuring with returned buffer sizes between one and 1024 measurements.</p>
<p>The application should call <a class="el" href="_a_d_c_buf_8h.html#a88a0ab421304465b22417a7adef6c0c2" title="Function to initialize the ADCBuf driver. ">ADCBuf_init()</a> once by the application to set the isOpened flag to false, indicating that the driver is ready to use.</p>
<p>The ADC driver is opened by calling <a class="el" href="_a_d_c_buf_8h.html#a292e0e615d57d93c2f87f7e915e7027b" title="This function opens a given ADCBuf peripheral. ">ADCBuf_open()</a> which will set up interrupts and configure the internal components of the driver. However, the ADC hardware or analog pins are not yet configured, since the sensor controller or basic ADC driver might be using the ADC.</p>
<p>In order to perform an ADC conversion, the application should call <a class="el" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97" title="Starts ADCBuf conversions on one or more channels. ">ADCBuf_convert()</a>. This call will request the ADC resource, configure the ADC, set up the DMA and GPTimer, and perform the requested ADC conversions on the selected DIO or internal signal. The DIO or internal signal is defined by the <a class="el" href="struct_a_d_c_buf___conversion.html" title="Defines a conversion to be used with ADCBuf_convert(). ">ADCBuf_Conversion</a> structure in the application code and adcBufCC26xxObjects in the board file.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the ADCBUF driver is setup in ADCBuf_RECURRENCE_MODE_CONTINUOUS mode, the user must assure that the provided callback function is completed before the next conversion completes. If the next conversion completes before the callback function finishes, the DMA will clobber the previous buffer with new data.</dd></dl>
<p>If the sensor controller is using the ADC when the driver requests it at the start of the <a class="el" href="_a_d_c_8h.html#afcac5582b8be42a7740091d150aef05c" title="Function to perform an ADC conversion. ">ADC_convert()</a> call, the conversion will fail and return false. The ADC resource may be pre-acquired by calling the control function ADCBufCC26XX_CMD_ACQUIRE_ADC_SEMAPHORE. It will be released again automatically after the next conversion completes.</p>
<p>In both ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS mode and ADCBufCC26XX_SAMPING_MODE_ASYNCHRONOUS mode, enough sampling time must be provided between conversions that each measurement may be completed before the next trigger arrives.</p>
<dl class="section note"><dt>Note</dt><dd>The ADCBuf driver requires GPTimer0A to function correctly. It expects it to be configured as position 0 in the GPTimer Config Table. GPTimer0A will be unavailable for other uses.</dd></dl>
<h1>Supported ADC pins</h1>
<p>Below is a table of the supported ADC IO pins for each package size, for both CC26xx and CC13xx. It maps a DIO to its corresponding driverlib define for the CompBInput that it is hardwired to. This table can be used to create virtual channel entries in the ADCBufCC26XX_adcChannelLut table in the board file.</p>
<p>| DIO | CC26xx 7x7 AUXIO CompBInput | CC13xx 7x7 AUXIO CompBInput | CC26xx 5x5 AUXIO CompBInput | CC13xx 5x5 AUXIO CompBInput | CC26xx 4x4 AUXIO CompBInput | CC13xx 4x4 AUXIO CompBInput |-----&mdash;|----------------------------&mdash;|----------------------------&mdash;|----------------------------&mdash;|----------------------------&mdash;|----------------------------&mdash;|--------------------------&mdash; | 0 | No | No | No | No | No | No | 1 | No | No | No | No | No | No | 2 | No | No | No | No | No | No | 3 | No | No | No | No | No | No | 4 | No | No | No | No | No | No | 5 | No | No | No | No | ADC_COMPB_IN_AUXIO7 | ADC_COMPB_IN_AUXIO7 | 6 | No | No | No | No | ADC_COMPB_IN_AUXIO6 | ADC_COMPB_IN_AUXIO6 | 7 | No | No | ADC_COMPB_IN_AUXIO7 | ADC_COMPB_IN_AUXIO7 | ADC_COMPB_IN_AUXIO5 | ADC_COMPB_IN_AUXIO5 | 8 | No | No | ADC_COMPB_IN_AUXIO6 | ADC_COMPB_IN_AUXIO6 | ADC_COMPB_IN_AUXIO4 | ADC_COMPB_IN_AUXIO4 | 9 | No | No | ADC_COMPB_IN_AUXIO4 | ADC_COMPB_IN_AUXIO4 | ADC_COMPB_IN_AUXIO3 | ADC_COMPB_IN_AUXIO3 | 10 | No | No | ADC_COMPB_IN_AUXIO5 | ADC_COMPB_IN_AUXIO5 | No | No | 11 | No | No | ADC_COMPB_IN_AUXIO3 | ADC_COMPB_IN_AUXIO3 | No | No | 12 | No | No | ADC_COMPB_IN_AUXIO2 | ADC_COMPB_IN_AUXIO2 | No | No | 13 | No | No | ADC_COMPB_IN_AUXIO1 | ADC_COMPB_IN_AUXIO1 | No | No | 14 | No | No | ADC_COMPB_IN_AUXIO0 | ADC_COMPB_IN_AUXIO0 | No | No | 15-22 | No | No | No | No | No | No | 23 | ADC_COMPB_IN_AUXIO7 | ADC_COMPB_IN_AUXIO7 | No | No | No | No | 24 | ADC_COMPB_IN_AUXIO6 | ADC_COMPB_IN_AUXIO6 | No | No | No | No | 25 | ADC_COMPB_IN_AUXIO5 | ADC_COMPB_IN_AUXIO5 | No | No | No | No | 26 | ADC_COMPB_IN_AUXIO4 | ADC_COMPB_IN_AUXIO4 | No | No | No | No | 27 | ADC_COMPB_IN_AUXIO3 | ADC_COMPB_IN_AUXIO3 | No | No | No | No | 28 | ADC_COMPB_IN_AUXIO2 | ADC_COMPB_IN_AUXIO2 | No | No | No | No | 29 | ADC_COMPB_IN_AUXIO1 | ADC_COMPB_IN_AUXIO1 | No | No | No | No | 30 | ADC_COMPB_IN_AUXIO0 | ADC_COMPB_IN_AUXIO0 | No | No | No | No</p>
<h1>Supported Internal Signals</h1>
<p>Below is a table of internal signals that can be measured using the ADC. Since we are not connecting to a DIO, there is no DIO to internal signal mapping. The DIO field in the channel lookup table should be marked PIN_UNASSIGNED. This table can be used to create virtual channel entries in the ADCBufCC26XX_adcChannelLut table in the board file.</p>
<table class="doxtable">
<tr>
<th>DIO </th><th>Internal Signal CompBInput  </th></tr>
<tr>
<td>PIN_UNASSIGNED </td><td>ADC_COMPB_IN_DCOUPL </td></tr>
<tr>
<td>PIN_UNASSIGNED </td><td>ADC_COMPB_IN_VSS </td></tr>
<tr>
<td>PIN_UNASSIGNED </td><td>ADC_COMPB_IN_VDDS </td></tr>
</table>
<h1>Error handling</h1>
<p>The following errors may occur when opening the ADC without assertions enabled:</p><ul>
<li>The ADC handle is already open.</li>
</ul>
<p>The following errors may occur when requesting an ADC conversion:</p><ul>
<li>The ADC is currently already doing a conversion.</li>
<li>The ADC was not available (used by sensor controller or basic ADC).</li>
</ul>
<h1>Power Management</h1>
<p>The TI-RTOS power management framework will try to put the device into the most power efficient mode whenever possible. Please see the technical reference manual for further details on each power mode.</p>
<p>While converting, the ADCBufCC26XX driver sets a power constraint to keep the device out of standby. When the conversion has finished, the power constraint is released. The driver also sets a dependency on the DMA to enable background transfers from the ADC FIFO to memory and to clear the GPTimer interrupt. The following statements are valid:</p><ul>
<li>After <a class="el" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97" title="Starts ADCBuf conversions on one or more channels. ">ADCBuf_convert()</a>: the device cannot enter standby.</li>
<li>After <a class="el" href="_a_d_c_buf_8h.html#a5201c27bddf11b9f9ae902807bded40d" title="Cancels all ADCBuf conversions in progress. ">ADCBuf_convertCancel()</a>: the device can enter standby again.</li>
<li>After a conversion finishes: the device can enter standby again.</li>
</ul>
<h1>Supported Functions</h1>
<table class="doxtable">
<tr>
<th>API function </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a88a0ab421304465b22417a7adef6c0c2" title="Function to initialize the ADCBuf driver. ">ADCBuf_init()</a> </td><td>Initialize ADC driver </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a292e0e615d57d93c2f87f7e915e7027b" title="This function opens a given ADCBuf peripheral. ">ADCBuf_open()</a> </td><td>Open the ADC driver and configure driver </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97" title="Starts ADCBuf conversions on one or more channels. ">ADCBuf_convert()</a> </td><td>Perform ADC conversion </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a5201c27bddf11b9f9ae902807bded40d" title="Cancels all ADCBuf conversions in progress. ">ADCBuf_convertCancel()</a> </td><td>Cancel ongoing ADC conversion </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a04ab5fae5da8f9ff77ab3ae4974d8f7d" title="Function to close an ADCBuf driver instance. ">ADCBuf_close()</a> </td><td>Close ADC driver </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#ae6ddd34c34fd06cdede98fb01033cc47" title="Initialize an ADCBuf_Params structure to its default values. ">ADCBuf_Params_init()</a> </td><td>Initialise <a class="el" href="struct_a_d_c_buf___params.html" title="ADCBuf parameters used with ADCBuf_open(). ">ADCBuf_Params</a> structure to default values </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a2ff6d7db155bcd1367ef82a9f5cef19c" title="Returns the resolution in bits of the specified ADCBuf instance. ">ADCBuf_getResolution()</a> </td><td>Get the resolution of the ADC of the current device </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a636816201fdb596b748a0ce4d4bf6739" title="Adjust a raw ADC output buffer. The function does the adjustment in-place. ">ADCBuf_adjustRawValues()</a> </td><td>Adjust the values in a returned buffer for manufacturing tolerances </td></tr>
<tr>
<td>ADCBuf_convertAdjustedToMicroVolts </td><td>Convert a buffer of adjusted values to microvolts </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a87678933c235c0bfc1a26472ef873014" title="Function performs implementation specific features on a driver instance. ">ADCBuf_control()</a> </td><td>Execute device specific functions </td></tr>
</table>
<h1>Not Supported Functionality</h1>
<ul>
<li>Performing conversions on multiple channels simultaneously is not supported. In other words, the parameter channelCount must always be set to 1 when calling <a class="el" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97" title="Starts ADCBuf conversions on one or more channels. ">ADCBuf_convert()</a>. The ADC on CC26XX devices does not support time-division multiplexing of channels or pins in hardware.</li>
</ul>
<h1>Use Cases</h1>
<h2>Basic one-shot conversion</h2>
<p>Perform one conversion on CONFIG_ADCCHANNEL_A1 in <a class="el" href="_a_d_c_buf_8h.html#a3d643e8024503c5ef2679c83419ba6eea5c6236b2f629b196d7874175be679399">ADCBuf_RETURN_MODE_BLOCKING</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_d_c_buf_8h.html">ti/drivers/ADCBuf.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ADCBUFFERSIZE   100</span></div><div class="line"></div><div class="line"><a class="code" href="struct_a_d_c_buf___config__.html">ADCBuf_Handle</a> adcBufHandle;</div><div class="line"><a class="code" href="struct_a_d_c_buf___params.html">ADCBuf_Params</a> adcBufParams;</div><div class="line"><a class="code" href="struct_a_d_c_buf___conversion.html">ADCBuf_Conversion</a> blockingConversion;</div><div class="line">uint16_t sampleBufferOne[ADCBUFFERSIZE];</div><div class="line"></div><div class="line"><a class="code" href="_a_d_c_buf_8h.html#ae6ddd34c34fd06cdede98fb01033cc47">ADCBuf_Params_init</a>(&amp;adcBufParams);</div><div class="line">adcBufHandle = <a class="code" href="_a_d_c_buf_8h.html#a292e0e615d57d93c2f87f7e915e7027b">ADCBuf_open</a>(CONFIG_ADCBuf0, &amp;adcBufParams);</div><div class="line"><span class="keywordflow">if</span> (adcBufHandle == NULL) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a47080bd2e4d552858be60f6e25be58dc">arg</a> = NULL;</div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a379de126469bdd35de64c36498fafb51">adcChannel</a> = CONFIG_ADCCHANNEL_A1;</div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a5415e58a69e40124f66cdcc52a097c4a">sampleBuffer</a> = sampleBufferOne;</div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a6953e200ba2e5a85b9197bdaeb101a5f">sampleBufferTwo</a> = NULL;</div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#afd95c203d1e7dd347102eef22dc9cc93">samplesRequestedCount</a> = ADCBUFFERSIZE;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97">ADCBuf_convert</a>(adcBufHandle, &amp;blockingConversion, 1) != <a class="code" href="group___a_d_c_buf___c_o_n_t_r_o_l.html#gac9c96db575dfaa6bcdfbd94cd875fbd4">ADCBuf_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div></div><!-- fragment --><h2>Using <a class="el" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html" title="CC26XX specfic extension to ADCBuf_Params. ">ADCBufCC26XX_ParamsExtension</a></h2>
<p>This specific configuration performs one conversion on CONFIG_ADCCHANNEL_A1 in <a class="el" href="_a_d_c_buf_8h.html#a3d643e8024503c5ef2679c83419ba6eea5c6236b2f629b196d7874175be679399">ADCBuf_RETURN_MODE_BLOCKING</a>. The custom parameters used here are identical to the defaults parameters. Users can of course define their own parameters. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_d_c_buf_8h.html">ti/drivers/ADCBuf.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ADCBUFFERSIZE   100</span></div><div class="line"></div><div class="line"><a class="code" href="struct_a_d_c_buf___config__.html">ADCBuf_Handle</a> adcBufHandle;</div><div class="line"><a class="code" href="struct_a_d_c_buf___params.html">ADCBuf_Params</a> adcBufParams;</div><div class="line"><a class="code" href="struct_a_d_c_buf___conversion.html">ADCBuf_Conversion</a> blockingConversion;</div><div class="line">uint16_t sampleBufferOne[ADCBUFFERSIZE];</div><div class="line"><a class="code" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html">ADCBufCC26XX_ParamsExtension</a> customParams;</div><div class="line"></div><div class="line"><a class="code" href="_a_d_c_buf_8h.html#ae6ddd34c34fd06cdede98fb01033cc47">ADCBuf_Params_init</a>(&amp;adcBufParams);</div><div class="line">customParams.<a class="code" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html#a13ae8ecf30cf89b0961f1c0dae0f8fae">samplingDuration</a>    = ADCBufCC26XX_SAMPLING_DURATION_2P7_US;</div><div class="line">customParams.<a class="code" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html#ac969cbedfed803be061feb5c82d58c66">refSource</a>           = ADCBufCC26XX_FIXED_REFERENCE;</div><div class="line">customParams.<a class="code" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html#af857a78cd52526e581e82d154793a221">samplingMode</a>        = ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS;</div><div class="line">customParams.<a class="code" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html#a2fc973ed16c05717691222fe517691a3">inputScalingEnabled</a> = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">adcBufParams.<a class="code" href="struct_a_d_c_buf___params.html#a72c7ec51318ec2f8fcf5d2ff37de33e3">custom</a> = &amp;customParams;</div><div class="line"></div><div class="line">adcBufHandle = <a class="code" href="_a_d_c_buf_8h.html#a292e0e615d57d93c2f87f7e915e7027b">ADCBuf_open</a>(CONFIG_ADCBuf0, &amp;adcBufParams);</div><div class="line"><span class="keywordflow">if</span> (adcBufHandle == NULL) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a47080bd2e4d552858be60f6e25be58dc">arg</a> = NULL;</div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a379de126469bdd35de64c36498fafb51">adcChannel</a> = CONFIG_ADCCHANNEL_A1;</div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a5415e58a69e40124f66cdcc52a097c4a">sampleBuffer</a> = sampleBufferOne;</div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a6953e200ba2e5a85b9197bdaeb101a5f">sampleBufferTwo</a> = NULL;</div><div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#afd95c203d1e7dd347102eef22dc9cc93">samplesRequestedCount</a> = ADCBUFFERSIZE;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97">ADCBuf_convert</a>(adcBufHandle, &amp;blockingConversion, 1) != <a class="code" href="group___a_d_c_buf___c_o_n_t_r_o_l.html#gac9c96db575dfaa6bcdfbd94cd875fbd4">ADCBuf_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div></div><!-- fragment --><h1>Instrumentation</h1>
<p>The ADC driver interface produces log statements if instrumentation is enabled.</p>
<table class="doxtable">
<tr>
<th>Diagnostics Mask </th><th>Log details  </th></tr>
<tr>
<td>Diags_USER1 </td><td>basic ADCBuf operations performed </td></tr>
<tr>
<td>Diags_USER2 </td><td>detailed ADCBuf operations performed </td></tr>
</table>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a31a41d718712f3d4ff936bb566da0d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a41d718712f3d4ff936bb566da0d0a">&sect;&nbsp;</a></span>ADCBufCC26XX_Reference_Source</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">ADCBufCC26XX_Reference_Source</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source. </p>
<ul>
<li>In practice, using the internal fixed voltage reference sets the upper range of the ADC to a fixed value. That value is 4.3V with input scaling enabled and ~1.4785V with input scaling disabled. In this mode, the output is a function of the input voltage multiplied by the resolution in alternatives (not bits) divided by the upper voltage range of the ADC. Output = Input (V) * 2^12 / (ADC range (V))</li>
<li>Using VDDS as a reference scales the upper range of the ADC with the battery voltage. As the battery depletes and its voltage drops, so does the range of the ADC. This is helpful when measuring signals that are generated relative to the battery voltage. In this mode, the output is a function of the input voltage multiplied by the resolution in alternatives (not bits) divided by VDDS multiplied by a scaling factor derived from the input scaling. Output = Input (V) * 2^12 / (VDDS (V) * Scaling factor), where the scaling factor is ~1.4785/4.3 for input scaling disabled and 1 for input scaling enabled.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The actual reference values are slightly different for each device and are higher than the values specified above. This gain is saved in the FCFG. The function ADCBuf_convertRawToMicroVolts() must be used to derive actual voltage values. Do not attempt to compare raw values between devices or derive a voltage from them yourself. The results of doing so will only be approximately correct.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Even though the upper voltage range of the ADC is 4.3 volts in fixed mode with input scaling enabled, the input should never exceed VDDS as per the data sheet. </dd></dl>

</div>
</div>
<a id="a4a95bf383dea0206b6708496a034a9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95bf383dea0206b6708496a034a9fb">&sect;&nbsp;</a></span>ADCBufCC26XX_Sampling_Duration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">ADCBufCC26XX_Sampling_Duration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Amount of time the ADC spends sampling the analogue input. </p>
<p>The analogue to digital conversion process consists of two phases in the CC26XX ADC, the sampling and conversion phases. During the sampling phase, the ADC samples the analogue input signal. Larger input loads require longer sample times for the most accurate results. In ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS mode, this enum specifies the sampling times available. </p>

</div>
</div>
<a id="a816f299f98f8fc3cc1124cda74a18d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816f299f98f8fc3cc1124cda74a18d10">&sect;&nbsp;</a></span>ADCBufCC26XX_Sampling_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">ADCBufCC26XX_Sampling_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source. </p>
<p>The CC26XX ADC can operate in two different ways with regards to the sampling phase of the ADC conversion process:</p><ul>
<li>It can spend a fixed amount of time sampling the signal after getting the start conversion trigger.</li>
<li>It can constantly keep sampling and immediately start the conversion process after getting the trigger.</li>
</ul>
<p>In ADCBufCC26XX_SYNCHRONOUS mode, the ADC goes into IDLE in between conversions and uses less power. The minimum sample time for full precision in ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS is dependent on the input load. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 21 2023 18:46:20 for API Documentation by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
