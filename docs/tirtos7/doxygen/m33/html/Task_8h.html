<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SYS/BIOS: /home/developer/.conan/data/tirtos/7.03.00.10/library-sb/ga/build/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/kernel/tirtos7/packages/ti/sysbios/knl/Task.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SYS/BIOS
   &#160;<span id="projectnumber">7.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_166a36ee10a8457f2f1d507eafd683e9.html">developer</a></li><li class="navelem"><a class="el" href="dir_ab47aaff52849945b02749b38626f831.html">.conan</a></li><li class="navelem"><a class="el" href="dir_2db58af45ff07475e1865bb6cfecd114.html">data</a></li><li class="navelem"><a class="el" href="dir_73aa28e1938cea8ca02173a6a02bb3cc.html">tirtos</a></li><li class="navelem"><a class="el" href="dir_b92035bd439bf87970152b15ca557739.html">7.03.00.10</a></li><li class="navelem"><a class="el" href="dir_a8aafc4147cd9aeef51c3eea0146f858.html">library-sb</a></li><li class="navelem"><a class="el" href="dir_cd46cd47afafa592114402c4301543d5.html">ga</a></li><li class="navelem"><a class="el" href="dir_2cab851584a752880681e90a2dfd4edd.html">build</a></li><li class="navelem"><a class="el" href="dir_5697d1fa77239cd87167d697b8481edf.html">5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9</a></li><li class="navelem"><a class="el" href="dir_a25849b87dcee5ac6bd91808e0cfd56f.html">kernel</a></li><li class="navelem"><a class="el" href="dir_62fe09a765bfb79fe774e523a5e63239.html">tirtos7</a></li><li class="navelem"><a class="el" href="dir_e3f05480a1de819db6de4292a46ffd2c.html">packages</a></li><li class="navelem"><a class="el" href="dir_c9091c0837bc7d5e21af62b18a8f3d2f.html">ti</a></li><li class="navelem"><a class="el" href="dir_e302b19c208f2b8f03cb96305b4c2fcc.html">sysbios</a></li><li class="navelem"><a class="el" href="dir_12d1e7e42787b42b41dd49f4db30667e.html">knl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Task.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Task Manager. </p>
<p>The Task module makes available a set of functions that manipulate task objects accessed through pointers of type <a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>. Tasks represent independent threads of control that conceptually execute functions in parallel within a single C program; in reality, concurrency is achieved by switching the processor from one task to another.</p>
<p>All tasks executing within a single program share a common set of global variables, accessed according to the standard rules of scope defined for C functions.</p>
<p>Each task is in one of five modes of execution at any point in time: running, ready, blocked, terminated, or inactive. By design, there is always one (and only one) task currently running, even if it is only the idle task managed internally by Task. The current task can be suspended from execution by calling certain Task functions, as well as functions provided by other modules like the Semaphore or Event Modules. The current task can also terminate its own execution. In either case, the processor is switched to the highest priority task that is ready to run.</p>
<p>You can assign numeric priorities to tasks. Tasks are readied for execution in strict priority order; tasks of the same priority are scheduled on a first-come, first-served basis. The priority of the currently running task is never lower than the priority of any ready task. Conversely, the running task is preempted and re-scheduled for execution whenever there exists some ready task of higher priority.</p>
<p>To use the Task module or to set any of the Task module configuration variables, the following must be added to the app.syscfg file:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Task = scripting.addModule(<span class="stringliteral">&quot;/ti/sysbios/knl/Task&quot;</span>);</div></div><!-- fragment --><h3>Task Stacks</h3>
<p>When you create a task, it is provided with its own run-time stack, used for storing local variables as well as for further nesting of function calls. Each stack must be large enough to handle normal subroutine calls and one task preemption context. A task preemption context is the context that gets saved when one task preempts another as a result of an interrupt thread readying a higher-priority task.</p>
<p>See the BIOS User's Guide for further discussions regarding task stack sizing.</p>
<p>Certain system configuration settings will result in task stacks needing to be large enough to absorb two interrupt contexts rather than just one. Setting the BIOS logsEnabled configuration parameter to 'true' or installing any Task hooks will have the side effect of allowing up to two interrupt contexts to be placed on a task stack.</p>
<h3>Task Deletion</h3>
<p>Any dynamically created task that is not in the Task_Mode_RUNNING state (ie not the currently running task) can be deleted using the <a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62">Task_delete</a> API.</p>
<p><a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62" title="Delete a task. ">Task_delete()</a> removes the task from all internal queues and calls <a class="el" href="Memory_8h.html#a9c912f5cb67b746653d06fe93aeb4de7" title="Frees the space if the heap manager offers such functionality. ">Memory_free()</a> is used to free the task object and its stack. <a class="el" href="Memory_8h.html#a9c912f5cb67b746653d06fe93aeb4de7" title="Frees the space if the heap manager offers such functionality. ">Memory_free()</a> must acquire a lock to the memory before proceeding. If another task already holds a lock to the memory, then the thread performing the delete will be blocked until the memory is unlocked.</p>
<p>Note: <a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62" title="Delete a task. ">Task_delete()</a> should be called with extreme care. As mentioned above, the scope of <a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62" title="Delete a task. ">Task_delete()</a> is limited to freeing the Task object itself, freeing the task's stack memory if it was allocated at create time, and removing the task from any SYS/BIOS-internal state structures.</p>
<p>SYS/BIOS does not keep track of any resources the task may have acquired or used during its lifetime.</p>
<p>It is the application's responsibility to guarantee the integrity of a task's partnerships prior to deleting that task.</p>
<p>For example, if a task has obtained exclusive access to a resource, deleting that task will make the resource forever unavailable.</p>
<p><a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62" title="Delete a task. ">Task_delete()</a> sets the referenced task handle to NULL. Any subsequent call to a Task instance API using that null task handle will behave unpredictably and will usually result in an application crash.</p>
<p>Assuming a task completely cleans up after itself prior to calling <a class="el" href="Task_8h.html#a46b487c00368dff4ad9fd7176893060d" title="Terminate execution of the current task. ">Task_exit()</a> (or falling through the the bottom of the task function), it is then safest to use <a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62" title="Delete a task. ">Task_delete()</a> only when a task is in the 'Task_Mode_TERMINATED' state.</p>
<p>Delete hooks: You can specify application-wide Delete hook functions that run whenever a task is deleted. See the discussion of Hook Functions below for details.</p>
<p><a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62" title="Delete a task. ">Task_delete()</a> constraints:</p>
<ul>
<li>The task cannot be the currently executing task (<a class="el" href="Task_8h.html#a45fb642c2d262f0cca5307323e8fc765" title="Returns a handle to the currently executing Task object. ">Task_self()</a>).</li>
<li>Task_delete cannot be called from a Swi or Hwi.</li>
<li>No check is performed to prevent Task_delete from being used on a statically-created object. If a program attempts to delete a task object that was created statically, the <a class="el" href="Memory_8h.html#a9c912f5cb67b746653d06fe93aeb4de7" title="Frees the space if the heap manager offers such functionality. ">Memory_free()</a> call will result in an assertion failure in its corresponding Heap manager, causing the application to exit.</li>
</ul>
<h3>Stack Alignment</h3>
<p>Stack size parameters for both static and dynamic tasks are rounded up to the nearest integer multiple of a target-specific alignment requirement.</p>
<p>In the case of Task's which are created with a user-provided stack, both the base address and the stackSize are aligned. The base address is increased to the nearest aligned address. The stack size is decreased accordingly and then rounded down to the nearest integer multiple of the target-specific required alignment.</p>
<p><a class="anchor" id="taskHookFunctions"></a> <b>Hook Functions</b></p>
<p>Sets of hook functions can be specified for the Task module. Each set can contain these hook functions:</p>
<ul>
<li>Register: A function called before any statically created tasks are initialized at runtime. The register hook is called at boot time before main() and before interrupts are enabled.</li>
<li>Create: A function that is called when a task is created. This includes tasks that are created statically and those created dynamically using Task_create or Task_construct. For statically created tasks, create hook is called before main() and before interrupts are enabled. For dynamically created or constructed tasks, create hook is called in the same context the task is created or constructed in i.e. if a task is created in main(), the create hook is called in main context and if the task is created within another task, it is called in task context. The create hook is called outside of a Task_disable/enable block and before the task has been added to the ready list.</li>
<li>Ready: A function that is called when a task becomes ready to run. The ready hook is called in the context of the thread unblocking a task and therefore it can be called in Hwi, Swi or Task context. If a Swi or Hwi posts a semaphore that unblocks a task, the ready hook would be called in the Swi or Hwi's context. The ready hook is called from within a Task_disable/enable block with interrupts enabled.</li>
<li>Switch: A function that is called just before a task switch occurs. The 'prev' and 'next' task handles are passed to the switch hook. 'prev' is set to NULL for the initial task switch that occurs during SYS/BIOS startup. The switch hook is called from within a Task_disable/enable block with interrupts enabled, in the context of the task being switched from (ie: the <code>prev</code> task).</li>
<li>Exit: A function that is called when a task exits using Task_exit. It is called in the exiting task's context. The exit hook is passed the handle of the exiting task. The exit hook is called outside of a Task_disable/enable block and before the task has been removed from the kernel lists.</li>
<li>Delete: A function that is called when any task is deleted at run-time with Task_delete. The delete hook is called in idle task context if Task_deleteTerminatedTasks is set to true. Otherwise, it is called in the context of the task that is deleting another task. The delete hook is called outside of a Task_disable/enable block.</li>
</ul>
<p>Hook functions can only be configured statically.</p>
<p>If you define more than one set of hook functions, all the functions of a particular type will be run when a Task triggers that type of hook.</p>
<p>To add a Task hook or set of Task hooks, the following syntax is used in the app.syscfg file:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Task = scripting.addModule(<span class="stringliteral">&quot;/ti/sysbios/knl/Task&quot;</span>);</div><div class="line">Task.taskHooks.create(1);</div><div class="line">Task.taskHooks[0].registerFxn = <span class="stringliteral">&quot;myRegisterFxn&quot;</span>;</div><div class="line">Task.taskHooks[0].createFxn   = <span class="stringliteral">&quot;myCreateFxn&quot;</span>;</div><div class="line">Task.taskHooks[0].readyFxn    = <span class="stringliteral">&quot;myReadyFxn&quot;</span>;</div><div class="line">Task.taskHooks[0].switchFxn   = <span class="stringliteral">&quot;mySwitchFxn&quot;</span>;</div><div class="line">Task.taskHooks[0].exitFxn     = <span class="stringliteral">&quot;myExitFxn&quot;</span>;</div><div class="line">Task.taskHooks[0].deleteFxn   = <span class="stringliteral">&quot;myDeleteFxn&quot;</span>;</div></div><!-- fragment --><p>Leaving a subset of the hook functions undefined is ok.</p>
<dl class="section warning"><dt>Warning</dt><dd>Configuring ANY Task hook function will have the side effect of allowing up to two interrupt contexts beings saved on a task stack. Be careful to size your task stacks accordingly.</dd></dl>
<p><b>Register Function</b></p>
<p>The Register function is provided to allow a hook set to store its hookset ID. This id can be passed to <a class="el" href="Task_8h.html#a31eb12719762e79487fb664650ab3901">Task_setHookContext</a> and <a class="el" href="Task_8h.html#a6fc7717c2bdb76d42723b713428b5f43">Task_getHookContext</a> to set or get hookset-specific context. The Register function must be specified if the hook implementation needs to use <a class="el" href="Task_8h.html#a31eb12719762e79487fb664650ab3901">Task_setHookContext</a> or <a class="el" href="Task_8h.html#a6fc7717c2bdb76d42723b713428b5f43">Task_getHookContext</a>. The registerFxn hook function is called during system initialization before interrupts have been enabled.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myRegisterFxn(<span class="keywordtype">int</span> <span class="keywordtype">id</span>);</div></div><!-- fragment --><p><b>Create and Delete Functions</b></p>
<p>The create and delete functions are called whenever a Task is created or deleted. They are called with interrupts enabled (unless called at boot time or from main()).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myCreateFxn(<a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, <a class="code" href="structError__Block.html">Error_Block</a> *eb);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> myDeleteFxn(<a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task);</div></div><!-- fragment --><p><b>Switch Function</b></p>
<p>If a switch function is specified, it is invoked just before the new task is switched to. The switch function is called with interrupts enabled.</p>
<p>This function can be used to save/restore additional task context (for example, external hardware registers), to check for task stack overflow, to monitor the time used by each task, etc.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> mySwitchFxn(<a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> prev, <a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> next);</div></div><!-- fragment --><p>To properly handle the switch to the first task your switchFxn should check for "prev == NULL" before using prev:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> mySwitchFxn(<a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> prev, <a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> next)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (prev != NULL) {</div><div class="line">        ...</div><div class="line">    }</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p><b>Ready Function</b></p>
<p>If a ready function is specified, it is invoked whenever a task is made ready to run. The ready function is called with interrupts enabled (unless called at boot time or from main()).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myReadyFxn(<a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task);</div></div><!-- fragment --><p><b>Exit Function</b></p>
<p>If an exit function is specified, it is invoked when a task exits (via call to <a class="el" href="Task_8h.html#a46b487c00368dff4ad9fd7176893060d" title="Terminate execution of the current task. ">Task_exit()</a> or when a task returns from its' main function). The Exit Function is called with interrupts enabled.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myExitFxn(<a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task);</div></div><!-- fragment --><p> 
 <h3> Calling Context </h3>
 <table border="1" cellpadding="3">
   <colgroup span="1"></colgroup> <colgroup span="5" align="center">
 </colgroup>

   <tr><th> Function                 </th><th>  Hwi   </th><th>  Swi   </th>
 <th>  Task  </th><th>  Main  </th><th>  Startup  </th></tr>
   <!--                                                       -->
   <tr><td> create          </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> disable         </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> exit            </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> getIdleTask     </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Params_init     </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   Y    </td></tr>
   <tr><td> restore         </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> self            </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> sleep           </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> yield           </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> construct       </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> delete          </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> destruct        </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> getEnv          </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> getHookContext  </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> getMode         </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> getPri          </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> getFunc         </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> setEnv          </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> setHookContext  </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> setPri          </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> stat            </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td colspan="6"> Definitions: <br />
      <ul>
        <li> <b>Hwi</b>: API is callable from a Hwi thread. </li>
        <li> <b>Swi</b>: API is callable from a Swi thread. </li>
        <li> <b>Task</b>: API is callable from a Task thread. </li>
        <li> <b>Main</b>: API is callable during any of these phases: </li>
          <ul>
            <li> In your module startup after this module is started
 (e.g. after Task_init() has been called). </li>
            <li> During xdc.runtime.Startup.lastFxns. </li>
            <li> During main().</li>
            <li> During BIOS.startupFxns.</li>
          </ul>
        <li> <b>Startup</b>: API is callable during any of these phases:</li>
          <ul>
            <li> During xdc.runtime.Startup.firstFxns.</li>
            <li> In your module startup before this module is started
 (e.g. before Task_init() has been called). </li>
          </ul>
      </ul>
   </td></tr>

 </table>
 </p>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Queue_8h_source.html">ti/sysbios/knl/Queue.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Clock_8h_source.html">ti/sysbios/knl/Clock.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Error_8h_source.html">ti/sysbios/runtime/Error.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="IHeap_8h_source.html">ti/sysbios/runtime/IHeap.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Task.h:</div>
<div class="dyncontent">
<div class="center"><img src="Task_8h__incl.png" border="0" usemap="#_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Task_8h" alt=""/></div>
<map name="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Task_8h" id="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Task_8h">
<area shape="rect" id="node5" href="Queue_8h.html" title="Queue Manager. " alt="" coords="297,295,463,322"/>
<area shape="rect" id="node6" href="Error_8h.html" title="Runtime error manager. " alt="" coords="479,377,617,419"/>
<area shape="rect" id="node7" href="Clock_8h.html" title="System Clock Manager. " alt="" coords="300,124,460,151"/>
<area shape="rect" id="node9" href="IHeap_8h.html" title="Interface to heap functions. " alt="" coords="640,199,779,240"/>
<area shape="rect" id="node8" href="Swi_8h.html" title="Software Interrupt Manager. " alt="" coords="311,206,457,233"/>
<area shape="rect" id="node10" href="Memory_8h.html" title="Static and run&#45;time memory manager. " alt="" coords="640,288,779,329"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="Task_8h__dep__incl.png" border="0" usemap="#_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Task_8hdep" alt=""/></div>
<map name="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Task_8hdep" id="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Task_8hdep">
<area shape="rect" id="node2" href="GateMutex_8h.html" title="Mutex Gate. " alt="" coords="5,361,459,432"/>
<area shape="rect" id="node3" href="GateMutexPri_8h.html" title="Mutex Gate with priority inheritance. " alt="" coords="960,361,1413,432"/>
<area shape="rect" id="node4" href="GateTask_8h.html" title="Software Interrupt Gate. " alt="" coords="1183,124,1636,195"/>
<area shape="rect" id="node5" href="HeapTrack_8h.html" title="Heap manager that enables tracking of all allocated blocks. " alt="" coords="1660,124,2113,195"/>
<area shape="rect" id="node6" href="Event_8h.html" title="Event Manager. " alt="" coords="655,124,1108,195"/>
<area shape="rect" id="node8" href="Semaphore_8h.html" title="Semaphore Manager. " alt="" coords="391,243,844,313"/>
<area shape="rect" id="node9" href="Load_8h.html" title="The Load module reports execution times and load information for threads in a system. " alt="" coords="2137,124,2591,195"/>
<area shape="rect" id="node7" href="Mailbox_8h.html" title="Mailbox Manager. " alt="" coords="483,361,936,432"/>
</map>
</div>
</div>
<p><a href="Task_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTask__Stat.html">Task_Stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTask__HookSet.html">Task_HookSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTask__Hook.html">Task_Hook</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTask__Params.html">Task_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a61e1828e798cc64bb154fc32bdf49591"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a61e1828e798cc64bb154fc32bdf49591">Task_A_badPriority</a>&#160;&#160;&#160;&quot;invalid priority&quot;</td></tr>
<tr class="memdesc:a61e1828e798cc64bb154fc32bdf49591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserted in Task_create.  <a href="#a61e1828e798cc64bb154fc32bdf49591">More...</a><br /></td></tr>
<tr class="separator:a61e1828e798cc64bb154fc32bdf49591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f2c1631e9f2b205aa6b077dac55aaa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a00f2c1631e9f2b205aa6b077dac55aaa">Task_A_badTaskState</a>&#160;&#160;&#160;&quot;cannot delete a task in RUNNING state&quot;</td></tr>
<tr class="memdesc:a00f2c1631e9f2b205aa6b077dac55aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserted in Task_delete.  <a href="#a00f2c1631e9f2b205aa6b077dac55aaa">More...</a><br /></td></tr>
<tr class="separator:a00f2c1631e9f2b205aa6b077dac55aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ff5185e629f540d2ab78b19759e657"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#ac7ff5185e629f540d2ab78b19759e657">Task_A_badThreadType</a>&#160;&#160;&#160;&quot;cannot create/delete a task from a Hwi or Swi thread&quot;</td></tr>
<tr class="memdesc:ac7ff5185e629f540d2ab78b19759e657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserted in Task_create and Task_delete.  <a href="#ac7ff5185e629f540d2ab78b19759e657">More...</a><br /></td></tr>
<tr class="separator:ac7ff5185e629f540d2ab78b19759e657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae863850aba72fcd91de4ffa6367742ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#ae863850aba72fcd91de4ffa6367742ca">Task_A_badTimeout</a>&#160;&#160;&#160;&quot;cannot sleep forever&quot;</td></tr>
<tr class="memdesc:ae863850aba72fcd91de4ffa6367742ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserted in Task_sleep.  <a href="#ae863850aba72fcd91de4ffa6367742ca">More...</a><br /></td></tr>
<tr class="separator:ae863850aba72fcd91de4ffa6367742ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2aad989070648630de8ad1114722b6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#ae2aad989070648630de8ad1114722b6f">Task_A_noPendElem</a>&#160;&#160;&#160;&quot;not enough info to delete BLOCKED task&quot;</td></tr>
<tr class="memdesc:ae2aad989070648630de8ad1114722b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserted in Task_delete.  <a href="#ae2aad989070648630de8ad1114722b6f">More...</a><br /></td></tr>
<tr class="separator:ae2aad989070648630de8ad1114722b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d890e8c16d34e6b509ac6e487b1b709"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a3d890e8c16d34e6b509ac6e487b1b709">Task_A_sleepTaskDisabled</a>&#160;&#160;&#160;&quot;cannot call <a class="el" href="Task_8h.html#a1c5f0ae2e0960e2e7bdc4f1a8edb07fa">Task_sleep</a> when the scheduler is disabled&quot;</td></tr>
<tr class="memdesc:a3d890e8c16d34e6b509ac6e487b1b709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserted in Task_sleep.  <a href="#a3d890e8c16d34e6b509ac6e487b1b709">More...</a><br /></td></tr>
<tr class="separator:a3d890e8c16d34e6b509ac6e487b1b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675811b9d3a034fc885341bcfe601443"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a675811b9d3a034fc885341bcfe601443">Task_A_taskDisabled</a>&#160;&#160;&#160;&quot;cannot create a task when tasking is disabled&quot;</td></tr>
<tr class="memdesc:a675811b9d3a034fc885341bcfe601443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserted in Task_create.  <a href="#a675811b9d3a034fc885341bcfe601443">More...</a><br /></td></tr>
<tr class="separator:a675811b9d3a034fc885341bcfe601443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fefe51e561363428928e71e44ff630d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a8fefe51e561363428928e71e44ff630d">Task_E_stackOverflow</a>&#160;&#160;&#160;&quot;task 0x%x stack overflow&quot;</td></tr>
<tr class="memdesc:a8fefe51e561363428928e71e44ff630d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when a stack overflow (or corruption) is detected.  <a href="#a8fefe51e561363428928e71e44ff630d">More...</a><br /></td></tr>
<tr class="separator:a8fefe51e561363428928e71e44ff630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba976178bbe8cf9f64079743a598e149"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#aba976178bbe8cf9f64079743a598e149">Task_E_spOutOfBounds</a>&#160;&#160;&#160;&quot;task 0x%x stack error, SP = 0x%x&quot;</td></tr>
<tr class="memdesc:aba976178bbe8cf9f64079743a598e149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when a task's stack pointer (SP) does not point somewhere within the task's stack.  <a href="#aba976178bbe8cf9f64079743a598e149">More...</a><br /></td></tr>
<tr class="separator:aba976178bbe8cf9f64079743a598e149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca77ef364427d455aaab36324abd034e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#aca77ef364427d455aaab36324abd034e">Task_E_deleteNotAllowed</a>&#160;&#160;&#160;&quot;delete not allowed task 0x%x&quot;</td></tr>
<tr class="memdesc:aca77ef364427d455aaab36324abd034e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task_delete error.  <a href="#aca77ef364427d455aaab36324abd034e">More...</a><br /></td></tr>
<tr class="separator:aca77ef364427d455aaab36324abd034e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a67c7b47937ab8d2111f3a90486160fec"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989ed">Task_Mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a67c7b47937ab8d2111f3a90486160fec">Task_Mode</a></td></tr>
<tr class="memdesc:a67c7b47937ab8d2111f3a90486160fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task execution modes.  <a href="#a67c7b47937ab8d2111f3a90486160fec">More...</a><br /></td></tr>
<tr class="separator:a67c7b47937ab8d2111f3a90486160fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df26af1e6db2d4535ba513806fad644"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a>) (uintptr_t arg1, uintptr_t arg2)</td></tr>
<tr class="memdesc:a6df26af1e6db2d4535ba513806fad644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function type definition.  <a href="#a6df26af1e6db2d4535ba513806fad644">More...</a><br /></td></tr>
<tr class="separator:a6df26af1e6db2d4535ba513806fad644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6b989cca03e3fde9e55c5ad2c37250"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a></td></tr>
<tr class="separator:a5f6b989cca03e3fde9e55c5ad2c37250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5263b1005ce773a8a9f27e6896b4cb45"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a5263b1005ce773a8a9f27e6896b4cb45">Task_Object</a></td></tr>
<tr class="separator:a5263b1005ce773a8a9f27e6896b4cb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecb0ef0b5985fed33489e317badab80"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a></td></tr>
<tr class="separator:a7ecb0ef0b5985fed33489e317badab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1848f40ef74fba721ee9595aa3ab01"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a8f1848f40ef74fba721ee9595aa3ab01">Task_Instance</a></td></tr>
<tr class="separator:a8f1848f40ef74fba721ee9595aa3ab01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5d250ffd9b4db2d236ed8ff4b848f6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structTask__Stat.html">Task_Stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a6f5d250ffd9b4db2d236ed8ff4b848f6">Task_Stat</a></td></tr>
<tr class="memdesc:a6f5d250ffd9b4db2d236ed8ff4b848f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task Status Buffer.  <a href="#a6f5d250ffd9b4db2d236ed8ff4b848f6">More...</a><br /></td></tr>
<tr class="separator:a6f5d250ffd9b4db2d236ed8ff4b848f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeca8977cef16529ef15c6206464a99"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structTask__HookSet.html">Task_HookSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#aadeca8977cef16529ef15c6206464a99">Task_HookSet</a></td></tr>
<tr class="memdesc:aadeca8977cef16529ef15c6206464a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task hook set type definition.  <a href="#aadeca8977cef16529ef15c6206464a99">More...</a><br /></td></tr>
<tr class="separator:aadeca8977cef16529ef15c6206464a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3680cb7da2b68dc133e3d0087be764ab"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structTask__Params.html">Task_Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a3680cb7da2b68dc133e3d0087be764ab">Task_Params</a></td></tr>
<tr class="separator:a3680cb7da2b68dc133e3d0087be764ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af592dff1548fc7b2a8183be86fd989ed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989ed">Task_Mode</a> { <br />
&#160;&#160;<a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989eda2338cc1c83eee97198b7d02768c6064e">Task_Mode_RUNNING</a>, 
<br />
&#160;&#160;<a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989edaf363130af70bdf838762fc0042906ce6">Task_Mode_READY</a>, 
<br />
&#160;&#160;<a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989edadc355e9973f38f9f0598961e156e13b2">Task_Mode_BLOCKED</a>, 
<br />
&#160;&#160;<a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989eda18ec5bae34b34a1e2c8a20981c28aaa6">Task_Mode_TERMINATED</a>, 
<br />
&#160;&#160;<a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989edaf5b33e64f1f2c57a5c45b86f8e517664">Task_Mode_INACTIVE</a>
<br />
 }<tr class="memdesc:af592dff1548fc7b2a8183be86fd989ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task execution modes.  <a href="Task_8h.html#af592dff1548fc7b2a8183be86fd989ed">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af592dff1548fc7b2a8183be86fd989ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a04b23120f349c8873c65ab0f22d69edb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a04b23120f349c8873c65ab0f22d69edb">Task_create</a> (<a class="el" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a> fxn, const <a class="el" href="structTask__Params.html">Task_Params</a> *prms, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:a04b23120f349c8873c65ab0f22d69edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Task.  <a href="#a04b23120f349c8873c65ab0f22d69edb">More...</a><br /></td></tr>
<tr class="separator:a04b23120f349c8873c65ab0f22d69edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad427969d99b6ad37f2a3ad6fa0b233a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#ad427969d99b6ad37f2a3ad6fa0b233a9">Task_construct</a> (<a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a> *obj, <a class="el" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a> fxn, const <a class="el" href="structTask__Params.html">Task_Params</a> *prms, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:ad427969d99b6ad37f2a3ad6fa0b233a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a task.  <a href="#ad427969d99b6ad37f2a3ad6fa0b233a9">More...</a><br /></td></tr>
<tr class="separator:ad427969d99b6ad37f2a3ad6fa0b233a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1448848bcd4ea4fb2da4eaca97420c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62">Task_delete</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> *task)</td></tr>
<tr class="memdesc:a1448848bcd4ea4fb2da4eaca97420c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a task.  <a href="#a1448848bcd4ea4fb2da4eaca97420c62">More...</a><br /></td></tr>
<tr class="separator:a1448848bcd4ea4fb2da4eaca97420c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42168f3d2064661371c0b3da3ad76ba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a42168f3d2064661371c0b3da3ad76ba0">Task_destruct</a> (<a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a> *obj)</td></tr>
<tr class="memdesc:a42168f3d2064661371c0b3da3ad76ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a task.  <a href="#a42168f3d2064661371c0b3da3ad76ba0">More...</a><br /></td></tr>
<tr class="separator:a42168f3d2064661371c0b3da3ad76ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293c4d0501b84901a2219b7563e55729"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> (void)</td></tr>
<tr class="memdesc:a293c4d0501b84901a2219b7563e55729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the task scheduler.  <a href="#a293c4d0501b84901a2219b7563e55729">More...</a><br /></td></tr>
<tr class="separator:a293c4d0501b84901a2219b7563e55729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2e27cd328465bd41f4ef9f4afb518f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> (unsigned int key)</td></tr>
<tr class="memdesc:a0a2e27cd328465bd41f4ef9f4afb518f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore Task scheduling state.  <a href="#a0a2e27cd328465bd41f4ef9f4afb518f">More...</a><br /></td></tr>
<tr class="separator:a0a2e27cd328465bd41f4ef9f4afb518f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fb642c2d262f0cca5307323e8fc765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a45fb642c2d262f0cca5307323e8fc765">Task_self</a> (void)</td></tr>
<tr class="memdesc:a45fb642c2d262f0cca5307323e8fc765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the currently executing Task object.  <a href="#a45fb642c2d262f0cca5307323e8fc765">More...</a><br /></td></tr>
<tr class="separator:a45fb642c2d262f0cca5307323e8fc765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad991648240f1e9338f99237291dbf6e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#ad991648240f1e9338f99237291dbf6e0">Task_checkStacks</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> oldTask, <a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> newTask)</td></tr>
<tr class="memdesc:ad991648240f1e9338f99237291dbf6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for stack overflow.  <a href="#ad991648240f1e9338f99237291dbf6e0">More...</a><br /></td></tr>
<tr class="separator:ad991648240f1e9338f99237291dbf6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b487c00368dff4ad9fd7176893060d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a46b487c00368dff4ad9fd7176893060d">Task_exit</a> (void)</td></tr>
<tr class="memdesc:a46b487c00368dff4ad9fd7176893060d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate execution of the current task.  <a href="#a46b487c00368dff4ad9fd7176893060d">More...</a><br /></td></tr>
<tr class="separator:a46b487c00368dff4ad9fd7176893060d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5f0ae2e0960e2e7bdc4f1a8edb07fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a1c5f0ae2e0960e2e7bdc4f1a8edb07fa">Task_sleep</a> (uint32_t nticks)</td></tr>
<tr class="memdesc:a1c5f0ae2e0960e2e7bdc4f1a8edb07fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay execution of the current task.  <a href="#a1c5f0ae2e0960e2e7bdc4f1a8edb07fa">More...</a><br /></td></tr>
<tr class="separator:a1c5f0ae2e0960e2e7bdc4f1a8edb07fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78841ab191646faa598ed8f723969dab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a78841ab191646faa598ed8f723969dab">Task_yield</a> (void)</td></tr>
<tr class="memdesc:a78841ab191646faa598ed8f723969dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield processor to equal priority task.  <a href="#a78841ab191646faa598ed8f723969dab">More...</a><br /></td></tr>
<tr class="separator:a78841ab191646faa598ed8f723969dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1e25e818f98b55b6bb5f05084d8213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a8e1e25e818f98b55b6bb5f05084d8213">Task_getIdleTask</a> (void)</td></tr>
<tr class="memdesc:a8e1e25e818f98b55b6bb5f05084d8213"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a handle to the idle task object (for core 0)  <a href="#a8e1e25e818f98b55b6bb5f05084d8213">More...</a><br /></td></tr>
<tr class="separator:a8e1e25e818f98b55b6bb5f05084d8213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38543edc2b6ff3e641c451404d2f931a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a38543edc2b6ff3e641c451404d2f931a">Task_getEnv</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task)</td></tr>
<tr class="memdesc:a38543edc2b6ff3e641c451404d2f931a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get task environment pointer.  <a href="#a38543edc2b6ff3e641c451404d2f931a">More...</a><br /></td></tr>
<tr class="separator:a38543edc2b6ff3e641c451404d2f931a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdf43516b3e3d707e3bf9cc3d91d12d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a0fdf43516b3e3d707e3bf9cc3d91d12d">Task_getFunc</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, uintptr_t *arg0, uintptr_t *arg1)</td></tr>
<tr class="memdesc:a0fdf43516b3e3d707e3bf9cc3d91d12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Task function and arguments.  <a href="#a0fdf43516b3e3d707e3bf9cc3d91d12d">More...</a><br /></td></tr>
<tr class="separator:a0fdf43516b3e3d707e3bf9cc3d91d12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc7717c2bdb76d42723b713428b5f43"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a6fc7717c2bdb76d42723b713428b5f43">Task_getHookContext</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, int id)</td></tr>
<tr class="memdesc:a6fc7717c2bdb76d42723b713428b5f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hook set's context for a task.  <a href="#a6fc7717c2bdb76d42723b713428b5f43">More...</a><br /></td></tr>
<tr class="separator:a6fc7717c2bdb76d42723b713428b5f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d51c8ad3b7390b54ac42174aa07cce"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a99d51c8ad3b7390b54ac42174aa07cce">Task_getName</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task)</td></tr>
<tr class="memdesc:a99d51c8ad3b7390b54ac42174aa07cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get task name.  <a href="#a99d51c8ad3b7390b54ac42174aa07cce">More...</a><br /></td></tr>
<tr class="separator:a99d51c8ad3b7390b54ac42174aa07cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181423bc2f4e53ec5c30f96b207a580"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#ab181423bc2f4e53ec5c30f96b207a580">Task_getPri</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task)</td></tr>
<tr class="memdesc:ab181423bc2f4e53ec5c30f96b207a580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get task priority.  <a href="#ab181423bc2f4e53ec5c30f96b207a580">More...</a><br /></td></tr>
<tr class="separator:ab181423bc2f4e53ec5c30f96b207a580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ed5ded6cb995b990be123a2b86c64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a17ed5ded6cb995b990be123a2b86c64e">Task_setEnv</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, void *env)</td></tr>
<tr class="memdesc:a17ed5ded6cb995b990be123a2b86c64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set task environment.  <a href="#a17ed5ded6cb995b990be123a2b86c64e">More...</a><br /></td></tr>
<tr class="separator:a17ed5ded6cb995b990be123a2b86c64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eb12719762e79487fb664650ab3901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a31eb12719762e79487fb664650ab3901">Task_setHookContext</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, int id, void *hookContext)</td></tr>
<tr class="memdesc:a31eb12719762e79487fb664650ab3901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hook instance's context for a task.  <a href="#a31eb12719762e79487fb664650ab3901">More...</a><br /></td></tr>
<tr class="separator:a31eb12719762e79487fb664650ab3901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830b456dd5fc2e93b6a55261bbe59d8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a830b456dd5fc2e93b6a55261bbe59d8a">Task_setPri</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, int newpri)</td></tr>
<tr class="memdesc:a830b456dd5fc2e93b6a55261bbe59d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a task's priority.  <a href="#a830b456dd5fc2e93b6a55261bbe59d8a">More...</a><br /></td></tr>
<tr class="separator:a830b456dd5fc2e93b6a55261bbe59d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caf96dc9c8302c091ff508de8cfef2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a3caf96dc9c8302c091ff508de8cfef2d">Task_stat</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, <a class="el" href="structTask__Stat.html">Task_Stat</a> *statbuf)</td></tr>
<tr class="memdesc:a3caf96dc9c8302c091ff508de8cfef2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the status of a task.  <a href="#a3caf96dc9c8302c091ff508de8cfef2d">More...</a><br /></td></tr>
<tr class="separator:a3caf96dc9c8302c091ff508de8cfef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfe4dc3216e80d3bbc51a002f5a29a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989ed">Task_Mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a9dfe4dc3216e80d3bbc51a002f5a29a0">Task_getMode</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task)</td></tr>
<tr class="memdesc:a9dfe4dc3216e80d3bbc51a002f5a29a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <a class="el" href="Task_8h.html#a67c7b47937ab8d2111f3a90486160fec">Task_Mode</a> of a task.  <a href="#a9dfe4dc3216e80d3bbc51a002f5a29a0">More...</a><br /></td></tr>
<tr class="separator:a9dfe4dc3216e80d3bbc51a002f5a29a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b71bd39d0a7e059893ca8b6afdc9e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a08b71bd39d0a7e059893ca8b6afdc9e6">Task_block</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task)</td></tr>
<tr class="memdesc:a08b71bd39d0a7e059893ca8b6afdc9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block a task.  <a href="#a08b71bd39d0a7e059893ca8b6afdc9e6">More...</a><br /></td></tr>
<tr class="separator:a08b71bd39d0a7e059893ca8b6afdc9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781237b98982a41ab65978dd327e1483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a781237b98982a41ab65978dd327e1483">Task_Params_init</a> (<a class="el" href="structTask__Params.html">Task_Params</a> *prms)</td></tr>
<tr class="memdesc:a781237b98982a41ab65978dd327e1483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="structTask__Params.html">Task_Params</a> structure with default values.  <a href="#a781237b98982a41ab65978dd327e1483">More...</a><br /></td></tr>
<tr class="separator:a781237b98982a41ab65978dd327e1483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a4c7dc5928364b4b1ffd8fd8ffe0f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a15a4c7dc5928364b4b1ffd8fd8ffe0f5">Task_Object_first</a> (void)</td></tr>
<tr class="memdesc:a15a4c7dc5928364b4b1ffd8fd8ffe0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return handle of the first task on task list  <a href="#a15a4c7dc5928364b4b1ffd8fd8ffe0f5">More...</a><br /></td></tr>
<tr class="separator:a15a4c7dc5928364b4b1ffd8fd8ffe0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6ccc9b79947319c2aa9f93f697965d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a2b6ccc9b79947319c2aa9f93f697965d">Task_Object_next</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task)</td></tr>
<tr class="memdesc:a2b6ccc9b79947319c2aa9f93f697965d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return handle of the next task on task list  <a href="#a2b6ccc9b79947319c2aa9f93f697965d">More...</a><br /></td></tr>
<tr class="separator:a2b6ccc9b79947319c2aa9f93f697965d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a34784aa144d29da673d63710a67d7f2b"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a34784aa144d29da673d63710a67d7f2b">Task_numPriorities</a></td></tr>
<tr class="memdesc:a34784aa144d29da673d63710a67d7f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Task priorities supported. Default is 16.  <a href="#a34784aa144d29da673d63710a67d7f2b">More...</a><br /></td></tr>
<tr class="separator:a34784aa144d29da673d63710a67d7f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca452d4eadd61b68d5044ed111422f01"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#aca452d4eadd61b68d5044ed111422f01">Task_defaultStackSize</a></td></tr>
<tr class="memdesc:aca452d4eadd61b68d5044ed111422f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stack size (in MAUs) used for all tasks.  <a href="#aca452d4eadd61b68d5044ed111422f01">More...</a><br /></td></tr>
<tr class="separator:aca452d4eadd61b68d5044ed111422f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7a3ab76a627d624abf873ececdfe8b"><td class="memItemLeft" align="right" valign="top">const Task_AllBlockedFuncPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#afc7a3ab76a627d624abf873ececdfe8b">Task_allBlockedFunc</a></td></tr>
<tr class="memdesc:afc7a3ab76a627d624abf873ececdfe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call while all tasks are blocked.  <a href="#afc7a3ab76a627d624abf873ececdfe8b">More...</a><br /></td></tr>
<tr class="separator:afc7a3ab76a627d624abf873ececdfe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab994085ea2c28016d797f172cf7ecc2"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#aab994085ea2c28016d797f172cf7ecc2">Task_initStackFlag</a></td></tr>
<tr class="memdesc:aab994085ea2c28016d797f172cf7ecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize stack with known value for stack checking at runtime (see <a class="el" href="Task_8h.html#a4071ade7303b594094c48458976d8bf2">Task_checkStackFlag</a>).  <a href="#aab994085ea2c28016d797f172cf7ecc2">More...</a><br /></td></tr>
<tr class="separator:aab994085ea2c28016d797f172cf7ecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4071ade7303b594094c48458976d8bf2"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Task_8h.html#a4071ade7303b594094c48458976d8bf2">Task_checkStackFlag</a></td></tr>
<tr class="memdesc:a4071ade7303b594094c48458976d8bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check 'from' and 'to' task stacks before task context switch.  <a href="#a4071ade7303b594094c48458976d8bf2">More...</a><br /></td></tr>
<tr class="separator:a4071ade7303b594094c48458976d8bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a61e1828e798cc64bb154fc32bdf49591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e1828e798cc64bb154fc32bdf49591">&sect;&nbsp;</a></span>Task_A_badPriority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_A_badPriority&#160;&#160;&#160;&quot;invalid priority&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserted in Task_create. </p>

</div>
</div>
<a id="a00f2c1631e9f2b205aa6b077dac55aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f2c1631e9f2b205aa6b077dac55aaa">&sect;&nbsp;</a></span>Task_A_badTaskState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_A_badTaskState&#160;&#160;&#160;&quot;cannot delete a task in RUNNING state&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserted in Task_delete. </p>

</div>
</div>
<a id="ac7ff5185e629f540d2ab78b19759e657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ff5185e629f540d2ab78b19759e657">&sect;&nbsp;</a></span>Task_A_badThreadType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_A_badThreadType&#160;&#160;&#160;&quot;cannot create/delete a task from a Hwi or Swi thread&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserted in Task_create and Task_delete. </p>

</div>
</div>
<a id="ae863850aba72fcd91de4ffa6367742ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae863850aba72fcd91de4ffa6367742ca">&sect;&nbsp;</a></span>Task_A_badTimeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_A_badTimeout&#160;&#160;&#160;&quot;cannot sleep forever&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserted in Task_sleep. </p>

</div>
</div>
<a id="ae2aad989070648630de8ad1114722b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2aad989070648630de8ad1114722b6f">&sect;&nbsp;</a></span>Task_A_noPendElem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_A_noPendElem&#160;&#160;&#160;&quot;not enough info to delete BLOCKED task&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserted in Task_delete. </p>

</div>
</div>
<a id="a3d890e8c16d34e6b509ac6e487b1b709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d890e8c16d34e6b509ac6e487b1b709">&sect;&nbsp;</a></span>Task_A_sleepTaskDisabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_A_sleepTaskDisabled&#160;&#160;&#160;&quot;cannot call <a class="el" href="Task_8h.html#a1c5f0ae2e0960e2e7bdc4f1a8edb07fa">Task_sleep</a> when the scheduler is disabled&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserted in Task_sleep. </p>

</div>
</div>
<a id="a675811b9d3a034fc885341bcfe601443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675811b9d3a034fc885341bcfe601443">&sect;&nbsp;</a></span>Task_A_taskDisabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_A_taskDisabled&#160;&#160;&#160;&quot;cannot create a task when tasking is disabled&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserted in Task_create. </p>

</div>
</div>
<a id="a8fefe51e561363428928e71e44ff630d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fefe51e561363428928e71e44ff630d">&sect;&nbsp;</a></span>Task_E_stackOverflow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_E_stackOverflow&#160;&#160;&#160;&quot;task 0x%x stack overflow&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when a stack overflow (or corruption) is detected. </p>
<p>This error is raised by kernel's stack checking function. This function checks the stacks before every task switch to make sure that reserved word at top of stack has not been modified.</p>
<p>The stack checking logic is enabled by the <a class="el" href="Task_8h.html#aab994085ea2c28016d797f172cf7ecc2">Task_initStackFlag</a> and <a class="el" href="Task_8h.html#a4071ade7303b594094c48458976d8bf2">Task_checkStackFlag</a> configuration parameters. If both of these flags are set to true, the kernel will validate the stacks. </p>

</div>
</div>
<a id="aba976178bbe8cf9f64079743a598e149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba976178bbe8cf9f64079743a598e149">&sect;&nbsp;</a></span>Task_E_spOutOfBounds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_E_spOutOfBounds&#160;&#160;&#160;&quot;task 0x%x stack error, SP = 0x%x&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when a task's stack pointer (SP) does not point somewhere within the task's stack. </p>
<p>This error is raised by kernel's stack checking function. This function checks the SPs before every task switch to make sure they point within the task's stack.</p>
<p>The stack checking logic is enabled by the <a class="el" href="Task_8h.html#aab994085ea2c28016d797f172cf7ecc2">Task_initStackFlag</a> and <a class="el" href="Task_8h.html#a4071ade7303b594094c48458976d8bf2">Task_checkStackFlag</a> configuration parameters. If both of these flags are set to true, the kernel will validate the stack pointers. </p>

</div>
</div>
<a id="aca77ef364427d455aaab36324abd034e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca77ef364427d455aaab36324abd034e">&sect;&nbsp;</a></span>Task_E_deleteNotAllowed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Task_E_deleteNotAllowed&#160;&#160;&#160;&quot;delete not allowed task 0x%x&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task_delete error. </p>
<p>This error raised when a <a class="el" href="Task_8h.html#a1448848bcd4ea4fb2da4eaca97420c62">Task_delete</a> is called when the Task.deleteTerminated configuration parameter is set to 'true' and the task is in the terminated state. When Task.deleteTerminated is 'true', the idle task will delete terminated tasks. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a67c7b47937ab8d2111f3a90486160fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c7b47937ab8d2111f3a90486160fec">&sect;&nbsp;</a></span>Task_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989ed">Task_Mode</a> <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989ed">Task_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task execution modes. </p>
<p>These enumerations are the range of modes or states that a task can be in. A task's current mode can be gotten using <a class="el" href="Task_8h.html#a3caf96dc9c8302c091ff508de8cfef2d">Task_stat</a>. </p>

</div>
</div>
<a id="a6df26af1e6db2d4535ba513806fad644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df26af1e6db2d4535ba513806fad644">&sect;&nbsp;</a></span>Task_FuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Task_FuncPtr) (uintptr_t arg1, uintptr_t arg2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function type definition. </p>

</div>
</div>
<a id="a5f6b989cca03e3fde9e55c5ad2c37250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6b989cca03e3fde9e55c5ad2c37250">&sect;&nbsp;</a></span>Task_Struct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a> <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5263b1005ce773a8a9f27e6896b4cb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5263b1005ce773a8a9f27e6896b4cb45">&sect;&nbsp;</a></span>Task_Object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a> <a class="el" href="Task_8h.html#a5263b1005ce773a8a9f27e6896b4cb45">Task_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ecb0ef0b5985fed33489e317badab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecb0ef0b5985fed33489e317badab80">&sect;&nbsp;</a></span>Task_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a>* <a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f1848f40ef74fba721ee9595aa3ab01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1848f40ef74fba721ee9595aa3ab01">&sect;&nbsp;</a></span>Task_Instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a>* <a class="el" href="Task_8h.html#a8f1848f40ef74fba721ee9595aa3ab01">Task_Instance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f5d250ffd9b4db2d236ed8ff4b848f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5d250ffd9b4db2d236ed8ff4b848f6">&sect;&nbsp;</a></span>Task_Stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structTask__Stat.html">Task_Stat</a> <a class="el" href="structTask__Stat.html">Task_Stat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task Status Buffer. </p>
<p>Passed to and filled in by <a class="el" href="Task_8h.html#a3caf96dc9c8302c091ff508de8cfef2d">Task_stat</a>; </p>

</div>
</div>
<a id="aadeca8977cef16529ef15c6206464a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadeca8977cef16529ef15c6206464a99">&sect;&nbsp;</a></span>Task_HookSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structTask__HookSet.html">Task_HookSet</a> <a class="el" href="structTask__HookSet.html">Task_HookSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task hook set type definition. </p>
<p>Sets of hook functions can be specified for the Task module. See <a class="el" href="Task_8h.html#taskHookFunctions">Hook Functions</a> for details. </p>

</div>
</div>
<a id="a3680cb7da2b68dc133e3d0087be764ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3680cb7da2b68dc133e3d0087be764ab">&sect;&nbsp;</a></span>Task_Params</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structTask__Params.html">Task_Params</a> <a class="el" href="structTask__Params.html">Task_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af592dff1548fc7b2a8183be86fd989ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af592dff1548fc7b2a8183be86fd989ed">&sect;&nbsp;</a></span>Task_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989ed">Task_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task execution modes. </p>
<p>These enumerations are the range of modes or states that a task can be in. A task's current mode can be gotten using <a class="el" href="Task_8h.html#a3caf96dc9c8302c091ff508de8cfef2d">Task_stat</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af592dff1548fc7b2a8183be86fd989eda2338cc1c83eee97198b7d02768c6064e"></a>Task_Mode_RUNNING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af592dff1548fc7b2a8183be86fd989edaf363130af70bdf838762fc0042906ce6"></a>Task_Mode_READY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af592dff1548fc7b2a8183be86fd989edadc355e9973f38f9f0598961e156e13b2"></a>Task_Mode_BLOCKED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af592dff1548fc7b2a8183be86fd989eda18ec5bae34b34a1e2c8a20981c28aaa6"></a>Task_Mode_TERMINATED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af592dff1548fc7b2a8183be86fd989edaf5b33e64f1f2c57a5c45b86f8e517664"></a>Task_Mode_INACTIVE&#160;</td><td class="fielddoc"><p>Task is on inactive task list. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a04b23120f349c8873c65ab0f22d69edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b23120f349c8873c65ab0f22d69edb">&sect;&nbsp;</a></span>Task_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> Task_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTask__Params.html">Task_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Task. </p>
<p>Task_create creates a new task object. If successful, Task_create returns the handle of the new task object. If unsuccessful, Task_create returns NULL unless it aborts.</p>
<p>The fxn parameter uses the <a class="el" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a> type to pass a pointer to the function the Task object should run. For example, if myFxn is a function in your program, your C code can create a Task object to call that function as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="structTask__Params.html">Task_Params</a> taskParams;</div><div class="line"></div><div class="line"><span class="comment">// Create task with priority 15</span></div><div class="line"><a class="code" href="Task_8h.html#a781237b98982a41ab65978dd327e1483">Task_Params_init</a>(&amp;taskParams);</div><div class="line">taskParams.<a class="code" href="structTask__Params.html#a5e12480c34c1c2a1c11afd10ca98380b">stackSize</a> = 512;</div><div class="line">taskParams.<a class="code" href="structTask__Params.html#af01c667e1700b496cff582002ed907e0">priority</a> = 15;</div><div class="line"><a class="code" href="Task_8h.html#a04b23120f349c8873c65ab0f22d69edb">Task_create</a>((<a class="code" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a>)myFxn, &amp;taskParams, &amp;eb);</div></div><!-- fragment --><p>The following statements statically create a task in the configuration file:</p>
<div class="fragment"><div class="line">var params = <span class="keyword">new</span> Task.Params;</div><div class="line">params.name = <span class="stringliteral">&quot;tsk0&quot;</span>;</div><div class="line">params.arg0 = 1;</div><div class="line">params.arg1 = 2;</div><div class="line">params.priority = 1;</div><div class="line">Task.create(<span class="stringliteral">&#39;&amp;tsk0_func&#39;</span>, params);</div></div><!-- fragment --><p>If NULL is passed instead of a pointer to an actual <a class="el" href="structTask__Params.html">Task_Params</a> struct, a default set of parameters is used. The "eb" is an error block that you can use to handle errors that may occur during Task object creation.</p>
<p>The newly created task is placed in <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989edaf363130af70bdf838762fc0042906ce6">Task_Mode_READY</a> mode, and is scheduled to begin concurrent execution of the following function call:</p>
<div class="fragment"><div class="line">(*fxn)(arg1, arg2);</div></div><!-- fragment --><p>As a result of being made ready to run, the task runs any application-wide Ready functions that have been specified.</p>
<p>Task_exit is automatically called if and when the task returns from fxn.</p>
<p><b>Create Hook Functions</b></p>
<p>You can specify application-wide Create hook functions in your config file that run whenever a task is created. This includes tasks that are created statically and those created dynamically using Task_create.</p>
<p>For Task objects created statically, Create functions are called during the Task module initialization phase of the program startup process prior to main().</p>
<p>For Task objects created dynamically, Create functions are called after the task handle has been initialized but before the task has been placed on its ready queue.</p>
<p>Any SYS/BIOS function can be called from Create functions. SYS/BIOS passes the task handle of the task being created to each of the Create functions.</p>
<p>All Create function declarations should be similar to this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myCreateFxn(<a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task);</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd></dd></dl>
<ul>
<li>The fxn parameter and the name attribute cannot be NULL.</li>
<li>The priority attribute must be less than or equal to (Task_numPriorities - 1) and greater than or equal to one (1) (priority 0 is owned by the Idle task).</li>
<li>The priority can be set to -1 for tasks that will not execute until another task changes the priority to a positive value.</li>
<li>The stackHeap attribute must identify a valid memory Heap.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fxn</td><td>Task function </td></tr>
    <tr><td class="paramname">prms</td><td>optional create parameters (NULL for defaults) </td></tr>
    <tr><td class="paramname">eb</td><td>error block</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Task</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad427969d99b6ad37f2a3ad6fa0b233a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad427969d99b6ad37f2a3ad6fa0b233a9">&sect;&nbsp;</a></span>Task_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> Task_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTask__Params.html">Task_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a task. </p>
<p>Task_construct is equivalent to Task_create except that the Task_Struct is pre-allocated. See <a class="el" href="Task_8h.html#a04b23120f349c8873c65ab0f22d69edb" title="Create a Task. ">Task_create()</a> for a description of this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to a Task object </td></tr>
    <tr><td class="paramname">fxn</td><td>Task function </td></tr>
    <tr><td class="paramname">prms</td><td>optional create parameters (NULL for defaults) </td></tr>
    <tr><td class="paramname">eb</td><td>error block</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Task</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1448848bcd4ea4fb2da4eaca97420c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1448848bcd4ea4fb2da4eaca97420c62">&sect;&nbsp;</a></span>Task_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a task. </p>
<p>Task_delete deletes a Task object. Note that Task_delete takes a pointer to a Task_Handle which enables Task_delete to set the Task handle to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to Task handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42168f3d2064661371c0b3da3ad76ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42168f3d2064661371c0b3da3ad76ba0">&sect;&nbsp;</a></span>Task_destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a5f6b989cca03e3fde9e55c5ad2c37250">Task_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct a task. </p>
<p>Task_destruct destructs a Task object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to Task object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a293c4d0501b84901a2219b7563e55729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293c4d0501b84901a2219b7563e55729">&sect;&nbsp;</a></span>Task_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Task_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the task scheduler. </p>
<p><a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> and <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> control Task scheduling. <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> disables all other Tasks from running until <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> is called. Hardware and Software interrupts can still run.</p>
<p><a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> and <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> allow you to ensure that statements that must be performed together during critical processing are not preempted by other Tasks.</p>
<p>The value of the key returned is opaque to applications and is meant to be passed to <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f" title="Restore Task scheduling state. ">Task_restore()</a>.</p>
<p>In the following example, the critical section is not preempted by any Tasks.</p>
<div class="fragment"><div class="line">key = <a class="code" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a>();</div><div class="line">    `critical section`</div><div class="line"><a class="code" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a>(key);</div></div><!-- fragment --><p>You can also use <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> and <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> to create several Tasks and allow them to be invoked in priority order.</p>
<p><a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> calls can be nested.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Do not call any function that can cause the current task to block within a <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a>/<a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> block. For example, <a class="el" href="Semaphore_8h.html#ac7e0b45f15b2f6f5a7e4ecc772ddbd0c">Semaphore_pend</a> (if timeout is non-zero), <a class="el" href="Task_8h.html#a1c5f0ae2e0960e2e7bdc4f1a8edb07fa">Task_sleep</a>, <a class="el" href="Task_8h.html#a78841ab191646faa598ed8f723969dab">Task_yield</a>, and Memory_alloc can all cause blocking.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">key</td><td>for use with <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a2e27cd328465bd41f4ef9f4afb518f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2e27cd328465bd41f4ef9f4afb518f">&sect;&nbsp;</a></span>Task_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_restore </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore Task scheduling state. </p>
<p><a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> and <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> control Task scheduling <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> disables all other Tasks from running until <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> is called. Hardware and Software interrupts can still run.</p>
<p><a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> and <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> allow you to ensure that statements that must be performed together during critical processing are not preempted.</p>
<p>In the following example, the critical section is not preempted by any Tasks.</p>
<div class="fragment"><div class="line">key = <a class="code" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a>();</div><div class="line">    `critical section`</div><div class="line"><a class="code" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a>(key);</div></div><!-- fragment --><p>You can also use <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> and <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> to create several Tasks and allow them to be performed in priority order.</p>
<p><a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> calls can be nested.</p>
<p><a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> returns with interrupts enabled if the key unlocks the scheduler</p>
<dl class="section pre"><dt>Precondition</dt><dd>Do not call any function that can cause the current task to block within a <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a>/<a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> block. For example, <a class="el" href="Semaphore_8h.html#ac7e0b45f15b2f6f5a7e4ecc772ddbd0c">Semaphore_pend</a> (if timeout is non-zero), <a class="el" href="Task_8h.html#a1c5f0ae2e0960e2e7bdc4f1a8edb07fa">Task_sleep</a>, <a class="el" href="Task_8h.html#a78841ab191646faa598ed8f723969dab">Task_yield</a>, and Memory_alloc can all cause blocking.</dd></dl>
<p><a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> internally calls <a class="el" href="hal_2Hwi_8h.html#afa2a5a08ef4d7f6b1bcdea2dfb90c4ac">Hwi_enable()</a> if the key passed to it results in the unlocking of the Task scheduler (ie if this is root Task_disable/Task_restore pair).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to restore previous Task scheduler state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45fb642c2d262f0cca5307323e8fc765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fb642c2d262f0cca5307323e8fc765">&sect;&nbsp;</a></span>Task_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> Task_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a handle to the currently executing Task object. </p>
<p>Task_self returns the object handle for the currently executing task. This function is useful when inspecting the object or when the current task changes its own priority through <a class="el" href="Task_8h.html#a830b456dd5fc2e93b6a55261bbe59d8a">Task_setPri</a>.</p>
<p>No task switch occurs when calling Task_self.</p>
<p>Task_self will return NULL until Tasking is initiated at the end of <a class="el" href="BIOS_8h.html#aa166cb986a863566660e378fdd48309e" title="Start SYS/BIOS. ">BIOS_start()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">address</td><td>of currently executing task object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad991648240f1e9338f99237291dbf6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad991648240f1e9338f99237291dbf6e0">&sect;&nbsp;</a></span>Task_checkStacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_checkStacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>oldTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>newTask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for stack overflow. </p>
<p>This function is usually called by the <a class="el" href="structTask__HookSet.html">Task_HookSet</a> switchFxn to make sure task stacks are valid before performing the context switch.</p>
<p>If a stack overflow is detected on either the oldTask or the newTask, a Task_E_stackOverflow error is raised and the system exited.</p>
<p>In order to work properly, <a class="el" href="Task_8h.html#ad991648240f1e9338f99237291dbf6e0">Task_checkStacks</a> requires that the <a class="el" href="Task_8h.html#aab994085ea2c28016d797f172cf7ecc2">Task_initStackFlag</a> set to true, which it is by default.</p>
<p>You can call <a class="el" href="Task_8h.html#ad991648240f1e9338f99237291dbf6e0">Task_checkStacks</a> directly from your application. For example, you can check the current task's stack integrity at any time with a call like the following:</p>
<div class="fragment"><div class="line"><a class="code" href="Task_8h.html#ad991648240f1e9338f99237291dbf6e0">Task_checkStacks</a>(<a class="code" href="Task_8h.html#a45fb642c2d262f0cca5307323e8fc765">Task_self</a>(), <a class="code" href="Task_8h.html#a45fb642c2d262f0cca5307323e8fc765">Task_self</a>());</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldTask</td><td>leaving Task Object void * </td></tr>
    <tr><td class="paramname">newTask</td><td>entering Task Object void * </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46b487c00368dff4ad9fd7176893060d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b487c00368dff4ad9fd7176893060d">&sect;&nbsp;</a></span>Task_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate execution of the current task. </p>
<p>Task_exit terminates execution of the current task, changing its mode from <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989eda2338cc1c83eee97198b7d02768c6064e">Task_Mode_RUNNING</a> to <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989eda18ec5bae34b34a1e2c8a20981c28aaa6">Task_Mode_TERMINATED</a>. If all tasks have been terminated, or if all remaining tasks have their vitalTaskFlag attribute set to false, then SYS/BIOS terminates the program as a whole by calling the function System_exit with a status code of 0.</p>
<p>Task_exit is automatically called whenever a task returns from its top-level function.</p>
<p>Exit Hooks (see exitFxn in <a class="el" href="structTask__HookSet.html">Task_HookSet</a>) can be used to provide functions that run whenever a task is terminated. The exitFxn Hooks are called before the task has been blocked and marked <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989eda18ec5bae34b34a1e2c8a20981c28aaa6">Task_Mode_TERMINATED</a>. See <a class="el" href="Task_8h.html#taskHookFunctions">Hook Functions</a> for more information.</p>
<p>Any SYS/BIOS function can be called from an Exit Hook function.</p>
<p>Calling <a class="el" href="Task_8h.html#a45fb642c2d262f0cca5307323e8fc765">Task_self</a> within an Exit function returns the task being exited. Your Exit function declaration should be similar to the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myExitFxn(<span class="keywordtype">void</span>);</div></div><!-- fragment --><p>A task switch occurs when calling Task_exit unless the program as a whole is terminated</p>
<dl class="section pre"><dt>Precondition</dt><dd>Task_exit cannot be called from a Swi or Hwi.</dd></dl>
<p>Task_exit cannot be called from the program's main() function. </p>

</div>
</div>
<a id="a1c5f0ae2e0960e2e7bdc4f1a8edb07fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5f0ae2e0960e2e7bdc4f1a8edb07fa">&sect;&nbsp;</a></span>Task_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_sleep </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay execution of the current task. </p>
<p>Task_sleep changes the current task's mode from <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989eda2338cc1c83eee97198b7d02768c6064e">Task_Mode_RUNNING</a> to <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989edadc355e9973f38f9f0598961e156e13b2">Task_Mode_BLOCKED</a>, and delays its execution for nticks increments of the "system clock". The actual time delayed can be up to 1 system clock tick less than nticks due to granularity in system timekeeping and the time elapsed per tick is determined by <a class="el" href="Clock_8h.html#a9be0e5d01b84a50998b32b5ccc4fa785">Clock_tickPeriod</a>.</p>
<p>After the specified period of time has elapsed, the task reverts to the <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989edaf363130af70bdf838762fc0042906ce6">Task_Mode_READY</a> mode and is scheduled for execution.</p>
<p>A task switch always occurs when calling Task_sleep if nticks &gt; 0.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Task_sleep cannot be called from a Swi or Hwi, or within a <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a> / <a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> block.</dd></dl>
<p>Task_sleep cannot be called from the program's main() function.</p>
<p>Task_sleep should not be called from within an Idle function. Doing so prevents analysis tools from gathering run-time information.</p>
<p>nticks cannot be <a class="el" href="BIOS_8h.html#af30174787e672154279b29377604a9b8">BIOS_WAIT_FOREVER</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nticks</td><td>number of system clock ticks to sleep </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78841ab191646faa598ed8f723969dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78841ab191646faa598ed8f723969dab">&sect;&nbsp;</a></span>Task_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield processor to equal priority task. </p>
<p>Task_yield yields the processor to another task of equal priority.</p>
<p>A task switch occurs when you call Task_yield if there is an equal priority task ready to run.</p>
<p>Tasks of higher priority preempt the currently running task without the need for a call to Task_yield. If only lower-priority tasks are ready to run when you call Task_yield, the current task continues to run. Control does not pass to a lower-priority task.</p>
<dl class="section pre"><dt>Precondition</dt><dd>When called within an Hwi, the code sequence calling Task_yield must be invoked by the Hwi dispatcher.</dd></dl>
<p>Task_yield cannot be called from the program's main() function. </p>

</div>
</div>
<a id="a8e1e25e818f98b55b6bb5f05084d8213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1e25e818f98b55b6bb5f05084d8213">&sect;&nbsp;</a></span>Task_getIdleTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> Task_getIdleTask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a handle to the idle task object (for core 0) </p>

</div>
</div>
<a id="a38543edc2b6ff3e641c451404d2f931a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38543edc2b6ff3e641c451404d2f931a">&sect;&nbsp;</a></span>Task_getEnv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Task_getEnv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get task environment pointer. </p>
<p>Task_getEnv returns the environment pointer of the specified task. The environment pointer references an arbitrary application-defined data structure.</p>
<p>If your program uses multiple hook sets, <a class="el" href="Task_8h.html#a6fc7717c2bdb76d42723b713428b5f43">Task_getHookContext</a> allows you to get environment pointers you have set for a particular hook set and Task object combination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">task</td><td>environment pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fdf43516b3e3d707e3bf9cc3d91d12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdf43516b3e3d707e3bf9cc3d91d12d">&sect;&nbsp;</a></span>Task_getFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Task_8h.html#a6df26af1e6db2d4535ba513806fad644">Task_FuncPtr</a> Task_getFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Task function and arguments. </p>
<p>If either arg0 or arg1 is NULL, then the corresponding argument is not returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg0</td><td>pointer for returning Task's first function argument</td></tr>
    <tr><td class="paramname">arg1</td><td>pointer for returning Task's second function argument</td></tr>
    <tr><td class="paramname">task</td><td>Task handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Task</td><td>function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fc7717c2bdb76d42723b713428b5f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc7717c2bdb76d42723b713428b5f43">&sect;&nbsp;</a></span>Task_getHookContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Task_getHookContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hook set's context for a task. </p>
<p>For example, this C code gets the HookContext, prints it, and sets a new value for the HookContext.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * pEnv;</div><div class="line"><a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> myTask;</div><div class="line"><span class="keywordtype">int</span> myHookSetId1;</div><div class="line"></div><div class="line">pEnv = <a class="code" href="Task_8h.html#a6fc7717c2bdb76d42723b713428b5f43">Task_getHookContext</a>(task, myHookSetId1);</div><div class="line"></div><div class="line"><a class="code" href="System_8h.html#a790b89a409dd53189bc82eb1d74f5116">System_printf</a>(<span class="stringliteral">&quot;myEnd1: pEnv = 0x%lx, time = %ld\n&quot;</span>,</div><div class="line">              (ULong)pEnv, (ULong)<a class="code" href="Timestamp_8h.html#aab5fb1d421a9fc9e618496151547cfcc">Timestamp_get32</a>());</div><div class="line"></div><div class="line"><a class="code" href="Task_8h.html#a31eb12719762e79487fb664650ab3901">Task_setHookContext</a>(task, myHookSetId1, (<span class="keywordtype">void</span> *)0xc0de1);</div></div><!-- fragment --><p>See <a class="el" href="Task_8h.html#taskHookFunctions">Hook Functions</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle </td></tr>
    <tr><td class="paramname">id</td><td>hook set ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">hook</td><td>set context for task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99d51c8ad3b7390b54ac42174aa07cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d51c8ad3b7390b54ac42174aa07cce">&sect;&nbsp;</a></span>Task_getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Task_getName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get task name. </p>
<p>Task_getName returns the name of the referenced task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">task</td><td>name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab181423bc2f4e53ec5c30f96b207a580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab181423bc2f4e53ec5c30f96b207a580">&sect;&nbsp;</a></span>Task_getPri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Task_getPri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get task priority. </p>
<p>Task_getPri returns the priority of the referenced task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">task</td><td>priority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17ed5ded6cb995b990be123a2b86c64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ed5ded6cb995b990be123a2b86c64e">&sect;&nbsp;</a></span>Task_setEnv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_setEnv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set task environment. </p>
<p>Task_setEnv sets the task environment pointer to env. The environment pointer references an arbitrary application-defined data structure.</p>
<p>If your program uses multiple hook sets, <a class="el" href="Task_8h.html#a31eb12719762e79487fb664650ab3901">Task_setHookContext</a> allows you to set environment pointers for any hook set and Task object combination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle </td></tr>
    <tr><td class="paramname">env</td><td>task environment pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31eb12719762e79487fb664650ab3901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eb12719762e79487fb664650ab3901">&sect;&nbsp;</a></span>Task_setHookContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_setHookContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hookContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set hook instance's context for a task. </p>
<p>For example, this C code gets the HookContext, prints it, and sets a new value for the HookContext.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * pEnv;</div><div class="line"><a class="code" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> myTask;</div><div class="line"><span class="keywordtype">int</span> myHookSetId1;</div><div class="line"></div><div class="line">pEnv = <a class="code" href="Task_8h.html#a6fc7717c2bdb76d42723b713428b5f43">Task_getHookContext</a>(task, myHookSetId1);</div><div class="line"></div><div class="line"><a class="code" href="System_8h.html#a790b89a409dd53189bc82eb1d74f5116">System_printf</a>(<span class="stringliteral">&quot;myEnd1: pEnv = 0x%lx, time = %ld\n&quot;</span>,</div><div class="line">              (ULong)pEnv, (ULong)<a class="code" href="Timestamp_8h.html#aab5fb1d421a9fc9e618496151547cfcc">Timestamp_get32</a>());</div><div class="line"></div><div class="line"><a class="code" href="Task_8h.html#a31eb12719762e79487fb664650ab3901">Task_setHookContext</a>(task, myHookSetId1, (<span class="keywordtype">void</span> *)0xc0de1);</div></div><!-- fragment --><p>See <a class="el" href="Task_8h.html#taskHookFunctions">Hook Functions</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle </td></tr>
    <tr><td class="paramname">id</td><td>hook set ID </td></tr>
    <tr><td class="paramname">hookContext</td><td>value to write to context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a830b456dd5fc2e93b6a55261bbe59d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830b456dd5fc2e93b6a55261bbe59d8a">&sect;&nbsp;</a></span>Task_setPri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Task_setPri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newpri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a task's priority. </p>
<p>Task_setpri sets the execution priority of task to newpri, and returns that task's old priority value. Raising or lowering a task's priority does not necessarily force preemption and re-scheduling of the caller: tasks in the <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989edadc355e9973f38f9f0598961e156e13b2">Task_Mode_BLOCKED</a> mode remain suspended despite a change in priority; and tasks in the <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989edaf363130af70bdf838762fc0042906ce6">Task_Mode_READY</a> mode gain control only if their new priority is greater than that of the currently executing task.</p>
<p>newpri should be set to a value greater than or equal to 1 and less than or equal to (<a class="el" href="Task_8h.html#a34784aa144d29da673d63710a67d7f2b">Task_numPriorities</a> - 1). newpri can also be set to -1 which puts the the task into the INACTIVE state and the task will not run until its priority is raised at a later time by another task. Priority 0 is reserved for the idle task. If newpri equals (<a class="el" href="Task_8h.html#a34784aa144d29da673d63710a67d7f2b">Task_numPriorities</a> - 1), execution of the task effectively locks out all other program activity, except for the handling of interrupts.</p>
<p>The current task can change its own priority (and possibly preempt its execution) by passing the output of <a class="el" href="Task_8h.html#a45fb642c2d262f0cca5307323e8fc765">Task_self</a> as the value of the task parameter.</p>
<p>A context switch occurs when calling Task_setpri if a currently running task priority is set lower than the priority of another currently ready task, or if another ready task is made to have a higher priority than the currently running task.</p>
<p>Task_setpri can be used for mutual exclusion.</p>
<p>If a task's new priority is different than its previous priority, then its relative placement in its new ready task priority queue can be different than the one it was removed from. This can effect the relative order in which it becomes the running task.</p>
<p>The effected task is placed at the head of its new priority queue if it is the currently running task. Otherwise it is placed at at the end of its new task priority queue.</p>
<dl class="section pre"><dt>Precondition</dt><dd>newpri must be a value between 1 and (<a class="el" href="Task_8h.html#a34784aa144d29da673d63710a67d7f2b">Task_numPriorities</a> - 1) or -1.</dd></dl>
<p>The task cannot be in the <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989eda18ec5bae34b34a1e2c8a20981c28aaa6">Task_Mode_TERMINATED</a> mode.</p>
<p>The new priority should not be zero (0). This priority level is reserved for the Idle task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle </td></tr>
    <tr><td class="paramname">newpri</td><td>task's new priority</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">task's</td><td>old priority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3caf96dc9c8302c091ff508de8cfef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caf96dc9c8302c091ff508de8cfef2d">&sect;&nbsp;</a></span>Task_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTask__Stat.html">Task_Stat</a> *&#160;</td>
          <td class="paramname"><em>statbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the status of a task. </p>
<p>Task_stat retrieves attribute values and status information about a task.</p>
<p>Status information is returned through statbuf, which references a structure of type <a class="el" href="structTask__Stat.html">Task_Stat</a>.</p>
<p>When a task is preempted by a software or hardware interrupt, the task execution mode returned for that task by Task_stat is still <a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989eda2338cc1c83eee97198b7d02768c6064e">Task_Mode_RUNNING</a> because the task runs when the preemption ends.</p>
<p>The current task can inquire about itself by passing the output of <a class="el" href="Task_8h.html#a45fb642c2d262f0cca5307323e8fc765">Task_self</a> as the first argument to Task_stat. However, the task stack pointer (sp) in the <a class="el" href="structTask__Stat.html">Task_Stat</a> structure is the value from the previous context switch.</p>
<p>Task_stat has a non-deterministic execution time. As such, it is not recommended to call this API from Swis or Hwis.</p>
<dl class="section pre"><dt>Precondition</dt><dd>statbuf cannot be NULL;</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle </td></tr>
    <tr><td class="paramname">statbuf</td><td>pointer to task status structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dfe4dc3216e80d3bbc51a002f5a29a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfe4dc3216e80d3bbc51a002f5a29a0">&sect;&nbsp;</a></span>Task_getMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Task_8h.html#af592dff1548fc7b2a8183be86fd989ed">Task_Mode</a> Task_getMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the <a class="el" href="Task_8h.html#a67c7b47937ab8d2111f3a90486160fec">Task_Mode</a> of a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08b71bd39d0a7e059893ca8b6afdc9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b71bd39d0a7e059893ca8b6afdc9e6">&sect;&nbsp;</a></span>Task_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block a task. </p>
<p>Remove a task from its ready list. The effect of this API is manifest the next time the internal Task scheduler is invoked. This can be done directly by embedding the call within a <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a>/<a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> block. Otherwise, the effect will be manifest as a result of processing the next dispatched interrupt, or by posting a Swi, or by falling through the task function.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If called from within a Hwi or a Swi, or main(), there is no need to embed the call within a <a class="el" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a>/<a class="el" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a> block.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a781237b98982a41ab65978dd327e1483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781237b98982a41ab65978dd327e1483">&sect;&nbsp;</a></span>Task_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTask__Params.html">Task_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="structTask__Params.html">Task_Params</a> structure with default values. </p>
<p>Task_Params_init initializes the <a class="el" href="structTask__Params.html">Task_Params</a> structure with default values. Task_Params_init should always be called before setting individual parameter fields. This allows new fields to be added in the future with compatible defaults &ndash; existing source code does not need to change when new fields are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prms</td><td>pointer to uninitialized params structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15a4c7dc5928364b4b1ffd8fd8ffe0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a4c7dc5928364b4b1ffd8fd8ffe0f5">&sect;&nbsp;</a></span>Task_Object_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> Task_Object_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return handle of the first task on task list </p>
<p>Return the handle of the first task on the create/construct list. NULL if no Tasks have been created or constructed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Task</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b6ccc9b79947319c2aa9f93f697965d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6ccc9b79947319c2aa9f93f697965d">&sect;&nbsp;</a></span>Task_Object_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> Task_Object_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return handle of the next task on task list </p>
<p>Return the handle of the next task on the create/construct list. NULL if no more Tasks are on the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Task</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a34784aa144d29da673d63710a67d7f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34784aa144d29da673d63710a67d7f2b">&sect;&nbsp;</a></span>Task_numPriorities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Task_numPriorities</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of Task priorities supported. Default is 16. </p>
<p>The maximum number of priorities supported is target specific and depends on the number of bits in a unsigned int data type. For 6x and ARM devices the maximum number of priorities is therefore 32. For C28x devices, the maximum number of priorities is 16.</p>
<div class="fragment"><div class="line">Task.numPriorities = 16;</div></div><!-- fragment --> 
</div>
</div>
<a id="aca452d4eadd61b68d5044ed111422f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca452d4eadd61b68d5044ed111422f01">&sect;&nbsp;</a></span>Task_defaultStackSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t Task_defaultStackSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default stack size (in MAUs) used for all tasks. </p>
<p>Default is provided by the ti/sysbios/family/Settings.js file.</p>
<div class="fragment"><div class="line">Task.defaultStackSize = 1024;</div></div><!-- fragment --> 
</div>
</div>
<a id="afc7a3ab76a627d624abf873ececdfe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7a3ab76a627d624abf873ececdfe8b">&sect;&nbsp;</a></span>Task_allBlockedFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Task_AllBlockedFuncPtr Task_allBlockedFunc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call while all tasks are blocked. </p>
<p>This function will be called repeatedly while no tasks are ready to run.</p>
<p>Ordinarily (in applications that have tasks ready to run at startup), the function will run in the context of the last task to block.</p>
<p>In an application where there are no tasks ready to run when <a class="el" href="BIOS_8h.html#aa166cb986a863566660e378fdd48309e" title="Start SYS/BIOS. ">BIOS_start()</a> is called, the allBlockedFunc function is called within the <a class="el" href="BIOS_8h.html#aa166cb986a863566660e378fdd48309e" title="Start SYS/BIOS. ">BIOS_start()</a> thread which runs on the system/ISR stack.</p>
<p>By default, allBlockedFunc is initialized to point to an internal function that simply returns.</p>
<p>By adding the following lines to the config script, the Idle functions will run whenever all tasks are blocked:</p>
<div class="fragment"><div class="line">Task.enableIdleTask = <span class="keyword">false</span>;</div><div class="line">Task.allBlockedFunc = <span class="stringliteral">&quot;ti_sysbios_knl_Idle_run&quot;</span>;</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>Task_enableIdleTask</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The configured allBlockedFunc is designed to be called repeatedly. It must return in order for the task scheduler to check if all tasks are STILL blocked and if not, run the highest priority task currently ready to run.</dd></dl>
<p>The configured allBlockedFunc function is called with interrupts disabled. If your function must run with interrupts enabled, surround the body of your code with <a class="el" href="hal_2Hwi_8h.html#afa2a5a08ef4d7f6b1bcdea2dfb90c4ac">Hwi_enable()</a>/Hwi_restore() function calls per the following example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> yourFunc() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hwiKey;</div><div class="line"></div><div class="line">    hwiKey = <a class="code" href="hal_2Hwi_8h.html#afa2a5a08ef4d7f6b1bcdea2dfb90c4ac">Hwi_enable</a>();</div><div class="line"></div><div class="line">    ...         <span class="comment">// your code here</span></div><div class="line"></div><div class="line">    <a class="code" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore</a>(hwiKey);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="aab994085ea2c28016d797f172cf7ecc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab994085ea2c28016d797f172cf7ecc2">&sect;&nbsp;</a></span>Task_initStackFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Task_initStackFlag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize stack with known value for stack checking at runtime (see <a class="el" href="Task_8h.html#a4071ade7303b594094c48458976d8bf2">Task_checkStackFlag</a>). </p>
<p>This is also useful for inspection of stack in debugger or core dump utilities. Default is true.</p>
<div class="fragment"><div class="line">Task.initStackFlag = <span class="keyword">true</span>/<span class="keyword">false</span>;</div></div><!-- fragment --> 
</div>
</div>
<a id="a4071ade7303b594094c48458976d8bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4071ade7303b594094c48458976d8bf2">&sect;&nbsp;</a></span>Task_checkStackFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Task_checkStackFlag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check 'from' and 'to' task stacks before task context switch. </p>
<p>The check consists of testing the top of stack value against its initial value (see configuration parameter Task.initStackFlag). If it is no longer at this value, the assumption is that the task has overrun its stack. If the test fails, then the Task_E_stackOverflow error is raised.</p>
<p>Default is true.</p>
<p>To enable or disable full stack checking, you should set both this flag and the Hwi.checkStackFlag configuration parameter.</p>
<div class="fragment"><div class="line">Task.checkStackFlag = <span class="keyword">true</span>/<span class="keyword">false</span>;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Enabling stack checking will add some interrupt latency because the checks are made within the Task scheduler while interrupts are disabled. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
