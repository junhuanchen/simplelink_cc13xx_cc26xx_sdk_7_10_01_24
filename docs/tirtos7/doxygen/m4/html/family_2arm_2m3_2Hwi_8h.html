<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SYS/BIOS: /home/developer/.conan/data/tirtos/7.03.00.10/library-sb/ga/build/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/kernel/tirtos7/packages/ti/sysbios/family/arm/m3/Hwi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SYS/BIOS
   &#160;<span id="projectnumber">7.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_166a36ee10a8457f2f1d507eafd683e9.html">developer</a></li><li class="navelem"><a class="el" href="dir_ab47aaff52849945b02749b38626f831.html">.conan</a></li><li class="navelem"><a class="el" href="dir_2db58af45ff07475e1865bb6cfecd114.html">data</a></li><li class="navelem"><a class="el" href="dir_73aa28e1938cea8ca02173a6a02bb3cc.html">tirtos</a></li><li class="navelem"><a class="el" href="dir_b92035bd439bf87970152b15ca557739.html">7.03.00.10</a></li><li class="navelem"><a class="el" href="dir_a8aafc4147cd9aeef51c3eea0146f858.html">library-sb</a></li><li class="navelem"><a class="el" href="dir_cd46cd47afafa592114402c4301543d5.html">ga</a></li><li class="navelem"><a class="el" href="dir_2cab851584a752880681e90a2dfd4edd.html">build</a></li><li class="navelem"><a class="el" href="dir_5697d1fa77239cd87167d697b8481edf.html">5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9</a></li><li class="navelem"><a class="el" href="dir_a25849b87dcee5ac6bd91808e0cfd56f.html">kernel</a></li><li class="navelem"><a class="el" href="dir_62fe09a765bfb79fe774e523a5e63239.html">tirtos7</a></li><li class="navelem"><a class="el" href="dir_e3f05480a1de819db6de4292a46ffd2c.html">packages</a></li><li class="navelem"><a class="el" href="dir_c9091c0837bc7d5e21af62b18a8f3d2f.html">ti</a></li><li class="navelem"><a class="el" href="dir_e302b19c208f2b8f03cb96305b4c2fcc.html">sysbios</a></li><li class="navelem"><a class="el" href="dir_beb0abfddef197817bb7bd075e8fa817.html">family</a></li><li class="navelem"><a class="el" href="dir_13dccd33faee438375b19b9050fda996.html">arm</a></li><li class="navelem"><a class="el" href="dir_1269de75b3f691f5d4c4f7edf9cce566.html">m3</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Hwi.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cortex M3/M4 Hardware Interrupt Manager. </p>
<p>The Hardware Interrupt Manager provides APIs for managing hardware interrupts.</p>
<p>The user can dynamically assign routines that run when specific hardware interrupts occur.</p>
<p>Dynamic assignment of Hwi routines to interrupts at run-time is done using the <a class="el" href="family_2arm_2m3_2Hwi_8h.html#adfc4ba27136fb55964a91eafdf664a1a">Hwi_create()</a> or <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a09fe90830ddba191124b6b742a53b73a">Hwi_construct()</a> functions.</p>
<p>Interrupt routines can be written completely in C, completely in assembly, or in a mix of C and assembly.</p>
<p>In order to support interrupt routines written completely in C, an interrupt dispatcher is provided that performs the requisite prolog and epilog for an interrupt routine so the interrupt function can safely inter-operate with the BIOS Task and Swi schedulers.</p>
<p>Some routines are assigned to interrupts by the other SYS/BIOS modules. For example, the Clock module configures its own timer interrupt handler. See the Clock Module for more details.</p>
<h3>Runtime Hwi Creation</h3>
<p>Below is an example of configuring an interrupt at runtime. Usually this code would be placed in main().</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="family_2arm_2m3_2Hwi_8h.html">ti/sysbios/family/arm/m3/Hwi.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Error_8h.html">ti/sysbios/runtime/Error.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="structHwi__Struct.html">Hwi_Handle</a> myHwi;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">    <a class="code" href="structHwi__Params.html">Hwi_Params</a> hwiParams;</div><div class="line"></div><div class="line">    <span class="comment">// set the argument you want passed to your ISR function</span></div><div class="line">    hwiParams.<a class="code" href="structHwi__Params.html#ac6efed7cbe485eba5c1a74b8b7c7e8f1">arg</a> = 1;</div><div class="line"></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Configure interrupt 16 to invoke &quot;myIsr&quot;.</span></div><div class="line">    <span class="comment">// Automatically enables interrupt 16 by default</span></div><div class="line">    <span class="comment">// set params.enableInt = false if you want to control</span></div><div class="line">    <span class="comment">// when the interrupt is enabled using Hwi_enableInterrupt()</span></div><div class="line">    <span class="comment">//</span></div><div class="line"></div><div class="line">    myHwi = <a class="code" href="family_2arm_2m3_2Hwi_8h.html#adfc4ba27136fb55964a91eafdf664a1a">Hwi_create</a>(16, myIsr, &amp;hwiParams, <a class="code" href="Error_8h.html#a1ba355eebe14987c16aa69e1ec50fb60">Error_IGNORE</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (myHwi == NULL) {</div><div class="line">        <span class="comment">// handle Hwi_create failure</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myIsr(uintptr_t arg)</div><div class="line">{</div><div class="line">    <span class="comment">// here when interrupt #16 goes off</span></div><div class="line">}</div></div><!-- fragment --><p>Below is an example of configuring the same interrupt without requiring the use of a heap.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="family_2arm_2m3_2Hwi_8h.html">ti/sysbios/family/arm/m3/Hwi.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Error_8h.html">ti/sysbios/runtime/Error.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="structHwi__Struct.html">Hwi_Struct</a> myHwiStruct;</div><div class="line"><a class="code" href="structHwi__Struct.html">Hwi_Handle</a> myHwi;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">    <a class="code" href="structHwi__Params.html">Hwi_Params</a> hwiParams;</div><div class="line"></div><div class="line">    <span class="comment">// set the argument you want passed to your ISR function</span></div><div class="line">    hwiParams.<a class="code" href="structHwi__Params.html#ac6efed7cbe485eba5c1a74b8b7c7e8f1">arg</a> = 1;</div><div class="line"></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Configure interrupt 16 to invoke &quot;myIsr&quot;.</span></div><div class="line">    <span class="comment">// Automatically enables interrupt 16 by default</span></div><div class="line">    <span class="comment">// set params.enableInt = false if you want to control</span></div><div class="line">    <span class="comment">// when the interrupt is enabled using Hwi_enableInterrupt()</span></div><div class="line">    <span class="comment">//</span></div><div class="line"></div><div class="line">    myHwi = <a class="code" href="family_2arm_2m3_2Hwi_8h.html#a09fe90830ddba191124b6b742a53b73a">Hwi_construct</a>(&amp;myHwiStruct, 16, myIsr, &amp;hwiParams, <a class="code" href="Error_8h.html#a1ba355eebe14987c16aa69e1ec50fb60">Error_IGNORE</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (myHwi == NULL) {</div><div class="line">        <span class="comment">// handle Hwi_create failure</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myIsr(uintptr_t arg)</div><div class="line">{</div><div class="line">    <span class="comment">// here when interrupt #16 goes off</span></div><div class="line">}</div></div><!-- fragment --><p>The Cortex-M devices' Nested Vectored Interrupt Controller (NVIC) supports up to 256 interrupts/exceptions. In practice, most devices support much fewer (ie the SimpleLink CC13XX/CC26XX family of devices have around 50 total interrupts defined).</p>
<p>SYS/BIOS Interrupt IDs or interrupt numbers correspond to an interrupt's position in the interrupt vector table.</p>
<p>ID 0 corresponds to vector 0 which is used by the NVIC to hold the initial (reset) stack pointer value.</p>
<p>ID 1 corresponds to vector 1 which is the reset vector which is usually initialized to point to an application's entry point (ie for the TI compiler tool chain, the entry point is "_c_int00")</p>
<p>IDs 2-13 are, by default, hard wired to the internal exception handler which will save important context information that can be viewed using the ROV tool within either the Code Composer Studio debugger or the IAR Workbench debugger.</p>
<p>ID 14 is the "pendSV" handler which is used exclusively by the shared interrupt dispatcher to orchestrate the execution of "Swis" posted from within interrupts, as well as to manage asynchronous task pre-emption upon returning from interrupts which have readied a task of higher priority than the task that was interrupted.</p>
<p>ID 15 is the SysTick timer interrupt.</p>
<p>ID's 16-255 are mapped to the NVIC's "User" interrupts 0-239 which are tied to platform specific interrupt sources.</p>
<h3>Zero Latency Interrupts</h3>
<p>The M3/M4 Hwi module supports "zero latency" interrupts. Interrupts configured with priority greater (in actual hardware priority, but lower in number) than the configured <a class="el" href="hal_2Hwi_8h.html#aa35617245a46155e1961f70f65e68b1f">Hwi_disablePriority</a> are NOT disabled by <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>, and they are not managed by the internal interrupt dispatcher.</p>
<p>Zero Latency interrupts fall into the commonly used category of "Unmanaged
Interrupts". However they are somewhat distinct from that definition in that in addition to being unmanaged, they are also almost never disabled by SYS/BIOS code, thus gaining the "Zero Latency" title.</p>
<p>Zero latency interrupts are distinguished from regular dispatched interrupts at create time solely by their interrupt priority being set greater than the configured <a class="el" href="hal_2Hwi_8h.html#aa35617245a46155e1961f70f65e68b1f">Hwi_disablePriority</a>.</p>
<p>Note that since zero latency interrupts don't use the dispatcher, the "arg" parameter is not functional. Also note that due to the Cortex-M's native automatic stacking of saved-by-caller C context on the way to an ISR, zero latency interrupt handlers are implemented using regular C functions (ie no 'interrupt' keyword is required).</p>
<dl class="section warning"><dt>Warning</dt><dd>Zero latency interrupts are NOT HANDLED by the SYS/BIOS interrupt dispatcher! Instead, they are vectored to directly. As such, and because they are NOT DISABLED BY <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>, these interrupt handlers are SEVERELY RESTRICTED in terms of the SYS/BIOS APIs they can invoke and THREAD SAFETY MUST BE CAREFULLY CONSIDERED! See the descriptions of Hwi_disable and the configuration parameter "Hwi.disablePriority" for more details.</dd></dl>
<h3>Interrupt Masking Options</h3>
<p>The NVIC interrupt controller is designed for priority based interrupts.</p>
<p>In this Hwi module, the Hwi_maskSetting instance configuration parameter is ignored. Effectively, only the Hwi_MaskingOption_LOWER is supported.</p>
<h3>Interrupt Priorities</h3>
<p>In general, the NVIC supports priority values of 0 thru 255.</p>
<p>In practice, the number of priorities and their values are device dependent, and their nesting behaviors depend on the <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a72fd0d22e8025d2288c28ad15dc8ca60">Hwi_priGroup</a> setting.</p>
<p>For most TI MCU devices, 8 priorities are supported. A peculiarity of ARM's NVIC is that, although the priority field is an 8 bit value, the range of supported priority values are left-justified within this 8 bit field. Consequently, the 8 priority values are not 0 thru 7 as one might expect, but rather:</p>
<div class="fragment"><div class="line">0x00    <span class="comment">// highest priority, non dispatched, Zero Latency priority</span></div><div class="line">0x20    <span class="comment">// highest dispatched interrupt priority</span></div><div class="line">0x40</div><div class="line">0x60</div><div class="line">0x80</div><div class="line">0xa0</div><div class="line">0xc0</div><div class="line">0xe0    <span class="comment">// lowest dispatched interrupt priority, (default)</span></div></div><!-- fragment --><p>Priority 0 is the highest priority and by default is reserved for zero latency interrupts (see Hwi.disablePriority configuration parameter).</p>
<p>See the "Cortex M4 Devices Generic User Guide" for details on the behavior of interrupt priorities and their relationship to the <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a72fd0d22e8025d2288c28ad15dc8ca60">Hwi.priGroup</a> setting.</p>
<h3>Interrupt Vector Tables</h3>
<p>SimpleLink CC13XX/CC26XX devices:</p>
<p>By default, two vector tables are created for SimpleLink devices:</p>
<p>A 15 entry boot vector table is placed at address 0x00000000 in FLASH.</p>
<p>A vector table of length <a class="el" href="family_2arm_2m3_2Hwi_8h.html#adcce9622df9b2e824dac1559364537e6">Hwi_NUM_INTERRUPTS</a> is placed at address 0x20000000 in RAM.</p>
<p>The FLASH boot vector table contains the reset vector and exception handler vectors used until the RAM based vector table is initialized.</p>
<p>The RAM vector table contains those same first 15 vectors plus the SysTick interrupt vector and the remainder of the user interrupt vectors.</p>
<p>During system startup, the NVIC Vector Table Offset Registor is intialized to point to the RAM vector table after it has been initialized.</p>
<h3>Hook Functions</h3>
<p>Sets of hook functions can be specified for the Hwi module using the configuration tool. Each set contains these hook functions:</p>
<p><b>Register:</b> A function called before any statically-created Hwis are initialized at runtime. The register hook is called at boot time before main() and before interrupts are enabled.</p>
<p><b>Create:</b> A function that is called when a Hwi is created. This includes hwis that are created statically and those created dynamically using Hwi_create.</p>
<p><b>Begin:</b> A function that is called just prior to running a Hwi.</p>
<p><b>End:</b> A function that is called just after a Hwi finishes.</p>
<p><b>Delete:</b> A function that is called when a Hwi is deleted at run-time with Hwi_delete.</p>
<p><b>Register Function</b></p>
<p>The Register function is provided to allow a hook set to store its hookset ID. This id can be passed to "Hwi_setHookContext" and "Hwi_getHookContext" to set or get hookset- specific context. The Register function must be specified if the hook implementation needs to use "Hwi_setHookContext" or "Hwi_getHookContext". The registerFxn hook function is called during system initialization before interrupts have been enabled.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myRegisterFxn(<span class="keywordtype">int</span> <span class="keywordtype">id</span>);</div></div><!-- fragment --><p><b>Create and Delete Functions</b></p>
<p>The create and delete functions are called whenever a Hwi is created or deleted. They are called with interrupts enabled (unless called at boot time or from main()).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myCreateFxn(<a class="code" href="structHwi__Struct.html">Hwi_Handle</a> hwi, <a class="code" href="structError__Block.html">Error_Block</a> *eb);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> myDeleteFxn(<a class="code" href="structHwi__Struct.html">Hwi_Handle</a> hwi);</div></div><!-- fragment --><p><b>Begin and End Functions</b></p>
<p>The beginFxn and endFxn function hooks are called with interrupts globally disabled, therefore any hook processing function will contribute to the overall system interrupt response latency. In order to minimize this impact, carefully consider the processing time spent in an Hwi beginFxn or endFxn function hook.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myBeginFxn(<a class="code" href="structHwi__Struct.html">Hwi_Handle</a> hwi);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> myEndFxn(<a class="code" href="structHwi__Struct.html">Hwi_Handle</a> hwi);</div></div><!-- fragment --><p><b>Hook functions can only be configured statically.</b></p>
<p>To add a Hwi hook or set of Hwi hooks, the following syntax is used in the app.syscfg file:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Hwi = scripting.addModule(<span class="stringliteral">&quot;/family/arm/m3/Hwi&quot;</span>);</div><div class="line">Hwi.hwiHooks.create(1);</div><div class="line">Hwi.hwiHooks[0].registerFxn = <span class="stringliteral">&quot;myRegisterFxn&quot;</span>;</div><div class="line">Hwi.hwiHooks[0].createFxn   = <span class="stringliteral">&quot;myCreateFxn&quot;</span>;</div><div class="line">Hwi.hwiHooks[0].beginFxn    = <span class="stringliteral">&quot;myBeginFxn&quot;</span>;</div><div class="line">Hwi.hwiHooks[0].endFxn      = <span class="stringliteral">&quot;myEndFxn&quot;</span>;</div><div class="line">Hwi.hwiHooks[0].deleteFxn   = <span class="stringliteral">&quot;myDeleteFxn&quot;</span>;</div></div><!-- fragment --><p>Leaving a subset of the hook functions undefined is ok.</p>
<p> 
 <h3> Calling Context </h3>
 <table border="1" cellpadding="3">
   <colgroup span="1"></colgroup> <colgroup span="5" align="center"></colgroup>

   <tr><th> Function                 </th><th>  Hwi   </th><th>  Swi   </th><th>  Task  </th><th>  Main  </th><th>  Startup  </th></tr>
   <!--                                                                                                                 -->
   <tr><td> Hwi_clearInterrupt   </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td></tr>
   <tr><td> Hwi_create           </td><td>   N    </td><td>   N    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Hwi_disable          </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td></tr>
   <tr><td> Hwi_disableInterrupt </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Hwi_enable           </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> Hwi_enableInterrupt  </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Hwi_Params_init      </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td></tr>
   <tr><td> Hwi_restore          </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td></tr>
   <tr><td> Hwi_restoreInterrupt </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td></tr>
   <tr><td> Hwi_construct        </td><td>   N    </td><td>   N    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Hwi_delete           </td><td>   N    </td><td>   N    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Hwi_destruct         </td><td>   N    </td><td>   N    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Hwi_getHookContext   </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Hwi_setFunc          </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Hwi_setHookContext   </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td colspan="6"> Definitions: <br />
      <ul>
        <li> <b>Hwi</b>: API is callable from a Hwi thread. </li>
        <li> <b>Swi</b>: API is callable from a Swi thread. </li>
        <li> <b>Task</b>: API is callable from a Task thread. </li>
        <li> <b>Main</b>: API is callable during any of these phases: </li>
          <ul>
            <li> During xdc.runtime.Startup.lastFxns. </li>
            <li> During main().</li>
            <li> During BIOS.startupFxns.</li>
          </ul>
        <li> <b>Startup</b>: API is callable during any of these phases:</li>
          <ul>
            <li> During xdc.runtime.Startup.firstFxns.</li>
          </ul>
      </ul>
   </td></tr>

 </table>
 </p>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="BIOS_8h_source.html">ti/sysbios/BIOS.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Error_8h_source.html">ti/sysbios/runtime/Error.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Hwi.h:</div>
<div class="dyncontent">
<div class="center"><img src="family_2arm_2m3_2Hwi_8h__incl.png" border="0" usemap="#_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2family_2arm_2m3_2Hwi_8h" alt=""/></div>
<map name="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2family_2arm_2m3_2Hwi_8h" id="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2family_2arm_2m3_2Hwi_8h">
<area shape="rect" id="node5" href="BIOS_8h.html" title="SYS/BIOS Top&#45;Level Manager. " alt="" coords="167,124,297,151"/>
<area shape="rect" id="node8" href="Error_8h.html" title="Runtime error manager. " alt="" coords="376,199,515,240"/>
<area shape="rect" id="node7" href="Types_8h.html" title="Basic constants and types. " alt="" coords="56,199,195,240"/>
</map>
</div>
</div>
<p><a href="family_2arm_2m3_2Hwi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHwi__HookSet.html">Hwi_HookSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hwi hook set type definition.  <a href="structHwi__HookSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHwi__Hook.html">Hwi_Hook</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHwi__StackInfo.html">Hwi_StackInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure contains Hwi stack usage info.  <a href="structHwi__StackInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHwi__NVIC.html">Hwi_NVIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested Vectored Interrupt Controller.  <a href="structHwi__NVIC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHwi__ExcContext.html">Hwi_ExcContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception Context - Register contents at the time of an exception.  <a href="structHwi__ExcContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHwi__Module__State.html">Hwi_Module_State</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHwi__Struct.html">Hwi_Struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHwi__Params.html">Hwi_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2ae652f0c7df32cbb6878eaed3a44b78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a2ae652f0c7df32cbb6878eaed3a44b78">Hwi_E_badIntNum</a>&#160;&#160;&#160;&quot;intnum: %d is out of range&quot;</td></tr>
<tr class="memdesc:a2ae652f0c7df32cbb6878eaed3a44b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised Error raised if an attempt is made to create a Hwi with an interrupt number greater than Hwi_NUM_INTERRUPTS - 1.  <a href="#a2ae652f0c7df32cbb6878eaed3a44b78">More...</a><br /></td></tr>
<tr class="separator:a2ae652f0c7df32cbb6878eaed3a44b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56480daf253d1050b6c613c66f63606f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a56480daf253d1050b6c613c66f63606f">Hwi_E_alreadyDefined</a>&#160;&#160;&#160;&quot;Hwi already defined: intr# %d&quot;</td></tr>
<tr class="memdesc:a56480daf253d1050b6c613c66f63606f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when a Hwi is already defined.  <a href="#a56480daf253d1050b6c613c66f63606f">More...</a><br /></td></tr>
<tr class="separator:a56480daf253d1050b6c613c66f63606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab7f3faf295e51ab8444f452f114635"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab7f3faf295e51ab8444f452f114635">Hwi_E_hwiLimitExceeded</a>&#160;&#160;&#160;&quot;Too many interrupts defined&quot;</td></tr>
<tr class="memdesc:adab7f3faf295e51ab8444f452f114635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when the number of interrupts being created exceeds the number supported.  <a href="#adab7f3faf295e51ab8444f452f114635">More...</a><br /></td></tr>
<tr class="separator:adab7f3faf295e51ab8444f452f114635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab9894ed2132c33fdc5781b65a72b1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#aeab9894ed2132c33fdc5781b65a72b1b">Hwi_E_exception</a>&#160;&#160;&#160;&quot;hardware exception id = %d, pc = 0x%08x&quot;</td></tr>
<tr class="memdesc:aeab9894ed2132c33fdc5781b65a72b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when an exception occurs.  <a href="#aeab9894ed2132c33fdc5781b65a72b1b">More...</a><br /></td></tr>
<tr class="separator:aeab9894ed2132c33fdc5781b65a72b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5f9405703ac992cdb6a3f0af1e9d9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a4c5f9405703ac992cdb6a3f0af1e9d9b">Hwi_E_noIsr</a>&#160;&#160;&#160;&quot;no ISR, id = %d, pc = 0x%08x&quot;</td></tr>
<tr class="memdesc:a4c5f9405703ac992cdb6a3f0af1e9d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when an uninitialized interrupt occurs.  <a href="#a4c5f9405703ac992cdb6a3f0af1e9d9b">More...</a><br /></td></tr>
<tr class="separator:a4c5f9405703ac992cdb6a3f0af1e9d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc270b59ad513adbb1786a14cb75321a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#adc270b59ad513adbb1786a14cb75321a">Hwi_E_NMI</a>&#160;&#160;&#160;&quot;NMI: %s&quot;</td></tr>
<tr class="memdesc:adc270b59ad513adbb1786a14cb75321a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when NMI exception occurs.  <a href="#adc270b59ad513adbb1786a14cb75321a">More...</a><br /></td></tr>
<tr class="separator:adc270b59ad513adbb1786a14cb75321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af567c4430ab0f1825ef02440426b98ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#af567c4430ab0f1825ef02440426b98ca">Hwi_E_hardFault</a>&#160;&#160;&#160;&quot;Hard-fault: %s&quot;</td></tr>
<tr class="memdesc:af567c4430ab0f1825ef02440426b98ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when hard fault exception occurs.  <a href="#af567c4430ab0f1825ef02440426b98ca">More...</a><br /></td></tr>
<tr class="separator:af567c4430ab0f1825ef02440426b98ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace58994ee380979189ab57960977691c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ace58994ee380979189ab57960977691c">Hwi_E_memFault</a>&#160;&#160;&#160;&quot;Mem-fault: %s, addresss: 0x%08x&quot;</td></tr>
<tr class="memdesc:ace58994ee380979189ab57960977691c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when memory fault exception occurs.  <a href="#ace58994ee380979189ab57960977691c">More...</a><br /></td></tr>
<tr class="separator:ace58994ee380979189ab57960977691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42529e4d242e2bab0f6521335f00a2ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a42529e4d242e2bab0f6521335f00a2ba">Hwi_E_busFault</a>&#160;&#160;&#160;&quot;Bus-fault: %s, address: 0x%08x&quot;</td></tr>
<tr class="memdesc:a42529e4d242e2bab0f6521335f00a2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when bus fault exception occurs.  <a href="#a42529e4d242e2bab0f6521335f00a2ba">More...</a><br /></td></tr>
<tr class="separator:a42529e4d242e2bab0f6521335f00a2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2673e0f27f7a521912ee263e81c775fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a2673e0f27f7a521912ee263e81c775fc">Hwi_E_usageFault</a>&#160;&#160;&#160;&quot;Usage-fault: %s&quot;</td></tr>
<tr class="memdesc:a2673e0f27f7a521912ee263e81c775fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when usage fault exception occurs.  <a href="#a2673e0f27f7a521912ee263e81c775fc">More...</a><br /></td></tr>
<tr class="separator:a2673e0f27f7a521912ee263e81c775fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014bfc7799cb6507f2afefb2c34e90b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a014bfc7799cb6507f2afefb2c34e90b2">Hwi_E_svCall</a>&#160;&#160;&#160;&quot;SvCall: svNum = %d&quot;</td></tr>
<tr class="memdesc:a014bfc7799cb6507f2afefb2c34e90b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when svCall exception occurs.  <a href="#a014bfc7799cb6507f2afefb2c34e90b2">More...</a><br /></td></tr>
<tr class="separator:a014bfc7799cb6507f2afefb2c34e90b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fd065c4f9ac3841ee0b187a35db7b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a04fd065c4f9ac3841ee0b187a35db7b1">Hwi_E_debugMon</a>&#160;&#160;&#160;&quot;Debug-monitor: %s&quot;</td></tr>
<tr class="memdesc:a04fd065c4f9ac3841ee0b187a35db7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when debugMon exception occurs.  <a href="#a04fd065c4f9ac3841ee0b187a35db7b1">More...</a><br /></td></tr>
<tr class="separator:a04fd065c4f9ac3841ee0b187a35db7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b035db3f59d87c6f2db4ba560dfa6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#aa5b035db3f59d87c6f2db4ba560dfa6e">Hwi_E_reserved</a>&#160;&#160;&#160;&quot;reserved %s %d&quot;</td></tr>
<tr class="memdesc:aa5b035db3f59d87c6f2db4ba560dfa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when reserved exceptions occur.  <a href="#aa5b035db3f59d87c6f2db4ba560dfa6e">More...</a><br /></td></tr>
<tr class="separator:aa5b035db3f59d87c6f2db4ba560dfa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba796bcdd372d44826424de0d1d162fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#aba796bcdd372d44826424de0d1d162fa">Hwi_E_stackOverflow</a>&#160;&#160;&#160;&quot;ISR stack overflow&quot;</td></tr>
<tr class="memdesc:aba796bcdd372d44826424de0d1d162fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error raised when the ISR stack has overflowed.  <a href="#aba796bcdd372d44826424de0d1d162fa">More...</a><br /></td></tr>
<tr class="separator:aba796bcdd372d44826424de0d1d162fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae6632e60a2959a8be923d862da09e9dd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHwi__Struct.html">Hwi_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ae6632e60a2959a8be923d862da09e9dd">Hwi_Struct</a></td></tr>
<tr class="separator:ae6632e60a2959a8be923d862da09e9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e2280a28fd84c37788b8137f7b2929"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHwi__Struct.html">Hwi_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a71e2280a28fd84c37788b8137f7b2929">Hwi_Object</a></td></tr>
<tr class="separator:a71e2280a28fd84c37788b8137f7b2929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3189422b01a80e5e79363a0a736a650"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structHwi__Struct.html">Hwi_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a></td></tr>
<tr class="separator:ab3189422b01a80e5e79363a0a736a650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd77cf6fb1d8a38db30996b80e77ca54"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structHwi__Struct.html">Hwi_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#afd77cf6fb1d8a38db30996b80e77ca54">Hwi_Instance</a></td></tr>
<tr class="separator:afd77cf6fb1d8a38db30996b80e77ca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaedb4b9a8a846bf0d3d76745e203b3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHwi__HookSet.html">Hwi_HookSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a8aaedb4b9a8a846bf0d3d76745e203b3">Hwi_HookSet</a></td></tr>
<tr class="memdesc:a8aaedb4b9a8a846bf0d3d76745e203b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hwi hook set type definition.  <a href="#a8aaedb4b9a8a846bf0d3d76745e203b3">More...</a><br /></td></tr>
<tr class="separator:a8aaedb4b9a8a846bf0d3d76745e203b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fa76c7b26390ea4db4feb233f7967d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHwi__Module__State.html">Hwi_Module_State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#af7fa76c7b26390ea4db4feb233f7967d">Hwi_Module_State</a></td></tr>
<tr class="separator:af7fa76c7b26390ea4db4feb233f7967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd62c84fde44cb75abe25098ae2d0ee1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHwi__Params.html">Hwi_Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#acd62c84fde44cb75abe25098ae2d0ee1">Hwi_Params</a></td></tr>
<tr class="separator:acd62c84fde44cb75abe25098ae2d0ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0fae8137234765d79629afb64cffca"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHwi__NVIC.html">Hwi_NVIC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a8a0fae8137234765d79629afb64cffca">Hwi_NVIC</a></td></tr>
<tr class="memdesc:a8a0fae8137234765d79629afb64cffca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested Vectored Interrupt Controller.  <a href="#a8a0fae8137234765d79629afb64cffca">More...</a><br /></td></tr>
<tr class="separator:a8a0fae8137234765d79629afb64cffca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bd11ada5c5c49e35dbd7bacf87cc4b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHwi__ExcContext.html">Hwi_ExcContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a41bd11ada5c5c49e35dbd7bacf87cc4b">Hwi_ExcContext</a></td></tr>
<tr class="memdesc:a41bd11ada5c5c49e35dbd7bacf87cc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception Context - Register contents at the time of an exception.  <a href="#a41bd11ada5c5c49e35dbd7bacf87cc4b">More...</a><br /></td></tr>
<tr class="separator:a41bd11ada5c5c49e35dbd7bacf87cc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388cc58013001e4c9d35dfc6c8609c42"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHwi__StackInfo.html">Hwi_StackInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a388cc58013001e4c9d35dfc6c8609c42">Hwi_StackInfo</a></td></tr>
<tr class="memdesc:a388cc58013001e4c9d35dfc6c8609c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure contains Hwi stack usage info.  <a href="#a388cc58013001e4c9d35dfc6c8609c42">More...</a><br /></td></tr>
<tr class="separator:a388cc58013001e4c9d35dfc6c8609c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0119190d0fc8f6f4a692251018b493c8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a>) (uintptr_t)</td></tr>
<tr class="memdesc:a0119190d0fc8f6f4a692251018b493c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hwi create function type definition.  <a href="#a0119190d0fc8f6f4a692251018b493c8">More...</a><br /></td></tr>
<tr class="separator:a0119190d0fc8f6f4a692251018b493c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7a897660823e037d0e1021deda824e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a2e7a897660823e037d0e1021deda824e">Hwi_VectorFuncPtr</a>) (void)</td></tr>
<tr class="memdesc:a2e7a897660823e037d0e1021deda824e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hwi vector function type definition.  <a href="#a2e7a897660823e037d0e1021deda824e">More...</a><br /></td></tr>
<tr class="separator:a2e7a897660823e037d0e1021deda824e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70350a70b691efe5b49478dc19249edb"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a70350a70b691efe5b49478dc19249edb">Hwi_ExceptionHookFuncPtr</a>) (<a class="el" href="structHwi__ExcContext.html">Hwi_ExcContext</a> *arg1)</td></tr>
<tr class="memdesc:a70350a70b691efe5b49478dc19249edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception hook function type definition.  <a href="#a70350a70b691efe5b49478dc19249edb">More...</a><br /></td></tr>
<tr class="separator:a70350a70b691efe5b49478dc19249edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb795b1c4d316ce21de274551beeb30d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a70350a70b691efe5b49478dc19249edb">Hwi_ExceptionHookFuncPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#afb795b1c4d316ce21de274551beeb30d">Hwi_ExcHookFunc</a></td></tr>
<tr class="separator:afb795b1c4d316ce21de274551beeb30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5ca8ed68f8a9a4dba67929ee3e6240"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44ab">Hwi_MaskingOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#abe5ca8ed68f8a9a4dba67929ee3e6240">Hwi_MaskingOption</a></td></tr>
<tr class="memdesc:abe5ca8ed68f8a9a4dba67929ee3e6240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand interrupt masking options.  <a href="#abe5ca8ed68f8a9a4dba67929ee3e6240">More...</a><br /></td></tr>
<tr class="separator:abe5ca8ed68f8a9a4dba67929ee3e6240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7157b4ad62fef4bb5af53b21dcca965c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a7157b4ad62fef4bb5af53b21dcca965c">Hwi_ExcHandlerFuncPtr</a>) (unsigned int *arg1, unsigned int arg2)</td></tr>
<tr class="memdesc:a7157b4ad62fef4bb5af53b21dcca965c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hwi exception handler function type definition.  <a href="#a7157b4ad62fef4bb5af53b21dcca965c">More...</a><br /></td></tr>
<tr class="separator:a7157b4ad62fef4bb5af53b21dcca965c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adab01a75be33b6d08c73d4db93bd44ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44ab">Hwi_MaskingOption</a> { <br />
&#160;&#160;<a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44aba8a2e54e82adc414a7b056c46b0ae8764">Hwi_MaskingOption_NONE</a>, 
<br />
&#160;&#160;<a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44aba2b6a7322bfa687dd35af9a40e0c9e74e">Hwi_MaskingOption_ALL</a>, 
<br />
&#160;&#160;<a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44aba07c9be851e468005222fc91582973d21">Hwi_MaskingOption_SELF</a>, 
<br />
&#160;&#160;<a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44aba487f24b9a7b46b30a4fe9d416f6c0715">Hwi_MaskingOption_BITMASK</a>, 
<br />
&#160;&#160;<a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44aba27157b54254bc172f584a2284a8da0c7">Hwi_MaskingOption_LOWER</a>
<br />
 }<tr class="memdesc:adab01a75be33b6d08c73d4db93bd44ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt masking options.  <a href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44ab">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adab01a75be33b6d08c73d4db93bd44ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5abb2606ef0d232268f11c6c9341f7d0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a5abb2606ef0d232268f11c6c9341f7d0">Hwi_Disable</a> ()</td></tr>
<tr class="memdesc:a5abb2606ef0d232268f11c6c9341f7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally disable interrupts.  <a href="#a5abb2606ef0d232268f11c6c9341f7d0">More...</a><br /></td></tr>
<tr class="separator:a5abb2606ef0d232268f11c6c9341f7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2263585352a40e55a7c385ab0c8f9790"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a2263585352a40e55a7c385ab0c8f9790">Hwi_Enable</a> ()</td></tr>
<tr class="memdesc:a2263585352a40e55a7c385ab0c8f9790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally enable interrupts.  <a href="#a2263585352a40e55a7c385ab0c8f9790">More...</a><br /></td></tr>
<tr class="separator:a2263585352a40e55a7c385ab0c8f9790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa563930d07267cebbe089d24943397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a7fa563930d07267cebbe089d24943397">Hwi_Restore</a> (uint32_t key)</td></tr>
<tr class="memdesc:a7fa563930d07267cebbe089d24943397"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore global interrupts to the state they were in prior <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>.  <a href="#a7fa563930d07267cebbe089d24943397">More...</a><br /></td></tr>
<tr class="separator:a7fa563930d07267cebbe089d24943397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc4ba27136fb55964a91eafdf664a1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#adfc4ba27136fb55964a91eafdf664a1a">Hwi_create</a> (int intNum, <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a> hwiFxn, const <a class="el" href="structHwi__Params.html">Hwi_Params</a> *prms, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="separator:adfc4ba27136fb55964a91eafdf664a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fe90830ddba191124b6b742a53b73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a09fe90830ddba191124b6b742a53b73a">Hwi_construct</a> (<a class="el" href="structHwi__Struct.html">Hwi_Struct</a> *obj, int intNum, <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a> hwiFxn, const <a class="el" href="structHwi__Params.html">Hwi_Params</a> *prms, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="separator:a09fe90830ddba191124b6b742a53b73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aeba325e5430219a7c01fd8f2dfa56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a75aeba325e5430219a7c01fd8f2dfa56">Hwi_delete</a> (<a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> *handle)</td></tr>
<tr class="separator:a75aeba325e5430219a7c01fd8f2dfa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf4c4e4271fdd903c558cd1afd18b8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a8cf4c4e4271fdd903c558cd1afd18b8d">Hwi_destruct</a> (<a class="el" href="structHwi__Struct.html">Hwi_Struct</a> *obj)</td></tr>
<tr class="separator:a8cf4c4e4271fdd903c558cd1afd18b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9ff7e74bc4a143524446f73718fa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a92e9ff7e74bc4a143524446f73718fa3">Hwi_getStackInfo</a> (<a class="el" href="structHwi__StackInfo.html">Hwi_StackInfo</a> *stkInfo, bool computeStackDepth)</td></tr>
<tr class="memdesc:a92e9ff7e74bc4a143524446f73718fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Hwi stack usage Info.  <a href="#a92e9ff7e74bc4a143524446f73718fa3">More...</a><br /></td></tr>
<tr class="separator:a92e9ff7e74bc4a143524446f73718fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a45af9dc08f95adb33a18f97c917826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a9a45af9dc08f95adb33a18f97c917826">Hwi_post</a> (unsigned int intNum)</td></tr>
<tr class="memdesc:a9a45af9dc08f95adb33a18f97c917826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an interrupt for test purposes.  <a href="#a9a45af9dc08f95adb33a18f97c917826">More...</a><br /></td></tr>
<tr class="separator:a9a45af9dc08f95adb33a18f97c917826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad500ecee3f2a8c5d59f733692122851c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ad500ecee3f2a8c5d59f733692122851c">Hwi_disableInterrupt</a> (unsigned int intNum)</td></tr>
<tr class="memdesc:ad500ecee3f2a8c5d59f733692122851c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a specific interrupt.  <a href="#ad500ecee3f2a8c5d59f733692122851c">More...</a><br /></td></tr>
<tr class="separator:ad500ecee3f2a8c5d59f733692122851c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd045355ed5dd64567b79f02b753cb06"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#abd045355ed5dd64567b79f02b753cb06">Hwi_enableInterrupt</a> (unsigned int intNum)</td></tr>
<tr class="memdesc:abd045355ed5dd64567b79f02b753cb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a specific interrupt.  <a href="#abd045355ed5dd64567b79f02b753cb06">More...</a><br /></td></tr>
<tr class="separator:abd045355ed5dd64567b79f02b753cb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1833125ededc257b4c0576afc15ab3f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a1833125ededc257b4c0576afc15ab3f3">Hwi_restoreInterrupt</a> (unsigned int intNum, unsigned int key)</td></tr>
<tr class="memdesc:a1833125ededc257b4c0576afc15ab3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore a specific interrupt's enabled/disabled state.  <a href="#a1833125ededc257b4c0576afc15ab3f3">More...</a><br /></td></tr>
<tr class="separator:a1833125ededc257b4c0576afc15ab3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c19067515726086319b2a1859a099d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a64c19067515726086319b2a1859a099d">Hwi_clearInterrupt</a> (unsigned int intNum)</td></tr>
<tr class="memdesc:a64c19067515726086319b2a1859a099d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a specific interrupt.  <a href="#a64c19067515726086319b2a1859a099d">More...</a><br /></td></tr>
<tr class="separator:a64c19067515726086319b2a1859a099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9239683f98889f05fccc83929faec49b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a9239683f98889f05fccc83929faec49b">Hwi_getFunc</a> (<a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> hwi, uintptr_t *arg)</td></tr>
<tr class="memdesc:a9239683f98889f05fccc83929faec49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Hwi function and arg.  <a href="#a9239683f98889f05fccc83929faec49b">More...</a><br /></td></tr>
<tr class="separator:a9239683f98889f05fccc83929faec49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd838e5c3d0ae7dc465b962adbcb5fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a6dd838e5c3d0ae7dc465b962adbcb5fb">Hwi_setFunc</a> (<a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> hwi, <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a> fxn, uintptr_t arg)</td></tr>
<tr class="memdesc:a6dd838e5c3d0ae7dc465b962adbcb5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite Hwi function and arg.  <a href="#a6dd838e5c3d0ae7dc465b962adbcb5fb">More...</a><br /></td></tr>
<tr class="separator:a6dd838e5c3d0ae7dc465b962adbcb5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75768724a6196a5bf313264756ac9184"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a75768724a6196a5bf313264756ac9184">Hwi_getHookContext</a> (<a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> hwi, int id)</td></tr>
<tr class="memdesc:a75768724a6196a5bf313264756ac9184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hook instance's context for a Hwi.  <a href="#a75768724a6196a5bf313264756ac9184">More...</a><br /></td></tr>
<tr class="separator:a75768724a6196a5bf313264756ac9184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9da3aca50c30b0e77e119300579a7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a3e9da3aca50c30b0e77e119300579a7f">Hwi_setHookContext</a> (<a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> hwi, int id, void *hookContext)</td></tr>
<tr class="memdesc:a3e9da3aca50c30b0e77e119300579a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hook instance's context for a Hwi.  <a href="#a3e9da3aca50c30b0e77e119300579a7f">More...</a><br /></td></tr>
<tr class="separator:a3e9da3aca50c30b0e77e119300579a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152228df237992b1713997d882d93f73"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a152228df237992b1713997d882d93f73">Hwi_getIrp</a> (<a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> hwi)</td></tr>
<tr class="memdesc:a152228df237992b1713997d882d93f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of interrupted instruction.  <a href="#a152228df237992b1713997d882d93f73">More...</a><br /></td></tr>
<tr class="separator:a152228df237992b1713997d882d93f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37408bb65bf9c4c55c9f65fac99392e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#af37408bb65bf9c4c55c9f65fac99392e">Hwi_plug</a> (unsigned int intNum, void *fxn)</td></tr>
<tr class="memdesc:af37408bb65bf9c4c55c9f65fac99392e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plug a non dispatched interrupt vector with an ISR address.  <a href="#af37408bb65bf9c4c55c9f65fac99392e">More...</a><br /></td></tr>
<tr class="separator:af37408bb65bf9c4c55c9f65fac99392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781c77a0f9a19be7e627619e55de9398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a781c77a0f9a19be7e627619e55de9398">Hwi_getHandle</a> (unsigned int intNum)</td></tr>
<tr class="memdesc:a781c77a0f9a19be7e627619e55de9398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Hwi_handle associated with intNum.  <a href="#a781c77a0f9a19be7e627619e55de9398">More...</a><br /></td></tr>
<tr class="separator:a781c77a0f9a19be7e627619e55de9398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0c787b07c43eefa6b53b07b012a9c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a5b0c787b07c43eefa6b53b07b012a9c6">Hwi_setPriority</a> (unsigned int intNum, unsigned int priority)</td></tr>
<tr class="memdesc:a5b0c787b07c43eefa6b53b07b012a9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an interrupt's relative priority.  <a href="#a5b0c787b07c43eefa6b53b07b012a9c6">More...</a><br /></td></tr>
<tr class="separator:a5b0c787b07c43eefa6b53b07b012a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e5d302f3372c23f9800e7ed9e9059a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a97e5d302f3372c23f9800e7ed9e9059a">Hwi_excSetBuffers</a> (void *excContextBuffer, void *excStackBuffer)</td></tr>
<tr class="memdesc:a97e5d302f3372c23f9800e7ed9e9059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the exception context and stack buffer pointers.  <a href="#a97e5d302f3372c23f9800e7ed9e9059a">More...</a><br /></td></tr>
<tr class="separator:a97e5d302f3372c23f9800e7ed9e9059a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc3f1e9a17a5ce9d34109a7ee70f186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#aabc3f1e9a17a5ce9d34109a7ee70f186">Hwi_reconfig</a> (<a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> hwi, <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a> fxn, const <a class="el" href="structHwi__Params.html">Hwi_Params</a> *params)</td></tr>
<tr class="memdesc:aabc3f1e9a17a5ce9d34109a7ee70f186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconfigure a dispatched interrupt.  <a href="#aabc3f1e9a17a5ce9d34109a7ee70f186">More...</a><br /></td></tr>
<tr class="separator:aabc3f1e9a17a5ce9d34109a7ee70f186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2b31338a8ed87e8c89ae4343bb97c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a4b2b31338a8ed87e8c89ae4343bb97c1">Hwi_Params_init</a> (<a class="el" href="structHwi__Params.html">Hwi_Params</a> *prms)</td></tr>
<tr class="separator:a4b2b31338a8ed87e8c89ae4343bb97c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5cd5de8b4296c6b8f073bb9705d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a95c5cd5de8b4296c6b8f073bb9705d71">Hwi_Object_first</a> (void)</td></tr>
<tr class="separator:a95c5cd5de8b4296c6b8f073bb9705d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f34e3239a63cce7121dc2ae2c7b89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ae5f34e3239a63cce7121dc2ae2c7b89c">Hwi_Object_next</a> (<a class="el" href="family_2arm_2m3_2Hwi_8h.html#a71e2280a28fd84c37788b8137f7b2929">Hwi_Object</a> *obj)</td></tr>
<tr class="separator:ae5f34e3239a63cce7121dc2ae2c7b89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aecdb022ec9882ec790586d22ab63181a"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="structHwi__NVIC.html">Hwi_NVIC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#aecdb022ec9882ec790586d22ab63181a">Hwi_nvic</a></td></tr>
<tr class="memdesc:aecdb022ec9882ec790586d22ab63181a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical Nested Vectored Interrupt Controller Device. short name is "Hwi_nvic" long name is "ti_sysbios_family_arm_m3_Hwi_nvic".  <a href="#aecdb022ec9882ec790586d22ab63181a">More...</a><br /></td></tr>
<tr class="separator:aecdb022ec9882ec790586d22ab63181a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcce9622df9b2e824dac1559364537e6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#adcce9622df9b2e824dac1559364537e6">Hwi_NUM_INTERRUPTS</a></td></tr>
<tr class="memdesc:adcce9622df9b2e824dac1559364537e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Cortex M3/M4 NVIC supports up to 256 interrupts/exceptions.  <a href="#adcce9622df9b2e824dac1559364537e6">More...</a><br /></td></tr>
<tr class="separator:adcce9622df9b2e824dac1559364537e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e67a5ea33ff592861862c1de3351d95"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a1e67a5ea33ff592861862c1de3351d95">Hwi_NUM_PRIORITIES</a></td></tr>
<tr class="memdesc:a1e67a5ea33ff592861862c1de3351d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Cortex M3/M4 NVIC supports up to 256 interrupt priorities.  <a href="#a1e67a5ea33ff592861862c1de3351d95">More...</a><br /></td></tr>
<tr class="separator:a1e67a5ea33ff592861862c1de3351d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b8808c2e031e599fd15a980d0cc297"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="family_2arm_2m3_2Hwi_8h.html#afb795b1c4d316ce21de274551beeb30d">Hwi_ExcHookFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a95b8808c2e031e599fd15a980d0cc297">Hwi_excHookFunc</a></td></tr>
<tr class="memdesc:a95b8808c2e031e599fd15a980d0cc297"><td class="mdescLeft">&#160;</td><td class="mdescRight">User Exception hook function.  <a href="#a95b8808c2e031e599fd15a980d0cc297">More...</a><br /></td></tr>
<tr class="separator:a95b8808c2e031e599fd15a980d0cc297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35617245a46155e1961f70f65e68b1f"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#aa35617245a46155e1961f70f65e68b1f">Hwi_disablePriority</a></td></tr>
<tr class="memdesc:aa35617245a46155e1961f70f65e68b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The priority that BASEPRI is set to by <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>.  <a href="#aa35617245a46155e1961f70f65e68b1f">More...</a><br /></td></tr>
<tr class="separator:aa35617245a46155e1961f70f65e68b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fd0d22e8025d2288c28ad15dc8ca60"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a72fd0d22e8025d2288c28ad15dc8ca60">Hwi_priGroup</a></td></tr>
<tr class="memdesc:a72fd0d22e8025d2288c28ad15dc8ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PRIGROUP setting. Default is 0.  <a href="#a72fd0d22e8025d2288c28ad15dc8ca60">More...</a><br /></td></tr>
<tr class="separator:a72fd0d22e8025d2288c28ad15dc8ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5445292396b94dfc0c40aec35cff08d"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ae5445292396b94dfc0c40aec35cff08d">Hwi_numSparseInterrupts</a></td></tr>
<tr class="memdesc:ae5445292396b94dfc0c40aec35cff08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Hwi.dispatchTableSize is initialized by the user then Hwi.numSparseInterrupts is set to the value of Hwi.dispatchTableSize.  <a href="#ae5445292396b94dfc0c40aec35cff08d">More...</a><br /></td></tr>
<tr class="separator:ae5445292396b94dfc0c40aec35cff08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2ae652f0c7df32cbb6878eaed3a44b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae652f0c7df32cbb6878eaed3a44b78">&sect;&nbsp;</a></span>Hwi_E_badIntNum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_badIntNum&#160;&#160;&#160;&quot;intnum: %d is out of range&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised Error raised if an attempt is made to create a Hwi with an interrupt number greater than Hwi_NUM_INTERRUPTS - 1. </p>

</div>
</div>
<a id="a56480daf253d1050b6c613c66f63606f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56480daf253d1050b6c613c66f63606f">&sect;&nbsp;</a></span>Hwi_E_alreadyDefined</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_alreadyDefined&#160;&#160;&#160;&quot;Hwi already defined: intr# %d&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when a Hwi is already defined. </p>

</div>
</div>
<a id="adab7f3faf295e51ab8444f452f114635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab7f3faf295e51ab8444f452f114635">&sect;&nbsp;</a></span>Hwi_E_hwiLimitExceeded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_hwiLimitExceeded&#160;&#160;&#160;&quot;Too many interrupts defined&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when the number of interrupts being created exceeds the number supported. </p>

</div>
</div>
<a id="aeab9894ed2132c33fdc5781b65a72b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab9894ed2132c33fdc5781b65a72b1b">&sect;&nbsp;</a></span>Hwi_E_exception</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_exception&#160;&#160;&#160;&quot;hardware exception id = %d, pc = 0x%08x&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when an exception occurs. </p>

</div>
</div>
<a id="a4c5f9405703ac992cdb6a3f0af1e9d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5f9405703ac992cdb6a3f0af1e9d9b">&sect;&nbsp;</a></span>Hwi_E_noIsr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_noIsr&#160;&#160;&#160;&quot;no ISR, id = %d, pc = 0x%08x&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when an uninitialized interrupt occurs. </p>

</div>
</div>
<a id="adc270b59ad513adbb1786a14cb75321a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc270b59ad513adbb1786a14cb75321a">&sect;&nbsp;</a></span>Hwi_E_NMI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_NMI&#160;&#160;&#160;&quot;NMI: %s&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when NMI exception occurs. </p>

</div>
</div>
<a id="af567c4430ab0f1825ef02440426b98ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af567c4430ab0f1825ef02440426b98ca">&sect;&nbsp;</a></span>Hwi_E_hardFault</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_hardFault&#160;&#160;&#160;&quot;Hard-fault: %s&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when hard fault exception occurs. </p>

</div>
</div>
<a id="ace58994ee380979189ab57960977691c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace58994ee380979189ab57960977691c">&sect;&nbsp;</a></span>Hwi_E_memFault</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_memFault&#160;&#160;&#160;&quot;Mem-fault: %s, addresss: 0x%08x&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when memory fault exception occurs. </p>

</div>
</div>
<a id="a42529e4d242e2bab0f6521335f00a2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42529e4d242e2bab0f6521335f00a2ba">&sect;&nbsp;</a></span>Hwi_E_busFault</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_busFault&#160;&#160;&#160;&quot;Bus-fault: %s, address: 0x%08x&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when bus fault exception occurs. </p>

</div>
</div>
<a id="a2673e0f27f7a521912ee263e81c775fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2673e0f27f7a521912ee263e81c775fc">&sect;&nbsp;</a></span>Hwi_E_usageFault</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_usageFault&#160;&#160;&#160;&quot;Usage-fault: %s&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when usage fault exception occurs. </p>

</div>
</div>
<a id="a014bfc7799cb6507f2afefb2c34e90b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014bfc7799cb6507f2afefb2c34e90b2">&sect;&nbsp;</a></span>Hwi_E_svCall</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_svCall&#160;&#160;&#160;&quot;SvCall: svNum = %d&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when svCall exception occurs. </p>

</div>
</div>
<a id="a04fd065c4f9ac3841ee0b187a35db7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fd065c4f9ac3841ee0b187a35db7b1">&sect;&nbsp;</a></span>Hwi_E_debugMon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_debugMon&#160;&#160;&#160;&quot;Debug-monitor: %s&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when debugMon exception occurs. </p>

</div>
</div>
<a id="aa5b035db3f59d87c6f2db4ba560dfa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b035db3f59d87c6f2db4ba560dfa6e">&sect;&nbsp;</a></span>Hwi_E_reserved</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_reserved&#160;&#160;&#160;&quot;reserved %s %d&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when reserved exceptions occur. </p>

</div>
</div>
<a id="aba796bcdd372d44826424de0d1d162fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba796bcdd372d44826424de0d1d162fa">&sect;&nbsp;</a></span>Hwi_E_stackOverflow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Hwi_E_stackOverflow&#160;&#160;&#160;&quot;ISR stack overflow&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error raised when the ISR stack has overflowed. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae6632e60a2959a8be923d862da09e9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6632e60a2959a8be923d862da09e9dd">&sect;&nbsp;</a></span>Hwi_Struct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHwi__Struct.html">Hwi_Struct</a> <a class="el" href="structHwi__Struct.html">Hwi_Struct</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71e2280a28fd84c37788b8137f7b2929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e2280a28fd84c37788b8137f7b2929">&sect;&nbsp;</a></span>Hwi_Object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHwi__Struct.html">Hwi_Struct</a> <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a71e2280a28fd84c37788b8137f7b2929">Hwi_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3189422b01a80e5e79363a0a736a650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3189422b01a80e5e79363a0a736a650">&sect;&nbsp;</a></span>Hwi_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structHwi__Struct.html">Hwi_Struct</a>* <a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd77cf6fb1d8a38db30996b80e77ca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd77cf6fb1d8a38db30996b80e77ca54">&sect;&nbsp;</a></span>Hwi_Instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structHwi__Struct.html">Hwi_Struct</a>* <a class="el" href="family_2arm_2m3_2Hwi_8h.html#afd77cf6fb1d8a38db30996b80e77ca54">Hwi_Instance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aaedb4b9a8a846bf0d3d76745e203b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaedb4b9a8a846bf0d3d76745e203b3">&sect;&nbsp;</a></span>Hwi_HookSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHwi__HookSet.html">Hwi_HookSet</a> <a class="el" href="structHwi__HookSet.html">Hwi_HookSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hwi hook set type definition. </p>
<p>The functions that make up a hookSet have certain restrictions. They cannot call any Hwi instance functions other than <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a75768724a6196a5bf313264756ac9184" title="Get hook instance&#39;s context for a Hwi. ">Hwi_getHookContext()</a> and <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a3e9da3aca50c30b0e77e119300579a7f" title="Set hook instance&#39;s context for a Hwi. ">Hwi_setHookContext()</a>. For all practical purposes, they should treat the Hwi_Handle passed to these functions as an opaque handle. </p>

</div>
</div>
<a id="af7fa76c7b26390ea4db4feb233f7967d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fa76c7b26390ea4db4feb233f7967d">&sect;&nbsp;</a></span>Hwi_Module_State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHwi__Module__State.html">Hwi_Module_State</a> <a class="el" href="structHwi__Module__State.html">Hwi_Module_State</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd62c84fde44cb75abe25098ae2d0ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd62c84fde44cb75abe25098ae2d0ee1">&sect;&nbsp;</a></span>Hwi_Params</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHwi__Params.html">Hwi_Params</a> <a class="el" href="structHwi__Params.html">Hwi_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a0fae8137234765d79629afb64cffca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0fae8137234765d79629afb64cffca">&sect;&nbsp;</a></span>Hwi_NVIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHwi__NVIC.html">Hwi_NVIC</a> <a class="el" href="structHwi__NVIC.html">Hwi_NVIC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested Vectored Interrupt Controller. </p>

</div>
</div>
<a id="a41bd11ada5c5c49e35dbd7bacf87cc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bd11ada5c5c49e35dbd7bacf87cc4b">&sect;&nbsp;</a></span>Hwi_ExcContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHwi__ExcContext.html">Hwi_ExcContext</a> <a class="el" href="structHwi__ExcContext.html">Hwi_ExcContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exception Context - Register contents at the time of an exception. </p>

</div>
</div>
<a id="a388cc58013001e4c9d35dfc6c8609c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388cc58013001e4c9d35dfc6c8609c42">&sect;&nbsp;</a></span>Hwi_StackInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHwi__StackInfo.html">Hwi_StackInfo</a> <a class="el" href="structHwi__StackInfo.html">Hwi_StackInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure contains Hwi stack usage info. </p>
<p>Used by getStackInfo() and viewGetStackInfo() functions </p>

</div>
</div>
<a id="a0119190d0fc8f6f4a692251018b493c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0119190d0fc8f6f4a692251018b493c8">&sect;&nbsp;</a></span>Hwi_FuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Hwi_FuncPtr) (uintptr_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hwi create function type definition. </p>

</div>
</div>
<a id="a2e7a897660823e037d0e1021deda824e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7a897660823e037d0e1021deda824e">&sect;&nbsp;</a></span>Hwi_VectorFuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Hwi_VectorFuncPtr) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hwi vector function type definition. </p>

</div>
</div>
<a id="a70350a70b691efe5b49478dc19249edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70350a70b691efe5b49478dc19249edb">&sect;&nbsp;</a></span>Hwi_ExceptionHookFuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Hwi_ExceptionHookFuncPtr) (<a class="el" href="structHwi__ExcContext.html">Hwi_ExcContext</a> *arg1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exception hook function type definition. </p>

</div>
</div>
<a id="afb795b1c4d316ce21de274551beeb30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb795b1c4d316ce21de274551beeb30d">&sect;&nbsp;</a></span>Hwi_ExcHookFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a70350a70b691efe5b49478dc19249edb">Hwi_ExceptionHookFuncPtr</a> <a class="el" href="family_2arm_2m3_2Hwi_8h.html#afb795b1c4d316ce21de274551beeb30d">Hwi_ExcHookFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe5ca8ed68f8a9a4dba67929ee3e6240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5ca8ed68f8a9a4dba67929ee3e6240">&sect;&nbsp;</a></span>Hwi_MaskingOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44ab">Hwi_MaskingOption</a> <a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44ab">Hwi_MaskingOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorthand interrupt masking options. </p>

</div>
</div>
<a id="a7157b4ad62fef4bb5af53b21dcca965c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7157b4ad62fef4bb5af53b21dcca965c">&sect;&nbsp;</a></span>Hwi_ExcHandlerFuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Hwi_ExcHandlerFuncPtr) (unsigned int *arg1, unsigned int arg2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hwi exception handler function type definition. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adab01a75be33b6d08c73d4db93bd44ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab01a75be33b6d08c73d4db93bd44ab">&sect;&nbsp;</a></span>Hwi_MaskingOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="family_2arm_2m3_2Hwi_8h.html#adab01a75be33b6d08c73d4db93bd44ab">Hwi_MaskingOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt masking options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adab01a75be33b6d08c73d4db93bd44aba8a2e54e82adc414a7b056c46b0ae8764"></a>Hwi_MaskingOption_NONE&#160;</td><td class="fielddoc"><p>No interrupts are disabled <b>(not support on cortexM devices)</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="adab01a75be33b6d08c73d4db93bd44aba2b6a7322bfa687dd35af9a40e0c9e74e"></a>Hwi_MaskingOption_ALL&#160;</td><td class="fielddoc"><p>All interrupts are disabled <b>(not support on cortexM devices)</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="adab01a75be33b6d08c73d4db93bd44aba07c9be851e468005222fc91582973d21"></a>Hwi_MaskingOption_SELF&#160;</td><td class="fielddoc"><p>Only this interrupt is disabled <b>(not support on cortexM devices)</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="adab01a75be33b6d08c73d4db93bd44aba487f24b9a7b46b30a4fe9d416f6c0715"></a>Hwi_MaskingOption_BITMASK&#160;</td><td class="fielddoc"><p>User supplies interrupt enable masks <b>(not support on cortexM devices)</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="adab01a75be33b6d08c73d4db93bd44aba27157b54254bc172f584a2284a8da0c7"></a>Hwi_MaskingOption_LOWER&#160;</td><td class="fielddoc"><p>All current and lower priority interrupts are disabled. <b>(default for all cortexM devices)</b> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5abb2606ef0d232268f11c6c9341f7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abb2606ef0d232268f11c6c9341f7d0">&sect;&nbsp;</a></span>Hwi_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Hwi_Disable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Globally disable interrupts. </p>
<p>Hwi_disable globally disables hardware interrupts and returns an opaque key indicating whether interrupts were globally enabled or disabled on entry to <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>. The actual value of the key is target/device specific and is meant to be passed to <a class="el" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore()</a>.</p>
<p>Call Hwi_disable before a portion of a function that needs to run without interruption. When critical processing is complete, call Hwi_restore or Hwi_enable to reenable hardware interrupts.</p>
<p>Servicing of interrupts that occur while interrupts are disabled is postponed until interrupts are reenabled. However, if the same type of interrupt occurs several times while interrupts are disabled, the interrupt's function is executed only once when interrupts are reenabled.</p>
<p>A context switch can occur when calling Hwi_enable or Hwi_restore if an enabled interrupt occurred while interrupts are disabled.</p>
<p>Hwi_disable may be called from main(). However, since Hwi interrupts are already disabled in main(), such a call has no effect.</p>
<dl class="section warning"><dt>Warning</dt><dd>The cortexM implementation of <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a> sets the basepri register to the value of <a class="el" href="hal_2Hwi_8h.html#aa35617245a46155e1961f70f65e68b1f">Hwi_disablePriority</a>.</dd>
<dd>
If a Task switching API such as <a class="el" href="Semaphore_8h.html#ac7e0b45f15b2f6f5a7e4ecc772ddbd0c" title="Wait for a semaphore. ">Semaphore_pend()</a>, <a class="el" href="Semaphore_8h.html#aeb5255ece95bc96188f617be327427d2" title="Signal a semaphore. ">Semaphore_post()</a>, <a class="el" href="Task_8h.html#a1c5f0ae2e0960e2e7bdc4f1a8edb07fa" title="Delay execution of the current task. ">Task_sleep()</a>, <a class="el" href="Task_8h.html#a78841ab191646faa598ed8f723969dab" title="Yield processor to equal priority task. ">Task_yield()</a>, is invoked which results in a context switch while interrupts are disabled, an embedded call to <a class="el" href="hal_2Hwi_8h.html#afa2a5a08ef4d7f6b1bcdea2dfb90c4ac">Hwi_enable()</a> occurs on the way to the new thread context which unconditionally re-enables interrupts. Interrupts will remain enabled until a subsequent <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a> invocation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">opaque</td><td>uint32_t key for use by <a class="el" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2263585352a40e55a7c385ab0c8f9790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2263585352a40e55a7c385ab0c8f9790">&sect;&nbsp;</a></span>Hwi_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Hwi_Enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Globally enable interrupts. </p>
<p><b><a class="el" href="hal_2Hwi_8h.html#afa2a5a08ef4d7f6b1bcdea2dfb90c4ac">Hwi_enable()</a></b></p>
<p>Hwi_enable globally enables hardware interrupts and returns an opaque key indicating whether interrupts were globally enabled or disabled on entry to <a class="el" href="hal_2Hwi_8h.html#afa2a5a08ef4d7f6b1bcdea2dfb90c4ac">Hwi_enable()</a>. The actual value of the key is target/device specific and is meant to be passed to <a class="el" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore()</a>.</p>
<p>This function is called within <a class="el" href="BIOS_8h.html#aa166cb986a863566660e378fdd48309e" title="Start SYS/BIOS. ">BIOS_start()</a> to enable interrupts after "main()" has been executed. Prior to <a class="el" href="BIOS_8h.html#aa166cb986a863566660e378fdd48309e" title="Start SYS/BIOS. ">BIOS_start()</a>, interrupts are globally disabled.</p>
<p>Hardware interrupts are enabled unless a call to <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a> disables them.</p>
<p>Servicing of interrupts that occur while interrupts are disabled is postponed until interrupts are reenabled. However, if the same type of interrupt occurs several times while interrupts are disabled, the interrupt's function is executed only once when interrupts are reenabled.</p>
<p>A context switch can occur when calling Hwi_enable or Hwi_restore if an enabled interrupt occurred while interrupts are disabled.</p>
<p>Any call to Hwi_enable enables interrupts, even if Hwi_disable has been called several times.</p>
<p>Hwi_enable must not be called from within "main()". </p>

</div>
</div>
<a id="a7fa563930d07267cebbe089d24943397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa563930d07267cebbe089d24943397">&sect;&nbsp;</a></span>Hwi_Restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_Restore </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>restore global interrupts to the state they were in prior <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>. </p>
<p><b>Hwi_restore(key)</b></p>
<p>Globally restore interrupts.</p>
<p><a class="el" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore()</a> globally restores interrupts to the state determined by the key argument provided by a previous invocation of <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>.</p>
<p>A context switch may occur when calling Hwi_restore if <a class="el" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore()</a> reenables interrupts and another Hwi occurred while interrupts were disabled.</p>
<p>The <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a> / <a class="el" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore()</a> pair may be called from within main(). However, since interrupts are globally disabled prior to main(), the call to <a class="el" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore()</a> has no effect.</p>
<ul>
<li>key = enable/disable state to restore </li>
</ul>

</div>
</div>
<a id="adfc4ba27136fb55964a91eafdf664a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc4ba27136fb55964a91eafdf664a1a">&sect;&nbsp;</a></span>Hwi_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> Hwi_create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>hwiFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structHwi__Params.html">Hwi_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09fe90830ddba191124b6b742a53b73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fe90830ddba191124b6b742a53b73a">&sect;&nbsp;</a></span>Hwi_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> Hwi_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHwi__Struct.html">Hwi_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>hwiFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structHwi__Params.html">Hwi_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75aeba325e5430219a7c01fd8f2dfa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aeba325e5430219a7c01fd8f2dfa56">&sect;&nbsp;</a></span>Hwi_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cf4c4e4271fdd903c558cd1afd18b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf4c4e4271fdd903c558cd1afd18b8d">&sect;&nbsp;</a></span>Hwi_destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHwi__Struct.html">Hwi_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92e9ff7e74bc4a143524446f73718fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e9ff7e74bc4a143524446f73718fa3">&sect;&nbsp;</a></span>Hwi_getStackInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Hwi_getStackInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHwi__StackInfo.html">Hwi_StackInfo</a> *&#160;</td>
          <td class="paramname"><em>stkInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeStackDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Hwi stack usage Info. </p>
<p>getStackInfo returns the Hwi stack usage info to its calling function by filling stack base address, stack size and stack peak fields in the <a class="el" href="structHwi__StackInfo.html" title="Structure contains Hwi stack usage info. ">Hwi_StackInfo</a> structure.</p>
<p>getStackInfo accepts two arguments, a pointer to a structure of type <a class="el" href="structHwi__StackInfo.html" title="Structure contains Hwi stack usage info. ">Hwi_StackInfo</a> and a boolean. If the boolean is set to true, the function computes the stack depth and fills the stack peak field in the StackInfo structure. If a stack overflow is detected, the stack depth is not computed. If the boolean is set to false, the function only checks for a stack overflow.</p>
<p>The isr stack is always checked for an overflow and a boolean is returned to indicate whether an overflow occured.</p>
<p>Below is an example of calling getStackInfo() API:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="BIOS_8h.html">ti/sysbios/BIOS.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="family_2arm_2m3_2Hwi_8h.html">ti/sysbios/family/arm/m3/Hwi.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Swi_8h.html">ti/sysbios/knl/Swi.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Task_8h.html">ti/sysbios/knl/Task.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi0;</div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> swiStackOverflow = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> swi0Fxn(uintptr_t arg1, uintptr_t arg2)</div><div class="line">{</div><div class="line">    <a class="code" href="structHwi__StackInfo.html">Hwi_StackInfo</a> stkInfo;</div><div class="line"></div><div class="line">    <span class="comment">// Request stack depth</span></div><div class="line">    swiStackOverflow = <a class="code" href="family_2arm_2m3_2Hwi_8h.html#a92e9ff7e74bc4a143524446f73718fa3">Hwi_getStackInfo</a>(&amp;stkInfo, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Alternately, we can omit the request for stack depth and</span></div><div class="line">    <span class="comment">// request only the stack base and stack size (the check for</span></div><div class="line">    <span class="comment">// stack overflow is always performed):</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    swiStackOverflow = <a class="code" href="family_2arm_2m3_2Hwi_8h.html#a92e9ff7e74bc4a143524446f73718fa3">Hwi_getStackInfo</a>(&amp;stkInfo, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (swiStackOverflow) {</div><div class="line">        <span class="comment">// isr Stack Overflow detected</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> idleTask()</div><div class="line">{</div><div class="line">    <a class="code" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a>(swi0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">    swi0 = <a class="code" href="Swi_8h.html#a5d383d9dee6303634644df22420d8240">Swi_create</a>(swi0Fxn, NULL, NULL);</div><div class="line"></div><div class="line">    <a class="code" href="BIOS_8h.html#aa166cb986a863566660e378fdd48309e">BIOS_start</a>();</div><div class="line">    <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stkInfo</td><td>pointer to stack info structure </td></tr>
    <tr><td class="paramname">computeStackDepth</td><td>decides whether to compute stack depth</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">boolean</td><td>to indicate a stack overflow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a45af9dc08f95adb33a18f97c917826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a45af9dc08f95adb33a18f97c917826">&sect;&nbsp;</a></span>Hwi_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_post </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>intNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an interrupt for test purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>ID of interrupt to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad500ecee3f2a8c5d59f733692122851c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad500ecee3f2a8c5d59f733692122851c">&sect;&nbsp;</a></span>Hwi_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Hwi_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>intNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable a specific interrupt. </p>
<p>Disable a specific interrupt identified by an interrupt number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>interrupt number to disable</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">key</td><td>to restore previous enable/disable state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd045355ed5dd64567b79f02b753cb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd045355ed5dd64567b79f02b753cb06">&sect;&nbsp;</a></span>Hwi_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Hwi_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>intNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable a specific interrupt. </p>
<p>Enables a specific interrupt identified by an interrupt number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>interrupt number to enable</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">key</td><td>to restore previous enable/disable state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1833125ededc257b4c0576afc15ab3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1833125ededc257b4c0576afc15ab3f3">&sect;&nbsp;</a></span>Hwi_restoreInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_restoreInterrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore a specific interrupt's enabled/disabled state. </p>
<p>Restores a specific interrupt identified by an interrupt number. restoreInterrupt is generally used to restore an interrupt to its state before Hwi_disableInterrupt or Hwi_enableInterrupt was invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>interrupt number to restore </td></tr>
    <tr><td class="paramname">key</td><td>key returned from enableInt or disableInt </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64c19067515726086319b2a1859a099d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c19067515726086319b2a1859a099d">&sect;&nbsp;</a></span>Hwi_clearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_clearInterrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>intNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a specific interrupt. </p>
<p>Clears a specific interrupt's pending status. The implementation is family- specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>interrupt number to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9239683f98889f05fccc83929faec49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9239683f98889f05fccc83929faec49b">&sect;&nbsp;</a></span>Hwi_getFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a> Hwi_getFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td>
          <td class="paramname"><em>hwi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Hwi function and arg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwi</td><td>Hwi handle </td></tr>
    <tr><td class="paramname">arg</td><td>pointer for returning hwi's ISR function argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">hwi's</td><td>ISR function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dd838e5c3d0ae7dc465b962adbcb5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd838e5c3d0ae7dc465b962adbcb5fb">&sect;&nbsp;</a></span>Hwi_setFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_setFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td>
          <td class="paramname"><em>hwi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite Hwi function and arg. </p>
<p>Replaces a Hwi object's hwiFxn function originally provided in Hwi_create.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a6dd838e5c3d0ae7dc465b962adbcb5fb" title="Overwrite Hwi function and arg. ">Hwi_setFunc()</a> is not thread safe. This means that the new value for for 'fxn' may be temporarily paired with the previous value for 'arg' if pre-emption occurs within the execution of <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a6dd838e5c3d0ae7dc465b962adbcb5fb" title="Overwrite Hwi function and arg. ">Hwi_setFunc()</a>.</dd></dl>
<p>To guard against this condition, surround the <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a6dd838e5c3d0ae7dc465b962adbcb5fb" title="Overwrite Hwi function and arg. ">Hwi_setFunc()</a> call with calls to <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a> and <a class="el" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore()</a>:</p>
<div class="fragment"><div class="line">key = <a class="code" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable</a>();</div><div class="line"></div><div class="line"><a class="code" href="family_2arm_2m3_2Hwi_8h.html#a6dd838e5c3d0ae7dc465b962adbcb5fb">Hwi_setFunc</a>(newFunc, newArg);</div><div class="line"></div><div class="line"><a class="code" href="hal_2Hwi_8h.html#a62f5c6adcdc834a7f7714a07a06538ff">Hwi_restore</a>(key);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwi</td><td>Hwi handle </td></tr>
    <tr><td class="paramname">fxn</td><td>pointer to ISR function </td></tr>
    <tr><td class="paramname">arg</td><td>argument to ISR function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75768724a6196a5bf313264756ac9184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75768724a6196a5bf313264756ac9184">&sect;&nbsp;</a></span>Hwi_getHookContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Hwi_getHookContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td>
          <td class="paramname"><em>hwi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hook instance's context for a Hwi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwi</td><td>Hwi handle </td></tr>
    <tr><td class="paramname">id</td><td>hook id</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">hook</td><td>instance's context for hwi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e9da3aca50c30b0e77e119300579a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9da3aca50c30b0e77e119300579a7f">&sect;&nbsp;</a></span>Hwi_setHookContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_setHookContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td>
          <td class="paramname"><em>hwi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hookContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set hook instance's context for a Hwi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwi</td><td>Hwi handle </td></tr>
    <tr><td class="paramname">id</td><td>hook id </td></tr>
    <tr><td class="paramname">hookContext</td><td>value to write to context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a152228df237992b1713997d882d93f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152228df237992b1713997d882d93f73">&sect;&nbsp;</a></span>Hwi_getIrp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t Hwi_getIrp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td>
          <td class="paramname"><em>hwi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address of interrupted instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwi</td><td>Hwi handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">most</td><td>current IRP of a Hwi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af37408bb65bf9c4c55c9f65fac99392e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37408bb65bf9c4c55c9f65fac99392e">&sect;&nbsp;</a></span>Hwi_plug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_plug </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plug a non dispatched interrupt vector with an ISR address. </p>
<p>Used internally by <a class="el" href="family_2arm_2m3_2Hwi_8h.html#adfc4ba27136fb55964a91eafdf664a1a">Hwi_create()</a> and <a class="el" href="family_2arm_2m3_2Hwi_8h.html#a09fe90830ddba191124b6b742a53b73a">Hwi_construct()</a>.</p>
<p>This API is provided for external use primarily to allow users to plug the NMI vector (interrupt #2) at runtime.</p>
<dl class="section note"><dt>Note</dt><dd>Interrupt vectors plugged using <a class="el" href="family_2arm_2m3_2Hwi_8h.html#af37408bb65bf9c4c55c9f65fac99392e" title="Plug a non dispatched interrupt vector with an ISR address. ">Hwi_plug()</a> are NOT managed by the Hwi interrupt dispatcher. Consequently, it is not safe to call SYS/BIOS APIs from within these ISRs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>interrupt number </td></tr>
    <tr><td class="paramname">fxn</td><td>pointer to ISR function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a781c77a0f9a19be7e627619e55de9398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781c77a0f9a19be7e627619e55de9398">&sect;&nbsp;</a></span>Hwi_getHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> Hwi_getHandle </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>intNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns Hwi_handle associated with intNum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Hwi</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b0c787b07c43eefa6b53b07b012a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0c787b07c43eefa6b53b07b012a9c6">&sect;&nbsp;</a></span>Hwi_setPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_setPriority </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an interrupt's relative priority. </p>
<p>Valid priorities are 0 - 255. 0 is highest priority.</p>
<dl class="section warning"><dt>Warning</dt><dd>Setting the priority of a dispatched Hwi to a value higher than Hwi_disablePriority will make it become non-maskable by Hwi_disable. The behavior of your application after that will be unpredictable and will likely yield catastrophic results!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>ID of interrupt </td></tr>
    <tr><td class="paramname">priority</td><td>priority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97e5d302f3372c23f9800e7ed9e9059a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e5d302f3372c23f9800e7ed9e9059a">&sect;&nbsp;</a></span>Hwi_excSetBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_excSetBuffers </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>excContextBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>excStackBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the exception context and stack buffer pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">excContextBuffer</td><td>Address to place ExcContext </td></tr>
    <tr><td class="paramname">excStackBuffer</td><td>Address to place ExcStack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabc3f1e9a17a5ce9d34109a7ee70f186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc3f1e9a17a5ce9d34109a7ee70f186">&sect;&nbsp;</a></span>Hwi_reconfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_reconfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a>&#160;</td>
          <td class="paramname"><em>hwi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a0119190d0fc8f6f4a692251018b493c8">Hwi_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structHwi__Params.html">Hwi_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconfigure a dispatched interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwi</td><td>Hwi handle </td></tr>
    <tr><td class="paramname">fxn</td><td>Hwi function </td></tr>
    <tr><td class="paramname">params</td><td>pointer to Hwi params structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b2b31338a8ed87e8c89ae4343bb97c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2b31338a8ed87e8c89ae4343bb97c1">&sect;&nbsp;</a></span>Hwi_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hwi_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHwi__Params.html">Hwi_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95c5cd5de8b4296c6b8f073bb9705d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c5cd5de8b4296c6b8f073bb9705d71">&sect;&nbsp;</a></span>Hwi_Object_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> Hwi_Object_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5f34e3239a63cce7121dc2ae2c7b89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f34e3239a63cce7121dc2ae2c7b89c">&sect;&nbsp;</a></span>Hwi_Object_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#ab3189422b01a80e5e79363a0a736a650">Hwi_Handle</a> Hwi_Object_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="family_2arm_2m3_2Hwi_8h.html#a71e2280a28fd84c37788b8137f7b2929">Hwi_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aecdb022ec9882ec790586d22ab63181a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdb022ec9882ec790586d22ab63181a">&sect;&nbsp;</a></span>Hwi_nvic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="structHwi__NVIC.html">Hwi_NVIC</a> Hwi_nvic</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physical Nested Vectored Interrupt Controller Device. short name is "Hwi_nvic" long name is "ti_sysbios_family_arm_m3_Hwi_nvic". </p>

</div>
</div>
<a id="adcce9622df9b2e824dac1559364537e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcce9622df9b2e824dac1559364537e6">&sect;&nbsp;</a></span>Hwi_NUM_INTERRUPTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Hwi_NUM_INTERRUPTS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Cortex M3/M4 NVIC supports up to 256 interrupts/exceptions. </p>
<p>The actual number supported is device specific and provided by the catalog device specification. </p>

</div>
</div>
<a id="a1e67a5ea33ff592861862c1de3351d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e67a5ea33ff592861862c1de3351d95">&sect;&nbsp;</a></span>Hwi_NUM_PRIORITIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Hwi_NUM_PRIORITIES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Cortex M3/M4 NVIC supports up to 256 interrupt priorities. </p>
<p>The actual number supported is device specific and provided by the catalog device specification. For all TI SimpleLink devices, 8 priorities are supported. </p>

</div>
</div>
<a id="a95b8808c2e031e599fd15a980d0cc297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b8808c2e031e599fd15a980d0cc297">&sect;&nbsp;</a></span>Hwi_excHookFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="family_2arm_2m3_2Hwi_8h.html#afb795b1c4d316ce21de274551beeb30d">Hwi_ExcHookFunc</a> Hwi_excHookFunc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User Exception hook function. </p>
<p>Called just after the exception context has been initialized.</p>
<p>This function will be run on the ISR stack.</p>
<p>This function must run to completion.</p>
<p>It is called without any Task or Swi scheduling protection and therefore can not call any functions that may cause a Swi or Task scheduling operation (<a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57" title="Unconditionally post a software interrupt. ">Swi_post()</a>, <a class="el" href="Semaphore_8h.html#aeb5255ece95bc96188f617be327427d2" title="Signal a semaphore. ">Semaphore_post()</a>, <a class="el" href="Event_8h.html#a18287b9cda7bced0442e1cd20dbfabaf" title="Post event(s) to an event object. ">Event_post()</a>, etc). </p>

</div>
</div>
<a id="aa35617245a46155e1961f70f65e68b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35617245a46155e1961f70f65e68b1f">&sect;&nbsp;</a></span>Hwi_disablePriority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Hwi_disablePriority</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The priority that BASEPRI is set to by <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>. </p>
<p>All interrupts configured with equal or less priority (equal or higher number) than disablePriority are disabled by Hwi_disable. Interrupts configured with higher priority (smaller number) than Hwi.disablePriority are non-maskable (ie zero-latency).</p>
<p>The default setting is the second highest interrupt priority defined for the device (typically '0x20' for devices which support 8 priority values). This results in priority 0 (and all other values in the same priority group, ie 0x00 thru 0x1f) being the zero-latency, non-maskable interrupt priority. All other priorities are disabled with <a class="el" href="hal_2Hwi_8h.html#a827920b3fe40f10d728e20c22550d9d2">Hwi_disable()</a>.</p>
<p>The constant Hwi_disablePriority is configured within the app.syscfg file using the following syntax:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Hwi = scripting.addModule(<span class="stringliteral">&quot;/family/arm/m3/Hwi&quot;</span>);</div><div class="line">Hwi.disablePriority = 0x20;</div></div><!-- fragment --> 
</div>
</div>
<a id="a72fd0d22e8025d2288c28ad15dc8ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fd0d22e8025d2288c28ad15dc8ca60">&sect;&nbsp;</a></span>Hwi_priGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Hwi_priGroup</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The PRIGROUP setting. Default is 0. </p>
<p>This value will be written to the PRIGROUP field within the NVIC's Application Interrupt and Reset Control Register (Hwi_nvic.AIRCR). It defines how the 8 bit priority values are interpreted by the hardware.</p>
<p>Valid settings are 0-7.</p>
<p>The default setting of 0 causes bits 7-1 of an interrupt's priority value to be used as pre-emption priority, while bit 0 is used to determine which of two simultaneous interrupts with the same pre-emption priority will be serviced first.</p>
<p>For most TI MCU devices, this means that each of the 8 supported priority values are unique pre-emption priorities and are not subdivided into priority groups.</p>
<p>See the "AIRCR" register description in the Arm "Cortex M4 Devices Generic
User Guide" for more details regarding priority groups.</p>
<p>The constant Hwi_priGroup is configured within the app.syscfg file using the following syntax:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Hwi = scripting.addModule(<span class="stringliteral">&quot;/family/arm/m3/Hwi&quot;</span>);</div><div class="line">Hwi.priGroup = 0;</div></div><!-- fragment --> 
</div>
</div>
<a id="ae5445292396b94dfc0c40aec35cff08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5445292396b94dfc0c40aec35cff08d">&sect;&nbsp;</a></span>Hwi_numSparseInterrupts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Hwi_numSparseInterrupts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If Hwi.dispatchTableSize is initialized by the user then Hwi.numSparseInterrupts is set to the value of Hwi.dispatchTableSize. </p>
<p>If Hwi.dispatchTableSize is NOT set by the user, the normal intNum-indexed Hwi dispatchTable mechanism is used by the dispatcher to find the corresponding Hwi object.</p>
<p>If Hwi.dispatchTableSize is set by the user, then a RAM-based fixed sized interrupt jump table is generated that contains a repeating pattern of the following 3 word assembly code snippets:</p>
<p>hwiX: ldr r3, hwiObjectX ldr pc, ti_sysbios_family_arm_m3_Hwi_dispatch__I hwiObjectX: .word 0 hwiY: ldr r3, hwiObjectY ldr pc, ti_sysbios_family_arm_m3_Hwi_dispatch__I hwiObjectY: .word 0</p>
<p>Each dispatched interrupt vector is then initialized to point to one of these tuples, and the address of the corresponding Hwi object is written into the hwiObjectX field.</p>
<p>The low level assembly code in Hwi_dispatch__I preserves the value of r3 when it calls Hwi_dispatchC(), which results in the Hwi object being passed as the arg3.</p>
<p>Depending on the boolean value of Hwi_numSparseInterrupts, the dispatcher either uses the value passed in arg3 as the Hwi object, or uses intNum to index into the standard dispatchTable to fetch the Hwi object. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
