<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SYS/BIOS: /home/developer/.conan/data/tirtos/7.03.00.10/library-sb/ga/build/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/kernel/tirtos7/packages/ti/sysbios/utils/Load.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SYS/BIOS
   &#160;<span id="projectnumber">7.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_166a36ee10a8457f2f1d507eafd683e9.html">developer</a></li><li class="navelem"><a class="el" href="dir_ab47aaff52849945b02749b38626f831.html">.conan</a></li><li class="navelem"><a class="el" href="dir_2db58af45ff07475e1865bb6cfecd114.html">data</a></li><li class="navelem"><a class="el" href="dir_73aa28e1938cea8ca02173a6a02bb3cc.html">tirtos</a></li><li class="navelem"><a class="el" href="dir_b92035bd439bf87970152b15ca557739.html">7.03.00.10</a></li><li class="navelem"><a class="el" href="dir_a8aafc4147cd9aeef51c3eea0146f858.html">library-sb</a></li><li class="navelem"><a class="el" href="dir_cd46cd47afafa592114402c4301543d5.html">ga</a></li><li class="navelem"><a class="el" href="dir_2cab851584a752880681e90a2dfd4edd.html">build</a></li><li class="navelem"><a class="el" href="dir_5697d1fa77239cd87167d697b8481edf.html">5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9</a></li><li class="navelem"><a class="el" href="dir_a25849b87dcee5ac6bd91808e0cfd56f.html">kernel</a></li><li class="navelem"><a class="el" href="dir_62fe09a765bfb79fe774e523a5e63239.html">tirtos7</a></li><li class="navelem"><a class="el" href="dir_e3f05480a1de819db6de4292a46ffd2c.html">packages</a></li><li class="navelem"><a class="el" href="dir_c9091c0837bc7d5e21af62b18a8f3d2f.html">ti</a></li><li class="navelem"><a class="el" href="dir_e302b19c208f2b8f03cb96305b4c2fcc.html">sysbios</a></li><li class="navelem"><a class="el" href="dir_927c5ea44575630373cf34efb47165d6.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Load.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Load module reports execution times and load information for threads in a system. </p>
<p>SYS/BIOS manages four distinct levels of execution threads: hardware interrupt service routines, software interrupt routines, tasks, and background idle functions. This module reports execution time and load on a per-task basis, and also provides information globally for hardware interrupt service routines, software interrupt routines and idle functions (in the form of the idle task). It can also report an estimate of the global CPU load.</p>
<p>Execution time is reported in units of Timestamp counts, and load is reported in percentages.</p>
<p>By default, load data is gathered for Task threads. Load_hwiEnabled, Load_swiEnabled and Load_taskEnabled can be used to select which type(s) of threads are monitored. Users can also choose to call <a class="el" href="Load_8h.html#a79957f0f2e49be91a860df0487a41359">Load_getTaskLoad</a>, <a class="el" href="Load_8h.html#a42783c090a69fdc1ca07ccc5ce231753">Load_getGlobalSwiLoad</a>, <a class="el" href="Load_8h.html#ae7e451f1ee13e6e505002138d87f22a3">Load_getGlobalHwiLoad</a> and <a class="el" href="Load_8h.html#a5e6e01fc3b9fdb57adbc8697c760780c">Load_getCPULoad</a> at any time to obtain the statistics at runtime.</p>
<p>The module relies on <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> to be called to compute load and execution times from the time when <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> was last called. This is automatically done for every period specified by Load_windowInMs in an Idle function when Load_updateInIdle is set to true. The time between two calls to <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> is called the benchmark time window.</p>
<p>By passing in a function pointer of type void(*Load_postUpdate)(void) through the Load_postUpdate config parameter, one can specify a Load_postUpdate function that is automatically called by <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> immediately after the statistics have been computed at the end of a benchmark time window. Setting this function allows the user to optionally post-process the thread statistics once and only once per benchmark window.</p>
<p>Advanced users could optionally omit calling <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> in the idle loop by setting Load_updateInIdle to false. They can then call <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> somewhere else (e.g. in a periodic higher priority Task) instead to ensure statistics are computed even when the system is never idle.</p>
<h3>CPU Load Calculation Methods</h3>
<p>The CPU load is computed in three different ways, depending on what threads are monitored, and whether or not Power management is used to idle the CPU when no threads are running.</p>
<p> 
 <B>Task Load Disabled and No Power Management</B>
</p>
<p>The first method of calculating CPU load is used when Task load monitoring is disabled, ie, Load_taskEnabled is false, and Power management is not used. The CPU load is computed as the percentage of time in the benchmark window which was NOT spent in the idle loop. More specifically, the load is computed as follows:</p>
<p>global CPU load = 100 * (1 - (min. time for a trip around idle loop * # times in idle loop)/(benchmark time window) )</p>
<p>Any work done in the idle loop is included in the CPU load - in other words, any time spent in the loop beyond the shortest trip around the idle loop is counted as non-idle time.</p>
<p>This method works fairly well if the timestamp frequency is sufficiently high (for example, if it's equal to the CPU frequency). The CPU load accuracy can also be affected by caching and user idle functions.</p>
<p> 
 <B>Task Load Enabled and No Power Management</B>
</p>
<p>The second method of calculating CPU load is used when Task load monitoring is enabled (Load_taskEnabled = true) and Power management is not used. In this case the CPU load is calculted as</p>
<p>global CPU load = 100 - (Idle task load)</p>
<p>This prevents any discrepancy between the calculated CPU load had we used the first method, and 100 - the Idle task load. If Swi and Hwi load monitoring are not enabled, however, time spent in a Swi or Hwi will be charged to the task in which it ran. This will affect the accuracy of the CPU (and Task) load, but the trade off is more overhead to do the Hwi and Swi load monitoring.</p>
<p> 
 <B>Power Management Enabled</B>
</p>
<p>The Load module is dependent on the timestamp timer, thus the latter must continue to run during idle, in order to accurately measure idle and non-idle time. On platforms where the timestamp timer is halted during sleep (e.g. CC32XX), the Load module can only report correct numbers when power management is disabled. On other platforms where the timer continues to run during sleep, the best way to get CPU load is to make sure that Load_taskEnabled is set to true. Then the CPU load will be calculated as 100 - the idle task load. However, for BIOS in ROM builds, this method will not work, as Task hooks are not allowed. So to use Load for any devices that support BIOS in ROM builds, make sure the ROM build is disabled.</p>
<h3>Caveats</h3>
<ul>
<li>For the module to return accurate load values, the <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> function must be run at least once before the Timestamp count gets to wrap around. This means on a platform with a 32-bit Timestamp frequency that runs at 200 MHz, the function must be called at least once every 21 sec. With faster Timestamp frequencies it would have to be called even more frequently.</li>
<li>If the Load_updateInIdle option is enabled, the module will call <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> periodically according to Load_windowInMs. The latter must be set to a time interval that is below (2^32) * 1000 / (Timestamp Frequency) milliseconds</li>
<li>If the Load_updateInIdle option is disabled, the user is then responsible for calling <a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> more often than the above time interval.</li>
<li>Load values might not add up to 100%. Because the module minimizes its interrupt latency and avoids locking up the system to compute all thread loads at once, each thread's execution time is evaluated separately over its own time window, which could be slightly different to that of another thread.</li>
<li>When disabling monitoring of a thread type of higher priority, the time spent in that thread type will be counted towards time spent in threads of lower priority. E.g. if Load_hwiEnabled and Load_swiEnabled are both false, then time spent in Hwi's and Swi's will be counted towards the Tasks in which the interrupts happened. Thus, for better accuracy, it is best to leave monitoring on for threads of a higher priority relative to the thread type of interest.</li>
<li>When Task load monitoring is not enabled and Power management is not used, the implementation of <a class="el" href="Load_8h.html#a5e6e01fc3b9fdb57adbc8697c760780c">Load_getCPULoad()</a> self-calibrates the shortest path through the idle loop. It does this by keeping track of the shortest time between invocations of an idle function automatically inserted by the Load module, and assumes that to be the time it takes for one iteration through the idle loop. Because of this, the CPU load value is only an estimate since the idle loop might occasionally take longer to run (e.g. due to caching effects, stalls). The reported CPU load tends to be slightly higher than reality, especially when the load is low.</li>
<li>Currently does not support Timestamp frequencies over 4 GHz.</li>
</ul>
<p> 
 <h3> Calling Context </h3>
 <table border="1" cellpadding="3">
   <colgroup span="1"></colgroup> <colgroup span="5" align="center">
   </colgroup>

   <tr><th> Function                 </th><th>  Hwi   </th><th>  Swi   </th>
   <th>  Task  </th><th>  Main  </th><th>  Startup  </th></tr>
   <!--                                                          -->
   <tr><td> getCPULoad      </td><td>   Y    </td><td>   Y    </td>
   <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> getGlobalHwiLoad</td><td>   Y    </td><td>   Y    </td>
   <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> getGlobalSwiLoad</td><td>   Y    </td><td>   Y    </td>
   <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> getTaskLoad     </td><td>   Y    </td><td>   Y    </td>
   <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> reset           </td><td>   Y*   </td><td>   Y*   </td>
   <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> update          </td><td>   Y*   </td><td>   Y*   </td>
   <td>   Y    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td colspan="6"> Definitions: <br />
      <ul>
        <li> <b>Hwi</b>: API is callable from a Hwi thread. </li>
        <li> <b>Swi</b>: API is callable from a Swi thread. </li>
        <li> <b>Task</b>: API is callable from a Task thread. </li>
        <li> <b>Main</b>: API is callable during any of these phases: </li>
          <ul>
            <li> In your module startup after this module is started
   (e.g. Load_Module_startupDone() returns true). </li>
            <li> During xdc.runtime.Startup.lastFxns. </li>
            <li> During main().</li>
            <li> During BIOS.startupFxns.</li>
          </ul>
        <li> <b>Startup</b>: API is callable during any of these phases:</li>
          <ul>
            <li> During xdc.runtime.Startup.firstFxns.</li>
            <li> In your module startup before this module is started
   (e.g. Load_Module_startupDone() returns false).</li>
          </ul>
      <li> <b>*</b>: Indicates only when taskEnabled
   is set to false. </li>
      </ul>
   </td></tr>
 </table>
 </p>
</div><div class="textblock"><code>#include &lt;xdc/std.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Queue_8h_source.html">ti/sysbios/knl/Queue.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Task_8h_source.html">ti/sysbios/knl/Task.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="hal_2Hwi_8h_source.html">ti/sysbios/hal/Hwi.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Error_8h_source.html">ti/sysbios/runtime/Error.h</a>&gt;</code><br />
<code>#include &quot;Load_defs.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Load.h:</div>
<div class="dyncontent">
<div class="center"><img src="Load_8h__incl.png" border="0" usemap="#_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2utils_2Load_8h" alt=""/></div>
<map name="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2utils_2Load_8h" id="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2utils_2Load_8h">
<area shape="rect" id="node6" href="Queue_8h.html" title="Queue Manager. " alt="" coords="297,370,463,397"/>
<area shape="rect" id="node7" href="Error_8h.html" title="Runtime error manager. " alt="" coords="499,452,637,493"/>
<area shape="rect" id="node8" href="Task_8h.html" title="Task Manager. " alt="" coords="575,124,729,151"/>
<area shape="rect" id="node13" href="hal_2Hwi_8h.html" title="Hwi header file for the HAL. " alt="" coords="985,370,1135,397"/>
<area shape="rect" id="node9" href="Clock_8h.html" title="System Clock Manager. " alt="" coords="404,199,564,225"/>
<area shape="rect" id="node11" href="IHeap_8h.html" title="Interface to heap functions. " alt="" coords="817,273,956,315"/>
<area shape="rect" id="node10" href="Swi_8h.html" title="Software Interrupt Manager. " alt="" coords="417,281,564,307"/>
<area shape="rect" id="node12" href="Memory_8h.html" title="Static and run&#45;time memory manager. " alt="" coords="817,363,956,404"/>
<area shape="rect" id="node14" href="Types_8h.html" title="Basic constants and types. " alt="" coords="813,452,952,493"/>
</map>
</div>
</div>
<p><a href="Load_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoad__Stat.html">Load_Stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load statistics info.  <a href="structLoad__Stat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoad__Module__State.html">Load_Module_State</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acc4f67887d1f6f97950f7c5c94231179"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#acc4f67887d1f6f97950f7c5c94231179">ti_sysbios_utils_Load_long_names</a></td></tr>
<tr class="separator:acc4f67887d1f6f97950f7c5c94231179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e7767b4c9e52ce440e4df39e63d65b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#a05e7767b4c9e52ce440e4df39e63d65b">Load_module</a>&#160;&#160;&#160;((<a class="el" href="structLoad__Module__State.html">Load_Module_State</a> *) &amp;(Load_Module_state))</td></tr>
<tr class="separator:a05e7767b4c9e52ce440e4df39e63d65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac1cee465aa94da30c75b2ad821b6f7d4"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#ac1cee465aa94da30c75b2ad821b6f7d4">Load_FuncPtr</a>) (void)</td></tr>
<tr class="memdesc:ac1cee465aa94da30c75b2ad821b6f7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type.  <a href="#ac1cee465aa94da30c75b2ad821b6f7d4">More...</a><br /></td></tr>
<tr class="separator:ac1cee465aa94da30c75b2ad821b6f7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9d29266f011280a25c735783c5ddd281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#a9d29266f011280a25c735783c5ddd281">Load_init</a> (void)</td></tr>
<tr class="separator:a9d29266f011280a25c735783c5ddd281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79957f0f2e49be91a860df0487a41359"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#a79957f0f2e49be91a860df0487a41359">Load_getTaskLoad</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, <a class="el" href="structLoad__Stat.html">Load_Stat</a> *stat)</td></tr>
<tr class="memdesc:a79957f0f2e49be91a860df0487a41359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the load and time spent in a specific task.  <a href="#a79957f0f2e49be91a860df0487a41359">More...</a><br /></td></tr>
<tr class="separator:a79957f0f2e49be91a860df0487a41359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7595962810bba35be8ea3287af05d29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#aa7595962810bba35be8ea3287af05d29">Load_update</a> ()</td></tr>
<tr class="memdesc:aa7595962810bba35be8ea3287af05d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record thread statistics and reset all counters.  <a href="#aa7595962810bba35be8ea3287af05d29">More...</a><br /></td></tr>
<tr class="separator:aa7595962810bba35be8ea3287af05d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace66e195e66ab810cb5a3f2a49c58abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#ace66e195e66ab810cb5a3f2a49c58abf">Load_reset</a> ()</td></tr>
<tr class="memdesc:ace66e195e66ab810cb5a3f2a49c58abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all internal load counters.  <a href="#ace66e195e66ab810cb5a3f2a49c58abf">More...</a><br /></td></tr>
<tr class="separator:ace66e195e66ab810cb5a3f2a49c58abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42783c090a69fdc1ca07ccc5ce231753"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#a42783c090a69fdc1ca07ccc5ce231753">Load_getGlobalSwiLoad</a> (<a class="el" href="structLoad__Stat.html">Load_Stat</a> *stat)</td></tr>
<tr class="memdesc:a42783c090a69fdc1ca07ccc5ce231753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the load and time spent in Swi's.  <a href="#a42783c090a69fdc1ca07ccc5ce231753">More...</a><br /></td></tr>
<tr class="separator:a42783c090a69fdc1ca07ccc5ce231753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e451f1ee13e6e505002138d87f22a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#ae7e451f1ee13e6e505002138d87f22a3">Load_getGlobalHwiLoad</a> (<a class="el" href="structLoad__Stat.html">Load_Stat</a> *stat)</td></tr>
<tr class="memdesc:ae7e451f1ee13e6e505002138d87f22a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the load and time spent in hwi's.  <a href="#ae7e451f1ee13e6e505002138d87f22a3">More...</a><br /></td></tr>
<tr class="separator:ae7e451f1ee13e6e505002138d87f22a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6e01fc3b9fdb57adbc8697c760780c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#a5e6e01fc3b9fdb57adbc8697c760780c">Load_getCPULoad</a> ()</td></tr>
<tr class="memdesc:a5e6e01fc3b9fdb57adbc8697c760780c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an estimate of the global CPU load.  <a href="#a5e6e01fc3b9fdb57adbc8697c760780c">More...</a><br /></td></tr>
<tr class="separator:a5e6e01fc3b9fdb57adbc8697c760780c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea922d5682edb0288322e4f9c3f98a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#a5ea922d5682edb0288322e4f9c3f98a9">Load_calculateLoad</a> (<a class="el" href="structLoad__Stat.html">Load_Stat</a> *stat)</td></tr>
<tr class="memdesc:a5ea922d5682edb0288322e4f9c3f98a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total CPU load from a <a class="el" href="structLoad__Stat.html" title="Load statistics info. ">Load_Stat</a> structure.  <a href="#a5ea922d5682edb0288322e4f9c3f98a9">More...</a><br /></td></tr>
<tr class="separator:a5ea922d5682edb0288322e4f9c3f98a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bc5be3adcb059baea4d0ce0af28482"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#ab6bc5be3adcb059baea4d0ce0af28482">Load_setMinIdle</a> (uint32_t newMinIdleTime)</td></tr>
<tr class="memdesc:ab6bc5be3adcb059baea4d0ce0af28482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lower bound on idle loop time used to compute CPU load.  <a href="#ab6bc5be3adcb059baea4d0ce0af28482">More...</a><br /></td></tr>
<tr class="separator:ab6bc5be3adcb059baea4d0ce0af28482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167d1386b6e386e5a5110b1a8b8e4d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#a167d1386b6e386e5a5110b1a8b8e4d5c">Load_addTask</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> task, Load_HookContext *env)</td></tr>
<tr class="memdesc:a167d1386b6e386e5a5110b1a8b8e4d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the list for benchmarking.  <a href="#a167d1386b6e386e5a5110b1a8b8e4d5c">More...</a><br /></td></tr>
<tr class="separator:a167d1386b6e386e5a5110b1a8b8e4d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5af24a33fcf9f00f197c5ab72ed2fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Load_8h.html#a6c5af24a33fcf9f00f197c5ab72ed2fb">Load_removeTask</a> (<a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a> taskHandle)</td></tr>
<tr class="memdesc:a6c5af24a33fcf9f00f197c5ab72ed2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a task from the list for benchmarking.  <a href="#a6c5af24a33fcf9f00f197c5ab72ed2fb">More...</a><br /></td></tr>
<tr class="separator:a6c5af24a33fcf9f00f197c5ab72ed2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="acc4f67887d1f6f97950f7c5c94231179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4f67887d1f6f97950f7c5c94231179">&sect;&nbsp;</a></span>ti_sysbios_utils_Load_long_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ti_sysbios_utils_Load_long_names</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05e7767b4c9e52ce440e4df39e63d65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e7767b4c9e52ce440e4df39e63d65b">&sect;&nbsp;</a></span>Load_module</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Load_module&#160;&#160;&#160;((<a class="el" href="structLoad__Module__State.html">Load_Module_State</a> *) &amp;(Load_Module_state))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac1cee465aa94da30c75b2ad821b6f7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cee465aa94da30c75b2ad821b6f7d4">&sect;&nbsp;</a></span>Load_FuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Load_FuncPtr) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9d29266f011280a25c735783c5ddd281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d29266f011280a25c735783c5ddd281">&sect;&nbsp;</a></span>Load_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Load_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79957f0f2e49be91a860df0487a41359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79957f0f2e49be91a860df0487a41359">&sect;&nbsp;</a></span>Load_getTaskLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Load_getTaskLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoad__Stat.html">Load_Stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the load and time spent in a specific task. </p>
<p>This function returns the load and time spent in a specific task along with the duration over which the measurement was done. Numbers are reported in Timestamp counts.</p>
<p>Task handle must be valid and have been registered with Load.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Handle of the Task which time we are interested in.</td></tr>
    <tr><td class="paramname">stat</td><td>Load and time statistics info</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if success, false if failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7595962810bba35be8ea3287af05d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7595962810bba35be8ea3287af05d29">&sect;&nbsp;</a></span>Load_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Load_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record thread statistics and reset all counters. </p>
<p>If Load_taskEnabled is set to true, this function can only be called in task context. </p>

</div>
</div>
<a id="ace66e195e66ab810cb5a3f2a49c58abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace66e195e66ab810cb5a3f2a49c58abf">&sect;&nbsp;</a></span>Load_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Load_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all internal load counters. </p>
<p>If Load_taskEnabled is set to true, this function can only be called in task context. </p>

</div>
</div>
<a id="a42783c090a69fdc1ca07ccc5ce231753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42783c090a69fdc1ca07ccc5ce231753">&sect;&nbsp;</a></span>Load_getGlobalSwiLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Load_getGlobalSwiLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoad__Stat.html">Load_Stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the load and time spent in Swi's. </p>
<p>This function returns the load and time spent in Swi's along with the time duration over which the measurement was done. Numbers are reported in Timestamp counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stat</td><td>Load and time statistics info</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if success, false if failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e451f1ee13e6e505002138d87f22a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e451f1ee13e6e505002138d87f22a3">&sect;&nbsp;</a></span>Load_getGlobalHwiLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Load_getGlobalHwiLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoad__Stat.html">Load_Stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the load and time spent in hwi's. </p>
<p>This function computes the load and time spent in Hwi's along with the time duration over which the measurement was done. Numbers are reported in Timestamp counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stat</td><td>Load and time statistics info</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if success, false if failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e6e01fc3b9fdb57adbc8697c760780c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6e01fc3b9fdb57adbc8697c760780c">&sect;&nbsp;</a></span>Load_getCPULoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Load_getCPULoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an estimate of the global CPU load. </p>
<p>This function returns an estimate of CPU load (% utilization of the CPU), with the idle time determined based on number of trips through the idle loop multiplied by the shortest amount of time through the loop.</p>
<p>This function requires the idle loop to be run during a benchmark time window.</p>
<p>Note: Time spent in kernel while switching to a Hwi/Swi/Task is considered non-idle time.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CPU</td><td>load in % </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ea922d5682edb0288322e4f9c3f98a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea922d5682edb0288322e4f9c3f98a9">&sect;&nbsp;</a></span>Load_calculateLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Load_calculateLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoad__Stat.html">Load_Stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute total CPU load from a <a class="el" href="structLoad__Stat.html" title="Load statistics info. ">Load_Stat</a> structure. </p>
<p>This function computes percent load from the values in a <a class="el" href="structLoad__Stat.html" title="Load statistics info. ">Load_Stat</a> structure.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Load</td><td>value of a <a class="el" href="structLoad__Stat.html" title="Load statistics info. ">Load_Stat</a> structure in %. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6bc5be3adcb059baea4d0ce0af28482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bc5be3adcb059baea4d0ce0af28482">&sect;&nbsp;</a></span>Load_setMinIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Load_setMinIdle </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>newMinIdleTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set lower bound on idle loop time used to compute CPU load. </p>
<dl class="section see"><dt>See also</dt><dd>Load_minIdle </dd></dl>

</div>
</div>
<a id="a167d1386b6e386e5a5110b1a8b8e4d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167d1386b6e386e5a5110b1a8b8e4d5c">&sect;&nbsp;</a></span>Load_addTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Load_addTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Load_HookContext *&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task to the list for benchmarking. </p>
<p>If Load_taskEnabled is set to true, this function can only be called in task context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Handle of the Task to be added to the list.</td></tr>
    <tr><td class="paramname">env</td><td>Handle of context structure to be used by the Task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c5af24a33fcf9f00f197c5ab72ed2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5af24a33fcf9f00f197c5ab72ed2fb">&sect;&nbsp;</a></span>Load_removeTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Load_removeTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Task_8h.html#a7ecb0ef0b5985fed33489e317badab80">Task_Handle</a>&#160;</td>
          <td class="paramname"><em>taskHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a task from the list for benchmarking. </p>
<p>If Load_taskEnabled is set to true, this funciton can only be called in task context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskHandle</td><td>Handle of the Task to be removed from the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
