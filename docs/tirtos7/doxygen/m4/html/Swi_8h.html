<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SYS/BIOS: /home/developer/.conan/data/tirtos/7.03.00.10/library-sb/ga/build/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/kernel/tirtos7/packages/ti/sysbios/knl/Swi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SYS/BIOS
   &#160;<span id="projectnumber">7.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_166a36ee10a8457f2f1d507eafd683e9.html">developer</a></li><li class="navelem"><a class="el" href="dir_ab47aaff52849945b02749b38626f831.html">.conan</a></li><li class="navelem"><a class="el" href="dir_2db58af45ff07475e1865bb6cfecd114.html">data</a></li><li class="navelem"><a class="el" href="dir_73aa28e1938cea8ca02173a6a02bb3cc.html">tirtos</a></li><li class="navelem"><a class="el" href="dir_b92035bd439bf87970152b15ca557739.html">7.03.00.10</a></li><li class="navelem"><a class="el" href="dir_a8aafc4147cd9aeef51c3eea0146f858.html">library-sb</a></li><li class="navelem"><a class="el" href="dir_cd46cd47afafa592114402c4301543d5.html">ga</a></li><li class="navelem"><a class="el" href="dir_2cab851584a752880681e90a2dfd4edd.html">build</a></li><li class="navelem"><a class="el" href="dir_5697d1fa77239cd87167d697b8481edf.html">5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9</a></li><li class="navelem"><a class="el" href="dir_a25849b87dcee5ac6bd91808e0cfd56f.html">kernel</a></li><li class="navelem"><a class="el" href="dir_62fe09a765bfb79fe774e523a5e63239.html">tirtos7</a></li><li class="navelem"><a class="el" href="dir_e3f05480a1de819db6de4292a46ffd2c.html">packages</a></li><li class="navelem"><a class="el" href="dir_c9091c0837bc7d5e21af62b18a8f3d2f.html">ti</a></li><li class="navelem"><a class="el" href="dir_e302b19c208f2b8f03cb96305b4c2fcc.html">sysbios</a></li><li class="navelem"><a class="el" href="dir_12d1e7e42787b42b41dd49f4db30667e.html">knl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Swi.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Software Interrupt Manager. </p>
<p>The Swi module manages software interrupt service routines, which are patterned after hardware interrupt service routines.</p>
<p>SYS/BIOS manages four distinct levels of execution threads: hardware interrupt service routines, software interrupt routines, tasks, and background idle functions. A software interrupt is an object that encapsulates a function to be executed and a priority. Software interrupts are prioritized, preempt tasks, and are preempted by hardware interrupt service routines.</p>
<p>Each software interrupt has a priority level. A software interrupt preempts any lower-priority software interrupt currently executing.</p>
<p>A target program uses an API call to post a Swi object. This causes the Swi module to schedule execution of the software interrupt's function. When a Swi is posted by an API call, the Swi object's function is not executed immediately. Instead, the function is scheduled for execution. SYS/BIOS uses the Swi's priority to determine whether to preempt the thread currently running. Note that if a Swi is posted several times before it begins running, (because Hwis and higher priority interrupts are running), when the Swi does eventually run, it will run only one time.</p>
<p>Software interrupts can be posted for execution with a call to <a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a> or a number of other Swi functions. Each Swi object has a "trigger" which is used either to determine whether to post the Swi or as a value that can be evaluated within the Swi's function. <a class="el" href="Swi_8h.html#a1ec78b937fe01567443697c7b3e8ec91">Swi_andn</a> and <a class="el" href="Swi_8h.html#a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef">Swi_dec</a> post the Swi if the trigger value transitions to 0. <a class="el" href="Swi_8h.html#ac9029bcc3f494baf782db5618a5c99af">Swi_or</a> and <a class="el" href="Swi_8h.html#a7ea8110315b5e5f59db73ef212b39a92">Swi_inc</a> also modify the trigger value. (<a class="el" href="Swi_8h.html#ac9029bcc3f494baf782db5618a5c99af">Swi_or</a> sets bits, and <a class="el" href="Swi_8h.html#a1ec78b937fe01567443697c7b3e8ec91">Swi_andn</a> clears bits.)</p>
<p>The <a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a> and <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7">Swi_restore</a> operations allow you to post several Swis and enable them all for execution at the same time. The Swi priorities then determine which Swi runs first.</p>
<p>All Swis run to completion; you cannot suspend a Swi while it waits for something (for example, a device) to be ready. So, you can use the trigger to tell the Swi when all the devices and other conditions it relies on are ready. Within a Swi processing function, a call to Swi_getTrigger returns the value of the trigger when the Swi started running. Note that the trigger is automatically reset to its original value when a Swi runs; however, <a class="el" href="Swi_8h.html#a5c9650a82dbc9bc2afd43b4da4659458">Swi_getTrigger</a> will return the saved trigger value from when the Swi started execution.</p>
<p>All Swis run with interrupts globally enabled (ie GIE = 1). Therefore, any Swi module API that results in a Swi being made ready to run (ie <a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a>, <a class="el" href="Swi_8h.html#a7ea8110315b5e5f59db73ef212b39a92">Swi_inc</a>, <a class="el" href="Swi_8h.html#a1ec78b937fe01567443697c7b3e8ec91">Swi_andn</a>, <a class="el" href="Swi_8h.html#ac9029bcc3f494baf782db5618a5c99af">Swi_or</a>, or <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7">Swi_restore</a>) will subsequently also cause interrupts to be enabled while the Swi function executes. Upon return from the Swi function, global interrupts are restored to their previous enabled/disabled state.</p>
<p>A Swi preempts any currently running Swi with a lower priority. When multiple Swis of the same priority level have been posted, their respective Swi functions are executed in the order the Swis were posted. Hwis in turn preempt any currently running Swi, allowing the target to respond quickly to hardware peripherals.</p>
<p>Swi threads are executed using the ISR (or "Hwi") stack. Thus they share the ISR stack with Hwi threads.</p>
<p>To use the Swi module or to set any of the Swi module configuration variables, the following must be added to the app.syscfg file:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Swi = scripting.addModule(<span class="stringliteral">&quot;/ti/sysbios/knl/Swi&quot;</span>);</div></div><!-- fragment --><p><a class="anchor" id="SwiHookFunctions"></a> <b>Hook Functions</b></p>
<p>Sets of hook functions can be specified for the Swi module. Each set contains these hook functions:</p>
<ul>
<li>Register: A function called before all statically-created Swis are initialized at runtime.</li>
<li>Create: A function that is called when a Swi is created. This includes Swis that are created statically and those created dynamically using <a class="el" href="Swi_8h.html#a5d383d9dee6303634644df22420d8240">Swi_create</a>.</li>
<li>Ready: A function that is called when any Swi becomes ready to run.</li>
<li>Begin: A function that is called just prior to running a Swi.</li>
<li>End: A function that is called just after a Swi finishes.</li>
<li>Delete: A function that is called when a Swi is deleted at run-time with Swi_delete.</li>
</ul>
<p>Hook functions can only be configured statically.</p>
<p>If you define more than one set of hook functions, all the functions of a particular type will be run when a Swi triggers that type of hook.</p>
<p>To add a Swi hook or set of Swi hooks, the following syntax is used in the app.syscfg file:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Swi = scripting.addModule(<span class="stringliteral">&quot;/ti/sysbios/knl/Swi&quot;</span>);</div><div class="line">Swi.swiHooks[0].registerFxn = <span class="stringliteral">&quot;myRegisterFxn&quot;</span>;</div><div class="line">Swi.swiHooks[0].createFxn   = <span class="stringliteral">&quot;myCreateFxn&quot;</span>;</div><div class="line">Swi.swiHooks[0].readyFxn    = <span class="stringliteral">&quot;myrReadyFxn&quot;</span>;</div><div class="line">Swi.swiHooks[0].beginFxn    = <span class="stringliteral">&quot;myBeginFxn&quot;</span>;</div><div class="line">Swi.swiHooks[0].endFxn      = <span class="stringliteral">&quot;myEndFxn&quot;</span>;</div><div class="line">Swi.swiHooks[0].deleteFxn   = <span class="stringliteral">&quot;myDeleteFxn&quot;</span>;</div></div><!-- fragment --><p>Leaving a subset of the hook functions undefined is ok.</p>
<p><b>Register Function</b></p>
<p>The Register function is provided to allow a hook set to store its hookset ID. This id can be passed to <a class="el" href="Swi_8h.html#af57241f2b7cbec3d63463379478a6aee">Swi_setHookContext</a> and <a class="el" href="Swi_8h.html#a723a695304a3a3d847ba81c547639f10">Swi_getHookContext</a> to set or get hookset-specific context. The Register function must be specified if the hook implementation needs to use <a class="el" href="Swi_8h.html#af57241f2b7cbec3d63463379478a6aee">Swi_setHookContext</a> or <a class="el" href="Swi_8h.html#a723a695304a3a3d847ba81c547639f10">Swi_getHookContext</a>. The registerFxn hook function is called during system initialization before interrupts have been enabled.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myRegisterFxn(<span class="keywordtype">int</span> <span class="keywordtype">id</span>);</div></div><!-- fragment --><p><b>Create and Delete Functions</b></p>
<p>The create and delete functions are called whenever a Swi is created or deleted. They are called with interrupts enabled (unless called at boot time or from main()).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myCreateFxn(<a class="code" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, <a class="code" href="structError__Block.html">Error_Block</a> *eb);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> myDeleteFxn(<a class="code" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi);</div></div><!-- fragment --><p> 
 <b>Ready, Begin, and End Functions</b>
</p>
<p>The ready, begin and end functions are all called with interrupts enabled. The ready function is called when a Swi is posted and made ready to run. The begin function is called right before the function associated with the given Swi is run. The end function is called right after this function returns.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myReady(<a class="code" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> myBegin(<a class="code" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> myEnd(<a class="code" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi);</div></div><!-- fragment --><p> 
 <h3> Calling Context </h3>
 <table border="1" cellpadding="3">
   <colgroup span="1"></colgroup> <colgroup span="5" align="center">
 </colgroup>

   <tr><th> Function                 </th><th>  Hwi   </th><th>  Swi   </th>
 <th>  Task  </th><th>  Main  </th><th>  Startup  </th></tr>
   <!--                                             -->
   <tr><td> Swi_create          </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_disable         </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_getTrigger      </td><td>   Y    </td><td>   Y    </td>
 <td>   N    </td><td>   N    </td><td>   N    </td></tr>
   <tr><td> Swi_Params_init     </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   Y    </td></tr>
   <tr><td> Swi_restore         </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_self            </td><td>   Y    </td><td>   Y    </td>
 <td>   N    </td><td>   N    </td><td>   N    </td></tr>

   <tr><td> Swi_andn            </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_construct       </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_dec             </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_delete          </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_destruct        </td><td>   N    </td><td>   N    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_getAttrs        </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_getFunc         </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_getHookContext  </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_getPri          </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_inc             </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_or              </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_post            </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_setAttrs        </td><td>   Y*   </td><td>   Y*   </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td> Swi_setHookContext  </td><td>   Y    </td><td>   Y    </td>
 <td>   Y    </td><td>   Y    </td><td>   N    </td></tr>
   <tr><td colspan="6"> Definitions: <br />
      <ul>
        <li> <b>Hwi</b>: API is callable from a Hwi thread. </li>
        <li> <b>Swi</b>: API is callable from a Swi thread. </li>
        <li> <b>Task</b>: API is callable from a Task thread. </li>
        <li> <b>Main</b>: API is callable during any of these phases: </li>
          <ul>
            <li> In your module startup after this module is started
   (e.g. after Swi_init() has been called). </li>
            <li> During xdc.runtime.Startup.lastFxns. </li>
            <li> During main().</li>
            <li> During BIOS.startupFxns.</li>
          </ul>
        <li> <b>Startup</b>: API is callable during any of these phases:</li>
          <ul>
            <li> During xdc.runtime.Startup.firstFxns.</li>
            <li> In your module startup before this module is started
   (e.g. before Swi_init() has been called). </li>
          </ul>
      </ul>
   </td></tr>

 </table>
 </p>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Queue_8h_source.html">ti/sysbios/knl/Queue.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Error_8h_source.html">ti/sysbios/runtime/Error.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Swi.h:</div>
<div class="dyncontent">
<div class="center"><img src="Swi_8h__incl.png" border="0" usemap="#_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Swi_8h" alt=""/></div>
<map name="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Swi_8h" id="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Swi_8h">
<area shape="rect" id="node5" href="Queue_8h.html" title="Queue Manager. " alt="" coords="64,124,231,151"/>
<area shape="rect" id="node6" href="Error_8h.html" title="Runtime error manager. " alt="" coords="129,199,267,240"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="Swi_8h__dep__incl.png" border="0" usemap="#_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Swi_8hdep" alt=""/></div>
<map name="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Swi_8hdep" id="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2knl_2Swi_8hdep">
<area shape="rect" id="node2" href="GateSwi_8h.html" title="Software Interrupt Gate. " alt="" coords="139,124,593,195"/>
<area shape="rect" id="node3" href="Clock_8h.html" title="System Clock Manager. " alt="" coords="617,124,1070,195"/>
<area shape="rect" id="node4" href="Semaphore_8h.html" title="Semaphore Manager. " alt="" coords="773,480,1226,551"/>
<area shape="rect" id="node8" href="Task_8h.html" title="Task Manager. " alt="" coords="1226,243,1679,313"/>
<area shape="rect" id="node5" href="GateMutex_8h.html" title="Mutex Gate. " alt="" coords="1409,599,1862,669"/>
<area shape="rect" id="node6" href="GateMutexPri_8h.html" title="Mutex Gate with priority inheritance. " alt="" coords="879,599,1333,669"/>
<area shape="rect" id="node7" href="Mailbox_8h.html" title="Mailbox Manager. " alt="" coords="297,599,750,669"/>
<area shape="rect" id="node9" href="GateTask_8h.html" title="Software Interrupt Gate. " alt="" coords="510,361,963,432"/>
<area shape="rect" id="node10" href="HeapTrack_8h.html" title="Heap manager that enables tracking of all allocated blocks. " alt="" coords="987,361,1441,432"/>
<area shape="rect" id="node11" href="Event_8h.html" title="Event Manager. " alt="" coords="33,361,486,432"/>
<area shape="rect" id="node12" href="Load_8h.html" title="The Load module reports execution times and load information for threads in a system. " alt="" coords="1465,361,1918,432"/>
</map>
</div>
</div>
<p><a href="Swi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSwi__HookSet.html">Swi_HookSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swi hook set type definition.  <a href="structSwi__HookSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSwi__Hook.html">Swi_Hook</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSwi__Params.html">Swi_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a96b79cda304a62695c167da840c07e43"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a96b79cda304a62695c167da840c07e43">Swi_A_swiDisabled</a>&#160;&#160;&#160;&quot;cannot create a SWI when Swi is disabled&quot;</td></tr>
<tr class="memdesc:a96b79cda304a62695c167da840c07e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertion raised if Swi_create is called and runtime Swi creation is disabled.  <a href="#a96b79cda304a62695c167da840c07e43">More...</a><br /></td></tr>
<tr class="separator:a96b79cda304a62695c167da840c07e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530c8a3661b8d996397285c861b9dce1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a530c8a3661b8d996397285c861b9dce1">Swi_A_badPriority</a>&#160;&#160;&#160;&quot;invalid priority&quot;</td></tr>
<tr class="memdesc:a530c8a3661b8d996397285c861b9dce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertion raised if a Swi's priority is out of range.  <a href="#a530c8a3661b8d996397285c861b9dce1">More...</a><br /></td></tr>
<tr class="separator:a530c8a3661b8d996397285c861b9dce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abf0c6286dd02ecf7446982f04c5fc9e1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a></td></tr>
<tr class="separator:abf0c6286dd02ecf7446982f04c5fc9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607e03a52277d34b4cf2e81b2cf847a4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a607e03a52277d34b4cf2e81b2cf847a4">Swi_Object</a></td></tr>
<tr class="separator:a607e03a52277d34b4cf2e81b2cf847a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60137d6a9b1895c46c58b744c953cdf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a></td></tr>
<tr class="separator:ad60137d6a9b1895c46c58b744c953cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b0ddc74846755e0921aa045300d979"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a12b0ddc74846755e0921aa045300d979">Swi_Instance</a></td></tr>
<tr class="separator:a12b0ddc74846755e0921aa045300d979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76db51e920707c0f17c8b86958a8721d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSwi__HookSet.html">Swi_HookSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a76db51e920707c0f17c8b86958a8721d">Swi_HookSet</a></td></tr>
<tr class="memdesc:a76db51e920707c0f17c8b86958a8721d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swi hook set type definition.  <a href="#a76db51e920707c0f17c8b86958a8721d">More...</a><br /></td></tr>
<tr class="separator:a76db51e920707c0f17c8b86958a8721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1554f30966a5e84e41b20893d5486d77"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSwi__Params.html">Swi_Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a1554f30966a5e84e41b20893d5486d77">Swi_Params</a></td></tr>
<tr class="separator:a1554f30966a5e84e41b20893d5486d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbdfa08fc08fb7fb9fc9f0a300b7906"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a>) (uintptr_t arg1, uintptr_t arg2)</td></tr>
<tr class="memdesc:a8fbdfa08fc08fb7fb9fc9f0a300b7906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swi function type definition.  <a href="#a8fbdfa08fc08fb7fb9fc9f0a300b7906">More...</a><br /></td></tr>
<tr class="separator:a8fbdfa08fc08fb7fb9fc9f0a300b7906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d383d9dee6303634644df22420d8240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a5d383d9dee6303634644df22420d8240">Swi_create</a> (<a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a> swiFxn, const <a class="el" href="structSwi__Params.html">Swi_Params</a> *prms, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:a5d383d9dee6303634644df22420d8240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a software interrupt.  <a href="#a5d383d9dee6303634644df22420d8240">More...</a><br /></td></tr>
<tr class="separator:a5d383d9dee6303634644df22420d8240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44cc513c66964ded18b55085c922329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#ae44cc513c66964ded18b55085c922329">Swi_construct</a> (<a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a> *obj, <a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a> swiFxn, const <a class="el" href="structSwi__Params.html">Swi_Params</a> *prms, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:ae44cc513c66964ded18b55085c922329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a software interrupt.  <a href="#ae44cc513c66964ded18b55085c922329">More...</a><br /></td></tr>
<tr class="separator:ae44cc513c66964ded18b55085c922329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add50495a56db35894456d0b74bf7d4bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#add50495a56db35894456d0b74bf7d4bf">Swi_delete</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> *swi)</td></tr>
<tr class="memdesc:add50495a56db35894456d0b74bf7d4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a software interrupt.  <a href="#add50495a56db35894456d0b74bf7d4bf">More...</a><br /></td></tr>
<tr class="separator:add50495a56db35894456d0b74bf7d4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0bb8b75d1d8f8e51be73f87b5875ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#acd0bb8b75d1d8f8e51be73f87b5875ad">Swi_destruct</a> (<a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a> *obj)</td></tr>
<tr class="memdesc:acd0bb8b75d1d8f8e51be73f87b5875ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a software interrupt.  <a href="#acd0bb8b75d1d8f8e51be73f87b5875ad">More...</a><br /></td></tr>
<tr class="separator:acd0bb8b75d1d8f8e51be73f87b5875ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f68ac1fa18fdc0c4079cee1187c13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a48f68ac1fa18fdc0c4079cee1187c13b">Swi_Params_init</a> (<a class="el" href="structSwi__Params.html">Swi_Params</a> *prms)</td></tr>
<tr class="memdesc:a48f68ac1fa18fdc0c4079cee1187c13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="structSwi__Params.html">Swi_Params</a> structure with default values.  <a href="#a48f68ac1fa18fdc0c4079cee1187c13b">More...</a><br /></td></tr>
<tr class="separator:a48f68ac1fa18fdc0c4079cee1187c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c49451a0cb3b2b52441a936f76d46c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#ad1c49451a0cb3b2b52441a936f76d46c">Swi_Object_first</a> (void)</td></tr>
<tr class="memdesc:ad1c49451a0cb3b2b52441a936f76d46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return handle of the first Swi on Swi list  <a href="#ad1c49451a0cb3b2b52441a936f76d46c">More...</a><br /></td></tr>
<tr class="separator:ad1c49451a0cb3b2b52441a936f76d46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c08197cf3f7da73a2f0b85cbca7b20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#aa6c08197cf3f7da73a2f0b85cbca7b20">Swi_Object_next</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi)</td></tr>
<tr class="memdesc:aa6c08197cf3f7da73a2f0b85cbca7b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">return handle of the next Swi on Swi list  <a href="#aa6c08197cf3f7da73a2f0b85cbca7b20">More...</a><br /></td></tr>
<tr class="separator:aa6c08197cf3f7da73a2f0b85cbca7b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea393af9fc565d3e68f2ebedae52a1b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a> (void)</td></tr>
<tr class="memdesc:a1ea393af9fc565d3e68f2ebedae52a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Swi Scheduling.  <a href="#a1ea393af9fc565d3e68f2ebedae52a1b">More...</a><br /></td></tr>
<tr class="separator:a1ea393af9fc565d3e68f2ebedae52a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade083f6ae10ef3952ccb60ca0fb6f6b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7">Swi_restore</a> (unsigned int key)</td></tr>
<tr class="memdesc:ade083f6ae10ef3952ccb60ca0fb6f6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore Swi Scheduling state.  <a href="#ade083f6ae10ef3952ccb60ca0fb6f6b7">More...</a><br /></td></tr>
<tr class="separator:ade083f6ae10ef3952ccb60ca0fb6f6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4309389ad7bcb94d7b511e94c2937b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a4309389ad7bcb94d7b511e94c2937b53">Swi_self</a> (void)</td></tr>
<tr class="memdesc:a4309389ad7bcb94d7b511e94c2937b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return address of currently executing Swi object.  <a href="#a4309389ad7bcb94d7b511e94c2937b53">More...</a><br /></td></tr>
<tr class="separator:a4309389ad7bcb94d7b511e94c2937b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9650a82dbc9bc2afd43b4da4659458"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a5c9650a82dbc9bc2afd43b4da4659458">Swi_getTrigger</a> (void)</td></tr>
<tr class="memdesc:a5c9650a82dbc9bc2afd43b4da4659458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trigger value of the currently executing Swi.  <a href="#a5c9650a82dbc9bc2afd43b4da4659458">More...</a><br /></td></tr>
<tr class="separator:a5c9650a82dbc9bc2afd43b4da4659458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec78b937fe01567443697c7b3e8ec91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a1ec78b937fe01567443697c7b3e8ec91">Swi_andn</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, unsigned int mask)</td></tr>
<tr class="memdesc:a1ec78b937fe01567443697c7b3e8ec91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear bits in Swi's trigger; post if trigger becomes 0.  <a href="#a1ec78b937fe01567443697c7b3e8ec91">More...</a><br /></td></tr>
<tr class="separator:a1ec78b937fe01567443697c7b3e8ec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef">Swi_dec</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi)</td></tr>
<tr class="memdesc:a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement Swi's trigger value; post if trigger becomes 0.  <a href="#a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef">More...</a><br /></td></tr>
<tr class="separator:a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723a695304a3a3d847ba81c547639f10"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a723a695304a3a3d847ba81c547639f10">Swi_getHookContext</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, int id)</td></tr>
<tr class="memdesc:a723a695304a3a3d847ba81c547639f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hook instance's context pointer for a Swi.  <a href="#a723a695304a3a3d847ba81c547639f10">More...</a><br /></td></tr>
<tr class="separator:a723a695304a3a3d847ba81c547639f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57241f2b7cbec3d63463379478a6aee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#af57241f2b7cbec3d63463379478a6aee">Swi_setHookContext</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, int id, void *hookContext)</td></tr>
<tr class="memdesc:af57241f2b7cbec3d63463379478a6aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hook instance's context for a swi.  <a href="#af57241f2b7cbec3d63463379478a6aee">More...</a><br /></td></tr>
<tr class="separator:af57241f2b7cbec3d63463379478a6aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fff78dcc07d47032f322834d6bd7ed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a77fff78dcc07d47032f322834d6bd7ed">Swi_getName</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi)</td></tr>
<tr class="memdesc:a77fff78dcc07d47032f322834d6bd7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Swi's name.  <a href="#a77fff78dcc07d47032f322834d6bd7ed">More...</a><br /></td></tr>
<tr class="separator:a77fff78dcc07d47032f322834d6bd7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d44153be8ae9b30da122fe5582263f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a48d44153be8ae9b30da122fe5582263f">Swi_getPri</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi)</td></tr>
<tr class="memdesc:a48d44153be8ae9b30da122fe5582263f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Swi's priority.  <a href="#a48d44153be8ae9b30da122fe5582263f">More...</a><br /></td></tr>
<tr class="separator:a48d44153be8ae9b30da122fe5582263f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f650b1611939fd894cbbe74f4b3811e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a8f650b1611939fd894cbbe74f4b3811e">Swi_getFunc</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, uintptr_t *arg0, uintptr_t *arg1)</td></tr>
<tr class="memdesc:a8f650b1611939fd894cbbe74f4b3811e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Swi function and arguments.  <a href="#a8f650b1611939fd894cbbe74f4b3811e">More...</a><br /></td></tr>
<tr class="separator:a8f650b1611939fd894cbbe74f4b3811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9e82b0e3c75f7b81dd170249b6d218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#adf9e82b0e3c75f7b81dd170249b6d218">Swi_getAttrs</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, <a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a> *swiFxn, <a class="el" href="structSwi__Params.html">Swi_Params</a> *params)</td></tr>
<tr class="memdesc:adf9e82b0e3c75f7b81dd170249b6d218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve attributes of an existing Swi object.  <a href="#adf9e82b0e3c75f7b81dd170249b6d218">More...</a><br /></td></tr>
<tr class="separator:adf9e82b0e3c75f7b81dd170249b6d218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1b3ba85aed422e177df5e4c5de6c32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a9f1b3ba85aed422e177df5e4c5de6c32">Swi_setAttrs</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, <a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a> swiFxn, <a class="el" href="structSwi__Params.html">Swi_Params</a> *params)</td></tr>
<tr class="memdesc:a9f1b3ba85aed422e177df5e4c5de6c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the attributes of an existing Swi object.  <a href="#a9f1b3ba85aed422e177df5e4c5de6c32">More...</a><br /></td></tr>
<tr class="separator:a9f1b3ba85aed422e177df5e4c5de6c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef855b6ac55b4d98f2961d8bfc03e104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#aef855b6ac55b4d98f2961d8bfc03e104">Swi_setPri</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, unsigned int priority)</td></tr>
<tr class="memdesc:aef855b6ac55b4d98f2961d8bfc03e104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a Swi's priority.  <a href="#aef855b6ac55b4d98f2961d8bfc03e104">More...</a><br /></td></tr>
<tr class="separator:aef855b6ac55b4d98f2961d8bfc03e104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea8110315b5e5f59db73ef212b39a92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a7ea8110315b5e5f59db73ef212b39a92">Swi_inc</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi)</td></tr>
<tr class="memdesc:a7ea8110315b5e5f59db73ef212b39a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Swi's trigger value and post the Swi.  <a href="#a7ea8110315b5e5f59db73ef212b39a92">More...</a><br /></td></tr>
<tr class="separator:a7ea8110315b5e5f59db73ef212b39a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9029bcc3f494baf782db5618a5c99af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#ac9029bcc3f494baf782db5618a5c99af">Swi_or</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi, unsigned int mask)</td></tr>
<tr class="memdesc:ac9029bcc3f494baf782db5618a5c99af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Or mask with value contained in Swi's trigger and post the Swi.  <a href="#ac9029bcc3f494baf782db5618a5c99af">More...</a><br /></td></tr>
<tr class="separator:ac9029bcc3f494baf782db5618a5c99af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af595c7bb6439f01c5c8bdf31507a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a> (<a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> swi)</td></tr>
<tr class="memdesc:a0af595c7bb6439f01c5c8bdf31507a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally post a software interrupt.  <a href="#a0af595c7bb6439f01c5c8bdf31507a57">More...</a><br /></td></tr>
<tr class="separator:a0af595c7bb6439f01c5c8bdf31507a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a752fa645505deaad242fa88fb35bad0f"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a752fa645505deaad242fa88fb35bad0f">Swi_numPriorities</a></td></tr>
<tr class="memdesc:a752fa645505deaad242fa88fb35bad0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Swi priorities supported.  <a href="#a752fa645505deaad242fa88fb35bad0f">More...</a><br /></td></tr>
<tr class="separator:a752fa645505deaad242fa88fb35bad0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbe8ac4899921f794e4de207b4a0234"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structSwi__Hook.html">Swi_Hook</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Swi_8h.html#a4bbe8ac4899921f794e4de207b4a0234">Swi_hooks</a></td></tr>
<tr class="memdesc:a4bbe8ac4899921f794e4de207b4a0234"><td class="mdescLeft">&#160;</td><td class="mdescRight">const array to hold all HookSet objects.  <a href="#a4bbe8ac4899921f794e4de207b4a0234">More...</a><br /></td></tr>
<tr class="separator:a4bbe8ac4899921f794e4de207b4a0234"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a96b79cda304a62695c167da840c07e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b79cda304a62695c167da840c07e43">&sect;&nbsp;</a></span>Swi_A_swiDisabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Swi_A_swiDisabled&#160;&#160;&#160;&quot;cannot create a SWI when Swi is disabled&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assertion raised if Swi_create is called and runtime Swi creation is disabled. </p>

</div>
</div>
<a id="a530c8a3661b8d996397285c861b9dce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530c8a3661b8d996397285c861b9dce1">&sect;&nbsp;</a></span>Swi_A_badPriority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Swi_A_badPriority&#160;&#160;&#160;&quot;invalid priority&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assertion raised if a Swi's priority is out of range. </p>
<p>Swi priorities must be in the range of 0 and Swi_numPriorities-1. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abf0c6286dd02ecf7446982f04c5fc9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0c6286dd02ecf7446982f04c5fc9e1">&sect;&nbsp;</a></span>Swi_Struct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a> <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a607e03a52277d34b4cf2e81b2cf847a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607e03a52277d34b4cf2e81b2cf847a4">&sect;&nbsp;</a></span>Swi_Object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a> <a class="el" href="Swi_8h.html#a607e03a52277d34b4cf2e81b2cf847a4">Swi_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad60137d6a9b1895c46c58b744c953cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60137d6a9b1895c46c58b744c953cdf">&sect;&nbsp;</a></span>Swi_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a>* <a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12b0ddc74846755e0921aa045300d979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b0ddc74846755e0921aa045300d979">&sect;&nbsp;</a></span>Swi_Instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a>* <a class="el" href="Swi_8h.html#a12b0ddc74846755e0921aa045300d979">Swi_Instance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76db51e920707c0f17c8b86958a8721d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76db51e920707c0f17c8b86958a8721d">&sect;&nbsp;</a></span>Swi_HookSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSwi__HookSet.html">Swi_HookSet</a> <a class="el" href="structSwi__HookSet.html">Swi_HookSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swi hook set type definition. </p>
<p>This structure defines the set of hook functions that can be specified for the Swi module.</p>
<p>See <a class="el" href="Swi_8h.html#SwiHookFunctions">Hook Functions</a> for details. </p>

</div>
</div>
<a id="a1554f30966a5e84e41b20893d5486d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1554f30966a5e84e41b20893d5486d77">&sect;&nbsp;</a></span>Swi_Params</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSwi__Params.html">Swi_Params</a> <a class="el" href="structSwi__Params.html">Swi_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fbdfa08fc08fb7fb9fc9f0a300b7906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbdfa08fc08fb7fb9fc9f0a300b7906">&sect;&nbsp;</a></span>Swi_FuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Swi_FuncPtr) (uintptr_t arg1, uintptr_t arg2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swi function type definition. </p>
<p>All Swi functions are passed two uninterpreted arguments of type uintptr_t and have no return value. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5d383d9dee6303634644df22420d8240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d383d9dee6303634644df22420d8240">&sect;&nbsp;</a></span>Swi_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> Swi_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>swiFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSwi__Params.html">Swi_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a software interrupt. </p>
<p>Swi_create creates a new Swi object.</p>
<p>The following C code sets Swi parameters and creates two Swi objects:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="structSwi__Params.html">Swi_Params</a> swiParams;</div><div class="line"></div><div class="line">    <a class="code" href="Swi_8h.html#a48f68ac1fa18fdc0c4079cee1187c13b">Swi_Params_init</a>(&amp;swiParams);</div><div class="line">    swiParams.<a class="code" href="structSwi__Params.html#aad44bd5c16c248e3377e795bae4e989a">arg0</a> = 1;</div><div class="line">    swiParams.<a class="code" href="structSwi__Params.html#aa369990511186cedf7f717731fc26cf2">arg1</a> = 0;</div><div class="line">    swiParams.<a class="code" href="structSwi__Params.html#a5711c4c49b11c775c4a958c5085d655f">priority</a> = 2;</div><div class="line">    swiParams.<a class="code" href="structSwi__Params.html#aadd1ba1d01d94c12710adb2045d46c56">trigger</a> = 0;</div><div class="line"></div><div class="line">    swi0 = <a class="code" href="Swi_8h.html#a5d383d9dee6303634644df22420d8240">Swi_create</a>(swi0Fxn, &amp;swiParams, NULL);</div><div class="line"></div><div class="line">    swiParams.<a class="code" href="structSwi__Params.html#aad44bd5c16c248e3377e795bae4e989a">arg0</a> = 2;</div><div class="line">    swiParams.<a class="code" href="structSwi__Params.html#aa369990511186cedf7f717731fc26cf2">arg1</a> = 0;</div><div class="line">    swiParams.<a class="code" href="structSwi__Params.html#a5711c4c49b11c775c4a958c5085d655f">priority</a> = 1;</div><div class="line">    swiParams.<a class="code" href="structSwi__Params.html#aadd1ba1d01d94c12710adb2045d46c56">trigger</a> = 3;</div><div class="line"></div><div class="line">    swi1 = <a class="code" href="Swi_8h.html#a5d383d9dee6303634644df22420d8240">Swi_create</a>(swi1Fxn, &amp;swiParams, NULL);</div><div class="line"></div><div class="line">    <a class="code" href="BIOS_8h.html#aa166cb986a863566660e378fdd48309e">BIOS_start</a>();</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swiFxn</td><td>Swi Function </td></tr>
    <tr><td class="paramname">prms</td><td>optional create parameters (NULL for defaults) </td></tr>
    <tr><td class="paramname">eb</td><td>error block</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Swi</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae44cc513c66964ded18b55085c922329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44cc513c66964ded18b55085c922329">&sect;&nbsp;</a></span>Swi_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> Swi_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>swiFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSwi__Params.html">Swi_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a software interrupt. </p>
<p>Swi_construct is equivalent to Swi_create except that the Swi_Struct is pre-allocated. See <a class="el" href="Swi_8h.html#a5d383d9dee6303634644df22420d8240" title="Create a software interrupt. ">Swi_create()</a> for a description of this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to a Swi object </td></tr>
    <tr><td class="paramname">swiFxn</td><td>Swi Function </td></tr>
    <tr><td class="paramname">prms</td><td>optional create parameters (NULL for defaults) </td></tr>
    <tr><td class="paramname">eb</td><td>error block</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Swi</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add50495a56db35894456d0b74bf7d4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add50495a56db35894456d0b74bf7d4bf">&sect;&nbsp;</a></span>Swi_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> *&#160;</td>
          <td class="paramname"><em>swi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a software interrupt. </p>
<p>Swi_delete deletes a Swi object. Note that Swi_delete takes a pointer to a Swi_Handle which enables Swi_delete to set the Swi_handle to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>pointer to Swi handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd0bb8b75d1d8f8e51be73f87b5875ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0bb8b75d1d8f8e51be73f87b5875ad">&sect;&nbsp;</a></span>Swi_destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#abf0c6286dd02ecf7446982f04c5fc9e1">Swi_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct a software interrupt. </p>
<p>Swi_destruct destructs a Swi object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to Swi object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48f68ac1fa18fdc0c4079cee1187c13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f68ac1fa18fdc0c4079cee1187c13b">&sect;&nbsp;</a></span>Swi_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSwi__Params.html">Swi_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="structSwi__Params.html">Swi_Params</a> structure with default values. </p>
<p>Swi_Params_init initializes the <a class="el" href="structSwi__Params.html">Swi_Params</a> structure with default values. Swi_Params_init should always be called before setting individual parameter fields. This allows new fields to be added in the future with compatible defaults &ndash; existing source code does not need to change when new fields are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prms</td><td>pointer to uninitialized params structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1c49451a0cb3b2b52441a936f76d46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c49451a0cb3b2b52441a936f76d46c">&sect;&nbsp;</a></span>Swi_Object_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> Swi_Object_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return handle of the first Swi on Swi list </p>
<p>Return the handle of the first Swi on the create/construct list. NULL if no Swis have been created or constructed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Swi</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6c08197cf3f7da73a2f0b85cbca7b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c08197cf3f7da73a2f0b85cbca7b20">&sect;&nbsp;</a></span>Swi_Object_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> Swi_Object_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return handle of the next Swi on Swi list </p>
<p>Return the handle of the next Swi on the create/construct list. NULL if no more Swis are on the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Swi</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ea393af9fc565d3e68f2ebedae52a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea393af9fc565d3e68f2ebedae52a1b">&sect;&nbsp;</a></span>Swi_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Swi_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Swi Scheduling. </p>
<p><a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b" title="Disable Swi Scheduling. ">Swi_disable()</a> and <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7">Swi_restore</a> control Swi scheduling. <a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b" title="Disable Swi Scheduling. ">Swi_disable()</a> disables all Swi functions from running until <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7" title="Restore Swi Scheduling state. ">Swi_restore()</a> is called. Hardware interrupts can still run.</p>
<p><a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b" title="Disable Swi Scheduling. ">Swi_disable()</a> and <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7" title="Restore Swi Scheduling state. ">Swi_restore()</a> allow you to ensure that statements that must be performed together during critical processing are not preempted by other Swis or Tasks.</p>
<p>The value of the key returned by <a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b" title="Disable Swi Scheduling. ">Swi_disable()</a> is opaque to applications and is meant to be passed to <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7" title="Restore Swi Scheduling state. ">Swi_restore()</a>.</p>
<p>In the following example, the critical section cannot be preempted by any Swis. Nor can it be pre-empted by other Tasks.</p>
<div class="fragment"><div class="line">key = <a class="code" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a>();</div><div class="line">    `critical section`</div><div class="line"><a class="code" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7">Swi_restore</a>(key);</div></div><!-- fragment --><h3>Side Effects of Disabling the Swi Scheduler</h3>
<p><a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a>, in addition to disabling Swis from pre- empting the code which follows its invocation, has the side effect of also disabling the Task scheduler. Consequently, Task pre-emption and blocking is also disabled while the Swi scheduler is disabled. When <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7">Swi_restore()</a> is subsequently called, it will re-enable and invoke the Task scheduler if the Task scheduler was not already disabled prior to invoking <a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b" title="Disable Swi Scheduling. ">Swi_disable()</a>.</p>
<p>The following code snippet:</p>
<div class="fragment"><div class="line">key = <a class="code" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a>();</div><div class="line">...</div><div class="line">Swi_post(swi);        &lt;-- <span class="stringliteral">&#39;swi&#39;</span> will not run</div><div class="line">...</div><div class="line">Swi_restore(key);     &lt;-- <span class="stringliteral">&#39;swi&#39;</span> runs now</div></div><!-- fragment --><p>Should be thought of as equivalent to this:</p>
<div class="fragment"><div class="line">tasKey = <a class="code" href="Task_8h.html#a293c4d0501b84901a2219b7563e55729">Task_disable</a>();</div><div class="line">swiKey = <a class="code" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a>();</div><div class="line">...</div><div class="line">Swi_post(swi);        &lt;-- <span class="stringliteral">&#39;swi&#39;</span> will not run</div><div class="line">...</div><div class="line">Swi_restore(swiKey);  &lt;-- <span class="stringliteral">&#39;swi&#39;</span> runs now</div><div class="line"><a class="code" href="Task_8h.html#a0a2e27cd328465bd41f4ef9f4afb518f">Task_restore</a>(taskKey);</div></div><!-- fragment --><p>In the following example, even though the <a class="el" href="Semaphore_8h.html#aeb5255ece95bc96188f617be327427d2" title="Signal a semaphore. ">Semaphore_post()</a> call unblocks a task of higher priority, the local task is not pre-empted until after the <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7" title="Restore Swi Scheduling state. ">Swi_restore()</a> call is made:</p>
<div class="fragment"><div class="line">key = <a class="code" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a>();</div><div class="line">...</div><div class="line">Swi_post(swi);        &lt;-- <span class="stringliteral">&#39;swi&#39;</span> will not run</div><div class="line"><a class="code" href="Semaphore_8h.html#aeb5255ece95bc96188f617be327427d2">Semaphore_post</a>(sem);  &lt;-- readys a task of higher priority than current task</div><div class="line">...</div><div class="line">Swi_restore(key);     &lt;-- <span class="stringliteral">&#39;swi&#39;</span> runs now, then current task is pre-empted.</div></div><!-- fragment --><p> 
  <B>
  A common mistake that users make is to invoke a blocking
  API such as Semaphore_pend() after calling Swi_disable().
  This results in unrecoverable damage to the Task scheduler's internal
  state and will lead to unpredictable and usually catastrophic behavior:
  </B>
 </p>
<div class="fragment"><div class="line">key = <a class="code" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a>();</div><div class="line">...</div><div class="line">Semaphore_pend(sem, <a class="code" href="BIOS_8h.html#af30174787e672154279b29377604a9b8">BIOS_WAIT_FOREVER</a>);  &lt;-- !!! DO NOT DO THIS !!!</div><div class="line">...</div><div class="line">Swi_restore(key);   &lt;-- !!! System failure guaranteed to follow !!!</div></div><!-- fragment --><p> 
  <B>
  A more subtle variant of the above problem occurs when an API such
  as GateMutex_enter() is invoked directly or indirectly while the
  Swi scheduler
  is disabled. If the GateMutex has already been entered by another thread,
  the current thread should block until the other thread calls
  GateMutex_leave().
  But because the Task scheduler is disabled, the local thread returns
  immediately from GateMutex_enter(), just as though it successfully
  entered the GateMutex! This usually leads to catastrophic results.
  </B>
 </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">opaque</td><td>key for use with <a class="el" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7" title="Restore Swi Scheduling state. ">Swi_restore()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade083f6ae10ef3952ccb60ca0fb6f6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade083f6ae10ef3952ccb60ca0fb6f6b7">&sect;&nbsp;</a></span>Swi_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_restore </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore Swi Scheduling state. </p>
<p>Swi_restore restores the Swi scheduler to the locked/unlocked state it was in when Swi_disable was called. If the scheduler becomes unlocked and Swis of sufficient priority have been made ready to run by any of the posting APIs, then they are run at this time.</p>
<p>Swi_disable and Swi_restore control software interrupt processing. Swi_disable disables all other Swi functions from running until Swi_restore is called. Hardware interrupts can still run.</p>
<p>Swi_disable and Swi_restore allow you to ensure that statements that must be performed together during critical processing are not pre-empted by other Swis.</p>
<p>In the following example, the critical section cannot be preempted by any Swis. Nor can it be pre-empted by other Tasks.</p>
<div class="fragment"><div class="line">key = <a class="code" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">Swi_disable</a>();</div><div class="line">    `critical section`</div><div class="line"><a class="code" href="Swi_8h.html#ade083f6ae10ef3952ccb60ca0fb6f6b7">Swi_restore</a>(key);</div></div><!-- fragment --><p>Read the discussion of the side effects of disabling the Swi scheduler <a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b">here</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Swi_restore will also re-enable and invoke the Task scheduler if the Task scheduler was not disabled prior to invoking <a class="el" href="Swi_8h.html#a1ea393af9fc565d3e68f2ebedae52a1b" title="Disable Swi Scheduling. ">Swi_disable()</a>.</dd></dl>
<p>The <a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a> discussion regarding global interrupts applies to this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to restore previous Swi scheduler state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4309389ad7bcb94d7b511e94c2937b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4309389ad7bcb94d7b511e94c2937b53">&sect;&nbsp;</a></span>Swi_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> Swi_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return address of currently executing Swi object. </p>
<p>Swi_self returns the handle of the currently executing Swi.</p>
<p>For example, you can call Swi_self as follows if you want a Swi to repost itself:</p>
<div class="fragment"><div class="line"><a class="code" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a>(<a class="code" href="Swi_8h.html#a4309389ad7bcb94d7b511e94c2937b53">Swi_self</a>());</div></div><!-- fragment --><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">handle</td><td>of currently running Swi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c9650a82dbc9bc2afd43b4da4659458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9650a82dbc9bc2afd43b4da4659458">&sect;&nbsp;</a></span>Swi_getTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Swi_getTrigger </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the trigger value of the currently executing Swi. </p>
<p>Swi_getTrigger returns the value that Swi's trigger had when the Swi started running. SYS/BIOS saves the trigger value internally, so that Swi_getTrigger can access it at any point within a Swi object's function, and then automatically resets the trigger to its initial value.</p>
<p>Swi_getTrigger should only be called within a function run by a Swi object.</p>
<p>When called from within the context of a Swi, the value returned by Swi_getTrigger is zero if the Swi was posted by a call to Swi_andn, or Swi_dec. Therefore, Swi_getTrigger provides relevant information only if the Swi was posted by a call to Swi_inc, Swi_or, or Swi_post.</p>
<p>This API is called within a Swi object's function to use the trigger value that caused the function to run. For example, if you use Swi_or or Swi_inc to post a Swi, different trigger values can require different processing.</p>
<div class="fragment"><div class="line">swicount = <a class="code" href="Swi_8h.html#a5c9650a82dbc9bc2afd43b4da4659458">Swi_getTrigger</a>();</div></div><!-- fragment --><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">trigger</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ec78b937fe01567443697c7b3e8ec91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec78b937fe01567443697c7b3e8ec91">&sect;&nbsp;</a></span>Swi_andn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_andn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear bits in Swi's trigger; post if trigger becomes 0. </p>
<p>Swi_andn is used to conditionally post a software interrupt. Swi_andn clears the bits specified by a mask from Swi's internal trigger. If the Swi's trigger becomes 0, Swi_andn posts the Swi. The bitwise logical operation performed is:</p>
<div class="fragment"><div class="line">trigger = trigger AND (NOT MASK)</div></div><!-- fragment --><p>If multiple conditions that all be met before a Swi can run, you should use a different bit in the trigger for each condition. When a condition is met, clear the bit for that condition.</p>
<p>For example, if two events must happen before a Swi is to be triggered, the initial trigger value of the Swi can be 3 (binary 0011). One call to Swi_andn can have a mask value of 2 (binary 0010), and another call to Swi_andn can have a mask value of 1 (binary 0001). After both calls have been made, the trigger value will be 0.</p>
<div class="fragment"><div class="line"><a class="code" href="Swi_8h.html#a1ec78b937fe01567443697c7b3e8ec91">Swi_andn</a>(swi0, 2);  <span class="comment">// clear bit 1</span></div><div class="line"><a class="code" href="Swi_8h.html#a1ec78b937fe01567443697c7b3e8ec91">Swi_andn</a>(swi0, 1);  <span class="comment">// clear bit 0</span></div></div><!-- fragment --><p>Swi_andn results in a context switch if the Swi's trigger becomes zero and the Swi has higher priority than the currently executing thread.</p>
<p>You specify a Swi's initial trigger value at Swi creation time. The trigger value is automatically reset when the Swi executes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a> discussion regarding global interrupts applies to this API.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
    <tr><td class="paramname">mask</td><td>inverse value to be ANDed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef">&sect;&nbsp;</a></span>Swi_dec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_dec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement Swi's trigger value; post if trigger becomes 0. </p>
<p>Swi_dec is used to conditionally post a software interrupt. Swi_dec decrements the value in Swi's trigger by 1. If Swi's trigger value becomes 0, Swi_dec posts the Swi. You can increment a trigger value by using Swi_inc, which always posts the Swi.</p>
<p>For example, you would use Swi_dec if you wanted to post a Swi after a number of occurrences of an event.</p>
<div class="fragment"><div class="line"><span class="comment">// swi0&#39;s trigger is configured to start at 3</span></div><div class="line"><a class="code" href="Swi_8h.html#a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef">Swi_dec</a>(swi0);      <span class="comment">// trigger = 2</span></div><div class="line"><a class="code" href="Swi_8h.html#a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef">Swi_dec</a>(swi0);      <span class="comment">// trigger = 1</span></div><div class="line"><a class="code" href="Swi_8h.html#a3b4ac7cd479b1a6e2b9e13c7ef9fb7ef">Swi_dec</a>(swi0);      <span class="comment">// trigger = 0</span></div></div><!-- fragment --><p>You specify a Swi's initial trigger value at Swi creation time. The trigger value is automatically reset when the Swi executes.</p>
<p>Swi_dec results in a context switch if the Swi's trigger becomes zero and the Swi has higher priority than the currently executing thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a> discussion regarding global interrupts applies to this API.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a723a695304a3a3d847ba81c547639f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723a695304a3a3d847ba81c547639f10">&sect;&nbsp;</a></span>Swi_getHookContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Swi_getHookContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hook instance's context pointer for a Swi. </p>
<p>For example, this C code gets the HookContext, prints it, and sets a new value for the HookContext.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * pEnv;</div><div class="line"><a class="code" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> mySwi;</div><div class="line"><span class="keywordtype">int</span> myHookSetId1;</div><div class="line"></div><div class="line">pEnv = <a class="code" href="Swi_8h.html#a723a695304a3a3d847ba81c547639f10">Swi_getHookContext</a>(swi, myHookSetId1);</div><div class="line"></div><div class="line"><a class="code" href="System_8h.html#a790b89a409dd53189bc82eb1d74f5116">System_printf</a>(<span class="stringliteral">&quot;myEnd1: pEnv = 0x%lx, time = %ld\n&quot;</span>,</div><div class="line">              (ULong)pEnv, (ULong)<a class="code" href="Timestamp_8h.html#aab5fb1d421a9fc9e618496151547cfcc">Timestamp_get32</a>());</div><div class="line"></div><div class="line"><a class="code" href="Swi_8h.html#af57241f2b7cbec3d63463379478a6aee">Swi_setHookContext</a>(swi, myHookSetId1, (<span class="keywordtype">void</span> *)0xc0de1);</div></div><!-- fragment --><p>See <a class="el" href="Swi_8h.html#SwiHookFunctions">Hook Functions</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
    <tr><td class="paramname">id</td><td>hook id</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">hook</td><td>instance's context pointer for Swi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af57241f2b7cbec3d63463379478a6aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57241f2b7cbec3d63463379478a6aee">&sect;&nbsp;</a></span>Swi_setHookContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_setHookContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hookContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set hook instance's context for a swi. </p>
<p>For example, this C code gets the HookContext, prints it, and sets a new value for the HookContext.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * pEnv;</div><div class="line"><a class="code" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a> mySwi;</div><div class="line"><span class="keywordtype">int</span> myHookSetId1;</div><div class="line"></div><div class="line">pEnv = <a class="code" href="Swi_8h.html#a723a695304a3a3d847ba81c547639f10">Swi_getHookContext</a>(swi, myHookSetId1);</div><div class="line"></div><div class="line"><a class="code" href="System_8h.html#a790b89a409dd53189bc82eb1d74f5116">System_printf</a>(<span class="stringliteral">&quot;myEnd1: pEnv = 0x%lx, time = %ld\n&quot;</span>,</div><div class="line">              (ULong)pEnv, (ULong)<a class="code" href="Timestamp_8h.html#aab5fb1d421a9fc9e618496151547cfcc">Timestamp_get32</a>());</div><div class="line"></div><div class="line"><a class="code" href="Swi_8h.html#af57241f2b7cbec3d63463379478a6aee">Swi_setHookContext</a>(swi, myHookSetId1, (<span class="keywordtype">void</span> *)0xc0de1);</div></div><!-- fragment --><p>See <a class="el" href="Swi_8h.html#SwiHookFunctions">Hook Functions</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
    <tr><td class="paramname">id</td><td>hook instance's ID </td></tr>
    <tr><td class="paramname">hookContext</td><td>value to write to context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77fff78dcc07d47032f322834d6bd7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fff78dcc07d47032f322834d6bd7ed">&sect;&nbsp;</a></span>Swi_getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Swi_getName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Swi's name. </p>
<p>Swi_getName returns the name of the Swi passed in as the argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">name</td><td>of the Swi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48d44153be8ae9b30da122fe5582263f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d44153be8ae9b30da122fe5582263f">&sect;&nbsp;</a></span>Swi_getPri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Swi_getPri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Swi's priority. </p>
<p>Swi_getPri returns the priority of the Swi passed in as the argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Priority</td><td>of Swi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f650b1611939fd894cbbe74f4b3811e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f650b1611939fd894cbbe74f4b3811e">&sect;&nbsp;</a></span>Swi_getFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a> Swi_getFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Swi function and arguments. </p>
<p>If either arg0 or arg1 is NULL, then the corresponding argument is not returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Swi_8h.html#adf9e82b0e3c75f7b81dd170249b6d218" title="Retrieve attributes of an existing Swi object. ">Swi_getAttrs</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
    <tr><td class="paramname">arg0</td><td>pointer for returning Swi's first function argument </td></tr>
    <tr><td class="paramname">arg1</td><td>pointer for returning Swi's second function argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Swi</td><td>function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf9e82b0e3c75f7b81dd170249b6d218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9e82b0e3c75f7b81dd170249b6d218">&sect;&nbsp;</a></span>Swi_getAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_getAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a> *&#160;</td>
          <td class="paramname"><em>swiFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSwi__Params.html">Swi_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve attributes of an existing Swi object. </p>
<p>The 'handle' argument specifies the address of the Swi object whose attributes are to be retrieved.</p>
<p>The 'swiFxn' argument is the address of a function pointer where the the Swi function address is to be written to. If NULL is passed for 'swiFxn', no attempt is made to return the Swi function.</p>
<p>The 'params' argument is a pointer to a <a class="el" href="structSwi__Params.html">Swi_Params</a> structure that will contain the retrieved Swi attributes. If 'params' is NULL, no attempt is made to retrieve the <a class="el" href="structSwi__Params.html">Swi_Params</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Swi_8h.html#a9f1b3ba85aed422e177df5e4c5de6c32" title="Set the attributes of an existing Swi object. ">Swi_setAttrs</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
    <tr><td class="paramname">swiFxn</td><td>pointer to a Swi_FuncPtr </td></tr>
    <tr><td class="paramname">params</td><td>pointer for returning Swi's Params </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f1b3ba85aed422e177df5e4c5de6c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1b3ba85aed422e177df5e4c5de6c32">&sect;&nbsp;</a></span>Swi_setAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_setAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#a8fbdfa08fc08fb7fb9fc9f0a300b7906">Swi_FuncPtr</a>&#160;</td>
          <td class="paramname"><em>swiFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSwi__Params.html">Swi_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the attributes of an existing Swi object. </p>
<p>The 'handle' argument specifies the address of the Swi object whose attributes are to be set.</p>
<p>The 'swiFxn' argument is the address of the function to be invoked when the Swi runs. If 'swiFxn' is NULL, no change is made to the Swi function.</p>
<p>The 'params' argument, which can be either NULL or a pointer to a <a class="el" href="structSwi__Params.html">Swi_Params</a> structure that contains attributes for the Swi object, facilitates setting the attributes of the Swi object.</p>
<p>If 'params' is NULL, the Swi object is assigned a default set of attributes. Otherwise, the Swi object's attributes are set according the values passed within 'params'.</p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="Swi_8h.html#a9f1b3ba85aed422e177df5e4c5de6c32" title="Set the attributes of an existing Swi object. ">Swi_setAttrs()</a> must not be used on a Swi that is preempted or is ready to run.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Swi_8h.html#adf9e82b0e3c75f7b81dd170249b6d218" title="Retrieve attributes of an existing Swi object. ">Swi_getAttrs</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
    <tr><td class="paramname">swiFxn</td><td>address of the Swi function </td></tr>
    <tr><td class="paramname">params</td><td>pointer to optional <a class="el" href="structSwi__Params.html">Swi_Params</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef855b6ac55b4d98f2961d8bfc03e104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef855b6ac55b4d98f2961d8bfc03e104">&sect;&nbsp;</a></span>Swi_setPri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_setPri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a Swi's priority. </p>
<p>Swi_setPri sets the priority of the Swi passed in as the argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The priority must be in the range of 0 and numPriorities-1.</dd>
<dd>
<a class="el" href="Swi_8h.html#aef855b6ac55b4d98f2961d8bfc03e104" title="Set a Swi&#39;s priority. ">Swi_setPri()</a> must not be used on a Swi that is preempted or is ready to run.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Swi_8h.html#a48d44153be8ae9b30da122fe5582263f" title="Return a Swi&#39;s priority. ">Swi_getPri</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
    <tr><td class="paramname">priority</td><td>priority of Swi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ea8110315b5e5f59db73ef212b39a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea8110315b5e5f59db73ef212b39a92">&sect;&nbsp;</a></span>Swi_inc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment Swi's trigger value and post the Swi. </p>
<p>Swi_inc increments the value in Swi's trigger by 1 and posts the Swi regardless of the resulting trigger value. You can decrement a trigger value using Swi_dec, which only posts the Swi if the trigger value is 0.</p>
<p>If a Swi is posted several times before it has a chance to begin executing (i.e. when Hwis or higher priority Swis are running) the Swi only runs one time. If this situation occurs, you can use Swi_inc to post the Swi. Within the Swi's function, you could then use Swi_getTrigger to find out how many times this Swi has been posted since the last time it was executed.</p>
<p>You specify a Swi's initial trigger value at Swi creation time. The trigger value is automatically reset when the Swi executes. To get the trigger value, use Swi_getTrigger.</p>
<p>Swi_inc results in a context switch if the Swi is higher priority than the currently executing thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a> discussion regarding global interrupts applies to this API.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9029bcc3f494baf782db5618a5c99af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9029bcc3f494baf782db5618a5c99af">&sect;&nbsp;</a></span>Swi_or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Or mask with value contained in Swi's trigger and post the Swi. </p>
<p>Swi_or is used to post a software interrupt. Swi_or sets the bits specified by a mask in Swi's trigger. Swi_or posts the Swi regardless of the resulting trigger value. The bitwise logical operation performed on the trigger value is:</p>
<div class="fragment"><div class="line">trigger = trigger OR mask</div></div><!-- fragment --><p>You specify a Swi's initial trigger value at Swi creation time. The trigger value is automatically reset when the Swi executes. To get the trigger value, use Swi_getTrigger.</p>
<p>For example, you might use Swi_or to post a Swi if any of three events should cause a Swi to be executed, but you want the Swi's function to be able to tell which event occurred. Each event would correspond to a different bit in the trigger.</p>
<p>Swi_or results in a context switch if the Swi is higher priority than the currently executing thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="Swi_8h.html#a0af595c7bb6439f01c5c8bdf31507a57">Swi_post</a> discussion regarding global interrupts applies to this API.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
    <tr><td class="paramname">mask</td><td>value to be ORed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af595c7bb6439f01c5c8bdf31507a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af595c7bb6439f01c5c8bdf31507a57">&sect;&nbsp;</a></span>Swi_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Swi_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Swi_8h.html#ad60137d6a9b1895c46c58b744c953cdf">Swi_Handle</a>&#160;</td>
          <td class="paramname"><em>swi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally post a software interrupt. </p>
<p>Swi_post is used to post a software interrupt regardless of the trigger value. No change is made to the Swi object's trigger value.</p>
<p>Swi_post results in a context switch if the Swi is higher priority than the currently executing thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Swis are ALWAYS run with interrupts enabled. If a Swi is made ready to run as a consequence of this API, interrupts will be globally enabled while the Swi function executes, regardless of the prior globally enabled/disabled state of interrupts. Upon return from this API, the global interrupt enabled/disabled state is restored to its previous value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swi</td><td>Swi handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a752fa645505deaad242fa88fb35bad0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752fa645505deaad242fa88fb35bad0f">&sect;&nbsp;</a></span>Swi_numPriorities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Swi_numPriorities</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of Swi priorities supported. </p>
<p>The maximum number of priorities supported is target-specific and depends on the number of bits in a unsigned int data type. For 6x and ARM devices the maximum number of priorities is therefore 32. For the C28x, the maximum number of priorities is 16. </p>

</div>
</div>
<a id="a4bbe8ac4899921f794e4de207b4a0234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbe8ac4899921f794e4de207b4a0234">&sect;&nbsp;</a></span>Swi_hooks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structSwi__Hook.html">Swi_Hook</a> Swi_hooks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const array to hold all HookSet objects. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
