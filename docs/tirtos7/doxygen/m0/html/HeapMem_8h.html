<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SYS/BIOS: /home/developer/.conan/data/tirtos/7.03.00.10/library-sb/ga/build/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/kernel/tirtos7/packages/ti/sysbios/heaps/HeapMem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SYS/BIOS
   &#160;<span id="projectnumber">7.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_166a36ee10a8457f2f1d507eafd683e9.html">developer</a></li><li class="navelem"><a class="el" href="dir_ab47aaff52849945b02749b38626f831.html">.conan</a></li><li class="navelem"><a class="el" href="dir_2db58af45ff07475e1865bb6cfecd114.html">data</a></li><li class="navelem"><a class="el" href="dir_73aa28e1938cea8ca02173a6a02bb3cc.html">tirtos</a></li><li class="navelem"><a class="el" href="dir_b92035bd439bf87970152b15ca557739.html">7.03.00.10</a></li><li class="navelem"><a class="el" href="dir_a8aafc4147cd9aeef51c3eea0146f858.html">library-sb</a></li><li class="navelem"><a class="el" href="dir_cd46cd47afafa592114402c4301543d5.html">ga</a></li><li class="navelem"><a class="el" href="dir_2cab851584a752880681e90a2dfd4edd.html">build</a></li><li class="navelem"><a class="el" href="dir_5697d1fa77239cd87167d697b8481edf.html">5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9</a></li><li class="navelem"><a class="el" href="dir_a25849b87dcee5ac6bd91808e0cfd56f.html">kernel</a></li><li class="navelem"><a class="el" href="dir_62fe09a765bfb79fe774e523a5e63239.html">tirtos7</a></li><li class="navelem"><a class="el" href="dir_e3f05480a1de819db6de4292a46ffd2c.html">packages</a></li><li class="navelem"><a class="el" href="dir_c9091c0837bc7d5e21af62b18a8f3d2f.html">ti</a></li><li class="navelem"><a class="el" href="dir_e302b19c208f2b8f03cb96305b4c2fcc.html">sysbios</a></li><li class="navelem"><a class="el" href="dir_ce87a5de68fe1c9da3cbae73cb85ff7e.html">heaps</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HeapMem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Variable size buffer heap manager. </p>
<p>HeapMem manager provides functions to allocate and free storage from a heap of type HeapMem which inherits from IHeap.</p>
<p>In addition to allowing multiple static HeapMem instances to be created who's buffer placements and sizes are defined by their instance configuration parameters, HeapMem allows one Heap instance to be defined who's heap memory is defined by buffer start and end symbols in the linker command file. This singular Heap instance is referred to as the 'Primary Heap'.</p>
<p> 
 <h3> HeapMem Gate </h3>
 A HeapMem instance will use the HeapMem module Gate to protect any accesses
 to its list of free memory blocks. The HeapMem instance will enter and
 leave the module Gate when allocating blocks, freeing blocks, and
 retrieving statistics about the HeapMem.

 By default, the Gate is of type GateMutex.

 A different Gate can be specified using the common$.gate parameter.
 For example, to use a GateTask to protect HeapMem:
     HeapMem.common$.gate = GateTask.create();

 To save on overhead, HeapMem does not create additional Gate instances on a
 per-instance basis; there is only one Gate instance shared across all of
 the HeapMem instances. Therefore, the HeapMem.common$.gateParams parameter
 (used for configuring per-instance Gates) is ignored.

 The type of Gate used should be chosen based on the type of threads (Hwi,
 Swi, Task, etc.) using the heap. It should also consider the
 non-deterministic nature of the HeapMem. A call to alloc or free will
 traverse a list of free blocks, so a GateHwi, for example, is likely an
 inappropriate Gate for HeapMem.

<h3> Calling Context </h3> <table border="1" cellpadding="3">
<colgroup span="1"></colgroup>
<colgroup span="5" align="center"></colgroup>

<tr><th> Function    </th><th>  Hwi   </th><th>  Swi   </th> <th>  Task
</th><th>  Main  </th><th>  Startup  </th></tr> <!--
--> <tr><td> Params_init         </td><td>   Y    </td><td>   Y    </td> <td>
Y    </td><td>   Y    </td><td>   Y    </td></tr> <tr><td> alloc
</td><td>   N**  </td><td>   N**  </td> <td>   Y**  </td><td>   Y
</td><td>   N    </td></tr> <tr><td> construct           </td><td>   Y
</td><td>   Y    </td> <td>   Y    </td><td>   Y    </td><td>   N
</td></tr> <tr><td> create              </td><td>   N*   </td><td>   N*
</td> <td>   Y    </td><td>   Y    </td><td>   N    </td></tr> <tr><td>
delete              </td><td>   N*   </td><td>   N*   </td> <td>   Y
</td><td>   Y    </td><td>   N    </td></tr> <tr><td> destruct
</td><td>   Y    </td><td>   Y    </td> <td>   Y    </td><td>   Y
</td><td>   N    </td></tr> <tr><td> free                </td><td>   N**
</td><td>   N**  </td> <td>   Y**  </td><td>   Y    </td><td>   N
</td></tr> <tr><td> getExtendedStats    </td><td>   Y    </td><td>   Y
</td> <td>   Y    </td><td>   Y    </td><td>   N    </td></tr> <tr><td>
getStats            </td><td>   N**  </td><td>   N**  </td> <td>   Y**
</td><td>   Y    </td><td>   N    </td></tr> <tr><td> isBlocking
</td><td>   Y    </td><td>   Y    </td> <td>   Y    </td><td>   Y
</td><td>   N    </td></tr> <tr><td> restore             </td><td>   Y+
</td><td>   Y+   </td> <td>   Y+   </td><td>   Y    </td><td>   N
</td></tr> <tr><td colspan="6"> Definitions: <br /> <ul> <li> <b>Hwi</b>: API
is callable from a Hwi thread. </li> <li> <b>Swi</b>: API is callable from a
Swi thread. </li> <li> <b>Task</b>: API is callable from a Task thread. </li>
<li> <b>Main</b>: API is callable during any of these phases: </li> <ul> <li>
In your module startup after this module is started (e.g.
HeapMem_Module_startupDone() returns true). </li> <li> During
xdc.runtime.Startup.lastFxns. </li> <li> During main().</li> <li> During
BIOS.startupFxns.</li> </ul> <li> <b>Startup</b>: API is callable during any
of these phases:</li> <ul> <li> During xdc.runtime.Startup.firstFxns.</li>
<li> In your module startup before this module is started (e.g.
HeapMem_Module_startupDone() returns false).</li> </ul> <li> <b>*</b> :
Assuming blocking Heap is used for creation. </li> <li> <b>**</b>: Assuming
GateMutex is used as HeapMem's Gate. </li> <li> <b>+</b> : Cannot use HeapMem
object while it is being restored. </li> </ul> </td></tr>

</table>

 </p>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Queue_8h_source.html">ti/sysbios/knl/Queue.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Error_8h_source.html">ti/sysbios/runtime/Error.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="IHeap_8h_source.html">ti/sysbios/runtime/IHeap.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Memory_8h_source.html">ti/sysbios/runtime/Memory.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for HeapMem.h:</div>
<div class="dyncontent">
<div class="center"><img src="HeapMem_8h__incl.png" border="0" usemap="#_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2heaps_2HeapMem_8h" alt=""/></div>
<map name="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2heaps_2HeapMem_8h" id="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2heaps_2HeapMem_8h">
<area shape="rect" id="node5" href="Queue_8h.html" title="Queue Manager. " alt="" coords="28,221,194,247"/>
<area shape="rect" id="node6" href="Error_8h.html" title="Runtime error manager. " alt="" coords="123,303,262,344"/>
<area shape="rect" id="node7" href="IHeap_8h.html" title="Interface to heap functions. " alt="" coords="270,124,408,165"/>
<area shape="rect" id="node8" href="Memory_8h.html" title="Static and run&#45;time memory manager. " alt="" coords="270,213,408,255"/>
</map>
</div>
</div>
<p><a href="HeapMem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeapMem__ExtendedStats.html">HeapMem_ExtendedStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stat structure for the HeapMem_getExtendedStats function.  <a href="structHeapMem__ExtendedStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeapMem__Params.html">HeapMem_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7a0dc41ad86d1bf8c5355ca81523a28e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a7a0dc41ad86d1bf8c5355ca81523a28e">HeapMem_reqAlign</a>&#160;&#160;&#160;sizeof(HeapMem_Header)</td></tr>
<tr class="separator:a7a0dc41ad86d1bf8c5355ca81523a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0275dbe3656439211d679d209769fbdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a0275dbe3656439211d679d209769fbdc">HeapMem_A_align</a>&#160;&#160;&#160;&quot;Requested align is not a power of 2&quot;</td></tr>
<tr class="memdesc:a0275dbe3656439211d679d209769fbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert raised when the requested alignment is not a power of 2.  <a href="#a0275dbe3656439211d679d209769fbdc">More...</a><br /></td></tr>
<tr class="separator:a0275dbe3656439211d679d209769fbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f6629bc45b0f1348ae83f47f0e91f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a29f6629bc45b0f1348ae83f47f0e91f5">HeapMem_A_heapSize</a>&#160;&#160;&#160;&quot;Requested heap size is too small&quot;</td></tr>
<tr class="memdesc:a29f6629bc45b0f1348ae83f47f0e91f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert raised when the requested heap size is too small.  <a href="#a29f6629bc45b0f1348ae83f47f0e91f5">More...</a><br /></td></tr>
<tr class="separator:a29f6629bc45b0f1348ae83f47f0e91f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce5f6cc017531afee027959184b36c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#acce5f6cc017531afee027959184b36c7">HeapMem_A_invalidFree</a>&#160;&#160;&#160;&quot;Heap-block free operations must not leave the heap in an invalid state&quot;</td></tr>
<tr class="memdesc:acce5f6cc017531afee027959184b36c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert raised when the free detects that an invalid addr or size.  <a href="#acce5f6cc017531afee027959184b36c7">More...</a><br /></td></tr>
<tr class="separator:acce5f6cc017531afee027959184b36c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4b9b70f937ea8dfa3c46c93d9b9afa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#aae4b9b70f937ea8dfa3c46c93d9b9afa">HeapMem_A_zeroBlock</a>&#160;&#160;&#160;&quot;Cannot allocate size 0&quot;</td></tr>
<tr class="memdesc:aae4b9b70f937ea8dfa3c46c93d9b9afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert raised when a block of size 0 is requested.  <a href="#aae4b9b70f937ea8dfa3c46c93d9b9afa">More...</a><br /></td></tr>
<tr class="separator:aae4b9b70f937ea8dfa3c46c93d9b9afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27528b066f1321266593e2afd997cf35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a27528b066f1321266593e2afd997cf35">HeapMem_E_memory</a>&#160;&#160;&#160;&quot;out of memory: handle = 0x%x, size=%u&quot;</td></tr>
<tr class="memdesc:a27528b066f1321266593e2afd997cf35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised when requested size exceeds largest free block.  <a href="#a27528b066f1321266593e2afd997cf35">More...</a><br /></td></tr>
<tr class="separator:a27528b066f1321266593e2afd997cf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c7e51cdfec74b788fb3717e77e45c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a11c7e51cdfec74b788fb3717e77e45c0">ti_sysbios_heaps_HeapMem_Handle_upCast</a>(handle)&#160;&#160;&#160;((IHeap_Handle)(handle))</td></tr>
<tr class="memdesc:a11c7e51cdfec74b788fb3717e77e45c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast handle to an IHeap_Handle for use by Memory_alloc, etc.  <a href="#a11c7e51cdfec74b788fb3717e77e45c0">More...</a><br /></td></tr>
<tr class="separator:a11c7e51cdfec74b788fb3717e77e45c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a12ad734c84bd40c89828c06b7d9e9b52"><td class="memItemLeft" align="right" valign="top">typedef HeapMem_Struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a12ad734c84bd40c89828c06b7d9e9b52">HeapMem_Object</a></td></tr>
<tr class="separator:a12ad734c84bd40c89828c06b7d9e9b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a974e0467328bd97671997edec03a8c75"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a974e0467328bd97671997edec03a8c75">HeapMem_alloc</a> (HeapMem_Handle heap, size_t size, size_t align, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:a974e0467328bd97671997edec03a8c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual block returned may be larger than requested to satisfy alignment requirements, and its size will always be a multiple of the size of the HeapMem_Header data structure (usually 8 bytes)  <a href="#a974e0467328bd97671997edec03a8c75">More...</a><br /></td></tr>
<tr class="separator:a974e0467328bd97671997edec03a8c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa702c0b25c346e90b0850f1b6a604c2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#aa702c0b25c346e90b0850f1b6a604c2a">HeapMem_free</a> (HeapMem_Handle heap, void *buf, size_t size)</td></tr>
<tr class="memdesc:aa702c0b25c346e90b0850f1b6a604c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="HeapMem_8h.html#aa702c0b25c346e90b0850f1b6a604c2a" title="HeapMem_free() places the memory block specified by addr and size back into the free pool of the heap...">HeapMem_free()</a> places the memory block specified by addr and size back into the free pool of the heap specified. The newly freed block is combined with any adjacent free blocks. The space is then available for further allocation by alloc().  <a href="#aa702c0b25c346e90b0850f1b6a604c2a">More...</a><br /></td></tr>
<tr class="separator:aa702c0b25c346e90b0850f1b6a604c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c29ffdcc836a5f912d504aa2fb99001"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a5c29ffdcc836a5f912d504aa2fb99001">HeapMem_isBlocking</a> (HeapMem_Handle heap)</td></tr>
<tr class="memdesc:a5c29ffdcc836a5f912d504aa2fb99001"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function queries the gate to determine if the alloc/free can be blocking.  <a href="#a5c29ffdcc836a5f912d504aa2fb99001">More...</a><br /></td></tr>
<tr class="separator:a5c29ffdcc836a5f912d504aa2fb99001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b297bee0f3a6ed1358539002ecbc1f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a9b297bee0f3a6ed1358539002ecbc1f4">HeapMem_getStats</a> (HeapMem_Handle heap, <a class="el" href="structMemory__Stats.html">Memory_Stats</a> *statBuf)</td></tr>
<tr class="memdesc:a9b297bee0f3a6ed1358539002ecbc1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">HeapMem_getStats will lock the heap using the HeapMem Gate while it retrieves the HeapMem's statistics.  <a href="#a9b297bee0f3a6ed1358539002ecbc1f4">More...</a><br /></td></tr>
<tr class="separator:a9b297bee0f3a6ed1358539002ecbc1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00125c85edf32c70f415596e6745f9a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a00125c85edf32c70f415596e6745f9a8">HeapMem_getExtendedStats</a> (HeapMem_Handle heap, <a class="el" href="structHeapMem__ExtendedStats.html">HeapMem_ExtendedStats</a> *statBuf)</td></tr>
<tr class="memdesc:a00125c85edf32c70f415596e6745f9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the extended statistics for a HeapMem instance.  <a href="#a00125c85edf32c70f415596e6745f9a8">More...</a><br /></td></tr>
<tr class="separator:a00125c85edf32c70f415596e6745f9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8874a46f8adb4df3e1dcd8be8fe4be"><td class="memItemLeft" align="right" valign="top">HeapMem_Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a5a8874a46f8adb4df3e1dcd8be8fe4be">HeapMem_create</a> (const <a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> *params, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:a5a8874a46f8adb4df3e1dcd8be8fe4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>HeapMem</code> heap.  <a href="#a5a8874a46f8adb4df3e1dcd8be8fe4be">More...</a><br /></td></tr>
<tr class="separator:a5a8874a46f8adb4df3e1dcd8be8fe4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63984204eae0eb8b6194d22ae8cd729f"><td class="memItemLeft" align="right" valign="top">HeapMem_Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a63984204eae0eb8b6194d22ae8cd729f">HeapMem_construct</a> (HeapMem_Struct *obj, const <a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> *params)</td></tr>
<tr class="memdesc:a63984204eae0eb8b6194d22ae8cd729f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code>HeapMem</code> heap.  <a href="#a63984204eae0eb8b6194d22ae8cd729f">More...</a><br /></td></tr>
<tr class="separator:a63984204eae0eb8b6194d22ae8cd729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575628be420cbf02a8c6ed04dd05ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a2575628be420cbf02a8c6ed04dd05ace">HeapMem_delete</a> (HeapMem_Handle *heap)</td></tr>
<tr class="memdesc:a2575628be420cbf02a8c6ed04dd05ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a <code>HeapMem</code> heap.  <a href="#a2575628be420cbf02a8c6ed04dd05ace">More...</a><br /></td></tr>
<tr class="separator:a2575628be420cbf02a8c6ed04dd05ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9487f7810fccdc76779d58c5de863f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#ae9487f7810fccdc76779d58c5de863f4">HeapMem_destruct</a> (HeapMem_Struct *obj)</td></tr>
<tr class="memdesc:ae9487f7810fccdc76779d58c5de863f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a <code>HeapMem</code> heap.  <a href="#ae9487f7810fccdc76779d58c5de863f4">More...</a><br /></td></tr>
<tr class="separator:ae9487f7810fccdc76779d58c5de863f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942ca4391e6d2cc51707552924f34ad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a942ca4391e6d2cc51707552924f34ad2">HeapMem_restore</a> (HeapMem_Handle heap)</td></tr>
<tr class="memdesc:a942ca4391e6d2cc51707552924f34ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore heap to its original created state.  <a href="#a942ca4391e6d2cc51707552924f34ad2">More...</a><br /></td></tr>
<tr class="separator:a942ca4391e6d2cc51707552924f34ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ceacc5e6782cff038b76aaa34c4f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#ab2ceacc5e6782cff038b76aaa34c4f02">HeapMem_init</a> (void)</td></tr>
<tr class="memdesc:ab2ceacc5e6782cff038b76aaa34c4f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize instance at runtime.  <a href="#ab2ceacc5e6782cff038b76aaa34c4f02">More...</a><br /></td></tr>
<tr class="separator:ab2ceacc5e6782cff038b76aaa34c4f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f3cf46d0cff27e384fa67d3547cd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#ab9f3cf46d0cff27e384fa67d3547cd45">HeapMem_Params_init</a> (<a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> *prms)</td></tr>
<tr class="memdesc:ab9f3cf46d0cff27e384fa67d3547cd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> structure with default values.  <a href="#ab9f3cf46d0cff27e384fa67d3547cd45">More...</a><br /></td></tr>
<tr class="separator:ab9f3cf46d0cff27e384fa67d3547cd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9e9e2be97d440899685b2849ac3f66"><td class="memItemLeft" align="right" valign="top">HeapMem_Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#a7f9e9e2be97d440899685b2849ac3f66">HeapMem_Object_first</a> (void)</td></tr>
<tr class="memdesc:a7f9e9e2be97d440899685b2849ac3f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">return handle of the first HeapMem on HeapMem list  <a href="#a7f9e9e2be97d440899685b2849ac3f66">More...</a><br /></td></tr>
<tr class="separator:a7f9e9e2be97d440899685b2849ac3f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72b738d7a43eaf46f71741e80b498e8"><td class="memItemLeft" align="right" valign="top">HeapMem_Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMem_8h.html#ad72b738d7a43eaf46f71741e80b498e8">HeapMem_Object_next</a> (HeapMem_Handle heap)</td></tr>
<tr class="memdesc:ad72b738d7a43eaf46f71741e80b498e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return handle of the next HeapMem on HeapMem list  <a href="#ad72b738d7a43eaf46f71741e80b498e8">More...</a><br /></td></tr>
<tr class="separator:ad72b738d7a43eaf46f71741e80b498e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7a0dc41ad86d1bf8c5355ca81523a28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0dc41ad86d1bf8c5355ca81523a28e">&sect;&nbsp;</a></span>HeapMem_reqAlign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HeapMem_reqAlign&#160;&#160;&#160;sizeof(HeapMem_Header)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0275dbe3656439211d679d209769fbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0275dbe3656439211d679d209769fbdc">&sect;&nbsp;</a></span>HeapMem_A_align</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HeapMem_A_align&#160;&#160;&#160;&quot;Requested align is not a power of 2&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert raised when the requested alignment is not a power of 2. </p>

</div>
</div>
<a id="a29f6629bc45b0f1348ae83f47f0e91f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f6629bc45b0f1348ae83f47f0e91f5">&sect;&nbsp;</a></span>HeapMem_A_heapSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HeapMem_A_heapSize&#160;&#160;&#160;&quot;Requested heap size is too small&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert raised when the requested heap size is too small. </p>

</div>
</div>
<a id="acce5f6cc017531afee027959184b36c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce5f6cc017531afee027959184b36c7">&sect;&nbsp;</a></span>HeapMem_A_invalidFree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HeapMem_A_invalidFree&#160;&#160;&#160;&quot;Heap-block free operations must not leave the heap in an invalid state&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert raised when the free detects that an invalid addr or size. </p>
<p>This could arise when multiple frees are done on the same buffer or if corruption occurred.</p>
<p>This also could occur when an alloc is made with size N and the free for this buffer specifies size M where M &gt; N. Note: not every case is detectable.</p>
<p>This assert can also be caused when passing an invalid addr to free or if the size is causing the end of the buffer to be out of the expected range. </p>

</div>
</div>
<a id="aae4b9b70f937ea8dfa3c46c93d9b9afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4b9b70f937ea8dfa3c46c93d9b9afa">&sect;&nbsp;</a></span>HeapMem_A_zeroBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HeapMem_A_zeroBlock&#160;&#160;&#160;&quot;Cannot allocate size 0&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert raised when a block of size 0 is requested. </p>
<p>This error can also be raised if the requested size wraps the contents of a SizeT type when it is adjusted for a minimum alignment. For example, when SizeT is 16-bits and a size request is made for 0xFFFB. </p>

</div>
</div>
<a id="a27528b066f1321266593e2afd997cf35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27528b066f1321266593e2afd997cf35">&sect;&nbsp;</a></span>HeapMem_E_memory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HeapMem_E_memory&#160;&#160;&#160;&quot;out of memory: handle = 0x%x, size=%u&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised when requested size exceeds largest free block. </p>

</div>
</div>
<a id="a11c7e51cdfec74b788fb3717e77e45c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c7e51cdfec74b788fb3717e77e45c0">&sect;&nbsp;</a></span>ti_sysbios_heaps_HeapMem_Handle_upCast</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ti_sysbios_heaps_HeapMem_Handle_upCast</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle</td><td>)</td>
          <td>&#160;&#160;&#160;((IHeap_Handle)(handle))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast handle to an IHeap_Handle for use by Memory_alloc, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>heap handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IHeap_Handle</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a12ad734c84bd40c89828c06b7d9e9b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ad734c84bd40c89828c06b7d9e9b52">&sect;&nbsp;</a></span>HeapMem_Object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HeapMem_Struct <a class="el" href="HeapMem_8h.html#a12ad734c84bd40c89828c06b7d9e9b52">HeapMem_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a974e0467328bd97671997edec03a8c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974e0467328bd97671997edec03a8c75">&sect;&nbsp;</a></span>HeapMem_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* HeapMem_alloc </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Handle&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual block returned may be larger than requested to satisfy alignment requirements, and its size will always be a multiple of the size of the HeapMem_Header data structure (usually 8 bytes) </p>
<p><a class="el" href="HeapMem_8h.html#a974e0467328bd97671997edec03a8c75" title="The actual block returned may be larger than requested to satisfy alignment requirements, and its size will always be a multiple of the size of the HeapMem_Header data structure (usually 8 bytes) ">HeapMem_alloc()</a> will lock the heap using the HeapMem Gate while it traverses the list of free blocks to find a large enough block for the request.</p>
<p><a class="el" href="HeapMem_8h.html#a974e0467328bd97671997edec03a8c75" title="The actual block returned may be larger than requested to satisfy alignment requirements, and its size will always be a multiple of the size of the HeapMem_Header data structure (usually 8 bytes) ">HeapMem_alloc()</a> should not be called directly. Application code should use <a class="el" href="Memory_8h.html#a8efb8cff93d5409ff1991152cc398092" title="Allocate a block of memory from a heap. ">Memory_alloc()</a> with a HeapMem_Handle as the first parameter. Among other things, <a class="el" href="Memory_8h.html#a8efb8cff93d5409ff1991152cc398092" title="Allocate a block of memory from a heap. ">Memory_alloc()</a> makes sure that the alignment parameter is greater than or equal to the minimum alignment required for the HeapMem_Header data structure for a given C compiler (8 bytes in most cases). <a class="el" href="HeapMem_8h.html#a974e0467328bd97671997edec03a8c75" title="The actual block returned may be larger than requested to satisfy alignment requirements, and its size will always be a multiple of the size of the HeapMem_Header data structure (usually 8 bytes) ">HeapMem_alloc()</a> may crash if you pass a smaller alignment.</p>
<p>Guidelines for using large heaps and multiple alloc() calls. </p><pre class="fragment">     - If possible, allocate larger blocks first. Previous
       allocations of small memory blocks can reduce the size
       of the blocks available for larger memory allocations.
     - Realize that alloc() can fail even if the heap contains a
       sufficient absolute amount of unallocated space. This is
       because the largest free memory block may be smaller than
       total amount of unallocated memory.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>heap handle </td></tr>
    <tr><td class="paramname">size</td><td>Requested size </td></tr>
    <tr><td class="paramname">align</td><td>Requested alignment </td></tr>
    <tr><td class="paramname">eb</td><td><a class="el" href="structError__Block.html" title="Error block. ">Error_Block</a> used to denote location in case of a failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">allocated</td><td>block or NULL is request cannot be honored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa702c0b25c346e90b0850f1b6a604c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa702c0b25c346e90b0850f1b6a604c2a">&sect;&nbsp;</a></span>HeapMem_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMem_free </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Handle&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="HeapMem_8h.html#aa702c0b25c346e90b0850f1b6a604c2a" title="HeapMem_free() places the memory block specified by addr and size back into the free pool of the heap...">HeapMem_free()</a> places the memory block specified by addr and size back into the free pool of the heap specified. The newly freed block is combined with any adjacent free blocks. The space is then available for further allocation by alloc(). </p>
<p>free() will lock the heap using the HeapMem Gate, if one is specified using 'HeapMem.common$.gate'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>heap handle </td></tr>
    <tr><td class="paramname">buf</td><td>block of memory to be freed </td></tr>
    <tr><td class="paramname">size</td><td>size of block to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c29ffdcc836a5f912d504aa2fb99001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c29ffdcc836a5f912d504aa2fb99001">&sect;&nbsp;</a></span>HeapMem_isBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HeapMem_isBlocking </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Handle&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function queries the gate to determine if the alloc/free can be blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>heap handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">returns</td><td>true if the gate can block, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b297bee0f3a6ed1358539002ecbc1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b297bee0f3a6ed1358539002ecbc1f4">&sect;&nbsp;</a></span>HeapMem_getStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMem_getStats </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Handle&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMemory__Stats.html">Memory_Stats</a> *&#160;</td>
          <td class="paramname"><em>statBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HeapMem_getStats will lock the heap using the HeapMem Gate while it retrieves the HeapMem's statistics. </p>
<p>The returned totalSize reflects the usable size of the buffer, not necessarily the size specified during create.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>heap handle </td></tr>
    <tr><td class="paramname">statBuf</td><td>pointer to stat buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00125c85edf32c70f415596e6745f9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00125c85edf32c70f415596e6745f9a8">&sect;&nbsp;</a></span>HeapMem_getExtendedStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMem_getExtendedStats </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Handle&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeapMem__ExtendedStats.html">HeapMem_ExtendedStats</a> *&#160;</td>
          <td class="paramname"><em>statBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the extended statistics for a HeapMem instance. </p>
<p>This function retrieves the extended statistics for a HeapMem instance. It does not retrieve the standard xdc.runtime.Memory.Stats information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>heap handle </td></tr>
    <tr><td class="paramname">statBuf</td><td>Location for the returned extended statistics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a8874a46f8adb4df3e1dcd8be8fe4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8874a46f8adb4df3e1dcd8be8fe4be">&sect;&nbsp;</a></span>HeapMem_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HeapMem_Handle HeapMem_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code>HeapMem</code> heap. </p>
<p>This heap is a growth-only heap that is intended to be used by systems that never delete objects or free memory. Objects can be created at runtime based on values determined at runtime, but objects can not be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>optional parameters </td></tr>
    <tr><td class="paramname">eb</td><td>error block</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HeapMem</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63984204eae0eb8b6194d22ae8cd729f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63984204eae0eb8b6194d22ae8cd729f">&sect;&nbsp;</a></span>HeapMem_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HeapMem_Handle HeapMem_construct </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Struct *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <code>HeapMem</code> heap. </p>
<p>HeapMem_construct is equivalent to HeapMem_create except that the HeapMem_Struct is pre-allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to a HeapMem object </td></tr>
    <tr><td class="paramname">params</td><td>optional parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HeapMem</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2575628be420cbf02a8c6ed04dd05ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2575628be420cbf02a8c6ed04dd05ace">&sect;&nbsp;</a></span>HeapMem_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMem_delete </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Handle *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a <code>HeapMem</code> heap. </p>
<p>Note that HeapMem_delete takes a pointer to a HeapMem_Handle which enables HeapMem_delete to set the HeapMem handle to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>pointer to a HeapMem handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9487f7810fccdc76779d58c5de863f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9487f7810fccdc76779d58c5de863f4">&sect;&nbsp;</a></span>HeapMem_destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMem_destruct </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Struct *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct a <code>HeapMem</code> heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to a HeapMem objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a942ca4391e6d2cc51707552924f34ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942ca4391e6d2cc51707552924f34ad2">&sect;&nbsp;</a></span>HeapMem_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMem_restore </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Handle&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore heap to its original created state. </p>
<p>This function restores a heap to its original created state. Any memory previously allocated from the heap is no longer valid after this API is called. This function does not check whether there is allocated memory or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>heap handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2ceacc5e6782cff038b76aaa34c4f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ceacc5e6782cff038b76aaa34c4f02">&sect;&nbsp;</a></span>HeapMem_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMem_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize instance at runtime. </p>
<p>This function is plugged as a Startup.firstFxn so that the HeapMem objects are ready and usable by malloc() and <a class="el" href="Memory_8h.html#a8efb8cff93d5409ff1991152cc398092" title="Allocate a block of memory from a heap. ">Memory_alloc()</a> by the time the module startup functions get called so that any calls to atexit(), which in some targets invokes malloc(), will be handled cleanly. </p>

</div>
</div>
<a id="ab9f3cf46d0cff27e384fa67d3547cd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f3cf46d0cff27e384fa67d3547cd45">&sect;&nbsp;</a></span>HeapMem_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMem_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> structure with default values. </p>
<p>HeapMem_Params_init initializes the <a class="el" href="structHeapMem__Params.html">HeapMem_Params</a> structure with default values. HeapMem_Params_init should always be called before setting individual parameter fields. This allows new fields to be added in the future with compatible defaults &ndash; existing source code does not need to change when new fields are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prms</td><td>pointer to uninitialized params structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f9e9e2be97d440899685b2849ac3f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9e9e2be97d440899685b2849ac3f66">&sect;&nbsp;</a></span>HeapMem_Object_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HeapMem_Handle HeapMem_Object_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return handle of the first HeapMem on HeapMem list </p>
<p>Return the handle of the first HeapMem on the create/construct list. NULL if no HeapMems have been created or constructed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HeapMem</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad72b738d7a43eaf46f71741e80b498e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72b738d7a43eaf46f71741e80b498e8">&sect;&nbsp;</a></span>HeapMem_Object_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HeapMem_Handle HeapMem_Object_next </td>
          <td>(</td>
          <td class="paramtype">HeapMem_Handle&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return handle of the next HeapMem on HeapMem list </p>
<p>Return the handle of the next HeapMem on the create/construct list. NULL if no more HeapMems are on the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>HeapMem handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HeapMem</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
