<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SYS/BIOS: /home/developer/.conan/data/tirtos/7.03.00.10/library-sb/ga/build/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/kernel/tirtos7/packages/ti/sysbios/heaps/HeapMultiBuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SYS/BIOS
   &#160;<span id="projectnumber">7.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_166a36ee10a8457f2f1d507eafd683e9.html">developer</a></li><li class="navelem"><a class="el" href="dir_ab47aaff52849945b02749b38626f831.html">.conan</a></li><li class="navelem"><a class="el" href="dir_2db58af45ff07475e1865bb6cfecd114.html">data</a></li><li class="navelem"><a class="el" href="dir_73aa28e1938cea8ca02173a6a02bb3cc.html">tirtos</a></li><li class="navelem"><a class="el" href="dir_b92035bd439bf87970152b15ca557739.html">7.03.00.10</a></li><li class="navelem"><a class="el" href="dir_a8aafc4147cd9aeef51c3eea0146f858.html">library-sb</a></li><li class="navelem"><a class="el" href="dir_cd46cd47afafa592114402c4301543d5.html">ga</a></li><li class="navelem"><a class="el" href="dir_2cab851584a752880681e90a2dfd4edd.html">build</a></li><li class="navelem"><a class="el" href="dir_5697d1fa77239cd87167d697b8481edf.html">5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9</a></li><li class="navelem"><a class="el" href="dir_a25849b87dcee5ac6bd91808e0cfd56f.html">kernel</a></li><li class="navelem"><a class="el" href="dir_62fe09a765bfb79fe774e523a5e63239.html">tirtos7</a></li><li class="navelem"><a class="el" href="dir_e3f05480a1de819db6de4292a46ffd2c.html">packages</a></li><li class="navelem"><a class="el" href="dir_c9091c0837bc7d5e21af62b18a8f3d2f.html">ti</a></li><li class="navelem"><a class="el" href="dir_e302b19c208f2b8f03cb96305b4c2fcc.html">sysbios</a></li><li class="navelem"><a class="el" href="dir_ce87a5de68fe1c9da3cbae73cb85ff7e.html">heaps</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HeapMultiBuf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Multiple fixed size buffer heap manager. </p>
<p>The HeapMultiBuf manager provides functions to allocate and free storage from a heap of type HeapMultiBuf which inherits from IHeap. HeapMultiBuf manages multiple fixed-size memory buffers. Each buffer contains a fixed number of allocable memory 'blocks' of the same size. Simply put, a HeapMultiBuf instance manages a collection of HeapBuf instances. HeapMultiBuf is intended as a fast and deterministic memory manager which can service requests for blocks of arbitrary size.</p>
<p>An example HeapMultiBuf instance might have sixteen 32-byte blocks in one buffer, and four 128-byte blocks in another buffer. A request for memory will be serviced by the smallest possible block, so a request for 100 bytes would receive a 128-byte block in our example.</p>
<p>Allocating from HeapMultiBuf will try to return a block from the first buffer which has:</p>
<ol type="1">
<li>A block size that is &gt;= to the requested size</li>
</ol>
<p>AND</p>
<ol type="1">
<li>An alignment that is &gt;= to the requested alignment</li>
</ol>
<p>If the first matching buffer is empty, HeapMultiBuf will only continue searching for a block if 'block borrowing' is enabled (see Block Borrowing).</p>
<p> 
 <h4>HeapMultiBuf and HeapBuf</h4>
 The HeapMultiBuf module is built on top of the HeapBuf module. Each buffer
 in a HeapMultiBuf is in fact managed by a HeapBuf instance. Configuration
 of a HeapMultiBuf is done by providing an array of configured HeapBuf
 parameter structures. Refer to the HeapBuf documentation for information on
 the buffer parameters. All of the documentation and parameters for HeapBuf
 apply equally to HeapMultiBuf.
 Another consequence of this is that configuration checking is left to the
 HeapBuf module. If a buffer in a HeapMultiBuf has been incorrectly
 configured (with blockSize = 0, for example), HeapBuf, not HeapMultiBuf,
 will raise an Assert.
 Since HeapMultiBuf is built on HeapBuf, it simply performs the logic to
 determine which HeapBuf to allocate a block from or which HeapBuf to free
 a block to.

</p>
<h4>Configuration Example</h4>
<p>The following configuration code creates a HeapMultiBuf instance which manages 3 pools of 10 blocks each, with block sizes of 64, 128 and 256.</p>
<div class="fragment"><div class="line">var HeapMultiBuf = xdc.useModule(<span class="stringliteral">&#39;ti.sysbios.heaps.HeapMultiBuf&#39;</span>);</div><div class="line">var HeapBuf = xdc.useModule(<span class="stringliteral">&#39;ti.sysbios.heaps.HeapBuf&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Create parameter structure for HeapMultiBuf instance.</span></div><div class="line">var hmbParams = <span class="keyword">new</span> HeapMultiBuf.Params();</div><div class="line">hmbParams.numBufs = 3;</div><div class="line"></div><div class="line"><span class="comment">// Create the parameter structures for each of the three</span></div><div class="line"><span class="comment">// HeapBufs to be managed by the HeapMultiBuf instance.</span></div><div class="line">hmbParams.bufParams.$add(<span class="keyword">new</span> HeapBuf.Params());</div><div class="line">hmbParams.bufParams[0].blockSize = 64;</div><div class="line">hmbParams.bufParams[0].numBlocks = 10;</div><div class="line"></div><div class="line">hmbParams.bufParams.$add(<span class="keyword">new</span> HeapBuf.Params());</div><div class="line">hmbParams.bufParams[1].blockSize = 128;</div><div class="line">hmbParams.bufParams[1].numBlocks = 10;</div><div class="line"></div><div class="line">hmbParams.bufParams.$add(<span class="keyword">new</span> HeapBuf.Params());</div><div class="line">hmbParams.bufParams[2].blockSize = 256;</div><div class="line">hmbParams.bufParams[2].numBlocks = 10;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Create the HeapMultiBuf instance, and assign the global handle</span></div><div class="line"><span class="comment">// &#39;multiBufHeap&#39; to it. Add &#39;#include &lt;xdc/cfg/global.h&gt;&#39; to your</span></div><div class="line"><span class="comment">// .c file to reference the instance by this handle.</span></div><div class="line">Program.global.multiBufHeap = HeapMultiBuf.create(hmbParams);</div></div><!-- fragment --><p> 
 <h4>Block Borrowing</h4>
 HeapMultiBuf can support "block borrowing". With this feature turned on,
 if a request is made for a 32-byte block and none are available,
 HeapMultiBuf will continue looking for an available block in other buffers.
 When a borrowed block is freed, it will be returned back to its original
 buffer. Enabling Block Borrowing changes the determinism of alloc, since it
 may have to check any number of buffers to find an available block.

 Block borrowing may also occur, even if it is disabled, if a block of a
 particular size is requested with an alignment that is greater than the
 configured alignment for that block size. For example, a HeapMultiBuf is
 configured with a buffer of 32-byte blocks with an alignment of 8, and
 a buffer of 64-byte blocks with an alignment of 16. If a request is made
 for a 32-byte block with an alignment of 16, it will be serviced by the
 buffer of 64-byte blocks.

 <h4>Static vs. Dynamic Creation</h4>
 As with HeapBuf, a statically created HeapMultiBuf instance will ignore the
 bufSize and buf parameters. Dynamic creates require all of the parameters.

 It should be noted that static creates are ideal if code space is a
 concern; dynamically creating a HeapMultiBuf requires a relatively large
 amount of initialization code to be pulled in to the executable.

 <h4>Block Sizes and Alignment</h4>
</p>
<ul>
<li>A buffer with a requested alignment of 0 will receive the target- specific minimum alignment. - The actual block sizes will be a multiple of the alignment. For example, if a buffer is configured to have 56-byte blocks with an alignment of 32, HeapMultiBuf will actually create 64-byte blocks. When providing the buffer for a dynamic create, make sure it is large enough to take this into account. - Multiple buffers with the same block size ARE allowed. This may occur, for example, if sizeof is used to specify the block sizes. - If any buffers have both the same block size and alignment, they will be merged. If this is a problem, consider managing these buffers directly with HeapBuf objects.</li>
</ul>
<p> 
 <h4>Real-Time Concerns</h4>
 Allocation from and freeing to a HeapMultiBuf instance is non-blocking.

 HeapMultiBuf is deterministic:
</p>
<ul>
<li>A call to alloc will always take the same amount of time for a given block size (with block borrowing disabled). - The worst case call to free is constant and proportional to the number of buffers managed.</li>
</ul>
<p> 
 <h4>Restrictions</h4>
</p>
<ul>
<li>Align parameters must be a power of 2. - The buffers passed to dynamically create a HeapMultiBuf must be aligned according to the alignment parameter, and must be large enough to account for the actual block size after it has been rounded up to a multiple of the alignment. - Buffers must be provided to dynamically create a HeapMultiBuf, and cannot be provided to statically create a HeapMultiBuf.</li>
</ul>
<p> 
 <h4>Unconstrained Functions</h4>
 All functions

<h3> Calling Context </h3> <table border="1" cellpadding="3">
<colgroup span="1"></colgroup>
<colgroup span="5" align="center"></colgroup>

<tr><th> Function    </th><th>  Hwi   </th><th>  Swi   </th> <th>  Task
</th><th>  Main  </th><th>  Startup  </th></tr> <!--
--> <tr><td> Params_init      </td><td>   Y    </td><td>   Y    </td> <td>
Y    </td><td>   Y    </td><td>   Y    </td></tr> <tr><td> alloc
</td><td>   Y    </td><td>   Y    </td> <td>   Y    </td><td>   Y
</td><td>   N    </td></tr> <tr><td> construct        </td><td>   N*
</td><td>   N*   </td> <td>   Y    </td><td>   Y    </td><td>   N
</td></tr> <tr><td> create           </td><td>   N*   </td><td>   N*   </td>
<td>   Y    </td><td>   Y    </td><td>   N    </td></tr> <tr><td> delete
</td><td>   N*   </td><td>   N*   </td> <td>   Y    </td><td>   Y
</td><td>   N    </td></tr> <tr><td> destruct         </td><td>   N*
</td><td>   N*   </td> <td>   Y    </td><td>   Y    </td><td>   N
</td></tr> <tr><td> free             </td><td>   Y    </td><td>   Y    </td>
<td>   Y    </td><td>   Y    </td><td>   N    </td></tr> <tr><td> getStats
</td><td>   Y    </td><td>   Y    </td> <td>   Y    </td><td>   Y
</td><td>   N    </td></tr> <tr><td> isBlocking       </td><td>   Y
</td><td>   Y    </td> <td>   Y    </td><td>   Y    </td><td>   N
</td></tr> <tr><td colspan="6"> Definitions: <br /> <ul> <li> <b>Hwi</b>: API
is callable from a Hwi thread. </li> <li> <b>Swi</b>: API is callable from a
Swi thread. </li> <li> <b>Task</b>: API is callable from a Task thread. </li>
<li> <b>Main</b>: API is callable during any of these phases: </li> <ul> <li>
In your module startup after this module is started (e.g.
HeapMultiBuf_Module_startupDone() returns true). </li> <li> During
xdc.runtime.Startup.lastFxns. </li> <li> During main().</li> <li> During
BIOS.startupFxns.</li> </ul> <li> <b>Startup</b>: API is callable during any
of these phases:</li> <ul> <li> During xdc.runtime.Startup.firstFxns.</li>
<li> In your module startup before this module is started (e.g.
HeapMultiBuf_Module_startupDone() returns false).</li> </ul> <li> <b>*</b>:
Assuming blocking Heap is used for creation. </li> <li> <b>**</b>: Assuming
GateMutex is used as HeapMem's Gate. </li> <li> <b>+</b> : Cannot use HeapMem
object while it is being restored. </li> </ul> </td></tr>

</table>

 </p>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="HeapBuf_8h_source.html">ti/sysbios/heaps/HeapBuf.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Error_8h_source.html">ti/sysbios/runtime/Error.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="IHeap_8h_source.html">ti/sysbios/runtime/IHeap.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Memory_8h_source.html">ti/sysbios/runtime/Memory.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for HeapMultiBuf.h:</div>
<div class="dyncontent">
<div class="center"><img src="HeapMultiBuf_8h__incl.png" border="0" usemap="#_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2heaps_2HeapMultiBuf_8h" alt=""/></div>
<map name="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2heaps_2HeapMultiBuf_8h" id="_2home_2developer_2_8conan_2data_2tirtos_27_803_800_810_2library-sb_2ga_2build_25ab84d6acfe1f23c4fae0ab88f26e3a396351ac9_2kernel_2tirtos7_2packages_2ti_2sysbios_2heaps_2HeapMultiBuf_8h">
<area shape="rect" id="node5" href="HeapBuf_8h.html" title="Fixed size buffer heap manager. " alt="" coords="181,124,379,151"/>
<area shape="rect" id="node7" href="Error_8h.html" title="Runtime error manager. " alt="" coords="347,377,485,419"/>
<area shape="rect" id="node8" href="IHeap_8h.html" title="Interface to heap functions. " alt="" coords="504,199,643,240"/>
<area shape="rect" id="node9" href="Memory_8h.html" title="Static and run&#45;time memory manager. " alt="" coords="504,288,643,329"/>
<area shape="rect" id="node6" href="Queue_8h.html" title="Queue Manager. " alt="" coords="195,295,362,322"/>
</map>
</div>
</div>
<p><a href="HeapMultiBuf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a55b2e676c423882e59e37952f0021015"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a55b2e676c423882e59e37952f0021015">HeapMultiBuf_A_blockNotFreed</a>&#160;&#160;&#160;&quot;Invalid block address on the free. Failed to free block back to heap.&quot;</td></tr>
<tr class="memdesc:a55b2e676c423882e59e37952f0021015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid block pointer.  <a href="#a55b2e676c423882e59e37952f0021015">More...</a><br /></td></tr>
<tr class="separator:a55b2e676c423882e59e37952f0021015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb218d14a82328145ea71463b514645"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#aedb218d14a82328145ea71463b514645">HeapMultiBuf_E_size</a>&#160;&#160;&#160;&quot;requested size is too big: handle=0x%x, size=%u&quot;</td></tr>
<tr class="memdesc:aedb218d14a82328145ea71463b514645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised when requested size exceeds all blockSizes.  <a href="#aedb218d14a82328145ea71463b514645">More...</a><br /></td></tr>
<tr class="separator:aedb218d14a82328145ea71463b514645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6ef2b8908c57f33ad2f5d399f5be7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a4bd6ef2b8908c57f33ad2f5d399f5be7">ti_sysbios_heaps_HeapMultiBuf_Handle_upCast</a>(handle)&#160;&#160;&#160;((IHeap_Handle)(handle))</td></tr>
<tr class="memdesc:a4bd6ef2b8908c57f33ad2f5d399f5be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast handle to an IHeap_Handle for use by Memory_alloc, etc.  <a href="#a4bd6ef2b8908c57f33ad2f5d399f5be7">More...</a><br /></td></tr>
<tr class="separator:a4bd6ef2b8908c57f33ad2f5d399f5be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0724fcf05b38d545ea310bfd4387096f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a></td></tr>
<tr class="separator:a0724fcf05b38d545ea310bfd4387096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066da8e983f68f13f88639a7186e9747"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a066da8e983f68f13f88639a7186e9747">HeapMultiBuf_Object</a></td></tr>
<tr class="separator:a066da8e983f68f13f88639a7186e9747"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaf3839eed8066ee9246bab80e9dc9646"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#aaf3839eed8066ee9246bab80e9dc9646">HeapMultiBuf_alloc</a> (<a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> handle, size_t size, size_t align, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:aaf3839eed8066ee9246bab80e9dc9646"><td class="mdescLeft">&#160;</td><td class="mdescRight">HeapMultiBuf will return a block that is &gt;= 'size' with an alignment that is &gt;= 'align'. The HeapMultiBuf will attempt to service a request for any size; the specified size does not need to match the configured block sizes of the buffers.  <a href="#aaf3839eed8066ee9246bab80e9dc9646">More...</a><br /></td></tr>
<tr class="separator:aaf3839eed8066ee9246bab80e9dc9646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37f2c909e2f483d20a13ad52e411042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#ad37f2c909e2f483d20a13ad52e411042">HeapMultiBuf_free</a> (<a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> handle, void *buf, size_t size)</td></tr>
<tr class="memdesc:ad37f2c909e2f483d20a13ad52e411042"><td class="mdescLeft">&#160;</td><td class="mdescRight">HeapMultiBuf ignores the 'size' parameter to free. It determines the correct buffer to free the block to by comparing addresses.  <a href="#ad37f2c909e2f483d20a13ad52e411042">More...</a><br /></td></tr>
<tr class="separator:ad37f2c909e2f483d20a13ad52e411042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361f750a8bc4949a2c4bdf5a4b65ca39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a361f750a8bc4949a2c4bdf5a4b65ca39">HeapMultiBuf_isBlocking</a> (<a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> handle)</td></tr>
<tr class="memdesc:a361f750a8bc4949a2c4bdf5a4b65ca39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function always returns false since the alloc/free never block on a resource.  <a href="#a361f750a8bc4949a2c4bdf5a4b65ca39">More...</a><br /></td></tr>
<tr class="separator:a361f750a8bc4949a2c4bdf5a4b65ca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb1dca92d45744da863630f50f90403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a5eb1dca92d45744da863630f50f90403">HeapMultiBuf_getStats</a> (<a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> handle, <a class="el" href="structMemory__Stats.html">Memory_Stats</a> *statBuf)</td></tr>
<tr class="memdesc:a5eb1dca92d45744da863630f50f90403"><td class="mdescLeft">&#160;</td><td class="mdescRight">get memory stats for a HeapMultiBuf object  <a href="#a5eb1dca92d45744da863630f50f90403">More...</a><br /></td></tr>
<tr class="separator:a5eb1dca92d45744da863630f50f90403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fccbfe9e5198bd46340d242996d264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#aa9fccbfe9e5198bd46340d242996d264">HeapMultiBuf_create</a> (const <a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> *params, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:aa9fccbfe9e5198bd46340d242996d264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>HeapMultiBuf</code> heap.  <a href="#aa9fccbfe9e5198bd46340d242996d264">More...</a><br /></td></tr>
<tr class="separator:aa9fccbfe9e5198bd46340d242996d264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d836390ca9a01e2feb1bbbbf77a7af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a75d836390ca9a01e2feb1bbbbf77a7af">HeapMultiBuf_construct</a> (<a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a> *obj, const <a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> *params, <a class="el" href="structError__Block.html">Error_Block</a> *eb)</td></tr>
<tr class="memdesc:a75d836390ca9a01e2feb1bbbbf77a7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code>HeapMultiBuf</code> heap.  <a href="#a75d836390ca9a01e2feb1bbbbf77a7af">More...</a><br /></td></tr>
<tr class="separator:a75d836390ca9a01e2feb1bbbbf77a7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad764bdaf15495a37f1ddb36a7ef781f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#ad764bdaf15495a37f1ddb36a7ef781f8">HeapMultiBuf_delete</a> (<a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> *handle)</td></tr>
<tr class="memdesc:ad764bdaf15495a37f1ddb36a7ef781f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a <code>HeapMultiBuf</code> heap.  <a href="#ad764bdaf15495a37f1ddb36a7ef781f8">More...</a><br /></td></tr>
<tr class="separator:ad764bdaf15495a37f1ddb36a7ef781f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409c4542539be401cdc353d3a136da1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a409c4542539be401cdc353d3a136da1f">HeapMultiBuf_destruct</a> (<a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a> *obj)</td></tr>
<tr class="memdesc:a409c4542539be401cdc353d3a136da1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a <code>HeapMultiBuf</code> heap.  <a href="#a409c4542539be401cdc353d3a136da1f">More...</a><br /></td></tr>
<tr class="separator:a409c4542539be401cdc353d3a136da1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7164881e1e1ff8d8f1b225f1ad833f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a2d7164881e1e1ff8d8f1b225f1ad833f">HeapMultiBuf_Params_init</a> (<a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> *prms)</td></tr>
<tr class="memdesc:a2d7164881e1e1ff8d8f1b225f1ad833f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> structure with default values.  <a href="#a2d7164881e1e1ff8d8f1b225f1ad833f">More...</a><br /></td></tr>
<tr class="separator:a2d7164881e1e1ff8d8f1b225f1ad833f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afd2c773b259eaf484348d0ffc86e30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a5afd2c773b259eaf484348d0ffc86e30">HeapMultiBuf_Object_first</a> (void)</td></tr>
<tr class="memdesc:a5afd2c773b259eaf484348d0ffc86e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">return handle of the first HeapMultiBuf on HeapMultiBuf list  <a href="#a5afd2c773b259eaf484348d0ffc86e30">More...</a><br /></td></tr>
<tr class="separator:a5afd2c773b259eaf484348d0ffc86e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f80c89b2749087566a90d42e15333ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HeapMultiBuf_8h.html#a7f80c89b2749087566a90d42e15333ed">HeapMultiBuf_Object_next</a> (<a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> heap)</td></tr>
<tr class="memdesc:a7f80c89b2749087566a90d42e15333ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">return handle of the next HeapMultiBuf on HeapMultiBuf list  <a href="#a7f80c89b2749087566a90d42e15333ed">More...</a><br /></td></tr>
<tr class="separator:a7f80c89b2749087566a90d42e15333ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a55b2e676c423882e59e37952f0021015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b2e676c423882e59e37952f0021015">&sect;&nbsp;</a></span>HeapMultiBuf_A_blockNotFreed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HeapMultiBuf_A_blockNotFreed&#160;&#160;&#160;&quot;Invalid block address on the free. Failed to free block back to heap.&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid block pointer. </p>
<p>This Assert is raised if a call to free does not successfully free the block back to any of the buffers. Indicates that the block pointer is invalid, or that the HeapMultiBuf state has been corrupted. </p>

</div>
</div>
<a id="aedb218d14a82328145ea71463b514645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb218d14a82328145ea71463b514645">&sect;&nbsp;</a></span>HeapMultiBuf_E_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HeapMultiBuf_E_size&#160;&#160;&#160;&quot;requested size is too big: handle=0x%x, size=%u&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised when requested size exceeds all blockSizes. </p>

</div>
</div>
<a id="a4bd6ef2b8908c57f33ad2f5d399f5be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6ef2b8908c57f33ad2f5d399f5be7">&sect;&nbsp;</a></span>ti_sysbios_heaps_HeapMultiBuf_Handle_upCast</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ti_sysbios_heaps_HeapMultiBuf_Handle_upCast</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle</td><td>)</td>
          <td>&#160;&#160;&#160;((IHeap_Handle)(handle))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast handle to an IHeap_Handle for use by Memory_alloc, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>heap handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IHeap_Handle</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0724fcf05b38d545ea310bfd4387096f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0724fcf05b38d545ea310bfd4387096f">&sect;&nbsp;</a></span>HeapMultiBuf_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef  struct <a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a> * <a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a066da8e983f68f13f88639a7186e9747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066da8e983f68f13f88639a7186e9747">&sect;&nbsp;</a></span>HeapMultiBuf_Object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a> <a class="el" href="HeapMultiBuf_8h.html#a066da8e983f68f13f88639a7186e9747">HeapMultiBuf_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaf3839eed8066ee9246bab80e9dc9646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3839eed8066ee9246bab80e9dc9646">&sect;&nbsp;</a></span>HeapMultiBuf_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* HeapMultiBuf_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HeapMultiBuf will return a block that is &gt;= 'size' with an alignment that is &gt;= 'align'. The HeapMultiBuf will attempt to service a request for any size; the specified size does not need to match the configured block sizes of the buffers. </p>

</div>
</div>
<a id="ad37f2c909e2f483d20a13ad52e411042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37f2c909e2f483d20a13ad52e411042">&sect;&nbsp;</a></span>HeapMultiBuf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMultiBuf_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HeapMultiBuf ignores the 'size' parameter to free. It determines the correct buffer to free the block to by comparing addresses. </p>

</div>
</div>
<a id="a361f750a8bc4949a2c4bdf5a4b65ca39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361f750a8bc4949a2c4bdf5a4b65ca39">&sect;&nbsp;</a></span>HeapMultiBuf_isBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HeapMultiBuf_isBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function always returns false since the alloc/free never block on a resource. </p>

</div>
</div>
<a id="a5eb1dca92d45744da863630f50f90403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb1dca92d45744da863630f50f90403">&sect;&nbsp;</a></span>HeapMultiBuf_getStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMultiBuf_getStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMemory__Stats.html">Memory_Stats</a> *&#160;</td>
          <td class="paramname"><em>statBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get memory stats for a HeapMultiBuf object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>heap handle </td></tr>
    <tr><td class="paramname">statBuf</td><td>pointer to a <a class="el" href="structMemory__Stats.html">Memory_Stats</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9fccbfe9e5198bd46340d242996d264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fccbfe9e5198bd46340d242996d264">&sect;&nbsp;</a></span>HeapMultiBuf_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> HeapMultiBuf_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code>HeapMultiBuf</code> heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>optional parameters </td></tr>
    <tr><td class="paramname">eb</td><td>error block</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HeapMultiBuf</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d836390ca9a01e2feb1bbbbf77a7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d836390ca9a01e2feb1bbbbf77a7af">&sect;&nbsp;</a></span>HeapMultiBuf_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> HeapMultiBuf_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structError__Block.html">Error_Block</a> *&#160;</td>
          <td class="paramname"><em>eb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <code>HeapMultiBuf</code> heap. </p>
<p>HeapMultiBuf_construct is equivalent to HeapMultiBuf_create except that the <a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a> is pre-allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to a HeapMultiBuf object </td></tr>
    <tr><td class="paramname">params</td><td>optional parameters </td></tr>
    <tr><td class="paramname">eb</td><td>error block</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HeapMultiBuf</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad764bdaf15495a37f1ddb36a7ef781f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad764bdaf15495a37f1ddb36a7ef781f8">&sect;&nbsp;</a></span>HeapMultiBuf_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMultiBuf_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a <code>HeapMultiBuf</code> heap. </p>
<p>Note that HeapMultiBuf_delete takes a pointer to a HeapMultiBuf_Handle which enables HeapMultiBuf_delete to set the HeapMultiBuf handle to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>pointer to a HeapMultiBuf handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409c4542539be401cdc353d3a136da1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409c4542539be401cdc353d3a136da1f">&sect;&nbsp;</a></span>HeapMultiBuf_destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMultiBuf_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeapMultiBuf__Struct.html">HeapMultiBuf_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct a <code>HeapMultiBuf</code> heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to a HeapMultiBuf objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d7164881e1e1ff8d8f1b225f1ad833f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7164881e1e1ff8d8f1b225f1ad833f">&sect;&nbsp;</a></span>HeapMultiBuf_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HeapMultiBuf_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> *&#160;</td>
          <td class="paramname"><em>prms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> structure with default values. </p>
<p>HeapMultiBuf_Params_init initializes the <a class="el" href="structHeapMultiBuf__Params.html">HeapMultiBuf_Params</a> structure with default values. HeapMultiBuf_Params_init should always be called before setting individual parameter fields. This allows new fields to be added in the future with compatible defaults &ndash; existing source code does not need to change when new fields are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prms</td><td>pointer to uninitialized params structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5afd2c773b259eaf484348d0ffc86e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afd2c773b259eaf484348d0ffc86e30">&sect;&nbsp;</a></span>HeapMultiBuf_Object_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> HeapMultiBuf_Object_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return handle of the first HeapMultiBuf on HeapMultiBuf list </p>
<p>Return the handle of the first HeapMultiBuf on the create/construct list. NULL if no HeapMultiBufs have been created or constructed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HeapMultiBuf</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f80c89b2749087566a90d42e15333ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f80c89b2749087566a90d42e15333ed">&sect;&nbsp;</a></span>HeapMultiBuf_Object_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a> HeapMultiBuf_Object_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HeapMultiBuf_8h.html#a0724fcf05b38d545ea310bfd4387096f">HeapMultiBuf_Handle</a>&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return handle of the next HeapMultiBuf on HeapMultiBuf list </p>
<p>Return the handle of the next HeapMultiBuf on the create/construct list. NULL if no more HeapMultiBufs are on the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>HeapMultiBuf handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HeapMultiBuf</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
