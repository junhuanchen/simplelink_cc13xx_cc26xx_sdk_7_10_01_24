<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <title>SysconfigDoc</title>
    <link href="doxygen/m0/html/tiapistylesheet.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <table width="100%">
      <tbody><tr>
        <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="doxygen/m0/html/tilogo.gif" /></a></td>
        <td bgcolor="red"><img src="doxygen/m0/html/titagline.gif" /></td>
     </tr></tbody>
    </table>
    <div class="contents">
      <div class="textblock">
        <div id="BIOS_Configuration_Options">
          <h2 class="groupheader" title="Summary of all BIOS configuration options">BIOS Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_cpuFrequency"><code>.cpuFrequency</code></a><code> = 48000000;</code></td><td><code>// CPU Frequency (Hz)</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_assertsEnabled"><code>.assertsEnabled</code></a><code> = true;</code></td><td><code>// Enable Asserts</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_rtsGateType"><code>.rtsGateType</code></a><code> = 'BIOS_GateMutex';</code></td><td><code>// Runtime Support Library Lock Type</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_heapType"><code>.heapType</code></a><code> = 'HeapMem';</code></td><td><code>// Default Memory Heap Type</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_heapSize"><code>.heapSize</code></a><code> = 4096;</code></td><td><code>// Heap Size</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_heapBaseAddr"><code>.heapBaseAddr</code></a><code> = '';</code></td><td><code>// Base Address For Heap Buffer</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_heapEndAddr"><code>.heapEndAddr</code></a><code> = '';</code></td><td><code>// End Address For Heap Buffer</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_heapTrackEnabled"><code>.heapTrackEnabled</code></a><code> = false;</code></td><td><code>// Use HeapTrack With Default Heap</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_disableTask"><code>.disableTask</code></a><code> = false;</code></td><td><code>// Disable Task</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_disableSwi"><code>.disableSwi</code></a><code> = false;</code></td><td><code>// Disable Swi</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_disableClock"><code>.disableClock</code></a><code> = false;</code></td><td><code>// Disable Clock</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_logsEnabled"><code>.logsEnabled</code></a><code> = false;</code></td><td><code>// Enable Logs</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_runtimeCreatesEnabled"><code>.runtimeCreatesEnabled</code></a><code> = true;</code></td><td><code>// Enable Runtime Creates</code></td></tr>
            <tr><td><var>BIOS</var><a href="#ti_sysbios_BIOS_compileFiles"><code>.compileFiles</code></a><code> = true;</code></td><td><code>// Compile Source Files</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="BIOS_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the BIOS driver as a whole">BIOS Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_cpuFrequency"></a>CPU Frequency (Hz)
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.cpuFrequency = 48000000]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_assertsEnabled"></a>Enable Asserts
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.assertsEnabled = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> SYS/BIOS Assert checking in Custom SYS/BIOS
                library enable flag<p /><p>When set to false, Assert checking code is removed from the final compiled kernel. This option can considerably improve
runtime performance as well as significantly reduce the application&#39;s code size.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_rtsGateType"></a>Runtime Support Library Lock Type
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.rtsGateType = 'BIOS_GateMutex']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Gate to make sure TI RTS library APIs are re-
                entrant<p /><p>The application gets to determine the type of gate (lock) that is used in the TI RTS library. The gate will be used to
guarantee re-entrancy of the RTS APIs.</p>
<p>The type of gate depends on the type of threads that are going to be calling into the RTS library.  For example, if
both Swi and Task threads are going to be calling the RTS library&#39;s printf, GateSwi should be used. In this case, Hwi
threads are not impacted (i.e. disabled) during the printf calls from the Swi or Task threads.</p>
<p>If NoLocking is used, the RTS lock is not plugged and re-entrancy for the TI RTS library calls are not guaranteed. The
application can plug the RTS locks directly if it wants.</p>
<p>Numerous gate types are provided by SYS/BIOS.  Each has its advantages and disadvantages.  The following list
summarizes when each type is appropriate for protecting an underlying non-reentrant RTS library.</p>
<ul>
<li><p>GateHwi: Interrupts are disabled and restored to maintain re-entrancy. Use if only making RTS calls from a Hwi, Swi
and/or Task.</p>
</li>
<li><p>GateSwi: Swis are disabled and restored to maintain re-entrancy. Use if only making RTS calls from a Swi and/or
Task.</p>
</li>
<li><p>GateMutex: A single mutex is used to maintain re-entrancy.  Use if only making RTS calls from a Task.  Blocks only
Tasks that are also trying to execute critical regions of RTS library.</p>
</li>
<li><p>GateMutexPri: A priority inheriting mutex is used to maintain re-entrancy. Blocks only Tasks that are also trying to
execute critical regions of RTS library.  Raises the priority of the Task that is executing the critical region in
the RTS library to the level of the highest priority Task that is block by the mutex.</p>
</li>
</ul>
<p>The default value of rtsGateType depends on the type of threading model enabled by other configuration parameters. If
taskEnabled is true, GateMutex is used. If swiEnabled is true and taskEnabled is false: GateSwi is used. If both
swiEnabled and taskEnabled are false: xdc.runtime#GateNull is used.</p>
<p>If taskEnabled is false, the user should not select GateMutex (or other Task level gates). Similarly, if taskEnabled
and swiEnabledare false, the user should not select GateSwi or the Task level gates.</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'BIOS_NoLocking'</code></td><td style="padding:10px"><code>No lock</code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'BIOS_GateHwi'</code></td><td style="padding:10px"><code>GateHwi</code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'BIOS_GateSwi'</code></td><td style="padding:10px"><code>GateSwi</code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'BIOS_GateMutex'</code></td><td style="padding:10px"><code>GateMutex</code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'BIOS_GateMutexPri'</code></td><td style="padding:10px"><code>GateMutexPri</code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_heapType"></a>Default Memory Heap Type
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.heapType = 'HeapMem']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p /><p>Specifies the type of heap to use for the system heap. The system heap is used to allocate instance object state
structures, such as Task objects and their stacks, Semaphore objects, etc.</p>
<p>If set to &quot;HeapCallback&quot; the user must also configure the HeapCallback module with the necessary callback functions.
HeapCallback_create() will be called at initialization time with a NULL HeapCallback_Params argument.</p>
<p>If set to &quot;HeapUser&quot;, no system heap will not be created at startup. The user can create a heap at runtime and use the
Memory_setDefaultHeap() API to register the heap with the Memory module. Or, you can use this option for applications
that do not require a heap.</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'HeapMem'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'HeapMin'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'HeapCallback'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'HeapUser'</code></td><td style="padding:10px"><code>HeapUser (None)</code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_heapSize"></a>Heap Size
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.heapSize = 4096]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Size of system heap, units are in MAUs<p /><p>If the BIOS.heapType configuration parameter is set to &quot;HeapMin&quot; or &quot;HeapMem&quot;, and the BIOS.heapBaseAddr and
BIOS.heapEndAddr are not set, then the system heap will be created with this size.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_heapBaseAddr"></a>Base Address For Heap Buffer
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.heapBaseAddr = '']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Base address of system heap buffer<p /><p>The BIOS.heapBaseAddr configuration parameter defines the base address of the system heap. A symbol from the linker
command file is often used for this parameter.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_heapEndAddr"></a>End Address For Heap Buffer
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.heapEndAddr = '']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> End address of system heap buffer, plus one<p /><p>The BIOS.heapEndAddr configuration parameter defines the end address
of the system heap. A symbol from the linker command file is often used for
this parameter.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_heapTrackEnabled"></a>Use HeapTrack With Default Heap
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.heapTrackEnabled = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Use HeapTrack with system default heap<p /><p>This configuration parameter will add a HeapTrack instance on top of the
system heap. HeapTrack adds a tracker packet to every allocated buffer and
displays the information in RTOS Object Viewer (ROV). An assert will be
raised on a free if there was a buffer overflow.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_disableTask"></a>Disable Task
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.disableTask = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Disable SYS/BIOS Task services<p /><p>The following behaviors occur when taskEnabled is set to false:</p>
<ul>
<li>Static Task creation will result in a fatal build error.</li>
<li>The Idle task object is not created. (The Idle functions are invoked within the start() thread.)</li>
<li>Runtime calls to Task_create will trigger an assertion violation via xdc.runtime.Assert#isTrue.</li>
</ul>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_disableSwi"></a>Disable Swi
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.disableSwi = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Disable SYS/BIOS Swi services<p /><p>The following behaviors occur when swiEnabled is set to false:</p>
<ul>
<li>Static Swi creation will result in a fatal build error.</li>
<li>Runtime calls to Swi_create will trigger an assertion violation via xdc.runtime.Assert#isTrue.</li>
<li>See other effects as noted for clockEnabled = false;</li>
</ul>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_disableClock"></a>Disable Clock
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.disableClock = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Disable SYS/BIOS Clock services<p /><p>The following behaviors occur when clockEnabled is set to false:</p>
<ul>
<li>Static Clock creation will result in a fatal build error.</li>
<li>No Clock Swi is created.</li>
<li>The Clock_tickSource is set to Clock_TickSource_NULL to prevent a Timer object from being created.</li>
<li>For APIs that take a timeout, values other than NO_WAIT will be equivalent to WAIT_FOREVER.</li>
</ul>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_logsEnabled"></a>Enable Logs
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.logsEnabled = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> SYS/BIOS Log support in Custom SYS/BIOS library enable flag<p /><p>When set to false, all Log code is removed from the final compiled kernel. This option can considerably improve runtime
performance as well as significantly reduce the application&#39;s code size.</p>
<p><strong><em>Warning:</em></strong> When logs are generated, this setting will have the side effect of requiring task stacks to be sized
large enough to absorb two interrupt contexts rather than one. See the discussion on task stacks in Task for more
information.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_runtimeCreatesEnabled"></a>Enable Runtime Creates
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.runtimeCreatesEnabled = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Runtime instance creation enable flag.<p /><p>If set to true, Module_create() and Module_delete() are callable at runtime. Resources for these will be allocated on
the heap. If false, Module_create() and Module_delete() are not callable at runtime</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_BIOS_compileFiles"></a>Compile Source Files
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>BIOS</var><code>.compileFiles = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Clock_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Clock configuration options">Clock Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Clock</var><a href="#ti_sysbios_knl_Clock_tickPeriod"><code>.tickPeriod</code></a><code> = 1000;</code></td><td><code>// Clock Tick Period Microseconds</code></td></tr>
            <tr><td><var>Clock</var><a href="#ti_sysbios_knl_Clock_tickSource"><code>.tickSource</code></a><code> = 'Clock_TickSource_TIMER';</code></td><td><code>// Clock Tick Source</code></td></tr>
            <tr><td><var>Clock</var><a href="#ti_sysbios_knl_Clock_tickMode"><code>.tickMode</code></a><code> = 'Clock_TickMode_DYNAMIC';</code></td><td><code>// Clock Tick Mode</code></td></tr>
            <tr><td><var>Clock</var><a href="#ti_sysbios_knl_Clock_swiPriority"><code>.swiPriority</code></a><code> = 15;</code></td><td><code>// Clock Swi Priority</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Clock_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Clock driver as a whole">Clock Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Clock_tickPeriod"></a>Clock Tick Period Microseconds
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Clock</var><code>.tickPeriod = 1000]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Tick period specified in microseconds<p /><p>Default value is family dependent. For example, Linux systems often only
support a minimum period of 10000 us and multiples of 10000 us. TI platforms
have a default of 1000 us.</p>
<p>Like most other module configuration parameters, the Clock.tickPeriod config
parameter value is accessible in runtime C code as &quot;Clock_tickPeriod&quot;.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Clock_tickSource"></a>Clock Tick Source
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Clock</var><code>.tickSource = 'Clock_TickSource_TIMER']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Source of clock ticks<p /><p>&quot;Clock_TickSource_TIMER&quot;: The Clock module automatically configures a
a Timer instance to drive the Clock tick.</p>
<p>&quot;Clock_TickSource_USER&quot;: The Application is responsible for calling
&quot;Clock_tick()&quot; periodically.</p>
<p>&quot;Clock_TickSource_NULL&quot;: The Clock module is disabled.
In this case, it is an error for the application to ever call
Clock_tick().</p>
<p>If this parameter is not set to &quot;Clock_TickSource_TIMER&quot;, Clock_tickStart(),
Clock_tickStop(), and Clock_tickReconfig(), have no effect.</p>
<p>The default is &quot;Clock_TickSource_TIMER&quot;.</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'Clock_TickSource_TIMER'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"> - Timer</td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'Clock_TickSource_USER'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"> - User</td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'Clock_TickSource_NULL'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"> - None</td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Clock_tickMode"></a>Clock Tick Mode
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Clock</var><code>.tickMode = 'Clock_TickMode_DYNAMIC']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Timer tick mode<p /><p>This parameter specifies the tick mode to be used by the underlying Timer.</p>
<p>With &quot;Clock_TickMode_PERIODIC&quot; the timer will interrupt the CPU at a fixed rate,
defined by the tickPeriod.</p>
<p>With &quot;Clock_TickMode_DYNAMIC&quot; the timer can be dynamically reprogrammed by Clock, to
interrupt the CPU when the next tick is actually needed for a scheduled
timeout. &quot;Clock_TickMode_DYNAMIC&quot; is not supported on all devices, and may have some
application constraints.</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'Clock_TickMode_PERIODIC'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"> - Periodic</td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'Clock_TickMode_DYNAMIC'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"> - Dynamic</td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Clock_swiPriority"></a>Clock Swi Priority
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Clock</var><code>.swiPriority = 15]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> The priority of Swi used by Clock to process
                its instances<p /><p>All Clock instances are executed in the context of a single Swi.  This
parameter allows you to control the priority of that Swi.</p>
<p>The default value of this parameter is Swi.numPriorities - 1; i.e., the
maximum Swi priority.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->


        <div id="Idle_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Idle configuration options">Idle Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>inst</var><a href="#ti_sysbios_knl_Idle_idleFxn"><code>.idleFxn</code></a><code> = '';</code></td><td><code>// Idle Function</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->

        <div id="Idle_Instance_Configuration_Options">
          <h2 class="groupheader" title="Options that are separately set for each added Idle instance">Idle Instance Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Idle_idleFxn"></a>Idle Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Instance parameter's script
                 name and its default value">
                 [<var>inst</var><code>.idleFxn = ''</code>]
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
           </div>
          </div>
          <hr />
        </div> <!-- end Instance_Configuration_Options -->

        <div id="Semaphore_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Semaphore configuration options">Semaphore Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Semaphore</var><a href="#ti_sysbios_knl_Semaphore_supportsPriority"><code>.supportsPriority</code></a><code> = true;</code></td><td><code>// Supports Priority</code></td></tr>
            <tr><td><var>Semaphore</var><a href="#ti_sysbios_knl_Semaphore_supportsEvents"><code>.supportsEvents</code></a><code> = false;</code></td><td><code>// Supports Events</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Semaphore_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Semaphore driver as a whole">Semaphore Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Semaphore_supportsPriority"></a>Supports Priority
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Semaphore</var><code>.supportsPriority = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Support Task priority pend queuing?<p /><p>When set to &#39;true&#39;, a Semaphore can be configured to support task priority-based
queueing.</p>
<p>When set to &#39;false&#39;, all Semaphores support only first-in, first-out task queueing.</p>
<p>The default for this parameter is true.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Semaphore_supportsEvents"></a>Supports Events
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Semaphore</var><code>.supportsEvents = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Support Semaphores with Events?<p /><p>When set to &#39;true&#39;, a Semaphore can be configuered with an embedded Event object
which will get &#39;posted&#39; whenever Semaphore_post() is called.</p>
<p>When set to &#39;false&#39; no Semaphores can be configured with embedded Event objects.</p>
<p>The default for this parameter is false.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Swi_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Swi configuration options">Swi Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Swi</var><a href="#ti_sysbios_knl_Swi_numPriorities"><code>.numPriorities</code></a><code> = 16;</code></td><td><code>// Number of Swi Priorities</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Swi_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Swi driver as a whole">Swi Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Swi_numPriorities"></a>Number of Swi Priorities
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Swi</var><code>.numPriorities = 16]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Number of Swi priorities supported<p /><p>The maximum number of priorities supported is target-specific and depends on
the number of bits in a UInt data type. For 6x and ARM devices the maximum
number of priorities is therefore 32. For the C28x, the maximum number of
priorities is 16.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Task_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Task configuration options">Task Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_numPriorities"><code>.numPriorities</code></a><code> = 16;</code></td><td><code>// Number of Task Priorities</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_defaultStackSize"><code>.defaultStackSize</code></a><code> = 1024;</code></td><td><code>// Default Stack Size</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_idleTaskStackSize"><code>.idleTaskStackSize</code></a><code> = 1024;</code></td><td><code>// Idle Task's Stack Size</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_idleTaskVitalTaskFlag"><code>.idleTaskVitalTaskFlag</code></a><code> = true;</code></td><td><code>// Idle Task's "Vital Task" Flag</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_allBlockedFunc"><code>.allBlockedFunc</code></a><code> = 'NULL';</code></td><td><code>// All Blocked Function</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_initStackFlag"><code>.initStackFlag</code></a><code> = true;</code></td><td><code>// Initialize Stack Flag</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_checkStackFlag"><code>.checkStackFlag</code></a><code> = true;</code></td><td><code>// Check Stack Flag</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_enableIdleTask"><code>.enableIdleTask</code></a><code> = true;</code></td><td><code>// Enable Idle Task</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_minimizeLatency"><code>.minimizeLatency</code></a><code> = false;</code></td><td><code>// Minimize Latency</code></td></tr>
            <tr><td><var>Task</var><a href="#ti_sysbios_knl_Task_deleteTerminatedTasks"><code>.deleteTerminatedTasks</code></a><code> = false;</code></td><td><code>// Delete Terminated Tasks</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Task_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Task driver as a whole">Task Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_numPriorities"></a>Number of Task Priorities
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.numPriorities = 16]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Number of Task priorities supported. Default is
                16.<p /><p>The maximum number of priorities supported is target specific and depends on
the number of bits in a UInt data type. For 6x and ARM devices the maximum
number of priorities is therefore 32. For C28x devices, the maximum number of
priorities is 16.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_defaultStackSize"></a>Default Stack Size
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.defaultStackSize = 1024]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Default stack size (in MAUs) used for all
                tasks.<p /><p>Default is obtained from the device-aware Settings table (
ti/sysbios/family/Settings.js).</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_idleTaskStackSize"></a>Idle Task's Stack Size
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.idleTaskStackSize = 1024]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Idle task stack size in MAUs<p /><p>Default is obtained from the device-aware Settings table (
ti/sysbios/family/Settings.js).</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_idleTaskVitalTaskFlag"></a>Idle Task's "Vital Task" Flag
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.idleTaskVitalTaskFlag = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Idle task's vitalTaskFlag. Default is true.<p /><p>See the &quot;vitalTaskFlag&quot; decription in the BIOS Users&#39; Guide</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_allBlockedFunc"></a>All Blocked Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.allBlockedFunc = 'NULL']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Function to call while all tasks are blocked.<p /><p>This function will be called repeatedly while no tasks are
ready to run.</p>
<p>Ordinarily (in applications that have tasks ready to run at startup),
the function will run in the context of the last task to block.</p>
<p>In an application where there are no tasks ready to run
when BIOS_start() is called, the allBlockedFunc function is
called within the BIOS_start() thread which runs on the system/ISR
stack.</p>
<p>By default, allBlockedFunc is initialized to point to an internal
function that simply returns.</p>
<p>By adding the following lines to the config script, the Idle
functions will run whenever all tasks are blocked:</p>
<pre><code>Task.enableIdleTask = false;
Task.allBlockedFunc = &quot;Idle_run&quot;;</code></pre>
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_initStackFlag"></a>Initialize Stack Flag
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.initStackFlag = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Initialize stack with known value for stack checking at runtime (see checkStackFlag).<p /><p>If this flag is set to false, while the ti.sysbios.hal.Hwi#checkStackFlag is set to true,
only the first byte of the stack is initialized.</p>
<p>This is also useful for inspection of stack in debugger or core dump utilities. Default is true.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_checkStackFlag"></a>Check Stack Flag
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.checkStackFlag = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Check 'from' and 'to' task stacks before task
                context switch.<p /><p>The check consists of testing the top of stack value against its initial
value (see initStackFlag). If it is no longer at this value, the assumption
is that the task has overrun its stack. If the test fails, then the
E_stackOverflow error is raised.</p>
<p>Default is true.</p>
<p>To enable or disable full stack checking, you should set both this flag and
the ti.sysbios.hal.Hwi#checkStackFlag.</p>
<p><strong><em>note:</em></strong> Enabling stack checking will add some interrupt latency because
the checks are made within the Task scheduler while interrupts are disabled.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_enableIdleTask"></a>Enable Idle Task
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.enableIdleTask = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Construct a task (of priority 0) to run the Idle functions in.<p /><p>When set to true, a task is constructed that continuously calls the
Idle_run() function, which, in turn calls each of
the configured Idle functions.</p>
<p>When set to false, no Idle Task is created and it is up to the
user to call the Idle_run() function if the configured Idle
functions need to be run. Or, by adding the following lines to
the config script, the Idle functions will run whenever all
tasks are blocked:</p>
<pre><code>Task.enableIdleTask = false;
Task.allBlockedFunc = &quot;Idle_run&quot;;</code></pre>
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_minimizeLatency"></a>Minimize Latency
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.minimizeLatency = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Reduce interrupt latency by enabling interrupts within the Task scheduler.<p /><p>By default, interrupts are disabled within certain critical
sections of the task scheduler when switching to a different
task thread. This default behavior guarantees that a task stack
will only ever absorb ONE ISR context. Nested interrupts all run
on the shared Hwi stack.</p>
<p>While most users find this behavior desirable, the resulting
impact on interrupt latency is too great for certain applications.</p>
<p>By setting this parameter to &#39;true&#39;, the worst case interrupt latency
imposed by the kernel will be reduced but will result in task stacks
needing to be sized to accommodate one additional interrupt context.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_knl_Task_deleteTerminatedTasks"></a>Delete Terminated Tasks
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Task</var><code>.deleteTerminatedTasks = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Automatically delete terminated tasks.<p /><p>If this feature is enabled, an Idle function is installed that deletes
dynamically created Tasks that have terminated either by falling through
their task function or by explicitly calling Task_exit().</p>
<p>A list of terminated Tasks that were created dynmically is maintained
internally. Each invocation of the installed Idle function deletes the first
Task on this list. This one-at-a-time process continues until the list is
empty.</p>
<p><strong><em>note:</em></strong> This feature is disabled by default.</p>
<p><strong><em>warning:</em></strong> When this feature is enabled, an error will be raised if the
user&#39;s application attempts to delete a terminated task. If a terminated task
has already been automatically deleted and THEN the user&#39;s application
attempts to delete it (ie: using a stale Task handle), the results are
undefined and probably catastrophic!</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Assert_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Assert configuration options">Assert Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Assert</var><a href="#ti_sysbios_runtime_Assert_addFileLine"><code>.addFileLine</code></a><code> = true;</code></td><td><code>// Add File/Line To Assert Messages</code></td></tr>
            <tr><td><var>Assert</var><a href="#ti_sysbios_runtime_Assert_useBkpt"><code>.useBkpt</code></a><code> = false;</code></td><td><code>// Use BKPT For Asserts</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Assert_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Assert driver as a whole">Assert Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Assert_addFileLine"></a>Add File/Line To Assert Messages
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Assert</var><code>.addFileLine = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Add file and line info to assert messages<p /><p>Use the C pre-processor&#39;s <strong>FILE</strong> and <strong>LINE</strong> macros to add file name and line
number to the output string. You can set this parameter to &#39;false&#39; to save flash
space on the target.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Assert_useBkpt"></a>Use BKPT For Asserts
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Assert</var><code>.useBkpt = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Use a software breakpoint for the assert function<p /><p>If this parameter is set to true, a software breakpoint opcode will be used to
halt the processor when an Assert is raised.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Error_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Error configuration options">Error Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Error</var><a href="#ti_sysbios_runtime_Error_policy"><code>.policy</code></a><code> = 'Error_UNWIND';</code></td><td><code>// Error Policy</code></td></tr>
            <tr><td><var>Error</var><a href="#ti_sysbios_runtime_Error_raiseHook"><code>.raiseHook</code></a><code> = 'NULL';</code></td><td><code>// Error Function Hook</code></td></tr>
            <tr><td><var>Error</var><a href="#ti_sysbios_runtime_Error_printDetails"><code>.printDetails</code></a><code> = true;</code></td><td><code>// Use System_printf()</code></td></tr>
            <tr><td><var>Error</var><a href="#ti_sysbios_runtime_Error_retainStrings"><code>.retainStrings</code></a><code> = true;</code></td><td><code>// Leave Strings In Flash</code></td></tr>
            <tr><td><var>Error</var><a href="#ti_sysbios_runtime_Error_addFileLine"><code>.addFileLine</code></a><code> = true;</code></td><td><code>// Add File/Line To Error Messages</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Error_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Error driver as a whole">Error Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Error_policy"></a>Error Policy
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Error</var><code>.policy = 'Error_UNWIND']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> System-wide error handling policy<p /><p>You can use this parameter to decide at the configuration time what happens
when an error is raised. The program can either return back to the caller,
call <code>System_abort()</code>, or spin indefinitely.</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'Error_UNWIND'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'Error_TERMINATE'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'Error_SPIN'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Error_raiseHook"></a>Error Function Hook
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Error</var><code>.raiseHook = 'NULL']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> The function to call whenever an error is raised<p /><p>If set to a non-<code>null</code> value, the referenced function is always called when
an error is raised, even if the <code>Error</code> policy is TERMINATE or SPIN.</p>
<p>By default, this function is set to Error_print which causes the error to be
formatted and output via System_printf.  Setting this configuration parameter
to <code>null</code> indicates that no function hook should be called.</p>
<p>@see #HookFxn @see #print</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Error_printDetails"></a>Use System_printf()
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Error</var><code>.printDetails = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Use System_printf() to print error details<p /><p>If set to true, error details will be printed using System_printf().
System_printf() is a fairly big function that uses a lot of flash. You
can set this parameter to false to avoid pulling in System_printf().</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Error_retainStrings"></a>Leave Strings In Flash
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Error</var><code>.retainStrings = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Keep strings in target memory (flash)<p /><p>If set to true, error strings will be stored in the .const section
which will be loaded and take up space on the target. If set to false,
the error strings will be placed in a separate section .error_str
section which can be be placed in a no load section that won&#39;t be
loaded on the target.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Error_addFileLine"></a>Add File/Line To Error Messages
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Error</var><code>.addFileLine = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Keep strings in target memory (flash)<p /><p>Use the C pre-processor&#39;s <strong>FILE</strong> and <strong>LINE</strong> macros to add file name and line
number to the output string. You can set this parameter to &#39;false&#39; to save flash
space on the target.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->


        <div id="Startup_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Startup configuration options">Startup Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Startup</var><a href="#ti_sysbios_runtime_Startup_startupEnabled"><code>.startupEnabled</code></a><code> = true;</code></td><td><code>// Startup Enabled</code></td></tr>
            <tr><td><var>inst</var><a href="#ti_sysbios_runtime_Startup_startupFxn"><code>.startupFxn</code></a><code> = '';</code></td><td><code>// Startup Function</code></td></tr>
            <tr><td><var>inst</var><a href="#ti_sysbios_runtime_Startup_functionType"><code>.functionType</code></a><code> = 'First Function';</code></td><td><code>// Startup Function Type</code></td></tr>
            <tr><td><var>inst</var><a href="#ti_sysbios_runtime_Startup_priority"><code>.priority</code></a><code> = 1;</code></td><td><code>// Priority</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Startup_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Startup driver as a whole">Startup Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Startup_startupEnabled"></a>Startup Enabled
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Startup</var><code>.startupEnabled = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Startup_Instance_Configuration_Options">
          <h2 class="groupheader" title="Options that are separately set for each added Startup instance">Startup Instance Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Startup_startupFxn"></a>Startup Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Instance parameter's script
                 name and its default value">
                 [<var>inst</var><code>.startupFxn = ''</code>]
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
           </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Startup_functionType"></a>Startup Function Type
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Instance parameter's script
                 name and its default value">
                 [<var>inst</var><code>.functionType = 'First Function'</code>]
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'Reset Function'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'First Function'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'Module Init Function'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'Last Function'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
</table><p />
           </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Startup_priority"></a>Priority
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Instance parameter's script
                 name and its default value">
                 [<var>inst</var><code>.priority = 1</code>]
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
           </div>
          </div>
          <hr />
        </div> <!-- end Instance_Configuration_Options -->
        <div id="SysCallback_Configuration_Options">
          <h2 class="groupheader" title="Summary of all SysCallback configuration options">SysCallback Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>SysCallback</var><a href="#ti_sysbios_runtime_SysCallback_abortFxn"><code>.abortFxn</code></a><code> = 'SysCallback_defaultAbort';</code></td><td><code>// User Supplied Abort Function</code></td></tr>
            <tr><td><var>SysCallback</var><a href="#ti_sysbios_runtime_SysCallback_exitFxn"><code>.exitFxn</code></a><code> = 'SysCallback_defaultExit';</code></td><td><code>// User Supplied Exit Function</code></td></tr>
            <tr><td><var>SysCallback</var><a href="#ti_sysbios_runtime_SysCallback_flushFxn"><code>.flushFxn</code></a><code> = 'SysCallback_defaultFlush';</code></td><td><code>// User Supplied Flush Function</code></td></tr>
            <tr><td><var>SysCallback</var><a href="#ti_sysbios_runtime_SysCallback_initFxn"><code>.initFxn</code></a><code> = 'SysCallback_defaultInit';</code></td><td><code>// User Supplied Init Function</code></td></tr>
            <tr><td><var>SysCallback</var><a href="#ti_sysbios_runtime_SysCallback_putchFxn"><code>.putchFxn</code></a><code> = 'SysCallback_defaultPutch';</code></td><td><code>// User Supplied Output Function</code></td></tr>
            <tr><td><var>SysCallback</var><a href="#ti_sysbios_runtime_SysCallback_readyFxn"><code>.readyFxn</code></a><code> = 'SysCallback_defaultReady';</code></td><td><code>// User Supplied Ready Function</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="SysCallback_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the SysCallback driver as a whole">SysCallback Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysCallback_abortFxn"></a>User Supplied Abort Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysCallback</var><code>.abortFxn = 'SysCallback_defaultAbort']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied abort function<p /><p>This function is called when the application calls System_abort() function.
If the user supplied funtion returns, the abort function of the ANSI C
Standard library is called. For more information see the System_abort()
documentation.</p>
<p>By default, this function is configured with a default abort function. This
default abort function spins forever and never returns.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysCallback_exitFxn"></a>User Supplied Exit Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysCallback</var><code>.exitFxn = 'SysCallback_defaultExit']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied exit function<p /><p>This function is called when the application calls System_exit() function. If
the user supplied function returns, the ANSI C Standard Library atexit
processing will be completed. For more information see the System_exit()
documentation.</p>
<p>By default, this function is configured with a default exit function. The
default exit function does nothing and returns.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysCallback_flushFxn"></a>User Supplied Flush Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysCallback</var><code>.flushFxn = 'SysCallback_defaultFlush']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied flush function<p /><p>This function is called when the application calls System_flush() function.</p>
<p>By default, this function is configured with a default flush function. The
default flush function does nothing and returns.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysCallback_initFxn"></a>User Supplied Init Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysCallback</var><code>.initFxn = 'SysCallback_defaultInit']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysCallback_putchFxn"></a>User Supplied Output Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysCallback</var><code>.putchFxn = 'SysCallback_defaultPutch']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied character output function<p /><p>This function is called whenever the <code>System</code> module needs to output a
character; e.g., during System_printf() or System_putch().</p>
<p>By default, this function is configured with a default putch function. The
default putch function drops the characters.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysCallback_readyFxn"></a>User Supplied Ready Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysCallback</var><code>.readyFxn = 'SysCallback_defaultReady']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied ready function<p /><p>This function is called by the <code>System</code> module prior to performing any
character output to check if the <code>SystemSupport</code> module is ready to accept
the character.</p>
<p>By default, this function is configured with a default ready function. The
default ready function returns <code>true</code> always.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="SysMin_Configuration_Options">
          <h2 class="groupheader" title="Summary of all SysMin configuration options">SysMin Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>SysMin</var><a href="#ti_sysbios_runtime_SysMin_outputFunc"><code>.outputFunc</code></a><code> = 'SysMin_output';</code></td><td><code>// Character Output Function Callback</code></td></tr>
            <tr><td><var>SysMin</var><a href="#ti_sysbios_runtime_SysMin_bufSize"><code>.bufSize</code></a><code> = 1024;</code></td><td><code>// Output Buffer Size</code></td></tr>
            <tr><td><var>SysMin</var><a href="#ti_sysbios_runtime_SysMin_flushAtExit"><code>.flushAtExit</code></a><code> = true;</code></td><td><code>// Flush At Exit</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="SysMin_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the SysMin driver as a whole">SysMin Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysMin_outputFunc"></a>Character Output Function Callback
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysMin</var><code>.outputFunc = 'SysMin_output']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied character output function<p /><p>If this parameter is set to a non-null value, the specified function will
be called by System_flush() to output any characters buffered
within SysMin.</p>
<p>For example, if you define a function named &quot;myOutputFxn&quot;, the following
configuration fragment will cause SysMin to call &quot;myOutputFxn&quot; whenever the
character buffer is flushed.
@p(code)
var SysMin = scripting.addModule(&quot;/ti/sysbios/runtime/SysMin&quot;);
SysMin.outputFxn = &quot;myOutputFxn&quot;;
@p</p>
<p>If this parameter is not set, a default function will be used which uses the
ANSI C Standard Library function fwrite() (or HOSTwrite in the TI C Run
Time Support library) to output accumulated output characters.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysMin_bufSize"></a>Output Buffer Size
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysMin</var><code>.bufSize = 1024]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Size (in MAUs) of the output.<p /><p>An internal buffer of this size is allocated. All output is stored in this
internal buffer.</p>
<p>If 0 is specified for the size, no buffer is created, all output is dropped,
and SysMin_ready() always returns false.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_SysMin_flushAtExit"></a>Flush At Exit
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>SysMin</var><code>.flushAtExit = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Flush the internal buffer during exit or
                abort.<p /><p>If the application&#39;s target is a TI target, the internal buffer is flushed
via the HOSTwrite function in the TI C Run Time Support (RTS) library.</p>
<p>If the application&#39;s target is not a TI target, the internal buffer is
flushed to stdout via fwrite(..., stdout).</p>
<p>Setting this parameter to false reduces the footprint of the application
at the expense of not getting output when the application ends via a
System_exit(), System_abort(), exit() or abort().</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="System_Configuration_Options">
          <h2 class="groupheader" title="Summary of all System configuration options">System Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>System</var><a href="#ti_sysbios_runtime_System_supportModule"><code>.supportModule</code></a><code> = 'SysMin';</code></td><td><code>// SystemSupport Module</code></td></tr>
            <tr><td><var>System</var><a href="#ti_sysbios_runtime_System_maxAtexitHandlers"><code>.maxAtexitHandlers</code></a><code> = 8;</code></td><td><code>// Maximum Atexit Handlers</code></td></tr>
            <tr><td><var>System</var><a href="#ti_sysbios_runtime_System_abortFxn"><code>.abortFxn</code></a><code> = 'System_abortStd';</code></td><td><code>// System_abort() Function</code></td></tr>
            <tr><td><var>System</var><a href="#ti_sysbios_runtime_System_exitFxn"><code>.exitFxn</code></a><code> = 'System_exitStd';</code></td><td><code>// System Exit Function</code></td></tr>
            <tr><td><var>System</var><a href="#ti_sysbios_runtime_System_extendedFormats"><code>.extendedFormats</code></a><code> = '';</code></td><td><code>// Optional System_printf Formats</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="System_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the System driver as a whole">System Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_System_supportModule"></a>SystemSupport Module
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>System</var><code>.supportModule = 'SysMin']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Back end support module<p /><p>Module used to handle the bulk of System support functionality.</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'SysMin'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'SysCallback'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_System_maxAtexitHandlers"></a>Maximum Atexit Handlers
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>System</var><code>.maxAtexitHandlers = 8]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Maximum number of dynamic atexit handlers allowed in the system.<p /><p>Maximum number of System_atexit handlers set during runtime via the
System_atexit() function.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_System_abortFxn"></a>System_abort() Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>System</var><code>.abortFxn = 'System_abortStd']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Abort handler function<p /><p>This configuration parameter allows users to plug in their own abort function.
By default, System_abortStd, which calls ANSI C Standard abort() is plugged in.
Alternatively, System_abortSpin can be plugged which loops infinitely.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_System_exitFxn"></a>System Exit Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>System</var><code>.exitFxn = 'System_exitStd']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Exit handler function System_exit(int status)<p /><p>This configuration parameter allows users to plug in their own exit function.
By default, System_exitStd, which calls ANSI C Standard exit() is plugged in.
Alternatively, System_exitSpin can be plugged which loops infinitely.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_System_extendedFormats"></a>Optional System_printf Formats
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>System</var><code>.extendedFormats = '']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Optional conversions supported by System_printf<p /><p>This string specifies the set of optional argument conversion specifiers
required by the application.  By reducing the number of optional conversions
understood by the System printf methods, it is possible to significantly
reduce the code size footprint of the System module.  This configuration
parameter enables one to balance printf functionality against code size
footprint.</p>
<p>The format of this string is simply a concatenated list of the desired
conversion specifiers (with the leading % character).  For example, to
support %f, set extendedFormats to &quot;%f&quot;.</p>
<p>To disable all optional converstions, set extendedFormats to null or
the empty string &quot;&quot;.</p>
<p>For a complete list of supported extensions, see the System_printf
&quot;Extended_Format_Specifiers&quot; section.</p>
<p><strong><em>Note:</em></strong> If an optional conversion is used by some part of the application
and it is not specified in extendedFormats, the conversion character(s)
and leading % are treated as ordinary characters to be output.  As a
result, all subsequent arguments will almost certainly be converted using the
wrong conversion specifier!</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Timestamp_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Timestamp configuration options">Timestamp Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Timestamp</var><a href="#ti_sysbios_runtime_Timestamp_timestampProvider"><code>.timestampProvider</code></a><code> = 'RTC TimestampProvider';</code></td><td><code>// Timestamp Provider</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Timestamp_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Timestamp driver as a whole">Timestamp Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_runtime_Timestamp_timestampProvider"></a>Timestamp Provider
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Timestamp</var><code>.timestampProvider = 'RTC TimestampProvider']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'RTC TimestampProvider'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'DWT TimestampProvider'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'LM4 TimestampProvider'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'SysTick TimestampProvider'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="HeapBuf_Configuration_Options">
          <h2 class="groupheader" title="Summary of all HeapBuf configuration options">HeapBuf Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>HeapBuf</var><a href="#ti_sysbios_heaps_HeapBuf_trackMaxAllocs"><code>.trackMaxAllocs</code></a><code> = false;</code></td><td><code>// Track Peak Allocations</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="HeapBuf_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the HeapBuf driver as a whole">HeapBuf Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapBuf_trackMaxAllocs"></a>Track Peak Allocations
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapBuf</var><code>.trackMaxAllocs = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Track maximum number of allocations<p /><p>This will enable/disable the tracking of the maximum number of allocations
for a HeapBuf instance.  This maximum refers to the &quot;all time&quot; maximum
number of allocations for the history of a HeapBuf instance, not the current
number of allocations.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="HeapCallback_Configuration_Options">
          <h2 class="groupheader" title="Summary of all HeapCallback configuration options">HeapCallback Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>HeapCallback</var><a href="#ti_sysbios_heaps_HeapCallback_allocInstFxn"><code>.allocInstFxn</code></a><code> = 'HeapCallback_defaultAlloc';</code></td><td><code>// Alloc Function Callback</code></td></tr>
            <tr><td><var>HeapCallback</var><a href="#ti_sysbios_heaps_HeapCallback_createInstFxn"><code>.createInstFxn</code></a><code> = 'HeapCallback_defaultCreate';</code></td><td><code>// Create Function Callback</code></td></tr>
            <tr><td><var>HeapCallback</var><a href="#ti_sysbios_heaps_HeapCallback_deleteInstFxn"><code>.deleteInstFxn</code></a><code> = 'HeapCallback_defaultDelete';</code></td><td><code>// Delete Function Callback</code></td></tr>
            <tr><td><var>HeapCallback</var><a href="#ti_sysbios_heaps_HeapCallback_freeInstFxn"><code>.freeInstFxn</code></a><code> = 'HeapCallback_defaultFree';</code></td><td><code>// Free Function Callback</code></td></tr>
            <tr><td><var>HeapCallback</var><a href="#ti_sysbios_heaps_HeapCallback_getStatsInstFxn"><code>.getStatsInstFxn</code></a><code> = 'HeapCallback_defaultGetStats';</code></td><td><code>// GetStats Function Callback</code></td></tr>
            <tr><td><var>HeapCallback</var><a href="#ti_sysbios_heaps_HeapCallback_initFxn"><code>.initFxn</code></a><code> = 'HeapCallback_defaultInit';</code></td><td><code>// Init Function Callback</code></td></tr>
            <tr><td><var>HeapCallback</var><a href="#ti_sysbios_heaps_HeapCallback_isBlockingInstFxn"><code>.isBlockingInstFxn</code></a><code> = 'HeapCallback_defaultIsBlocking';</code></td><td><code>// IsBlocking Function Callback</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="HeapCallback_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the HeapCallback driver as a whole">HeapCallback Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapCallback_allocInstFxn"></a>Alloc Function Callback
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapCallback</var><code>.allocInstFxn = 'HeapCallback_defaultAlloc']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied instance alloc function<p /><p>This function is called when HeapCallback_alloc() is called.</p>
<p>This parameter is configured with a default alloc function. The default alloc
function returns NULL.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapCallback_createInstFxn"></a>Create Function Callback
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapCallback</var><code>.createInstFxn = 'HeapCallback_defaultCreate']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied instance create function<p /><p>This function is called when HeapCallback_create() is called.</p>
<p>This parameter is configured with a default create function. The default
create function returns 0.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapCallback_deleteInstFxn"></a>Delete Function Callback
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapCallback</var><code>.deleteInstFxn = 'HeapCallback_defaultDelete']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied instance delete function<p /><p>This function is called when HeapCallback_delete() is called.</p>
<p>This parameter is configured with a default delete function.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapCallback_freeInstFxn"></a>Free Function Callback
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapCallback</var><code>.freeInstFxn = 'HeapCallback_defaultFree']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied instance free function<p /><p>This function is called when HeapCallback_free() is called.</p>
<p>This parameter is configured with a default free function.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapCallback_getStatsInstFxn"></a>GetStats Function Callback
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapCallback</var><code>.getStatsInstFxn = 'HeapCallback_defaultGetStats']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied getStats function<p /><p>This function is called when HeapCallback_getStats() is called.</p>
<p>This parameter is configured with a default getStats function. The default
getStats function does not make any changes to stats structure.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapCallback_initFxn"></a>Init Function Callback
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapCallback</var><code>.initFxn = 'HeapCallback_defaultInit']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied init function<p /><p>This function is called at boot time to initialize the custom heap manager.</p>
<p>This parameter is configured with a default init function.  The default
init function is a noop and does nothing.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapCallback_isBlockingInstFxn"></a>IsBlocking Function Callback
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapCallback</var><code>.isBlockingInstFxn = 'HeapCallback_defaultIsBlocking']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User supplied isBlocking function<p /><p>This function is called when HeapCallback_isBlocking() is called.</p>
<p>This parameter is configured with a default isBlocking function.  The default
isBlocking returns FALSE.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="HeapMem_Configuration_Options">
          <h2 class="groupheader" title="Summary of all HeapMem configuration options">HeapMem Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>HeapMem</var><a href="#ti_sysbios_heaps_HeapMem_modGateType"><code>.modGateType</code></a><code> = 'GateMutex';</code></td><td><code>// Module Gate Type</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="HeapMem_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the HeapMem driver as a whole">HeapMem Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapMem_modGateType"></a>Module Gate Type
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapMem</var><code>.modGateType = 'GateMutex']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'GateHwi'</code></td><td style="padding:10px"><code>Gate Hwi</code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'GateSwi'</code></td><td style="padding:10px"><code>Gate Swi</code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'GateTask'</code></td><td style="padding:10px"><code>Gate Task</code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'GateMutex'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'GateMutexPri'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="HeapMin_Configuration_Options">
          <h2 class="groupheader" title="Summary of all HeapMin configuration options">HeapMin Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>HeapMin</var><a href="#ti_sysbios_heaps_HeapMin_freeError"><code>.freeError</code></a><code> = true;</code></td><td><code>// Raise Error On Free</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="HeapMin_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the HeapMin driver as a whole">HeapMin Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_heaps_HeapMin_freeError"></a>Raise Error On Free
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>HeapMin</var><code>.freeError = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Flag to control whether HeapMin_E_freeError is enabled.<p /><p>If true, a HeapMin_E_freeError error occurs when trying to free a buffer.</p>
<p>If false, no error occurs and the free() does nothing.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->








        <div id="Hwi_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Hwi configuration options">Hwi Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_numInterrupts"><code>.numInterrupts</code></a><code> = 54;</code></td><td><code>// Number of Interrupts</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_disablePriority"><code>.disablePriority</code></a><code> = '1';</code></td><td><code>// Hwi_disable() Priority</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_priGroup"><code>.priGroup</code></a><code> = '0';</code></td><td><code>// Priority Group</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_nvicCCR"><code>.nvicCCR</code></a><code> = STKALIGN;</code></td><td><code>// NVIC CCR Register Settings</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_initStackFlag"><code>.initStackFlag</code></a><code> = true;</code></td><td><code>// Initialize Hwi Stack</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_checkStackFlag"><code>.checkStackFlag</code></a><code> = false;</code></td><td><code>// Check Hwi Stack In Idle Task</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_dispatcherAutoNestingSupport"><code>.dispatcherAutoNestingSupport</code></a><code> = true;</code></td><td><code>// Dispatcher Auto Nesting Support</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_dispatcherSwiSupport"><code>.dispatcherSwiSupport</code></a><code> = true;</code></td><td><code>// Dispatcher Swi Support</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_dispatcherTaskSupport"><code>.dispatcherTaskSupport</code></a><code> = true;</code></td><td><code>// Dispatcher Task Support</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_enableException"><code>.enableException</code></a><code> = true;</code></td><td><code>// Enable Exception Decoding At Runtime</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_excHandlerFunc"><code>.excHandlerFunc</code></a><code> = 'Hwi_excHandlerMax';</code></td><td><code>// Exception Handler</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_resetVectorAddress"><code>.resetVectorAddress</code></a><code> = 0;</code></td><td><code>// Reset Vector Table Address</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_vectorTableAddress"><code>.vectorTableAddress</code></a><code> = 0;</code></td><td><code>// Runtime Vector Table Address</code></td></tr>
            <tr><td><var>Hwi</var><a href="#ti_sysbios_family_arm_m3_Hwi_coreVectors"><code>.coreVectors</code></a><code> = ;</code></td><td><code>// Core Exception Handlers</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Hwi_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Hwi driver as a whole">Hwi Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_numInterrupts"></a>Number of Interrupts
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.numInterrupts = 54]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_disablePriority"></a>Hwi_disable() Priority
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.disablePriority = '1']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> The priority that BASEPRI is set to by Hwi_disable().<p /><p>All interrupts configured with equal or less priority (equal or higher
number) than disablePriority are disabled by Hwi_disable. Interrupts
configured with higher priority (smaller number) than Hwi.disablePriority are
non-maskable (ie zero-latency).</p>
<p>The default setting is the second highest interrupt priority defined for the
device (typically &#39;0x20&#39; for devices which support 8 priority values). This
results in priority 0 (and all other values in the same priority group, ie
0x00 thru 0x1f) being the zero-latency, non-maskable interrupt priority. All
other priorities are disabled with Hwi_disable().</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'7'</code></td><td style="padding:10px"><code>7 - Lowest Priority</code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'6'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'5'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'4'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'3'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'2'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'1'</code></td><td style="padding:10px"><code>1 - Highest Priority</code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_priGroup"></a>Priority Group
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.priGroup = '0']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Priority Group Setting<p /><p>This value will be written to the PRIGROUP field within the NVIC&#39;s
Application Interrupt and Reset Control Register (Hwi_nvic.AIRCR). It defines
how the 8 bit priority values are interpreted by the hardware.</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>'0'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'1'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'2'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'3'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'4'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'5'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'6'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>'7'</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_nvicCCR"></a>NVIC CCR Register Settings
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.nvicCCR = STKALIGN]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p /><p>These setting are written to Hwi_nvic.CCR at startup time.</p>

              <p style="margin-bottom:2px;">Valid options include the following:</p>
              <table style="margin-left:35px">
  <tr><td style="padding:10px;vertical-align: top"><code>STKALIGN</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>BFHFNMIGN</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>DIV_0_TRP</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>UNALIGN_TRP</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>USERSETMPEND</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
  <tr><td style="padding:10px;vertical-align: top"><code>NONEBASETHRDENA</code></td><td style="padding:10px"><code></code></td><td style="padding:10px"></td></tr>
</table><p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_initStackFlag"></a>Initialize Hwi Stack
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.initStackFlag = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Initialize ISR stack with known value for stack checking at runtime<p /><p>This is useful for inspection of the stack in the debugger or core
dump utilities for stack overflow and depth. Default is true.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_checkStackFlag"></a>Check Hwi Stack In Idle Task
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.checkStackFlag = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Check for Hwi stack overrun during Idle loop.<p /><p>When set to &#39;true&#39;, an idle function is added to the idle loop
that checks for a Hwi stack overrun condition and raises
an Error if one is detected.</p>
<p>The check consists of testing the top of stack value against
its initial value. If it is no
longer at this value, the assumption is that the ISR stack
has been overrun. If the test fails, then the
&quot;Hwi_E_stackOverflow&quot; error is raised.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_dispatcherAutoNestingSupport"></a>Dispatcher Auto Nesting Support
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.dispatcherAutoNestingSupport = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Include interrupt nesting logic in interrupt
                dispatcher?<p /><p>Default is true.</p>
<p>This option provides the user with the ability to optimize interrupt
dispatcher performance when support for interrupt nesting is not required.</p>
<p><strong><em>warning:</em></strong> Setting this parameter to false will disable interrupts during the
execution of your Hwi functions.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_dispatcherSwiSupport"></a>Dispatcher Swi Support
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.dispatcherSwiSupport = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Include Swi scheduling logic in interrupt
                dispatcher?<p /><p>This option provides the user with the ability to optimize interrupt
dispatcher performance when it is known that Swis will not be posted from any
of their Hwi threads.</p>
<p><strong><em>warning:</em></strong> Setting this parameter to false will disable the logic in the
interrupt dispatcher that invokes the Swi scheduler prior to returning from
an interrupt. With this setting, Swis MUST NOT be posted from Hwi functions!</p>
<p>The default is &#39;true&#39;.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_dispatcherTaskSupport"></a>Dispatcher Task Support
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.dispatcherTaskSupport = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Include Task scheduling logic in interrupt
                dispatcher?<p /><p>This option provides the user with the ability to optimize interrupt
dispatcher performance when it is known that no Task scheduling APIs (ie
Semaphore_post()) will be executed from any of their Hwi threads.</p>
<p><strong><em>warning:</em></strong> Setting this parameter to false will disable the logic in the interrupt
dispatcher that invokes the Task scheduler prior to returning from an
interrupt.</p>
<p>Default is &#39;true&#39;.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_enableException"></a>Enable Exception Decoding At Runtime
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.enableException = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Enable full exception decoding<p /><p>When this is enabled, the exception handler will fully decode an exception
and dump the registers to the system console.</p>
<p>When disabled, the exception context is only available using ROV.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_excHandlerFunc"></a>Exception Handler
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.excHandlerFunc = 'Hwi_excHandlerMax']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Exception handler function pointer.<p /><p>The default is determined by the value of Hwi.enableException.</p>
<p>If the user does NOT set this parameter, then the following default behavior
is followed:</p>
<p>If Hwi.enableException is true, then the internal &#39;Hwi_excHandlerMax&#39;
function is used. This exception handler saves the exception context then
does a complete exception decode and dump to the console, then raises an
Error. The exception context can be viewed within CCS in the ROV Hwi module&#39;s
Exception view.</p>
<p>If Hwi.enableException is false, then the internal &#39;Hwi_excHandlerMin&#39;
function is used. This exception handler saves the exception context then
raises an Error. The exception context can be viewed within CCS in the ROV
Hwi module&#39;s Exception view.</p>
<p>If the user sets this parameter to their own function, then the user&#39;s
function will be invoked with the following arguments:</p>
<p>Void myExceptionHandler(UInt *excStack, UInt lr);</p>
<p>Where &#39;excStack&#39; is the address of the stack containing the register context
at the time of the exception, and &#39;lr&#39; is the link register value when the
low-level-assembly-coded exception handler was vectored to.</p>
<p>If this parameter is set to &#39;null&#39;, then an infinite while loop is entered
when an exception occurs. This setting minimizes code and data footprint but
provides no automatic exception decoding.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_resetVectorAddress"></a>Reset Vector Table Address
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.resetVectorAddress = 0]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Reset vector table address. Default is
                0x00000000.<p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_vectorTableAddress"></a>Runtime Vector Table Address
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.vectorTableAddress = 0]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Location of the Runtime Interrupt Vector Table.
                Default is device dependent.<p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_m3_Hwi_coreVectors"></a>Core Exception Handlers
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Hwi</var><code>.coreVectors = ]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> <p />
            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Boot_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Boot configuration options">Boot Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Boot</var><a href="#ti_sysbios_family_arm_cc26xx_Boot_trimDevice"><code>.trimDevice</code></a><code> = true;</code></td><td><code>// Trim Device Flag</code></td></tr>
            <tr><td><var>Boot</var><a href="#ti_sysbios_family_arm_cc26xx_Boot_customerConfig"><code>.customerConfig</code></a><code> = false;</code></td><td><code>// Use Default Driverlib CCFG</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Boot_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Boot driver as a whole">Boot Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_cc26xx_Boot_trimDevice"></a>Trim Device Flag
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Boot</var><code>.trimDevice = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Trim device flag; determines if SetupTrimDevice() is called at boot, default is true.<p /><p>Set to false to disable the Boot module from trimming the device. The device
<em>must</em> be trimmed for proper operation. If the Boot module doesn&#39;t do this,
the application must explicitly call SetupTrimDevice().</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_family_arm_cc26xx_Boot_customerConfig"></a>Use Default Driverlib CCFG
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Boot</var><code>.customerConfig = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Include a default customer configuration (CCFG) structure, default is false.<p /><p>Set to true to link in the default CCFG data structure in driverlib.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <div id="Load_Configuration_Options">
          <h2 class="groupheader" title="Summary of all Load configuration options">Load Configuration Synopsis</h2>
          <table style="margin-left:35px">
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_postUpdate"><code>.postUpdate</code></a><code> = 'NULL';</code></td><td><code>// Post Update Function</code></td></tr>
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_updateInIdle"><code>.updateInIdle</code></a><code> = true;</code></td><td><code>// Update In Idle</code></td></tr>
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_windowInMs"><code>.windowInMs</code></a><code> = 500;</code></td><td><code>// Window Size</code></td></tr>
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_hwiEnabled"><code>.hwiEnabled</code></a><code> = false;</code></td><td><code>// Enable Hwi Load Monitoring</code></td></tr>
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_swiEnabled"><code>.swiEnabled</code></a><code> = false;</code></td><td><code>// Enable Swi Load Monitoring</code></td></tr>
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_taskEnabled"><code>.taskEnabled</code></a><code> = true;</code></td><td><code>// Enable Task Load Monitoring</code></td></tr>
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_autoAddTasks"><code>.autoAddTasks</code></a><code> = true;</code></td><td><code>// Automatically Add All Tasks</code></td></tr>
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_enableCPULoadCalc"><code>.enableCPULoadCalc</code></a><code> = true;</code></td><td><code>// Enable CPU Load Calculation</code></td></tr>
            <tr><td><var>Load</var><a href="#ti_sysbios_utils_Load_minIdle"><code>.minIdle</code></a><code> = 0;</code></td><td><code>// Minimum Idle Time</code></td></tr>
          </table>
          <hr />
        </div> <!-- end Configuration_Options summary -->
        <div id="Load_Module_Configuration_Options">
          <h2 class="groupheader" title="Options that apply to the Load driver as a whole">Load Module Configuration Options</h2>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_postUpdate"></a>Post Update Function
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.postUpdate = 'NULL']</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> User function called after each load update<p /><p>If non-NULL, postUpdate is run immediately after each update.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_updateInIdle"></a>Update In Idle
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.updateInIdle = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Automatically call update in Idle loop<p /><p>If this parameter is set to <code>true</code>, an Idle function, which computes and
updates the CPU load, is added to the Idle loop.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_windowInMs"></a>Window Size
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.windowInMs = 500]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Load averaging period (milliseconds)<p /><p>When updateInIdle is enabled, this period determines the minimum elapsed time
between updates of the load statistics in the idle loop.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_hwiEnabled"></a>Enable Hwi Load Monitoring
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.hwiEnabled = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Enables Hwi time monitoring<p /><p>When this parameter is set to <code>true</code>, Hwi processing time is accumulated
between successive calls of update and, as part of Load_update, an event with
this cumulative time is logged.  This time, together with the total elapsed
time, is used to estimate the CPU load due to any Hwi instances run between
these updates.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_swiEnabled"></a>Enable Swi Load Monitoring
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.swiEnabled = false]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Enables Swi time monitoring<p /><p>When this parameter is set to <code>true</code>, Swi processing time is accumulated
between successive calls of update and, as part of Load_update, an event with
this cumulative time is logged.  This time together with the total elapsed
time is used to estimate the CPU load due to any Swi instances run between
these updates.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_taskEnabled"></a>Enable Task Load Monitoring
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.taskEnabled = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Enables Task time monitoring<p /><p>When this parameter is set to <code>true</code>, each Task&#39;s processing time is
accumulated between successive calls of update and, as part of Load_update,
an event with this cumulative time is logged for each task.  This time
together with the total elapsed time is used to estimate the CPU load due to
each Task run between these updates.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_autoAddTasks"></a>Automatically Add All Tasks
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.autoAddTasks = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Automatically add all tasks<p />
            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_enableCPULoadCalc"></a>Enable CPU Load Calculation
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.enableCPULoadCalc = true]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Automatically update the Load module's CPU load
                value in update.<p /><p>If this parameter is set to <code>true</code>, Load_update() will calculate the CPU
load for the elapsed time.  In some cases, the user may prefer to use the
statistics gathered by the Load module and do the CPU load calculation
themself.  Set this parameter to false, to disable the Load module&#39;s CPU load
calculations.  This can improve performance of the Load_update() call.</p>

            </div>
          </div>
          <div class="memitem">
            <div class="memproto">
              <table class="memname"><tbody><tr><td>
              <a id="ti_sysbios_utils_Load_minIdle"></a>Minimum Idle Time
              <a href="#How_to_Read_SysConfig_Synopsis_Lines"
                 title="Module parameter's script
                 name and its default value">
                 [<var>Load</var><code>.minIdle = 0]</code>
              </a>
              </td></tr></tbody></table>
            </div>
            <div class="memdoc">
              <em></em> Specifies the minimum time used to compute idle time<p /><p>During CPU load measurement, the minimum time observed executing the idle
loop together with the count of the number of times the idle loop runs id
used to compute the total idle time.  However, since the <em>actual</em> time spent
in the idle loop will almost always be greater then the observed minimum, the
idle time is almost always under estimated.</p>
<p>This configuration parameter can be used to compensate for this underestimate
by placing a lower bound on the minimum time used in the CPU measurements.
The minimum idle time used to compute CPU load is guarenteed to be greater
than or equal to <code>minIdle</code>.</p>

            </div>
          </div>
          <hr />
        </div> <!-- end Module_Configuration_Options -->

        <a id="How_to_Read_SysConfig_Synopsis_Lines"></a>
        <h3>How to Read SysConfig Synopsis Lines</h3>
        <p>SysConfig configuration scripts consist of a sequence of assignments
          to configuration parameters defined by the modules used in an
          application.  There are two types of assignments: assignments to
          module-level configuration parameters (that apply to all
          instances of the module) and assignments to instance-level
          configuration parameters (which are specific to the instance
          alone). All configuration parameters have a default value
          that's used in the event that it's not explicitly set in the
          configuration script.
        </p>
        <p>Synopsis lines of the form<br />
          <table style="margin-left:35px">
            <tr><td>
              <var>MOD</var><code>.paramName = defaultValue</code>
            </td></tr>
          </table>
          illustrate an assignment of a module configuration
          parameter's default value to the configuration
          parameter itself.
        </p>
        <p>Similarily,<br />
          <table style="margin-left:35px">
            <tr><td>
              <var>inst</var><code>.paramName = defaultValue</code>
            </td></tr>
          </table>
          illustrates an assignment of a instance configuration
          parameter's default value to the configuration
          parameter itself.
        </p>
        <p>For example, the following is a snippet of a SysConfg
          script that configures the GPIO module and a GPIO instance.
        </p>
        <div class="fragment">
          <div class="line"><span class="comment">// Add the GPIO module to this configuration</span></div>
          <div class="line"><span class="keyword">var</span> GPIO = system.addModule('/ti/drivers/GPIO');</div>
          <div class="line"></div>
          <div class="line"><span class="comment">// Set a GPIO module configuration parameter</span></div>
          <div class="line">GPIO.optimizeCallbackTableSize = true;</div>
          <div class="line"></div>
          <div class="line"><span class="comment">// Add a new GPIO instance</span></div>
          <div class="line"><span class="keyword">var</span> led = GPIO.addInstance();</div>
          <div class="line"></div>
          <div class="line"><span class="comment">// Set this instance's configuration parameters</span></div>
          <div class="line">led.$name = 'LED';</div>
          <div class="line">led.mode = 'Output';</div>
        </div> <!-- end class "fragment" -->
      </div> <!-- end class "textblock" -->
    </div> <!-- end class "contents" -->
  </body>
</html>
