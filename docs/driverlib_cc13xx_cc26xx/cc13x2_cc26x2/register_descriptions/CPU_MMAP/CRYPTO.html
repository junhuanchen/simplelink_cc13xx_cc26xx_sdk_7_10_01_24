<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<link href="..//elements/mmap.css" rel="stylesheet" type="text/css">
<TITLE>CRYPTO</TITLE>
</HEAD>
<BODY class=mmapBody>
<h2 class="mmapCellTitle">
  <a name="Top_Tag">CRYPTO</a>
</h2>
<P>Instance: CRYPTO<BR>
Component: CRYPTO<BR>
Base address: 0x40024000</P>
<BR>
<P>DMA Crypto Core is a low power low gate count crypto core with DMA capability and local key storage.</P>
 <H3 class="mmapRegisterSummaryTitle"><A name="CRYPTO"></A><A href="CPU_MMAP.html"> TOP</A>:<B>CRYPTO</B> Register Summary</H3>
<TABLE cellspacing="0" class="mmapRegisterSummaryTable">
<TR class="rowTop">
<TD class="cellTopCol1">
  <P>Register Name</P>
</TD>
<TD class="cellTopCol2">
  <P>Type</P>
</TD>
<TD class="cellTopCol3">
  <P>Register Width (Bits)</P>
</TD>
<TD class="cellTopCol4">
  <P>Register Reset</P>
</TD>
<TD class="cellTopCol5">
  <P>Address Offset</P>
</TD>
<TD class="cellTopCol5">
  <P>Physical Address</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMACH0CTL" title="Channel 0 Control">DMACH0CTL</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4000</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMACH0EXTADDR" title="Channel 0 External Address">DMACH0EXTADDR</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0004</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4004</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMACH0LEN" title="Channel 0 DMA Length">DMACH0LEN</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 000C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 400C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMASTAT" title="DMAC Status">DMASTAT</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0018</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4018</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMASWRESET" title="DMAC Software Reset">DMASWRESET</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 001C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 401C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMACH1CTL" title="Channel 1 Control">DMACH1CTL</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0020</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4020</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMACH1EXTADDR" title="Channel 1 External Address">DMACH1EXTADDR</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0024</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4024</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMACH1LEN" title="Channel 1 DMA Length">DMACH1LEN</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 002C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 402C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMABUSCFG" title="DMAC Master Run-time Parameters">DMABUSCFG</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 2400</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0078</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4078</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMAPORTERR" title="DMAC Port Error Raw Status">DMAPORTERR</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 007C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 407C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMAHWVER" title="DMAC Version">DMAHWVER</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0101 2ED1</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 00FC</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 40FC</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#KEYWRITEAREA" title="Key Store Write Area">KEYWRITEAREA</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0400</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4400</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#KEYWRITTENAREA" title="Key Store Written Area">KEYWRITTENAREA</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0404</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4404</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#KEYSIZE" title="Key Store Size">KEYSIZE</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0001</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0408</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4408</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#KEYREADAREA" title="Key Store Read Area">KEYREADAREA</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0008</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 040C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 440C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESKEY2__0-AESKEY2__3" title="AES_KEY2_0 / AES_GHASH_H_IN_0">AESKEY2__0-AESKEY2__3</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0500 - 0x0000 050C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4500 - 0x4002 450C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESKEY3__0-AESKEY3__3" title="AES_KEY3_0 / AES_KEY2_4">AESKEY3__0-AESKEY3__3</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0510 - 0x0000 051C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4510 - 0x4002 451C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESIV__0-AESIV__3" title="AES initialization vector registers">AESIV__0-AESIV__3</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0540 - 0x0000 054C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4540 - 0x4002 454C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESCTL" title="AES Control">AESCTL</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x8000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0550</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4550</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATALEN0" title="AES Crypto Length 0 (LSW)">AESDATALEN0</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0554</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4554</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATALEN1" title="AES Crypto Length 1 (MSW)">AESDATALEN1</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0558</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4558</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESAUTHLEN" title="AES Authentication Length ">AESAUTHLEN</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 055C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 455C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATAOUT0" title="Data Input/Output">AESDATAOUT0</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0560</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4560</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATAIN0" title="AES Data Input_Output 0">AESDATAIN0</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0560</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4560</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATAOUT1" title="Data Input/Output">AESDATAOUT1</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0564</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4564</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATAIN1" title="AES Data Input_Output 0">AESDATAIN1</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0564</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4564</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATAOUT2" title="Data Input/Output">AESDATAOUT2</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0568</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4568</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATAIN2" title="AES Data Input_Output 2">AESDATAIN2</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0568</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4568</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATAOUT3" title="Data Input/Output">AESDATAOUT3</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 056C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 456C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESDATAIN3" title="AES Data Input_Output 3">AESDATAIN3</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 056C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 456C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#AESTAGOUT__0-AESTAGOUT__3" title="AES Tag Out 0">AESTAGOUT__0-AESTAGOUT__3</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0570 - 0x0000 057C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4570 - 0x4002 457C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN1" title="HASH Data Input 1">HASHDATAIN1</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0604</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4604</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN2" title="HASH Data Input 2 ">HASHDATAIN2</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0608</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4608</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN3" title="HASH Data Input 3">HASHDATAIN3</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 060C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 460C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN4" title="HASH Data Input 4">HASHDATAIN4</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0610</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4610</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN5" title="HASH Data Input 5">HASHDATAIN5</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0614</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4614</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN6" title="HASH Data Input 6">HASHDATAIN6</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0618</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4618</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN7" title="HASH Data Input 7">HASHDATAIN7</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 061C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 461C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN8" title="HASH Data Input 8 ">HASHDATAIN8</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0620</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4620</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN9" title="HASH Data Input 9">HASHDATAIN9</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0624</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4624</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN10" title="HASH Data Input 10">HASHDATAIN10</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0628</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4628</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN11" title="HASH Data Input 11">HASHDATAIN11</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 062C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 462C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN12" title="HASH Data Input 12">HASHDATAIN12</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0630</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4630</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN13" title="HASH Data Input 13">HASHDATAIN13</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0634</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4634</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN14" title="HASH Data Input 14">HASHDATAIN14</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0638</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4638</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN15" title="HASH Data Input 15">HASHDATAIN15</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 063C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 463C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN16" title="HASH Data Input 16">HASHDATAIN16</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0640</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4640</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN17" title="HASH Data Input 17">HASHDATAIN17</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0644</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4644</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN18" title="HASH Data Input 18">HASHDATAIN18</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0648</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4648</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN19" title="HASH Data Input 19">HASHDATAIN19</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 064C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 464C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN20" title="HASH Data Input 20">HASHDATAIN20</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0650</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4650</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN21" title="HASH Data Input 21">HASHDATAIN21</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0654</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4654</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN22" title="HASH Data Input 22">HASHDATAIN22</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0658</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4658</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN23" title="HASH Data Input 23">HASHDATAIN23</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 065C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 465C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN24" title="HASH Data Input 24">HASHDATAIN24</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0660</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4660</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN25" title="HASH Data Input 25">HASHDATAIN25</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0664</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4664</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN26" title="HASH Data Input 26">HASHDATAIN26</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0668</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4668</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN27" title="HASH Data Input 27">HASHDATAIN27</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 066C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 466C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN28" title="HASH Data Input 28">HASHDATAIN28</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0670</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4670</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN29" title="HASH Data Input 29">HASHDATAIN29</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0674</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4674</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN30" title="HASH Data Input 30">HASHDATAIN30</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0678</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4678</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDATAIN31" title="HASH Data Input 31">HASHDATAIN31</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 067C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 467C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHIOBUFCTRL" title="HASH Input_Output Buffer Control">HASHIOBUFCTRL</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0004</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0680</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4680</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHMODE" title="HASH Mode ">HASHMODE</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0684</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4684</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHINLENL" title="HASH Input Length LSB">HASHINLENL</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0688</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4688</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHINLENH" title="HASH Input Length MSB">HASHINLENH</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 068C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 468C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTA" title="HASH Digest A">HASHDIGESTA</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06C0</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46C0</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTB" title="HASH Digest B">HASHDIGESTB</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06C4</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46C4</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTC" title="HASH Digest C">HASHDIGESTC</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06C8</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46C8</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTD" title="HASH Digest D">HASHDIGESTD</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06CC</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46CC</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTE" title="HASH Digest E">HASHDIGESTE</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06D0</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46D0</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTF" title="HASH Digest F">HASHDIGESTF</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06D4</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46D4</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTG" title="HASH Digest G">HASHDIGESTG</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06D8</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46D8</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTH" title="HASH Digest H">HASHDIGESTH</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06DC</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46DC</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTI" title="HASH Digest I">HASHDIGESTI</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06E0</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46E0</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTJ" title="HASH Digest J">HASHDIGESTJ</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06E4</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46E4</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTK" title="HASH Digest K">HASHDIGESTK</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06E8</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46E8</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTL" title="HASH Digest L">HASHDIGESTL</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06EC</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46EC</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTM" title="HASH Digest M">HASHDIGESTM</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06F0</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46F0</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTN" title="HASH Digest N">HASHDIGESTN</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06F4</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46F4</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTO" title="HASH Digest 0">HASHDIGESTO</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06F8</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46F8</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HASHDIGESTP" title="HASH Digest P">HASHDIGESTP</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 06FC</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 46FC</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#ALGSEL" title="Algorithm Select">ALGSEL</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0b0000 0000 0000 0000 0000 0000 0000 X000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0700</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4700</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#DMAPROTCTL" title="DMA Protection Control">DMAPROTCTL</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0704</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4704</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#SWRESET" title="Software Reset">SWRESET</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0740</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4740</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#IRQTYPE" title="Control Interrupt Configuration">IRQTYPE</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0780</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4780</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#IRQEN" title="Control Interrupt Enable">IRQEN</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RW</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0784</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4784</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#IRQCLR" title="Control Interrupt Clear">IRQCLR</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0788</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4788</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#IRQSET" title="Control Interrupt Set">IRQSET</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>WO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 078C</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 478C</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#IRQSTAT" title="Control Interrupt Status">IRQSTAT</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x0000 0000</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 0790</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 4790</P>
</TD>
</TR>
<TR class="row">
<TD class="cellCol1">
  <P>
    <A href="#HWVER" title="Hardware Version ">HWVER</A>
  </P>
</TD>
<TD class="cellCol2">
  <P>RO</P>
</TD>
<TD class="cellCol3">
  <P>32</P>
</TD>
<TD class="cellCol4">
  <P>0x9200 8778</P>
</TD>
<TD class="cellCol5">
  <P>0x0000 07FC</P>
</TD>
<TD class="cellCol5">
  <P>0x4002 47FC</P>
</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterSummaryTitle"><A href="CPU_MMAP.html"> TOP</A>:CRYPTO Register Descriptions</H3>
<H3 class="mmapRegisterTitle"><A name="DMACH0CTL"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMACH0CTL</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0000</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4000</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4000</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Channel 0 Control<BR>
This register is used for channel enabling and priority selection. When a channel is disabled, it becomes inactive only when all ongoing requests are finished.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH0CTL_RESERVED2">31:2</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED2</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b00 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH0CTL_PRIO">1</a>
</TD>
<TD class="cellBitfieldCol2">PRIO</TD>
<TD class="cellBitfieldCol3" colspan="3">Channel priority<BR>
0: Low<BR>
1: High<BR>
If both channels have the same priority, access of the channels to the external port is arbitrated using the round robin scheme. If one channel has a high priority and another one low, the channel with the high priority is served first, in case of simultaneous access requests.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH0CTL_EN">0</a>
</TD>
<TD class="cellBitfieldCol2">EN</TD>
<TD class="cellBitfieldCol3" colspan="3">Channel enable<BR>
0: Disabled<BR>
1: Enable<BR>
Note: Disabling an active channel interrupts the DMA operation. The ongoing block transfer completes, but no new transfers are requested.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMACH0EXTADDR"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMACH0EXTADDR</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0004</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4004</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4004</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Channel 0 External Address</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH0EXTADDR_ADDR">31:0</a>
</TD>
<TD class="cellBitfieldCol2">ADDR</TD>
<TD class="cellBitfieldCol3" colspan="3">Channel external address value<BR>
When read during operation, it holds the last updated external address after being sent to the master interface.  Note: The crypto DMA copies out upto 3 bytes until it hits a word boundary, thus the address need not be word aligned.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMACH0LEN"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMACH0LEN</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 000C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 400C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 400C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Channel 0 DMA Length</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH0LEN_RESERVED16">31:16</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED16</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH0LEN_DMALEN">15:0</a>
</TD>
<TD class="cellBitfieldCol2">DMALEN</TD>
<TD class="cellBitfieldCol3" colspan="3">Channel DMA length in bytes<BR>
During configuration, this register contains the DMA transfer length in bytes. During operation, it contains the last updated value of the DMA transfer length after being sent to the master interface.<BR>
Note: Setting this register to a nonzero value starts the transfer if the channel is enabled. Therefore, this register must be written last when setting up a DMA channel.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMASTAT"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMASTAT</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0018</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4018</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4018</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">DMAC Status<BR>
This register provides the actual state of each DMA channel. It also reports port errors in case these were received by the master interface module during the data transfer.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMASTAT_RESERVED18">31:18</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED18</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0b00 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMASTAT_PORT_ERR">17</a>
</TD>
<TD class="cellBitfieldCol2">PORT_ERR</TD>
<TD class="cellBitfieldCol3" colspan="3">Reflects possible transfer errors on the AHB port.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMASTAT_RESERVED2">16:2</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED2</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMASTAT_CH1_ACT">1</a>
</TD>
<TD class="cellBitfieldCol2">CH1_ACT</TD>
<TD class="cellBitfieldCol3" colspan="3">A value of 1 indicates that channel 1 is active (DMA transfer on-going).</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMASTAT_CH0_ACT">0</a>
</TD>
<TD class="cellBitfieldCol2">CH0_ACT</TD>
<TD class="cellBitfieldCol3" colspan="3">A value of 1 indicates that channel 0 is active (DMA transfer on-going).</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMASWRESET"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMASWRESET</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 001C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 401C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 401C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">DMAC Software Reset<BR>
Software reset is used to reset the DMAC to stop all transfers and clears the port error status register. After the software reset is performed, all the channels are disabled and no new requests are performed by the channels. The DMAC waits for the existing (active) requests to finish and accordingly sets the <A class="xref" href="#DMASTAT">DMASTAT</A>.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMASWRESET_RESERVED1">31:1</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED1</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMASWRESET_SWRES">0</a>
</TD>
<TD class="cellBitfieldCol2">SWRES</TD>
<TD class="cellBitfieldCol3" colspan="3">Software reset enable<BR>
0 : Disabled<BR>
1 :  Enabled (self-cleared to 0)<BR>
Completion of the software reset must be checked through the <A class="xref" href="#DMASTAT">DMASTAT</A></TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMACH1CTL"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMACH1CTL</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0020</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4020</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4020</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Channel 1 Control<BR>
This register is used for channel enabling and priority selection. When a channel is disabled, it becomes inactive only when all ongoing requests are finished.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH1CTL_RESERVED2">31:2</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED2</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b00 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH1CTL_PRIO">1</a>
</TD>
<TD class="cellBitfieldCol2">PRIO</TD>
<TD class="cellBitfieldCol3" colspan="3">Channel priority<BR>
0: Low<BR>
1: High<BR>
If both channels have the same priority, access of the channels to the external port is arbitrated using the round robin scheme. If one channel has a high priority and another one low, the channel with the high priority is served first, in case of simultaneous access requests.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH1CTL_EN">0</a>
</TD>
<TD class="cellBitfieldCol2">EN</TD>
<TD class="cellBitfieldCol3" colspan="3">Channel enable<BR>
0: Disabled<BR>
1: Enable<BR>
Note: Disabling an active channel interrupts the DMA operation. The ongoing block transfer completes, but no new transfers are requested.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMACH1EXTADDR"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMACH1EXTADDR</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0024</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4024</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4024</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Channel 1 External Address</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH1EXTADDR_ADDR">31:0</a>
</TD>
<TD class="cellBitfieldCol2">ADDR</TD>
<TD class="cellBitfieldCol3" colspan="3">Channel external address value.<BR>
When read during operation, it holds the last updated external address after being sent to the master interface.   Note: The crypto DMA copies out upto 3 bytes until it hits a word boundary, thus the address need not be word aligned.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMACH1LEN"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMACH1LEN</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 002C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 402C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 402C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Channel 1 DMA Length</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH1LEN_RESERVED16">31:16</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED16</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMACH1LEN_DMALEN">15:0</a>
</TD>
<TD class="cellBitfieldCol2">DMALEN</TD>
<TD class="cellBitfieldCol3" colspan="3">Channel DMA length in bytes.<BR>
During configuration, this register contains the DMA transfer length in bytes. During operation, it contains the last updated value of the DMA transfer length after being sent to the master interface.<BR>
Note: Setting this register to a nonzero value starts the transfer if the channel is enabled. Therefore, this register must be written last when setting up a DMA channel.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMABUSCFG"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMABUSCFG</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0078</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4078</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4078</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">DMAC Master Run-time Parameters<BR>
This register defines all the run-time parameters for the AHB master interface port. These parameters are required for the proper functioning of the EIP-101m AHB master adapter.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMABUSCFG_RESERVED16">31:16</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED16</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMABUSCFG_AHB_MST1_BURST_SIZE">15:12</a>
</TD>
<TD class="cellBitfieldCol2">AHB_MST1_BURST_SIZE</TD>
<TD class="cellBitfieldCol3" colspan="3">Maximum burst size that can be performed on the AHB bus<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x2</TD>
<TD class="cellEnumTableCol2">4_BYTE</TD>
<TD class="cellEnumTableCol3">4 bytes</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x3</TD>
<TD class="cellEnumTableCol2">8_BYTE</TD>
<TD class="cellEnumTableCol3">8 bytes</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x4</TD>
<TD class="cellEnumTableCol2">16_BYTE</TD>
<TD class="cellEnumTableCol3">16 bytes</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x5</TD>
<TD class="cellEnumTableCol2">32_BYTE</TD>
<TD class="cellEnumTableCol3">32 bytes</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x6</TD>
<TD class="cellEnumTableCol2">64_BYTE</TD>
<TD class="cellEnumTableCol3">64 bytes</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x2</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMABUSCFG_AHB_MST1_IDLE_EN">11</a>
</TD>
<TD class="cellBitfieldCol2">AHB_MST1_IDLE_EN</TD>
<TD class="cellBitfieldCol3" colspan="3">Idle insertion between consecutive burst transfers on AHB<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NO_IDLE</TD>
<TD class="cellEnumTableCol3">Do not insert idle transfers.</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">IDLE</TD>
<TD class="cellEnumTableCol3">Idle transfer insertion enabled</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMABUSCFG_AHB_MST1_INCR_EN">10</a>
</TD>
<TD class="cellBitfieldCol2">AHB_MST1_INCR_EN</TD>
<TD class="cellBitfieldCol3" colspan="3">Burst length type of AHB transfer<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">UNSPECIFIED</TD>
<TD class="cellEnumTableCol3">Unspecified length burst transfers</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SPECIFIED</TD>
<TD class="cellEnumTableCol3">Fixed length bursts or single transfers</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">1</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMABUSCFG_AHB_MST1_LOCK_EN">9</a>
</TD>
<TD class="cellBitfieldCol2">AHB_MST1_LOCK_EN</TD>
<TD class="cellBitfieldCol3" colspan="3">Locked transform on AHB<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_LOCKED</TD>
<TD class="cellEnumTableCol3">Transfers are not locked</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">LOCKED</TD>
<TD class="cellEnumTableCol3">Transfers are locked</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMABUSCFG_AHB_MST1_BIGEND">8</a>
</TD>
<TD class="cellBitfieldCol2">AHB_MST1_BIGEND</TD>
<TD class="cellBitfieldCol3" colspan="3">Endianess for the AHB master<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">LITTLE_ENDIAN</TD>
<TD class="cellEnumTableCol3">Little Endian</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">BIG_ENDIAN</TD>
<TD class="cellEnumTableCol3">Big Endian</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMABUSCFG_RESERVED0">7:0</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED0</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x00</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMAPORTERR"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMAPORTERR</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 007C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 407C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 407C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">DMAC Port Error Raw Status<BR>
This register provides the actual status of individual port errors. It also indicates which channel is serviced by an external AHB port (which is frozen by a port error). A port error aborts operations on all serviced channels (channel enable bit is forced to 0) and prevents further transfers via that port until the error is cleared by writing to the <A class="xref" href="#DMASWRESET">DMASWRESET</A> register.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAPORTERR_RESERVED13">31:13</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED13</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAPORTERR_PORT1_AHB_ERROR">12</a>
</TD>
<TD class="cellBitfieldCol2">PORT1_AHB_ERROR</TD>
<TD class="cellBitfieldCol3" colspan="3">A value of 1 indicates that the EIP-101 has detected an AHB bus error</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAPORTERR_RESERVED10">11:10</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED10</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0b00</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAPORTERR_PORT1_CHANNEL">9</a>
</TD>
<TD class="cellBitfieldCol2">PORT1_CHANNEL</TD>
<TD class="cellBitfieldCol3" colspan="3">Indicates which channel has serviced last (channel 0 or channel 1) by AHB master port.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAPORTERR_RESERVED0">8:0</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED0</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0b0 0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMAHWVER"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMAHWVER</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 00FC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 40FC</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 40FC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">DMAC Version<BR>
This register contains an indication (or signature) of the EIP type of this DMAC, as well as the hardware version/patch numbers.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAHWVER_RESERVED28">31:28</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED28</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAHWVER_HW_MAJOR_VERSION">27:24</a>
</TD>
<TD class="cellBitfieldCol2">HW_MAJOR_VERSION</TD>
<TD class="cellBitfieldCol3" colspan="3">Major version number</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x1</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAHWVER_HW_MINOR_VERSION">23:20</a>
</TD>
<TD class="cellBitfieldCol2">HW_MINOR_VERSION</TD>
<TD class="cellBitfieldCol3" colspan="3">Minor version number</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAHWVER_HW_PATCH_LEVEL">19:16</a>
</TD>
<TD class="cellBitfieldCol2">HW_PATCH_LEVEL</TD>
<TD class="cellBitfieldCol3" colspan="3">Patch level<BR>
Starts at 0 at first delivery of this version</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x1</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAHWVER_EIP_NUMBER_COMPL">15:8</a>
</TD>
<TD class="cellBitfieldCol2">EIP_NUMBER_COMPL</TD>
<TD class="cellBitfieldCol3" colspan="3">Bit-by-bit complement of the EIP_NUMBER field bits.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x2E</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAHWVER_EIP_NUMBER">7:0</a>
</TD>
<TD class="cellBitfieldCol2">EIP_NUMBER</TD>
<TD class="cellBitfieldCol3" colspan="3">Binary encoding of the EIP-number of this DMA controller (209)</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0xD1</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="KEYWRITEAREA"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:KEYWRITEAREA</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0400</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4400</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4400</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Key Store Write Area<BR>
This register defines where the keys should be written in the key store RAM. After writing this register, the key store module is ready to receive the keys through a DMA operation. In case the key data transfer triggered an error in the key store, the error will be available in the interrupt status register after the DMA is finished. The key store write-error is asserted when the programmed/selected area is not completely written. This error is also asserted when the DMA operation writes to ram areas that are not selected.<BR>
The key store RAM is divided into 8 areas of 128 bits.<BR>
192-bit keys written in the key store RAM should start on boundaries of 256 bits. This means that writing a 192-bit key to the key store RAM must be done by writing 256 bits of data with the 64 most-significant bits set to 0. These bits are ignored by the AES engine.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RESERVED8">31:8</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED8</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x00 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RAM_AREA7">7</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA7</TD>
<TD class="cellBitfieldCol3" colspan="3">Each RAM_AREAx represents an area of 128 bits.<BR>
Select the key store RAM area(s) where the key(s) needs to be written<BR>
0: RAM_AREA7 is not selected to be written.<BR>
1: RAM_AREA7 is selected to be written.<BR>
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.<BR>
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is not selected to be written</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is selected to be written</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RAM_AREA6">6</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA6</TD>
<TD class="cellBitfieldCol3" colspan="3">Each RAM_AREAx represents an area of 128 bits.<BR>
Select the key store RAM area(s) where the key(s) needs to be written<BR>
0: RAM_AREA6 is not selected to be written.<BR>
1: RAM_AREA6 is selected to be written.<BR>
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.<BR>
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is not selected to be written</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is selected to be written</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RAM_AREA5">5</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA5</TD>
<TD class="cellBitfieldCol3" colspan="3">Each RAM_AREAx represents an area of 128 bits.<BR>
Select the key store RAM area(s) where the key(s) needs to be written<BR>
0: RAM_AREA5 is not selected to be written.<BR>
1: RAM_AREA5 is selected to be written.<BR>
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.<BR>
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is not selected to be written</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is selected to be written</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RAM_AREA4">4</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA4</TD>
<TD class="cellBitfieldCol3" colspan="3">Each RAM_AREAx represents an area of 128 bits.<BR>
Select the key store RAM area(s) where the key(s) needs to be written<BR>
0: RAM_AREA4 is not selected to be written.<BR>
1: RAM_AREA4 is selected to be written.<BR>
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.<BR>
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is not selected to be written</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is selected to be written</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RAM_AREA3">3</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA3</TD>
<TD class="cellBitfieldCol3" colspan="3">Each RAM_AREAx represents an area of 128 bits.<BR>
Select the key store RAM area(s) where the key(s) needs to be written<BR>
0: RAM_AREA3 is not selected to be written.<BR>
1: RAM_AREA3 is selected to be written.<BR>
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.<BR>
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is not selected to be written</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is selected to be written</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RAM_AREA2">2</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA2</TD>
<TD class="cellBitfieldCol3" colspan="3">Each RAM_AREAx represents an area of 128 bits.<BR>
Select the key store RAM area(s) where the key(s) needs to be written<BR>
0: RAM_AREA2 is not selected to be written.<BR>
1: RAM_AREA2 is selected to be written.<BR>
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.<BR>
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is not selected to be written</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is selected to be written</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RAM_AREA1">1</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA1</TD>
<TD class="cellBitfieldCol3" colspan="3">Each RAM_AREAx represents an area of 128 bits.<BR>
Select the key store RAM area(s) where the key(s) needs to be written<BR>
0: RAM_AREA1 is not selected to be written.<BR>
1: RAM_AREA1 is selected to be written.<BR>
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.<BR>
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is not selected to be written</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is selected to be written</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITEAREA_RAM_AREA0">0</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA0</TD>
<TD class="cellBitfieldCol3" colspan="3">Each RAM_AREAx represents an area of 128 bits.<BR>
Select the key store RAM area(s) where the key(s) needs to be written<BR>
0: RAM_AREA0 is not selected to be written.<BR>
1: RAM_AREA0 is selected to be written.<BR>
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.<BR>
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is not selected to be written</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">SEL</TD>
<TD class="cellEnumTableCol3">This RAM area is selected to be written</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="KEYWRITTENAREA"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:KEYWRITTENAREA</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0404</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4404</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4404</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Key Store Written Area<BR>
This register shows which areas of the key store RAM contain valid written keys.<BR>
When a new key needs to be written to the key store, on a location that is already occupied by a valid key, this key area must be cleared first. This can be done by writing this register before the new key is written to the key store memory.<BR>
Attempting to write to a key area that already contains a valid key is not allowed and results in an error.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RESERVED8">31:8</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED8</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x00 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RAM_AREA_WRITTEN7">7</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA_WRITTEN7</TD>
<TD class="cellBitfieldCol3" colspan="3">On read this bit returns the key area written status.<BR>
<BR>
This bit can be reset by writing a 1.<BR>
<BR>
Note: This register will be reset on a soft reset initiated by writing to <A class="xref" href="#DMASWRESET_SWRES">DMASWRESET.SWRES</A>. After a soft reset, all keys must be rewritten to the key store memory.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is not written with valid key information</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is written with valid key information</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RAM_AREA_WRITTEN6">6</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA_WRITTEN6</TD>
<TD class="cellBitfieldCol3" colspan="3">On read this bit returns the key area written status.<BR>
<BR>
This bit can be reset by writing a 1.<BR>
<BR>
Note: This register will be reset on a soft reset initiated by writing to <A class="xref" href="#DMASWRESET_SWRES">DMASWRESET.SWRES</A>. After a soft reset, all keys must be rewritten to the key store memory.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is not written with valid key information</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is written with valid key information</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RAM_AREA_WRITTEN5">5</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA_WRITTEN5</TD>
<TD class="cellBitfieldCol3" colspan="3">On read this bit returns the key area written status.<BR>
<BR>
This bit can be reset by writing a 1.<BR>
<BR>
Note: This register will be reset on a soft reset initiated by writing to <A class="xref" href="#DMASWRESET_SWRES">DMASWRESET.SWRES</A>. After a soft reset, all keys must be rewritten to the key store memory.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is not written with valid key information</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is written with valid key information</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RAM_AREA_WRITTEN4">4</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA_WRITTEN4</TD>
<TD class="cellBitfieldCol3" colspan="3">On read this bit returns the key area written status.<BR>
<BR>
This bit can be reset by writing a 1.<BR>
<BR>
Note: This register will be reset on a soft reset initiated by writing to <A class="xref" href="#DMASWRESET_SWRES">DMASWRESET.SWRES</A>. After a soft reset, all keys must be rewritten to the key store memory.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is not written with valid key information</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is written with valid key information</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RAM_AREA_WRITTEN3">3</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA_WRITTEN3</TD>
<TD class="cellBitfieldCol3" colspan="3">On read this bit returns the key area written status.<BR>
<BR>
This bit can be reset by writing a 1.<BR>
<BR>
Note: This register will be reset on a soft reset initiated by writing to <A class="xref" href="#DMASWRESET_SWRES">DMASWRESET.SWRES</A>. After a soft reset, all keys must be rewritten to the key store memory.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is not written with valid key information</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is written with valid key information</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RAM_AREA_WRITTEN2">2</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA_WRITTEN2</TD>
<TD class="cellBitfieldCol3" colspan="3">On read this bit returns the key area written status.<BR>
<BR>
This bit can be reset by writing a 1.<BR>
<BR>
Note: This register will be reset on a soft reset initiated by writing to <A class="xref" href="#DMASWRESET_SWRES">DMASWRESET.SWRES</A>. After a soft reset, all keys must be rewritten to the key store memory.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is not written with valid key information</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is written with valid key information</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RAM_AREA_WRITTEN1">1</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA_WRITTEN1</TD>
<TD class="cellBitfieldCol3" colspan="3">On read this bit returns the key area written status.<BR>
<BR>
This bit can be reset by writing a 1.<BR>
<BR>
Note: This register will be reset on a soft reset initiated by writing to <A class="xref" href="#DMASWRESET_SWRES">DMASWRESET.SWRES</A>. After a soft reset, all keys must be rewritten to the key store memory.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">NOT_WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is not written with valid key information</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">WRITTEN</TD>
<TD class="cellEnumTableCol3">This RAM area is written with valid key information</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYWRITTENAREA_RAM_AREA_WRITTEN0">0</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA_WRITTEN0</TD>
<TD class="cellBitfieldCol3" colspan="3">On read this bit returns the key area written status.<BR>
<BR>
This bit can be reset by writing a 1.<BR>
<BR>
Note: This register will be reset on a soft reset initiated by writing to <A class="xref" href="#DMASWRESET_SWRES">DMASWRESET.SWRES</A>. After a soft reset, all keys must be rewritten to the key store memory.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="KEYSIZE"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:KEYSIZE</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0408</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4408</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4408</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Key Store Size<BR>
This register defines the size of the keys that are written with DMA. This register should be configured before writing to the KEY_STORE_WRITE_AREA register.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYSIZE_RESERVED2">31:2</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED2</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b00 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYSIZE_SIZE">1:0</a>
</TD>
<TD class="cellBitfieldCol2">SIZE</TD>
<TD class="cellBitfieldCol3" colspan="3">Key size:<BR>
00: Reserved<BR>
When writing this to this register, the KEY_STORE_WRITTEN_AREA register is reset.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">128_BIT</TD>
<TD class="cellEnumTableCol3">128 bits</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x2</TD>
<TD class="cellEnumTableCol2">192_BIT</TD>
<TD class="cellEnumTableCol3">192 bits</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x3</TD>
<TD class="cellEnumTableCol2">256_BIT</TD>
<TD class="cellEnumTableCol3">256 bits</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b01</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="KEYREADAREA"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:KEYREADAREA</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 040C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 440C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 440C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Key Store Read Area<BR>
This register selects the key store RAM area from where the key needs to be read that will be used for an AES operation. The operation directly starts after writing this register. When the operation is finished, the status of the key store read operation is available in the interrupt status register. Key store read error is asserted when a RAM area is selected which does not contain valid written key.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYREADAREA_BUSY">31</a>
</TD>
<TD class="cellBitfieldCol2">BUSY</TD>
<TD class="cellBitfieldCol3" colspan="3">Key store operation busy status flag (read only):<BR>
0: Operation is complete.<BR>
1: Operation is not completed and the key store is busy.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYREADAREA_RESERVED4">30:4</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED4</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="KEYREADAREA_RAM_AREA">3:0</a>
</TD>
<TD class="cellBitfieldCol2">RAM_AREA</TD>
<TD class="cellBitfieldCol3" colspan="3">Selects the area of the key store RAM from where the key needs to be read that will be writen to the AES engine<BR>
RAM_AREA:<BR>
<BR>
RAM areas RAM_AREA0, RAM_AREA2, RAM_AREA4 and RAM_AREA6 are the only valid read areas for 192 and 256 bits key sizes.<BR>
Only RAM areas that contain valid written keys can be selected.<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">RAM_AREA0</TD>
<TD class="cellEnumTableCol3">RAM Area 0</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">RAM_AREA1</TD>
<TD class="cellEnumTableCol3">RAM Area 1</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x2</TD>
<TD class="cellEnumTableCol2">RAM_AREA2</TD>
<TD class="cellEnumTableCol3">RAM Area 2</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x3</TD>
<TD class="cellEnumTableCol2">RAM_AREA3</TD>
<TD class="cellEnumTableCol3">RAM Area 3</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x4</TD>
<TD class="cellEnumTableCol2">RAM_AREA4</TD>
<TD class="cellEnumTableCol3">RAM Area 4</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x5</TD>
<TD class="cellEnumTableCol2">RAM_AREA5</TD>
<TD class="cellEnumTableCol3">RAM Area 5</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x6</TD>
<TD class="cellEnumTableCol2">RAM_AREA6</TD>
<TD class="cellEnumTableCol3">RAM Area 6</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x7</TD>
<TD class="cellEnumTableCol2">RAM_AREA7</TD>
<TD class="cellEnumTableCol3">RAM Area 7</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x8</TD>
<TD class="cellEnumTableCol2">NO_RAM</TD>
<TD class="cellEnumTableCol3">No RAM</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x8</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESKEY2__0-AESKEY2__3"></A><A name="AESKEY20"></A><A name="AESKEY21"></A><A name="AESKEY22"></A><A name="AESKEY23"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESKEY2__0-AESKEY2__3</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0500 - 0x0000 050C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4500 - 0x4002 450C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4500 - 0x4002 450C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES_KEY2_0 / AES_GHASH_H_IN_0<BR>
Second Key / GHASH Key (internal, but clearable)<BR>
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.<BR>
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<a name="AESKEY20_AES_KEY2"></a><a name="AESKEY21_AES_KEY2"></a><a name="AESKEY22_AES_KEY2"></a><a name="AESKEY23_AES_KEY2"></a><TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESKEY2__0-AESKEY2__3_AES_KEY2">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AES_KEY2</TD>
<TD class="cellBitfieldCol3" colspan="3">AES_KEY2/AES_GHASH_H[31:0]<BR>
<BR>
For GCM: <BR>
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).<BR>
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.<BR>
<BR>
For CCM:<BR>
-[255:0] - This register is used to store intermediate values.<BR>
<BR>
For CBC-MAC:<BR>
-[255:0] - ZEROES - This register must remain 0.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESKEY3__0-AESKEY3__3"></A><A name="AESKEY30"></A><A name="AESKEY31"></A><A name="AESKEY32"></A><A name="AESKEY33"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESKEY3__0-AESKEY3__3</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0510 - 0x0000 051C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4510 - 0x4002 451C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4510 - 0x4002 451C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES_KEY3_0 / AES_KEY2_4<BR>
Third Key / Second Key (internal, but clearable)<BR>
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.<BR>
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<a name="AESKEY30_AES_KEY3"></a><a name="AESKEY31_AES_KEY3"></a><a name="AESKEY32_AES_KEY3"></a><a name="AESKEY33_AES_KEY3"></a><TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESKEY3__0-AESKEY3__3_AES_KEY3">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AES_KEY3</TD>
<TD class="cellBitfieldCol3" colspan="3">AES_KEY3[31:0]/AES_KEY2[159:128]<BR>
<BR>
For GCM: <BR>
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).<BR>
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.<BR>
<BR>
For CCM:<BR>
-[255:0] - This register is used to store intermediate values.<BR>
<BR>
For CBC-MAC:<BR>
-[255:0] - ZEROES - This register must remain 0.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESIV__0-AESIV__3"></A><A name="AESIV0"></A><A name="AESIV1"></A><A name="AESIV2"></A><A name="AESIV3"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESIV__0-AESIV__3</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0540 - 0x0000 054C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4540 - 0x4002 454C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4540 - 0x4002 454C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES initialization vector registers<BR>
These registers are used to provide and read the IV from the AES engine.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<a name="AESIV0_AES_IV"></a><a name="AESIV1_AES_IV"></a><a name="AESIV2_AES_IV"></a><a name="AESIV3_AES_IV"></a><TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESIV__0-AESIV__3_AES_IV">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AES_IV</TD>
<TD class="cellBitfieldCol3" colspan="3">AES_IV[31:0]<BR>
<BR>
Initialization vector<BR>
Used for regular non-ECB modes (CBC/CTR):<BR>
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine<BR>
<BR>
For GCM:<BR>
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.<BR>
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.<BR>
<BR>
For CCM:<BR>
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits &#39;L&#39;), Nonce and counter value. &#39;L&#39; must be a copy from the &#39;L&#39; value of the AES_CTRL register. This &#39;L&#39; indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.<BR>
<BR>
For CBC-MAC:<BR>
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESCTL"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESCTL</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0550</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4550</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4550</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Control<BR>
<BR>
AES input/output buffer control and mode register<BR>
This register specifies the AES mode of operation for the EIP-120t.<BR>
Electronic codebook (ECB) mode is automatically selected if bits [28:5] of this register are all 0.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_CONTEXT_READY">31</a>
</TD>
<TD class="cellBitfieldCol2">CONTEXT_READY</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1, this read-only status bit indicates that the context data registers can be overwritten and the host is permitted to write the next context.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">1</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_SAVED_CONTEXT_RDY">30</a>
</TD>
<TD class="cellBitfieldCol2">SAVED_CONTEXT_RDY</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1, this status bit indicates that an AES authentication TAG and/or IV block(s) is/are available for the host to retrieve. This bit is only asserted if the save_context bit is set to 1. The bit is mutual exclusive with the context_ready bit.<BR>
Writing one clears the bit to 0, indicating the AES core can start its next operation. This bit is also cleared when the 4th word of the output TAG and/or IV is read.<BR>
Note: All other mode bit writes are ignored when this mode bit is written with 1.<BR>
Note: This bit is controlled automatically by the EIP-120t for TAG read DMA operations.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_SAVE_CONTEXT">29</a>
</TD>
<TD class="cellBitfieldCol2">SAVE_CONTEXT</TD>
<TD class="cellBitfieldCol3" colspan="3">This bit indicates that an authentication TAG or result IV needs to be stored as a result context.<BR>
Typically this bit must be set for authentication modes returning a TAG (CBC-MAC, GCM and CCM), or for basic encryption modes that require future continuation with the current result IV.<BR>
If this bit is set, the engine retains its full context until the TAG and/or IV registers are read.<BR>
The TAG or IV must be read before the AES engine can start a new operation.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_RESERVED25">28:25</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED25</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_CCM_M">24:22</a>
</TD>
<TD class="cellBitfieldCol2">CCM_M</TD>
<TD class="cellBitfieldCol3" colspan="3">Defines M, which indicates the length of the authentication field for CCM operations; the authentication field length equals two times (the value of CCM-M plus one).<BR>
Note: The EIP-120t always returns a 128-bit authentication field, of which the M least significant bytes are valid. All values are supported.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_CCM_L">21:19</a>
</TD>
<TD class="cellBitfieldCol2">CCM_L</TD>
<TD class="cellBitfieldCol3" colspan="3">Defines L, which indicates the width of the length field for CCM operations; the length field in bytes equals the value of CMM-L plus one. All values are supported.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_CCM">18</a>
</TD>
<TD class="cellBitfieldCol2">CCM</TD>
<TD class="cellBitfieldCol3" colspan="3">If set to 1, AES-CCM is selected<BR>
AES-CCM is a combined mode, using AES for authentication and encryption.<BR>
Note: Selecting AES-CCM mode requires writing of the AAD length register after all other registers.<BR>
Note: The CTR mode bit in this register must also be set to 1 to enable AES-CTR; selecting other AES modes than CTR mode is invalid.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_GCM">17:16</a>
</TD>
<TD class="cellBitfieldCol2">GCM</TD>
<TD class="cellBitfieldCol3" colspan="3">Set these bits to 11 to select AES-GCM mode.<BR>
AES-GCM is a combined mode, using the Galois field multiplier GF(2 to the power of 128) for authentication and AES-CTR mode for encryption.<BR>
Note: The CTR mode bit in this register must also be set to 1 to enable AES-CTR<BR>
Bit combination description:<BR>
00 = No GCM mode<BR>
01 = Reserved, do not select<BR>
10 = Reserved, do not select<BR>
11 = Autonomous GHASH (both H- and Y0-encrypted calculated internally)<BR>
Note: The EIP-120t-1 configuration only supports mode 11 (autonomous GHASH), other GCM modes are not allowed.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b00</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_CBC_MAC">15</a>
</TD>
<TD class="cellBitfieldCol2">CBC_MAC</TD>
<TD class="cellBitfieldCol3" colspan="3">Set to 1 to select AES-CBC MAC mode.<BR>
The direction bit must be set to 1 for this mode.<BR>
Selecting this mode requires writing the length register after all other registers.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_RESERVED9">14:9</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED9</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b00 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_CTR_WIDTH">8:7</a>
</TD>
<TD class="cellBitfieldCol2">CTR_WIDTH</TD>
<TD class="cellBitfieldCol3" colspan="3">Specifies the counter width for AES-CTR mode<BR>
00 = 32-bit counter<BR>
01 = 64-bit counter<BR>
10 = 96-bit counter<BR>
11 = 128-bit counter<TABLE cellspacing="0" class="LprfEnum">
<TR class="rowEnumHead">
<TD class="cellEnumTableHeadCol1">Value</TD>
<TD class="cellEnumTableHeadCol2">ENUM Name</TD>
<TD class="cellEnumTableHeadCol3">Description</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x0</TD>
<TD class="cellEnumTableCol2">32_BIT</TD>
<TD class="cellEnumTableCol3">32 bits</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x1</TD>
<TD class="cellEnumTableCol2">64_BIT</TD>
<TD class="cellEnumTableCol3">64 bits</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x2</TD>
<TD class="cellEnumTableCol2">96_BIT</TD>
<TD class="cellEnumTableCol3">96 bits</TD>
</TR>
<TR class="rowEnum">
<TD class="cellEnumTableCol1">0x3</TD>
<TD class="cellEnumTableCol2">128_BIT</TD>
<TD class="cellEnumTableCol3">128 bits</TD>
</TR>
</TABLE>
</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b00</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_CTR">6</a>
</TD>
<TD class="cellBitfieldCol2">CTR</TD>
<TD class="cellBitfieldCol3" colspan="3">If set to 1, AES counter mode (CTR) is selected.<BR>
Note: This bit must also be set for GCM and CCM, when encryption/decryption is required.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_CBC">5</a>
</TD>
<TD class="cellBitfieldCol2">CBC</TD>
<TD class="cellBitfieldCol3" colspan="3">If set to 1, cipher-block-chaining (CBC) mode is selected.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_KEY_SIZE">4:3</a>
</TD>
<TD class="cellBitfieldCol2">KEY_SIZE</TD>
<TD class="cellBitfieldCol3" colspan="3">This read-only field specifies the key size.<BR>
The key size is automatically configured when a new key is loaded through the key store module.<BR>
00 = N/A - Reserved<BR>
01 = 128-bit<BR>
10 = 192-bit<BR>
11 = 256-bit</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0b00</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_DIR">2</a>
</TD>
<TD class="cellBitfieldCol2">DIR</TD>
<TD class="cellBitfieldCol3" colspan="3">If set to 1 an encrypt operation is performed.<BR>
If set to 0 a decrypt operation is performed.<BR>
This bit must be written with a 1 when CBC-MAC is selected.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_INPUT_READY">1</a>
</TD>
<TD class="cellBitfieldCol2">INPUT_READY</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1, this status bit indicates that the 16-byte AES input buffer is empty. The host is permitted to write the next block of data.<BR>
Writing 0 clears the bit to 0 and indicates that the AES core can use the provided input data block.<BR>
Writing 1 to this bit is ignored.<BR>
Note: For DMA operations, this bit is automatically controlled by the EIP-120t.<BR>
After reset, this bit is 0. After writing a context, this bit becomes 1.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESCTL_OUTPUT_READY">0</a>
</TD>
<TD class="cellBitfieldCol2">OUTPUT_READY</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1, this status bit indicates that an AES output block is available to be retrieved by the host.<BR>
Writing 0 clears the bit to 0 and indicates that output data is read by the host. The AES core can provide a next output data block.<BR>
Writing 1 to this bit is ignored.<BR>
Note: For DMA operations, this bit is automatically controlled by the EIP-120t.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATALEN0"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATALEN0</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0554</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4554</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4554</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Crypto Length 0 (LSW)<BR>
These registers are used to write the Length values to the EIP-120t. While processing, the length values decrement to 0. If both lengths are 0, the data stream is finished and a new context is requested. For basic AES modes (ECB, CBC, and CTR), a crypto length of 0 can be written if multiple streams need to be processed with the same key. Writing 0 length results in continued data requests until a new context is written. For the other modes (CBC-MAC, GCM, and CCM) no (new) data requests are done if the length decrements to or equals 0.<BR>
It is advised to write a new length per packet. If the length registers decrement to 0, no new data is processed until a new context or length value is written.<BR>
When writing a new mode without writing the length registers, the length register values from the previous context is reused.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATALEN0_C_LENGTH">31:0</a>
</TD>
<TD class="cellBitfieldCol2">C_LENGTH</TD>
<TD class="cellBitfieldCol3" colspan="3">C_LENGTH[31:0]<BR>
Bits [60:0] of the crypto length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started, this length decrements to 0. Data lengths up to (261: 1) bytes are allowed.<BR>
For GCM, any value up to 236 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 232 - 2, resulting in a maximum number of bytes of 236 - 32.<BR>
A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM.<BR>
Note: For the combined modes (GCM and CCM), this length does not include the authentication only data; the authentication length is specified in the <A class="xref" href="#AESAUTHLEN">AESAUTHLEN</A> register<BR>
All modes must have a length greater than 0. For the combined modes, it is allowed to have one of the lengths equal to 0.<BR>
For the basic encryption modes (ECB, CBC, and CTR) it is allowed to program zero to the length field; in that case the length is assumed infinite.<BR>
All data must be byte (8-bit) aligned for stream cipher modes; bit aligned data streams are not supported by the EIP-120t. For block cipher modes, the data length must be programmed in multiples of the block cipher size, 16 bytes.<BR>
For a host read operation, these registers return all-0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATALEN1"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATALEN1</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0558</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4558</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4558</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Crypto Length 1 (MSW)<BR>
These registers are used to write the Length values to the EIP-120t. While processing, the length values decrement to 0. If both lengths are 0, the data stream is finished and a new context is requested. For basic AES modes (ECB, CBC, and CTR), a crypto length of 0 can be written if multiple streams need to be processed with the same key. Writing 0 length results in continued data requests until a new context is written. For the other modes (CBC-MAC, GCM and CCM) no (new) data requests are done if the length decrements to or equals 0.<BR>
It is advised to write a new length per packet. If the length registers decrement to 0, no new data is processed until a new context or length value is written.<BR>
When writing a new mode without writing the length registers, the length register values from the previous context is reused.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATALEN1_RESERVED29">31:29</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED29</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0b000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATALEN1_C_LENGTH">28:0</a>
</TD>
<TD class="cellBitfieldCol2">C_LENGTH</TD>
<TD class="cellBitfieldCol3" colspan="3">C_LENGTH[60:32]<BR>
Bits [60:0] of the crypto length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started, this length decrements to 0. Data lengths up to (261: 1) bytes are allowed.<BR>
For GCM, any value up to 236 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 232 - 2, resulting in a maximum number of bytes of 236 - 32.<BR>
A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM.<BR>
Note: For the combined modes (GCM and CCM), this length does not include the authentication only data; the authentication length is specified in the <A class="xref" href="#AESAUTHLEN">AESAUTHLEN</A> register<BR>
All modes must have a length greater than 0. For the combined modes, it is allowed to have one of the lengths equal to 0.<BR>
For the basic encryption modes (ECB, CBC, and CTR) it is allowed to program zero to the length field; in that case the length is assumed infinite.<BR>
All data must be byte (8-bit) aligned for stream cipher modes; bit aligned data streams are not supported by the EIP-120t. For block cipher modes, the data length must be programmed in multiples of the block cipher size, 16 bytes.<BR>
For a host read operation, these registers return all-0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0b0 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESAUTHLEN"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESAUTHLEN</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 055C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 455C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 455C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Authentication Length</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESAUTHLEN_AUTH_LENGTH">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AUTH_LENGTH</TD>
<TD class="cellBitfieldCol3" colspan="3">Bits [31:0] of the authentication length register store the authentication data length in bytes for combined modes only (GCM or CCM).<BR>
Supported AAD-lengths for CCM are from 0 to (2^16 - 2^8) bytes. For GCM any value up to (2^32 - 1) bytes can be used. Once processing with this context is started, this length decrements to 0.<BR>
A write to this register triggers the engine to start using this context for GCM and CCM.<BR>
For a host read operation, these registers return all-0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATAOUT0"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATAOUT0</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0560</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4560</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4560</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Data Input/Output</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATAOUT0_DATA">31:0</a>
</TD>
<TD class="cellBitfieldCol2">DATA</TD>
<TD class="cellBitfieldCol3" colspan="3">Data register 0 for output block data from the Crypto peripheral.<BR>
These bits = AES Output Data[31:0] of {127:0]<BR>
<BR>
For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.<BR>
<BR>
For a Host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range will read one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, <A class="xref" href="#AESCTL_OUTPUT_READY">AESCTL.OUTPUT_READY</A> must be written.<BR>
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.<BR>
<BR>
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATAIN0"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATAIN0</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0560</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4560</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4560</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Data Input_Output 0<BR>
The data registers are typically accessed through the DMA and not with host writes and/or reads. However, for debugging purposes the data input/output registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.<BR>
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.<BR>
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATAIN0_AES_DATA_IN_OUT">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AES_DATA_IN_OUT</TD>
<TD class="cellBitfieldCol3" colspan="3">AES input data[31:0] / AES output data[31:0]<BR>
Data registers for input/output block data to/from the EIP-120t.<BR>
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.<BR>
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.<BR>
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.<BR>
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.<BR>
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATAOUT1"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATAOUT1</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0564</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4564</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4564</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Data Input/Output</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATAOUT1_DATA">31:0</a>
</TD>
<TD class="cellBitfieldCol2">DATA</TD>
<TD class="cellBitfieldCol3" colspan="3">Data register 0 for output block data from the Crypto peripheral.<BR>
These bits = AES Output Data[31:0] of {127:0]<BR>
<BR>
For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.<BR>
<BR>
For a Host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range will read one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, <A class="xref" href="#AESCTL_OUTPUT_READY">AESCTL.OUTPUT_READY</A> must be written.<BR>
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.<BR>
<BR>
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATAIN1"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATAIN1</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0564</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4564</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4564</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Data Input_Output 0<BR>
The data registers are typically accessed through the DMA and not with host writes and/or reads. However, for debugging purposes the data input/output registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.<BR>
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.<BR>
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATAIN1_AES_DATA_IN_OUT">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AES_DATA_IN_OUT</TD>
<TD class="cellBitfieldCol3" colspan="3">AES input data[31:0] / AES output data[63:32]<BR>
Data registers for input/output block data to/from the EIP-120t.<BR>
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.<BR>
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.<BR>
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.<BR>
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.<BR>
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATAOUT2"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATAOUT2</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0568</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4568</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4568</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Data Input/Output</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATAOUT2_DATA">31:0</a>
</TD>
<TD class="cellBitfieldCol2">DATA</TD>
<TD class="cellBitfieldCol3" colspan="3">Data register 0 for output block data from the Crypto peripheral.<BR>
These bits = AES Output Data[31:0] of {127:0]<BR>
<BR>
For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.<BR>
<BR>
For a Host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range will read one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, <A class="xref" href="#AESCTL_OUTPUT_READY">AESCTL.OUTPUT_READY</A> must be written.<BR>
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.<BR>
<BR>
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATAIN2"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATAIN2</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0568</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4568</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4568</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Data Input_Output 2<BR>
The data registers are typically accessed via DMA and not with host writes and/or reads. However, for debugging purposes the Data Input/Output Registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.<BR>
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.<BR>
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATAIN2_AES_DATA_IN_OUT">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AES_DATA_IN_OUT</TD>
<TD class="cellBitfieldCol3" colspan="3">AES input data[95:64] / AES output data[95:64]<BR>
Data registers for input/output block data to/from the EIP-120t.<BR>
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.<BR>
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.<BR>
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.<BR>
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.<BR>
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATAOUT3"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATAOUT3</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 056C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 456C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 456C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Data Input/Output</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATAOUT3_DATA">31:0</a>
</TD>
<TD class="cellBitfieldCol2">DATA</TD>
<TD class="cellBitfieldCol3" colspan="3">Data register 0 for output block data from the Crypto peripheral.<BR>
These bits = AES Output Data[31:0] of {127:0]<BR>
<BR>
For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.<BR>
<BR>
For a Host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range will read one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, <A class="xref" href="#AESCTL_OUTPUT_READY">AESCTL.OUTPUT_READY</A> must be written.<BR>
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.<BR>
<BR>
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESDATAIN3"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESDATAIN3</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 056C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 456C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 456C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Data Input_Output 3<BR>
The data registers are typically accessed via DMA and not with host writes and/or reads. However, for debugging purposes the Data Input/Output Registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.<BR>
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.<BR>
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESDATAIN3_AES_DATA_IN_OUT">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AES_DATA_IN_OUT</TD>
<TD class="cellBitfieldCol3" colspan="3">AES input data[127:96] / AES output data[127:96]<BR>
Data registers for input/output block data to/from the EIP-120t.<BR>
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.<BR>
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.<BR>
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.<BR>
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.<BR>
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="AESTAGOUT__0-AESTAGOUT__3"></A><A name="AESTAGOUT0"></A><A name="AESTAGOUT1"></A><A name="AESTAGOUT2"></A><A name="AESTAGOUT3"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:AESTAGOUT__0-AESTAGOUT__3</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0570 - 0x0000 057C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4570 - 0x4002 457C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4570 - 0x4002 457C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">AES Tag Out 0<BR>
The tag registers can be accessed via DMA or directly with host reads.<BR>
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order will return the IV twice.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<a name="AESTAGOUT0_AES_TAG"></a><a name="AESTAGOUT1_AES_TAG"></a><a name="AESTAGOUT2_AES_TAG"></a><a name="AESTAGOUT3_AES_TAG"></a><TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="AESTAGOUT__0-AESTAGOUT__3_AES_TAG">31:0</a>
</TD>
<TD class="cellBitfieldCol2">AES_TAG</TD>
<TD class="cellBitfieldCol3" colspan="3">AES_TAG[31:0]<BR>
Bits [31:0] of this register stores the authentication value for the combined and authentication only modes.<BR>
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.<BR>
This register will only contain valid data if the TAG is available and when the <A class="xref" href="#AESCTL_SAVED_CONTEXT_RDY">AESCTL.SAVED_CONTEXT_RDY</A> register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN1"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN1</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0604</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4604</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4604</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 1<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN1_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[63:32]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A> is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A> is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN2"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN2</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0608</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4608</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4608</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 2 <BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN2_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[95:64]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when  <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A> is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A> is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN3"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN3</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 060C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 460C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 460C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 3<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN3_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[127:96]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN4"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN4</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0610</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4610</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4610</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 4<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN4_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[159:128]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when  <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is &#39;1&#39;. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN5"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN5</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0614</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4614</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4614</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 5<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN5_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[191:160]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN6"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN6</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0618</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4618</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4618</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 6<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN6_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[223:192]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN7"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN7</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 061C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 461C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 461C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 7<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN7_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[255:224]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN8"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN8</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0620</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4620</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4620</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 8 <BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN8_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[287:256]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN9"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN9</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0624</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4624</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4624</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 9<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN9_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[319:288]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN10"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN10</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0628</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4628</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4628</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 10<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN10_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[351:320]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN11"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN11</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 062C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 462C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 462C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 11<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN11_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[383:352]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN12"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN12</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0630</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4630</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4630</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 12<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN12_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[415:384]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN13"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN13</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0634</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4634</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4634</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 13<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN13_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[447:416]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN14"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN14</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0638</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4638</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4638</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 14<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN14_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[479:448]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN15"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN15</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 063C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 463C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 463C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 15<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN15_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[511:480]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN16"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN16</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0640</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4640</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4640</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 16<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN16_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[543:512]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN17"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN17</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0644</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4644</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4644</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 17<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN17_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[575:544]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN18"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN18</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0648</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4648</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4648</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 18<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN18_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[607:576]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN19"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN19</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 064C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 464C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 464C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 19<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN19_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[639:608]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN20"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN20</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0650</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4650</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4650</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 20<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN20_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[671:640]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN21"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN21</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0654</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4654</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4654</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 21<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN21_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[703:672]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN22"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN22</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0658</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4658</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4658</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 22<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN22_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[735:704]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN23"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN23</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 065C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 465C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 465C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 23<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN23_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[767:736]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN24"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN24</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0660</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4660</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4660</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 24<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN24_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[799:768]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN25"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN25</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0664</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4664</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4664</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 25<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN25_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[831:800]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN26"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN26</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0668</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4668</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4668</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 26<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN26_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[863:832]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN27"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN27</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 066C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 466C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 466C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 27<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN27_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[895:864]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN28"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN28</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0670</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4670</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4670</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 28<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN28_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[923:896]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN29"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN29</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0674</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4674</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4674</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 29<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN29_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[959:924]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN30"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN30</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0678</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4678</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4678</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 30<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN30_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[991:960]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDATAIN31"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDATAIN31</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 067C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 467C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 467C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Data Input 31<BR>
The data input registers should be used to provide input data to the hash module through the slave interface.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDATAIN31_HASH_DATA_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DATA_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DATA_IN[1023:992]<BR>
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&#39;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.<BR>
Note: The host may only write the input data buffer when <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>  is 1. If the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A>   is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.<BR>
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the <A class="xref" href="#HASHIOBUFCTRL">HASHIOBUFCTRL</A> register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.<BR>
Host read operations from these register addresses return 0s.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHIOBUFCTRL"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHIOBUFCTRL</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0680</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4680</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4680</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Input_Output Buffer Control<BR>
This register pair shares a single address location and contains bits that control and monitor the data flow between the host and the hash engine.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHIOBUFCTRL_RESERVED8">31:8</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED8</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x00 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHIOBUFCTRL_PAD_DMA_MESSAGE">7</a>
</TD>
<TD class="cellBitfieldCol2">PAD_DMA_MESSAGE</TD>
<TD class="cellBitfieldCol3" colspan="3">Note: This bit must only be used when data is supplied through the DMA. It should not be used when data is supplied through the slave interface.<BR>
This bit indicates whether the hash engine has to pad the message, received through the DMA and finalize the hash.<BR>
When set to 1, the hash engine pads the last block using the programmed length. After padding, the final hash result is calculated.<BR>
When set to 0, the hash engine treats the last written block as block-size aligned and calculates the intermediate digest.<BR>
This bit is automatically cleared when the last DMA data block is arrived in the hash engine.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHIOBUFCTRL_GET_DIGEST">6</a>
</TD>
<TD class="cellBitfieldCol2">GET_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.<BR>
This bit indicates whether the hash engine should provide the hash digest.<BR>
When provided simultaneously with data_in_av, the hash digest is provided after processing the data that is currently in the <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> register. When provided without data_in_av, the current internal digest buffer value is copied to the <A class="xref" href="#HASHDIGEST0">HASHDIGESTn</A> registers.<BR>
The host must write a 1 to this bit to make the intermediate hash digest available.<BR>
Writing 0 to this bit has no effect.<BR>
This bit is automatically cleared (that is, reads 0) when the hash engine has processed the contents of the <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> register. In the period between this bit is set by the host and the actual <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> processing, this bit reads 1.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHIOBUFCTRL_PAD_MESSAGE">5</a>
</TD>
<TD class="cellBitfieldCol2">PAD_MESSAGE</TD>
<TD class="cellBitfieldCol3" colspan="3">Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.<BR>
This bit indicates that the <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> registers hold the last data of the message and hash padding must be applied.<BR>
The host must write this bit to 1 in order to indicate to the hash engine that the <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> register currently holds the last data of the message. When pad_message is set to 1, the hash engine will add padding bits to the data currently in the <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> register.<BR>
When the last message block is smaller than 512 bits, the pad_message bit must be set to 1 together with the data_in_av bit.<BR>
When the last message block is equal to 512 bits, pad_message may be set together with data_in_av. In this case the pad_message bit may also be set after the last data block has been written to the hash engine (so when the rfd_in bit has become 1 again after writing the last data block).<BR>
Writing 0 to this bit has no effect.<BR>
This bit is automatically cleared (i.e. reads 0) by the hash engine. This bit reads 1 between the time it was set by the host and the hash engine interpreted its value.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHIOBUFCTRL_RESERVED3">4:3</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED3</TD>
<TD class="cellBitfieldCol3" colspan="3">Write 0s and ignore on reading</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b00</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHIOBUFCTRL_RFD_IN">2</a>
</TD>
<TD class="cellBitfieldCol2">RFD_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">Note: The bit description below is only applicable when data is sent through the slave interface. This bit can be ignored when data is received through the DMA.<BR>
Read-only status of the input buffer of the hash engine.<BR>
When 1, the input buffer of the hash engine can accept new data; the <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> registers can safely be populated with new data.<BR>
When 0, the input buffer of the hash engine is processing the data that is currently in <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A>; writing new data to these registers is not allowed.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">1</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHIOBUFCTRL_DATA_IN_AV">1</a>
</TD>
<TD class="cellBitfieldCol2">DATA_IN_AV</TD>
<TD class="cellBitfieldCol3" colspan="3">Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.<BR>
This bit indicates that the <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> registers contain new input data for processing.<BR>
The host must write a 1 to this bit to start processing the data in <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A>; the hash engine will process the new data as soon as it is ready for it (rfd_in bit is 1).<BR>
Writing 0 to this bit has no effect.<BR>
This bit is automatically cleared (i.e. reads as 0) when the hash engine starts processing the <A class="xref" href="#HASHDATAIN0">HASHDATAINn</A> contents. This bit reads 1 between the time it was set by the host and the hash engine actually starts processing the input data block.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHIOBUFCTRL_OUTPUT_FULL">0</a>
</TD>
<TD class="cellBitfieldCol2">OUTPUT_FULL</TD>
<TD class="cellBitfieldCol3" colspan="3">Indicates that the output buffer registers (<A class="xref" href="#HASHDIGEST0">HASHDIGESTn</A>) are available for reading by the host.<BR>
When this bit reads 0, the output buffer registers are released; the hash engine is allowed to write new data to it. In this case, the registers should not be read by the host.<BR>
When this bit reads 1, the hash engine has stored the result of the latest hash operation in the output buffer registers. As long as this bit reads 1, the host may read output buffer registers and the hash engine is prevented from writing new data to the output buffer.<BR>
After retrieving the hash result data from the output buffer, the host must write a 1 to this bit to clear it. This makes the digest output buffer available for the hash engine to store new hash results.<BR>
Writing 0 to this bit has no effect.<BR>
Note: If this bit is asserted (1) no new operation should be started before the digest is retrieved from the hash engine and this bit is cleared (0).</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHMODE"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHMODE</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0684</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4684</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4684</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Mode</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHMODE_RESERVED7">31:7</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED7</TD>
<TD class="cellBitfieldCol3" colspan="3">Write 0s and ignore on reading</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0b0 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHMODE_SHA384_MODE">6</a>
</TD>
<TD class="cellBitfieldCol2">SHA384_MODE</TD>
<TD class="cellBitfieldCol3" colspan="3">The host must write this bit with 1  prior to  processing a SHA 384 session.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHMODE_SHA512_MODE">5</a>
</TD>
<TD class="cellBitfieldCol2">SHA512_MODE</TD>
<TD class="cellBitfieldCol3" colspan="3">The host must write this bit with 1  prior to  processing a SHA 512 session.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHMODE_SHA224_MODE">4</a>
</TD>
<TD class="cellBitfieldCol2">SHA224_MODE</TD>
<TD class="cellBitfieldCol3" colspan="3">The host must write this bit with 1  prior to  processing a SHA 224 session.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHMODE_SHA256_MODE">3</a>
</TD>
<TD class="cellBitfieldCol2">SHA256_MODE</TD>
<TD class="cellBitfieldCol3" colspan="3">The host must write this bit with 1  prior to  processing a SHA 256 session.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHMODE_RESERVED1">2:1</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED1</TD>
<TD class="cellBitfieldCol3" colspan="3">Write 0s and ignore on reading</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0b00</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHMODE_NEW_HASH">0</a>
</TD>
<TD class="cellBitfieldCol2">NEW_HASH</TD>
<TD class="cellBitfieldCol3" colspan="3">When set to 1, it indicates that the hash engine must start processing a new hash session. The [HASHDIGESTn.* ] registers will automatically be loaded with the initial hash algorithm constants of the selected hash algorithm.<BR>
When this bit is 0 while the hash processing is started, the initial hash algorithm constants are not loaded in the <A class="xref" href="#HASHDIGEST0">HASHDIGESTn</A> registers. The hash engine will start processing with the digest that is currently in its internal <A class="xref" href="#HASHDIGEST0">HASHDIGESTn</A> registers.<BR>
This bit is automatically cleared when hash processing is started.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHINLENL"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHINLENL</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0688</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4688</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4688</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Input Length LSB</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHINLENL_LENGTH_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">LENGTH_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">LENGTH_IN[31:0]<BR>
Message length registers. The content of these registers is used by the hash engine during the message padding phase of the hash session. The data lines of this registers are directly connected to the interface of the hash engine.<BR>
For a write operation by the host, these registers should be written with the message length in bits.<BR>
<BR>
Final hash operations:<BR>
The total input data length must be programmed for new hash operations that require finalization (padding). The input data must be provided through the slave or DMA interface.<BR>
<BR>
Continued hash operations (finalized):<BR>
For continued hash operations that require finalization, the total message length must be programmed, including the length of previously hashed data that corresponds to the written input digest.<BR>
<BR>
Non-final hash operations:<BR>
For hash operations that do not require finalization (input data length is multiple of 512-bits which is SHA-256 data block size), the length field does not need to be programmed since not used by the operation.<BR>
<BR>
If the message length in bits is below (2^32-1), then only this register needs to be written. The hardware automatically sets HASH_LENGTH_IN_H to 0s in this case.<BR>
The host may write the length register at any time during the hash session when the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A> is high. The length register must be written before the last data of the active hash session is written into the hash engine.<BR>
host read operations from these register locations will return 0s.<BR>
Note: When getting data from DMA, this register must be programmed before DMA is programmed to start.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHINLENH"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHINLENH</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 068C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 468C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 468C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Input Length MSB</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHINLENH_LENGTH_IN">31:0</a>
</TD>
<TD class="cellBitfieldCol2">LENGTH_IN</TD>
<TD class="cellBitfieldCol3" colspan="3">LENGTH_IN[63:32]<BR>
Message length registers. The content of these registers is used by the hash engine during the message padding phase of the hash session. The data lines of this registers are directly connected to the interface of the hash engine.<BR>
For a write operation by the host, these registers should be written with the message length in bits.<BR>
<BR>
Final hash operations:<BR>
The total input data length must be programmed for new hash operations that require finalization (padding). The input data must be provided through the slave or DMA interface.<BR>
<BR>
Continued hash operations (finalized):<BR>
For continued hash operations that require finalization, the total message length must be programmed, including the length of previously hashed data that corresponds to the written input digest.<BR>
<BR>
Non-final hash operations:<BR>
For hash operations that do not require finalization (input data length is multiple of 512-bits which is SHA-256 data block size), the length field does not need to be programmed since not used by the operation.<BR>
<BR>
If the message length in bits is below (2^32-1), then only <A class="xref" href="#HASHINLENL">HASHINLENL</A> needs to be written. The hardware automatically sets HASH_LENGTH_IN_H to 0s in this case.<BR>
The host may write the length register at any time during the hash session when the <A class="xref" href="#HASHIOBUFCTRL_RFD_IN">HASHIOBUFCTRL.RFD_IN</A> is high. The length register must be written before the last data of the active hash session is written into the hash engine.<BR>
host read operations from these register locations will return 0s.<BR>
Note: When getting data from DMA, this register must be programmed before DMA is programmed to start.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTA"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTA</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06C0</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46C0</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46C0</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest A<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTA_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[31:0]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTB"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTB</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06C4</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46C4</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46C4</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest B<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTB_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[63:32]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTC"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTC</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06C8</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46C8</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46C8</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest C<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTC_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[95:64]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTD"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTD</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06CC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46CC</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46CC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest D<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTD_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[127:96]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTE"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTE</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06D0</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46D0</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46D0</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest E<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTE_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[159:128]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTF"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTF</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06D4</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46D4</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46D4</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest F<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTF_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[191:160]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTG"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTG</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06D8</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46D8</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46D8</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest G<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTG_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[223:192]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTH"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTH</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06DC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46DC</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46DC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest H<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTH_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[255:224]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTI"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTI</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06E0</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46E0</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46E0</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest I<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTI_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[287:256]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTJ"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTJ</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06E4</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46E4</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46E4</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest J<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTJ_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[319:288]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTK"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTK</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06E8</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46E8</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46E8</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest K<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTK_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[351:320]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTL"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTL</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06EC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46EC</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46EC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest L<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTL_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[383:352]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTM"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTM</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06F0</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46F0</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46F0</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest M<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTM_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[415:384]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTN"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTN</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06F4</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46F4</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46F4</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest N<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTN_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[447:416]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTO"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTO</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06F8</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46F8</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46F8</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest 0<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTO_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[479:448]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HASHDIGESTP"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HASHDIGESTP</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 06FC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 46FC</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 46FC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">HASH Digest P<BR>
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HASHDIGESTP_HASH_DIGEST">31:0</a>
</TD>
<TD class="cellBitfieldCol2">HASH_DIGEST</TD>
<TD class="cellBitfieldCol3" colspan="3">HASH_DIGEST[511:480]<BR>
Hash digest registers<BR>
Write operation:<BR>
<BR>
Continued hash:<BR>
These registers should be written with the context data, before the start of a resumed hash session (the <A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 0 when starting a hash session).<BR>
<BR>
New hash:<BR>
When initiating a new hash session (the<A class="xref" href="#HASHMODE_NEW_HASH">HASHMODE.NEW_HASH</A> bit is 1), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.<BR>
<BR>
Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0x0000 0000</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="ALGSEL"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:ALGSEL</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0700</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4700</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4700</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Algorithm Select<BR>
This algorithm selection register configures the internal destination of the DMA controller.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="ALGSEL_HASH_SHA_512">32</a>
</TD>
<TD class="cellBitfieldCol2">HASH_SHA_512</TD>
<TD class="cellBitfieldCol3" colspan="3">If set to one, selects the hash engine in 512B mode as destination for the DMA<BR>
The maximum transfer size to DMA engine is set to 64 bytes for reading and 32 bytes for writing (the latter is only applicable if the hash result is written out through the DMA).</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="ALGSEL_TAG">31</a>
</TD>
<TD class="cellBitfieldCol2">TAG</TD>
<TD class="cellBitfieldCol3" colspan="3">If this bit is cleared to 0, the DMA operation involves only data.<BR>
If this bit is set, the DMA operation includes a TAG (Authentication Result / Digest).<BR>
For SHA-256 operation, a DMA must be set up for both input data and TAG. For any other selected module, setting this bit only allows a DMA that reads the TAG. No data allowed to be transferred to or from the selected module via the DMA.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="ALGSEL_RESERVED4">30:4</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED4</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="ALGSEL_HASH_SHA_256">2</a>
</TD>
<TD class="cellBitfieldCol2">HASH_SHA_256</TD>
<TD class="cellBitfieldCol3" colspan="3">If set to one, selects the hash engine in 256B mode as destination for the DMA<BR>
The maximum transfer size to DMA engine is set to 64 bytes for reading and 32 bytes for writing (the latter is only applicable if the hash result is written out through the DMA).</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="ALGSEL_AES">1</a>
</TD>
<TD class="cellBitfieldCol2">AES</TD>
<TD class="cellBitfieldCol3" colspan="3">If set to one, selects the AES engine as source/destination for the DMA<BR>
The read and write maximum transfer size to the DMA engine is set to 16 bytes.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="ALGSEL_KEY_STORE">0</a>
</TD>
<TD class="cellBitfieldCol2">KEY_STORE</TD>
<TD class="cellBitfieldCol3" colspan="3">If set to one, selects the Key Store as destination for the DMA<BR>
The maximum transfer size to DMA engine is set to 32 bytes (however transfers of 16, 24 and 32 bytes are allowed)</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="DMAPROTCTL"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:DMAPROTCTL</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0704</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4704</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4704</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">DMA Protection Control<BR>
<BR>
Master PROT privileged access enable<BR>
This register enables the second bit (bit [1]) of the AHB HPROT bus of the AHB master interface when a read action of key(s) is performed on the AHB master interface for writing keys into the store module.</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAPROTCTL_RESERVED1">31:1</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED1</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="DMAPROTCTL_PROT_EN">0</a>
</TD>
<TD class="cellBitfieldCol2">PROT_EN</TD>
<TD class="cellBitfieldCol3" colspan="3">Select AHB transfer protection control for DMA transfers using the key store area as destination.<BR>
0 : transfers use &#39;USER&#39; type access.<BR>
1 : transfers use &#39;PRIVILEGED&#39; type access.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="SWRESET"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:SWRESET</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0740</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4740</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4740</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Software Reset</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="SWRESET_RESERVED1">31:1</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED1</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="SWRESET_SW_RESET">0</a>
</TD>
<TD class="cellBitfieldCol2">SW_RESET</TD>
<TD class="cellBitfieldCol3" colspan="3">If this bit is set to 1, the following modules are reset: <BR>
- Master control internal state is reset. That includes interrupt, error status register, and result available interrupt generation FSM. <BR>
- Key store module state is reset. That includes clearing the written area flags; therefore, the keys must be reloaded to the key store module.<BR>
Writing 0 has no effect.<BR>
The bit is self cleared after executing the reset.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="IRQTYPE"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:IRQTYPE</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0780</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4780</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4780</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Control Interrupt Configuration</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQTYPE_RESERVED1">31:1</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED1</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQTYPE_LEVEL">0</a>
</TD>
<TD class="cellBitfieldCol2">LEVEL</TD>
<TD class="cellBitfieldCol3" colspan="3">If this bit is 0, the interrupt output is a pulse.<BR>
If this bit is set to 1, the interrupt is a level interrupt that must be cleared by writing the interrupt clear register.<BR>
This bit is applicable for both interrupt output signals.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="IRQEN"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:IRQEN</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0784</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4784</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4784</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Control Interrupt Enable</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RW</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQEN_RESERVED2">31:2</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED2</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0b00 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQEN_DMA_IN_DONE">1</a>
</TD>
<TD class="cellBitfieldCol2">DMA_IN_DONE</TD>
<TD class="cellBitfieldCol3" colspan="3">If this bit is set to 0, the DMA input done (irq_dma_in_done) interrupt output is disabled and remains 0.<BR>
If this bit is set to 1, the DMA input done interrupt output is enabled.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQEN_RESULT_AVAIL">0</a>
</TD>
<TD class="cellBitfieldCol2">RESULT_AVAIL</TD>
<TD class="cellBitfieldCol3" colspan="3">If this bit is set to 0, the result available (irq_result_av) interrupt output is disabled and remains 0.<BR>
If this bit is set to 1, the result available interrupt output is enabled.</TD>
<TD class="cellBitfieldCol4">RW</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="IRQCLR"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:IRQCLR</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0788</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4788</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4788</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Control Interrupt Clear</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQCLR_DMA_BUS_ERR">31</a>
</TD>
<TD class="cellBitfieldCol2">DMA_BUS_ERR</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1 is written to this bit, the DMA bus error status is cleared.<BR>
Writing 0 has no effect.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQCLR_KEY_ST_WR_ERR">30</a>
</TD>
<TD class="cellBitfieldCol2">KEY_ST_WR_ERR</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1 is written to this bit, the key store write error status is cleared.<BR>
Writing 0 has no effect.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQCLR_KEY_ST_RD_ERR">29</a>
</TD>
<TD class="cellBitfieldCol2">KEY_ST_RD_ERR</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1 is written to this bit, the key store read error status is cleared.<BR>
Writing 0 has no effect.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQCLR_RESERVED2">28:2</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED2</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQCLR_DMA_IN_DONE">1</a>
</TD>
<TD class="cellBitfieldCol2">DMA_IN_DONE</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1 is written to this bit, the DMA in done (irq_dma_in_done) interrupt output is cleared.<BR>
Writing 0 has no effect.<BR>
Note that clearing an interrupt makes sense only if the interrupt output is programmed as level (refer to <A class="xref" href="#IRQTYPE">IRQTYPE</A>).</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQCLR_RESULT_AVAIL">0</a>
</TD>
<TD class="cellBitfieldCol2">RESULT_AVAIL</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1 is written to this bit, the result available (irq_result_av) interrupt output is cleared.<BR>
Writing 0 has no effect.<BR>
Note that clearing an interrupt makes sense only if the interrupt output is programmed as level (refer to <A class="xref" href="#IRQTYPE">IRQTYPE</A>).</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="IRQSET"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:IRQSET</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 078C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 478C</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 478C</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Control Interrupt Set</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">WO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSET_RESERVED2">31:2</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED2</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0b00 0000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSET_DMA_IN_DONE">1</a>
</TD>
<TD class="cellBitfieldCol2">DMA_IN_DONE</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1 is written to this bit, the DMA data in done (irq_dma_in_done) interrupt output is set to one.<BR>
Writing 0 has no effect.<BR>
If the interrupt configuration register is programmed to pulse, clearing the DMA data in done (irq_dma_in_done) interrupt is not needed. If it is programmed to level, clearing the interrupt output should be done by writing the interrupt clear register (<A class="xref" href="#IRQCLR_DMA_IN_DONE">IRQCLR.DMA_IN_DONE</A>).</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSET_RESULT_AVAIL">0</a>
</TD>
<TD class="cellBitfieldCol2">RESULT_AVAIL</TD>
<TD class="cellBitfieldCol3" colspan="3">If 1 is written to this bit, the result available (irq_result_av) interrupt output is set to one.<BR>
Writing 0 has no effect.<BR>
If the interrupt configuration register is programmed to pulse, clearing the result available (irq_result_av) interrupt is not needed. If it is programmed to level, clearing the interrupt output should be done by writing the interrupt clear register (<A class="xref" href="#IRQCLR_RESULT_AVAIL">IRQCLR.RESULT_AVAIL</A>).</TD>
<TD class="cellBitfieldCol4">WO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="IRQSTAT"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:IRQSTAT</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 0790</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 4790</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 4790</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Control Interrupt Status</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSTAT_DMA_BUS_ERR">31</a>
</TD>
<TD class="cellBitfieldCol2">DMA_BUS_ERR</TD>
<TD class="cellBitfieldCol3" colspan="3">This bit is set when a DMA bus error is detected during a DMA operation. The value of this register is held until it is cleared through the <A class="xref" href="#IRQCLR_DMA_BUS_ERR">IRQCLR.DMA_BUS_ERR</A> <BR>
Note: This error is asserted if an error is detected on the AHB master interface during a DMA operation.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSTAT_KEY_ST_WR_ERR">30</a>
</TD>
<TD class="cellBitfieldCol2">KEY_ST_WR_ERR</TD>
<TD class="cellBitfieldCol3" colspan="3">This bit is set when a write error is detected during the DMA write operation to the key store memory. The value of this register is held until it is cleared through the <A class="xref" href="#IRQCLR_KEY_ST_WR_ERR">IRQCLR.KEY_ST_WR_ERR</A> register.<BR>
Note: This error is asserted if a DMA operation does not cover a full key area or more areas are written than expected.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSTAT_KEY_ST_RD_ERR">29</a>
</TD>
<TD class="cellBitfieldCol2">KEY_ST_RD_ERR</TD>
<TD class="cellBitfieldCol3" colspan="3">This bit is set when a read error is detected during the read of a key from the key store, while copying it to the AES core. The value of this register is held until it is cleared through the <A class="xref" href="#IRQCLR_KEY_ST_RD_ERR">IRQCLR.KEY_ST_RD_ERR</A> register.<BR>
Note: This error is asserted if a key location is selected in the key store that is not available.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSTAT_RESERVED2">28:2</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED2</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0b000 0000 0000 0000 0000 0000 0000</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSTAT_DMA_IN_DONE">1</a>
</TD>
<TD class="cellBitfieldCol2">DMA_IN_DONE</TD>
<TD class="cellBitfieldCol3" colspan="3">This read only bit returns the actual DMA data in done (irq_data_in_done) interrupt status of the DMA data in done interrupt output pin (irq_data_in_done).</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="IRQSTAT_RESULT_AVAIL">0</a>
</TD>
<TD class="cellBitfieldCol2">RESULT_AVAIL</TD>
<TD class="cellBitfieldCol3" colspan="3">This read only bit returns the actual result available (irq_result_av) interrupt status of the result available interrupt output pin (irq_result_av).</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0</TD>
</TR>
</TABLE>
<H3 class="mmapRegisterTitle"><A name="HWVER"></A><A class="mmapRegisterTitle" href="CPU_MMAP.html">TOP</A>:<A class="mmapRegisterTitle" href="#Top_Tag">CRYPTO</A>:HWVER</H3><TABLE cellspacing="0" class="mmapRegisterTable">
<TR class="row">
<TD class="cellCol1"><B>Address Offset</B></TD>
<TD class="cellCol2" colspan="3">0x0000 07FC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Physical Address</TD>
<TD class="cellCol2">0x4002 47FC</TD>
<TD class="cellCol3">Instance</TD>
<TD class="cellCol4">0x4002 47FC</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Description</TD>
<TD class="cellCol2" colspan="3">Hardware Version</TD>
</TR>
<TR class="row">
<TD class="cellCol1">Type</TD>
<TD class="cellCol2" colspan="3">RO</TD>
</TR>
</TABLE>
<TABLE cellspacing="0" class="mmapBitfieldTable">
<TR class="rowTop">
<TD class="cellTopCol1">Bits</TD>
<TD class="cellTopCol2">Field Name</TD>
<TD class="cellTopCol3" colspan="3">Description</TD>
<TD class="cellTopCol4">Type</TD>
<TD class="cellTopCol5">Reset</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HWVER_RESERVED28">31:28</a>
</TD>
<TD class="cellBitfieldCol2">RESERVED28</TD>
<TD class="cellBitfieldCol3" colspan="3">Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x9</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HWVER_HW_MAJOR_VER">27:24</a>
</TD>
<TD class="cellBitfieldCol2">HW_MAJOR_VER</TD>
<TD class="cellBitfieldCol3" colspan="3">Major version number</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x2</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HWVER_HW_MINOR_VER">23:20</a>
</TD>
<TD class="cellBitfieldCol2">HW_MINOR_VER</TD>
<TD class="cellBitfieldCol3" colspan="3">Minor version number</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HWVER_HW_PATCH_LVL">19:16</a>
</TD>
<TD class="cellBitfieldCol2">HW_PATCH_LVL</TD>
<TD class="cellBitfieldCol3" colspan="3">Patch level<BR>
Starts at 0 at first delivery of this version</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x0</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HWVER_VER_NUM_COMPL">15:8</a>
</TD>
<TD class="cellBitfieldCol2">VER_NUM_COMPL</TD>
<TD class="cellBitfieldCol3" colspan="3">These bits simply contain the complement of bits [7:0] (0x87), used by a driver to ascertain that the EIP-120t register is indeed read.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x87</TD>
</TR>
<TR class="rowBitfield">
<TD class="cellBitfieldCol1"><a name="HWVER_VER_NUM">7:0</a>
</TD>
<TD class="cellBitfieldCol2">VER_NUM</TD>
<TD class="cellBitfieldCol3" colspan="3">These bits encode the EIP number for the EIP-120t, this field contains the value 120 (decimal) or 0x78.</TD>
<TD class="cellBitfieldCol4">RO</TD>
<TD class="cellBitfieldCol5">0x78</TD>
</TR>
</TABLE>
<BR>
<BR>
<hr><table class="footer"><tr><td>&copy; 2015 - 2016. Texas Instruments | All Rights Reserved</td></tr></table>
</BODY>
</HTML>
