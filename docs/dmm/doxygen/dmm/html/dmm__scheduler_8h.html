<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>DMM API Reference: source/ti/dmm/dmm_scheduler.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DMM API Reference
   &#160;<span id="projectnumber">5.10.00.43</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dmm__scheduler_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dmm_scheduler.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>DMM Scheduler. </p>
<hr/>
<p>DMM enables devices to run multiple wireless protocol stacks concurrently. The DMMSch module enables concurrent operation of multiple stacks with minimized conflicts so that it does not cause significant performance degradation. The DMMSch uses Application Level, Stack Level information, and Global Priority Table (GPT) when scheduling a command. Stack Level information (provided by stack) is embedded in each RF command and it includes:</p><ul>
<li>Start Type, Start Time, AllowDelay, Priority, Activity, etc. Application Level information (provided by User via the Policy Table) includes:</li>
<li>Application State Name, Weight, AppliedActivity, Pause, etc. Global Priority Table (GPT)</li>
<li>GPT defines relative priorities of the two stacks The DMMSch uses Start Type, Start Time, and AllowDelay (Stack Level Information) when scheduling a RF command and tries to avoid a conflict by delaying the command if allowed. When a command conflicts with another (during scheduling or execution), The DMMSch selects one command over the other based on the final priority of two commands as below: Final Priority = GPT (Stack level priority) + weight (Application Level)</li>
</ul>
<h1>DMMSch API</h1>
<p>To use the DMMSch module to schedule a stack's RF commands, the application calls the following APIs:</p><ul>
<li><a class="el" href="dmm__scheduler_8h.html#a8b759869efad3b4428ba1cbd5a31a2be" title="Function that initializes the DMMSch module. ">DMMSch_init()</a>: Initialize the DMMSch module/task.</li>
<li><a class="el" href="dmm__scheduler_8h.html#a8fb89967829d38ab19ffabcfc36eed8b" title="Function to initialize the DMMSch_Params struct to its defaults. ">DMMSch_Params_init()</a>: Initialize a <a class="el" href="structDMMSch__Params.html" title="RF parameter struct DMM Scheduler parameters are used with the DMMSch_open() and DMMSch_Params_init()...">DMMSch_Params</a> structure with default values. Then change the parameters from non-default values as needed.</li>
<li><a class="el" href="dmm__scheduler_8h.html#ad53b1679ba0e2557222075ceffa0c8ed" title="Open the DMMSch module. ">DMMSch_open()</a>: Open an instance of the DMMSch module, passing the initialized parameters.</li>
<li>Stack A application - <a class="el" href="dmm__scheduler_8h.html#a1628a99f53b1b2431cadfd83cd1b9823" title="Register an DMM Scheduler client. ">DMMSch_registerClient()</a>: Passes Task_Handle and StackRole so DMMSch can map the Task_Handle to the stack role</li>
<li>Stack A application - RF_open() -&gt; <a class="el" href="dmm__scheduler_8h.html#af9d12f9aa1b47a5a3fb396fd731e5a07" title="Intercepts calls from a stack to RF_postCmd (re-mapped to DMMSch_rfOpen), The DMMSch module uses this...">DMMSch_rfOpen()</a>: DMMSch overwrites the RF_Mode and rf patches for multi-mode operation, maps RF Handle to the stack ID, assigns phySwitchingTime for DMM operation. From this point, Task_Handle, StackRole, and Stack ID are all related.</li>
<li>Stack B application - <a class="el" href="dmm__scheduler_8h.html#a1628a99f53b1b2431cadfd83cd1b9823" title="Register an DMM Scheduler client. ">DMMSch_registerClient()</a>: Passes Task_Handle and StackRole so DMMSch can map the Task_Handle to the stack role</li>
<li>Stack B application - RF_open() -&gt; <a class="el" href="dmm__scheduler_8h.html#af9d12f9aa1b47a5a3fb396fd731e5a07" title="Intercepts calls from a stack to RF_postCmd (re-mapped to DMMSch_rfOpen), The DMMSch module uses this...">DMMSch_rfOpen()</a>: DMMSch overwrites the RF_Mode and rf patches for multi-mode operation, maps RF Handle to the stack ID, assigns phySwitchingTime for DMM operation. From this point, Task_Handle, StackRole, and Stack ID are all related.</li>
<li>Stack A application - RF_scheduleCmd() -&gt; <a class="el" href="dmm__scheduler_8h.html#a4c9e8e73743fd34f577419b3ec20a56d" title="Handles calls from a stack to RF_scheduleCmd (re-mapped to DMMSch_scheduleCmd), adjusts timing as nec...">DMMSch_rfScheduleCmd()</a>: DMMSch adjusted timing based on policy</li>
<li>Stack B application - RF_scheduleCmd() -&gt; <a class="el" href="dmm__scheduler_8h.html#a4c9e8e73743fd34f577419b3ec20a56d" title="Handles calls from a stack to RF_scheduleCmd (re-mapped to DMMSch_scheduleCmd), adjusts timing as nec...">DMMSch_rfScheduleCmd()</a>: DMMSch adjusted timing based on policy </li>
</ul>
</div><div class="textblock"><code>#include &quot;stdint.h&quot;</code><br />
<code>#include &lt;ti/drivers/rf/RF.h&gt;</code><br />
<code>#include &lt;ti/sysbios/knl/Task.h&gt;</code><br />
<code>#include &quot;<a class="el" href="dmm__policy_8h_source.html">dmm_policy.h</a>&quot;</code><br />
</div>
<p><a href="dmm__scheduler_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDMMSch__Params.html">DMMSch_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RF parameter struct DMM Scheduler parameters are used with the <a class="el" href="dmm__scheduler_8h.html#ad53b1679ba0e2557222075ceffa0c8ed" title="Open the DMMSch module. ">DMMSch_open()</a> and <a class="el" href="dmm__scheduler_8h.html#a8fb89967829d38ab19ffabcfc36eed8b" title="Function to initialize the DMMSch_Params struct to its defaults. ">DMMSch_Params_init()</a> call.  <a href="structDMMSch__Params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab50c78b4424b3db43891281578d08ed1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#ab50c78b4424b3db43891281578d08ed1">CONFLICT_FLUSH_ALL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ab50c78b4424b3db43891281578d08ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define to flush all commands.  <a href="#ab50c78b4424b3db43891281578d08ed1">More...</a><br /></td></tr>
<tr class="separator:ab50c78b4424b3db43891281578d08ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1a251bb09ec11ba57b4ced3fd6cd0bc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a1a251bb09ec11ba57b4ced3fd6cd0bc1">xDMM_DEBUG_LOGGING</a></td></tr>
<tr class="memdesc:a1a251bb09ec11ba57b4ced3fd6cd0bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMM Debug Logging.  <a href="#a1a251bb09ec11ba57b4ced3fd6cd0bc1">More...</a><br /></td></tr>
<tr class="separator:a1a251bb09ec11ba57b4ced3fd6cd0bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e1238304bd61d80432b7d160e6eb90"><td class="memItemLeft" align="right" valign="top"><a id="ae5e1238304bd61d80432b7d160e6eb90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DMM_dbgLog0</b>(str)</td></tr>
<tr class="separator:ae5e1238304bd61d80432b7d160e6eb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ded0b3ad348295a8e85a9e36ee2193"><td class="memItemLeft" align="right" valign="top"><a id="a95ded0b3ad348295a8e85a9e36ee2193"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DMM_dbgLog1</b>(str,  a0)</td></tr>
<tr class="separator:a95ded0b3ad348295a8e85a9e36ee2193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994b236cc3817376e8cd7371b61f1501"><td class="memItemLeft" align="right" valign="top"><a id="a994b236cc3817376e8cd7371b61f1501"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DMM_dbgLog2</b>(str,  a0,  a1)</td></tr>
<tr class="separator:a994b236cc3817376e8cd7371b61f1501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0d12ef7469eb92b4665b58caef435c"><td class="memItemLeft" align="right" valign="top"><a id="a3e0d12ef7469eb92b4665b58caef435c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DMM_dbgLog3</b>(str,  a0,  a1,  a2)</td></tr>
<tr class="separator:a3e0d12ef7469eb92b4665b58caef435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae270217459856076d35f52e423f09dec"><td class="memItemLeft" align="right" valign="top"><a id="ae270217459856076d35f52e423f09dec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DMM_dbgLog4</b>(str,  a0,  a1,  a2,  a3)</td></tr>
<tr class="separator:ae270217459856076d35f52e423f09dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee04d4aecbaffa2cad0e7f1f659e9bc"><td class="memItemLeft" align="right" valign="top"><a id="a8ee04d4aecbaffa2cad0e7f1f659e9bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DMM_dbgLog5</b>(str,  a0,  a1,  a2,  a3,  a4)</td></tr>
<tr class="separator:a8ee04d4aecbaffa2cad0e7f1f659e9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab859531c7cd71e8bdfca0bb07226d7a2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#ab859531c7cd71e8bdfca0bb07226d7a2">DMMSch_PreemptionCb</a>) (<a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a> stackRolePreempted)</td></tr>
<tr class="memdesc:ab859531c7cd71e8bdfca0bb07226d7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the preemption callback.  <a href="#ab859531c7cd71e8bdfca0bb07226d7a2">More...</a><br /></td></tr>
<tr class="separator:ab859531c7cd71e8bdfca0bb07226d7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a94d985ecc9cf86da8f6ce5ae69b8ebef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a94d985ecc9cf86da8f6ce5ae69b8ebef">DMM_ConflictStatus</a> { <a class="el" href="dmm__scheduler_8h.html#a94d985ecc9cf86da8f6ce5ae69b8ebefafab3905862da9b5fc90e450e9067cfc6">DMM_NoConflict</a> = 0, 
<a class="el" href="dmm__scheduler_8h.html#a94d985ecc9cf86da8f6ce5ae69b8ebefa6b4fb04650718cdc7cba61c745dd70aa">DMM_ConflictWithPrev</a>, 
<a class="el" href="dmm__scheduler_8h.html#a94d985ecc9cf86da8f6ce5ae69b8ebefa4fb473b63e72792f0f5b73c52cf31964">DMM_ConflictWithNext</a>, 
<a class="el" href="dmm__scheduler_8h.html#a94d985ecc9cf86da8f6ce5ae69b8ebefae457e86e617743fe3cb40b6e7382511e">DMM_ConfictWithBoth</a>
 }<tr class="memdesc:a94d985ecc9cf86da8f6ce5ae69b8ebef"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMM Conflict struct DMM Conflict Status.  <a href="dmm__scheduler_8h.html#a94d985ecc9cf86da8f6ce5ae69b8ebef">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a94d985ecc9cf86da8f6ce5ae69b8ebef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8fb89967829d38ab19ffabcfc36eed8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a8fb89967829d38ab19ffabcfc36eed8b">DMMSch_Params_init</a> (<a class="el" href="structDMMSch__Params.html">DMMSch_Params</a> *params)</td></tr>
<tr class="memdesc:a8fb89967829d38ab19ffabcfc36eed8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="structDMMSch__Params.html" title="RF parameter struct DMM Scheduler parameters are used with the DMMSch_open() and DMMSch_Params_init()...">DMMSch_Params</a> struct to its defaults.  <a href="#a8fb89967829d38ab19ffabcfc36eed8b">More...</a><br /></td></tr>
<tr class="separator:a8fb89967829d38ab19ffabcfc36eed8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b759869efad3b4428ba1cbd5a31a2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a8b759869efad3b4428ba1cbd5a31a2be">DMMSch_init</a> (void)</td></tr>
<tr class="memdesc:a8b759869efad3b4428ba1cbd5a31a2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes the DMMSch module.  <a href="#a8b759869efad3b4428ba1cbd5a31a2be">More...</a><br /></td></tr>
<tr class="separator:a8b759869efad3b4428ba1cbd5a31a2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a967bdc4b0a614834392971f21f530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#aa1a967bdc4b0a614834392971f21f530">DMMSch_registerPreemptionCb</a> (<a class="el" href="dmm__scheduler_8h.html#ab859531c7cd71e8bdfca0bb07226d7a2">DMMSch_PreemptionCb</a> dmmSchPreemptionCb)</td></tr>
<tr class="memdesc:aa1a967bdc4b0a614834392971f21f530"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows policy manager to register a callback on command preemption  <a href="#aa1a967bdc4b0a614834392971f21f530">More...</a><br /></td></tr>
<tr class="separator:aa1a967bdc4b0a614834392971f21f530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53b1679ba0e2557222075ceffa0c8ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#ad53b1679ba0e2557222075ceffa0c8ed">DMMSch_open</a> (<a class="el" href="structDMMSch__Params.html">DMMSch_Params</a> *params)</td></tr>
<tr class="memdesc:ad53b1679ba0e2557222075ceffa0c8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the DMMSch module.  <a href="#ad53b1679ba0e2557222075ceffa0c8ed">More...</a><br /></td></tr>
<tr class="separator:ad53b1679ba0e2557222075ceffa0c8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1628a99f53b1b2431cadfd83cd1b9823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a1628a99f53b1b2431cadfd83cd1b9823">DMMSch_registerClient</a> (Task_Handle *pTaskHndl, <a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a> StackRole)</td></tr>
<tr class="memdesc:a1628a99f53b1b2431cadfd83cd1b9823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an DMM Scheduler client.  <a href="#a1628a99f53b1b2431cadfd83cd1b9823">More...</a><br /></td></tr>
<tr class="separator:a1628a99f53b1b2431cadfd83cd1b9823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d12f9aa1b47a5a3fb396fd731e5a07"><td class="memItemLeft" align="right" valign="top">RF_Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#af9d12f9aa1b47a5a3fb396fd731e5a07">DMMSch_rfOpen</a> (RF_Object *pObj, RF_Mode *pRfMode, RF_RadioSetup *pOpSetup, RF_Params *params)</td></tr>
<tr class="memdesc:af9d12f9aa1b47a5a3fb396fd731e5a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intercepts calls from a stack to RF_postCmd (re-mapped to DMMSch_rfOpen), The DMMSch module uses this to tie.  <a href="#af9d12f9aa1b47a5a3fb396fd731e5a07">More...</a><br /></td></tr>
<tr class="separator:af9d12f9aa1b47a5a3fb396fd731e5a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a1402d5be04f038553f4b8971daaed"><td class="memItemLeft" align="right" valign="top">RF_CmdHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#ab1a1402d5be04f038553f4b8971daaed">DMMSch_rfPostCmd</a> (RF_Handle h, RF_Op *pOp, RF_Priority ePri, RF_Callback pCb, RF_EventMask bmEvent)</td></tr>
<tr class="memdesc:ab1a1402d5be04f038553f4b8971daaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles calls from a stack to RF_postCmd (re-mapped to DMMSch_postCmd), adjusts timing as necessary and schedules then accordingly with RF_scheduleCmd.  <a href="#ab1a1402d5be04f038553f4b8971daaed">More...</a><br /></td></tr>
<tr class="separator:ab1a1402d5be04f038553f4b8971daaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9e8e73743fd34f577419b3ec20a56d"><td class="memItemLeft" align="right" valign="top">RF_CmdHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a4c9e8e73743fd34f577419b3ec20a56d">DMMSch_rfScheduleCmd</a> (RF_Handle h, RF_Op *pOp, RF_ScheduleCmdParams *pSchParams, RF_Callback pCb, RF_EventMask bmEvent)</td></tr>
<tr class="memdesc:a4c9e8e73743fd34f577419b3ec20a56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles calls from a stack to RF_scheduleCmd (re-mapped to DMMSch_scheduleCmd), adjusts timing as necessary and schedules then accordingly with RF_scheduleCmd.  <a href="#a4c9e8e73743fd34f577419b3ec20a56d">More...</a><br /></td></tr>
<tr class="separator:a4c9e8e73743fd34f577419b3ec20a56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093aeaf3232d19ec4e204d24bb39c49d"><td class="memItemLeft" align="right" valign="top">RF_EventMask&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a093aeaf3232d19ec4e204d24bb39c49d">DMMSch_rfRunCmd</a> (RF_Handle h, RF_Op *pOp, RF_Priority ePri, RF_Callback pCb, RF_EventMask bmEvent)</td></tr>
<tr class="memdesc:a093aeaf3232d19ec4e204d24bb39c49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles calls from a stack to RF_runCmd (re-mapped to DMMSch_runCmd), adjusts timing as necessary and schedules then accordingly with RF_scheduleCmd.  <a href="#a093aeaf3232d19ec4e204d24bb39c49d">More...</a><br /></td></tr>
<tr class="separator:a093aeaf3232d19ec4e204d24bb39c49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208b337e52fcc3a69e7c9123cc6b00a8"><td class="memItemLeft" align="right" valign="top">RF_EventMask&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a208b337e52fcc3a69e7c9123cc6b00a8">DMMSch_rfRunScheduleCmd</a> (RF_Handle h, RF_Op *pOp, RF_ScheduleCmdParams *pSchParams, RF_Callback pCb, RF_EventMask bmEvent)</td></tr>
<tr class="memdesc:a208b337e52fcc3a69e7c9123cc6b00a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles calls from a stack to RF_runScheduleCmd (re-mapped to DMMSch_runScheduleCmd), adjusts timing as necessary and schedules then accordingly with RF_scheduleCmd.  <a href="#a208b337e52fcc3a69e7c9123cc6b00a8">More...</a><br /></td></tr>
<tr class="separator:a208b337e52fcc3a69e7c9123cc6b00a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce9f0c869b26c108c182427346685ef"><td class="memItemLeft" align="right" valign="top">RF_Stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#abce9f0c869b26c108c182427346685ef">DMMSch_rfCancelCmd</a> (RF_Handle h, RF_CmdHandle ch, uint8_t mode)</td></tr>
<tr class="memdesc:abce9f0c869b26c108c182427346685ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort/stop/cancel single command in command queue.  <a href="#abce9f0c869b26c108c182427346685ef">More...</a><br /></td></tr>
<tr class="separator:abce9f0c869b26c108c182427346685ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e881f2a1d91452777e9a9597ab71f0"><td class="memItemLeft" align="right" valign="top">RF_Stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a57e881f2a1d91452777e9a9597ab71f0">DMMSch_rfFlushCmd</a> (RF_Handle h, RF_CmdHandle ch, uint8_t mode)</td></tr>
<tr class="memdesc:a57e881f2a1d91452777e9a9597ab71f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort/stop/cancel command and any subsequent commands in command queue.  <a href="#a57e881f2a1d91452777e9a9597ab71f0">More...</a><br /></td></tr>
<tr class="separator:a57e881f2a1d91452777e9a9597ab71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec66d7055e1df822bc91e7dfc53d707f"><td class="memItemLeft" align="right" valign="top">RF_Stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#aec66d7055e1df822bc91e7dfc53d707f">DMMSch_rfRunImmediateCmd</a> (RF_Handle h, uint32_t *pCmdStruct)</td></tr>
<tr class="memdesc:aec66d7055e1df822bc91e7dfc53d707f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send any Immediate command. <br />
  <a href="#aec66d7055e1df822bc91e7dfc53d707f">More...</a><br /></td></tr>
<tr class="separator:aec66d7055e1df822bc91e7dfc53d707f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e233ac5222b453b88585b3980e170c"><td class="memItemLeft" align="right" valign="top">RF_Stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a15e233ac5222b453b88585b3980e170c">DMMSch_rfRunDirectCmd</a> (RF_Handle h, uint32_t cmd)</td></tr>
<tr class="memdesc:a15e233ac5222b453b88585b3980e170c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send any Direct command. <br />
  <a href="#a15e233ac5222b453b88585b3980e170c">More...</a><br /></td></tr>
<tr class="separator:a15e233ac5222b453b88585b3980e170c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab3e42436dde7fa66bb1c36ee551b74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#abab3e42436dde7fa66bb1c36ee551b74">DMMSch_setBlockModeOn</a> (<a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a> stackRole)</td></tr>
<tr class="memdesc:abab3e42436dde7fa66bb1c36ee551b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on Block mode.  <a href="#abab3e42436dde7fa66bb1c36ee551b74">More...</a><br /></td></tr>
<tr class="separator:abab3e42436dde7fa66bb1c36ee551b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce84a1f78a8d694cf513b5381bfb67e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a2ce84a1f78a8d694cf513b5381bfb67e">DMMSch_setBlockModeOff</a> (<a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a> stackRole)</td></tr>
<tr class="memdesc:a2ce84a1f78a8d694cf513b5381bfb67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off Block mode.  <a href="#a2ce84a1f78a8d694cf513b5381bfb67e">More...</a><br /></td></tr>
<tr class="separator:a2ce84a1f78a8d694cf513b5381bfb67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751843ed42028b4c2f95a67f06b073d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a751843ed42028b4c2f95a67f06b073d7">DMMSch_getBlockModeStatus</a> (<a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a> stackRole)</td></tr>
<tr class="memdesc:a751843ed42028b4c2f95a67f06b073d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Block mode status.  <a href="#a751843ed42028b4c2f95a67f06b073d7">More...</a><br /></td></tr>
<tr class="separator:a751843ed42028b4c2f95a67f06b073d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d53a24dd1e98e6c248bf5aae1d0c84c"><td class="memItemLeft" align="right" valign="top"><a id="a8d53a24dd1e98e6c248bf5aae1d0c84c"></a>
RF_Stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmm__scheduler_8h.html#a8d53a24dd1e98e6c248bf5aae1d0c84c">DMMSch_rfRequestAccess</a> (RF_Handle h, RF_AccessParams *pParams)</td></tr>
<tr class="memdesc:a8d53a24dd1e98e6c248bf5aae1d0c84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request access RF API that should not be used in DMM <br />
 <br /></td></tr>
<tr class="separator:a8d53a24dd1e98e6c248bf5aae1d0c84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab50c78b4424b3db43891281578d08ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50c78b4424b3db43891281578d08ed1">&sect;&nbsp;</a></span>CONFLICT_FLUSH_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFLICT_FLUSH_ALL&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define to flush all commands. </p>
<p>Default option to flush all commands for a specific client for a conflict </p>

</div>
</div>
<a id="a1a251bb09ec11ba57b4ced3fd6cd0bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a251bb09ec11ba57b4ced3fd6cd0bc1">&sect;&nbsp;</a></span>xDMM_DEBUG_LOGGING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xDMM_DEBUG_LOGGING</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMM Debug Logging. </p>
<p><a class="anchor" id="DMM_dbgLog"></a> Debugging for internal use only. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab859531c7cd71e8bdfca0bb07226d7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab859531c7cd71e8bdfca0bb07226d7a2">&sect;&nbsp;</a></span>DMMSch_PreemptionCb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DMMSch_PreemptionCb) (<a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a> stackRolePreempted)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the preemption callback. </p>
<p>The function is invoked when a preemption occurs in DMM Scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stackRolePreempted</td><td>Stack role for command was preempted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a94d985ecc9cf86da8f6ce5ae69b8ebef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d985ecc9cf86da8f6ce5ae69b8ebef">&sect;&nbsp;</a></span>DMM_ConflictStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dmm__scheduler_8h.html#a94d985ecc9cf86da8f6ce5ae69b8ebef">DMM_ConflictStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMM Conflict struct DMM Conflict Status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a94d985ecc9cf86da8f6ce5ae69b8ebefafab3905862da9b5fc90e450e9067cfc6"></a>DMM_NoConflict&#160;</td><td class="fielddoc"><p>No conflict in commands. </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d985ecc9cf86da8f6ce5ae69b8ebefa6b4fb04650718cdc7cba61c745dd70aa"></a>DMM_ConflictWithPrev&#160;</td><td class="fielddoc"><p>There is a conflict with the previous command. </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d985ecc9cf86da8f6ce5ae69b8ebefa4fb473b63e72792f0f5b73c52cf31964"></a>DMM_ConflictWithNext&#160;</td><td class="fielddoc"><p>There is a conflict with the next command. </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d985ecc9cf86da8f6ce5ae69b8ebefae457e86e617743fe3cb40b6e7382511e"></a>DMM_ConfictWithBoth&#160;</td><td class="fielddoc"><p>There is a conflict with both previous and next commands. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a751843ed42028b4c2f95a67f06b073d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751843ed42028b4c2f95a67f06b073d7">&sect;&nbsp;</a></span>DMMSch_getBlockModeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DMMSch_getBlockModeStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a>&#160;</td>
          <td class="paramname"><em>stackRole</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Block mode status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stackRole</td><td>stack role associated with Task handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: Block Mode is On, False: Block Mode is Off </dd></dl>

</div>
</div>
<a id="a8b759869efad3b4428ba1cbd5a31a2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b759869efad3b4428ba1cbd5a31a2be">&sect;&nbsp;</a></span>DMMSch_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMMSch_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes the DMMSch module. </p>

</div>
</div>
<a id="ad53b1679ba0e2557222075ceffa0c8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53b1679ba0e2557222075ceffa0c8ed">&sect;&nbsp;</a></span>DMMSch_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMMSch_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDMMSch__Params.html">DMMSch_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the DMMSch module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to initialized <a class="el" href="structDMMSch__Params.html" title="RF parameter struct DMM Scheduler parameters are used with the DMMSch_open() and DMMSch_Params_init()...">DMMSch_Params</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fb89967829d38ab19ffabcfc36eed8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb89967829d38ab19ffabcfc36eed8b">&sect;&nbsp;</a></span>DMMSch_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMMSch_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDMMSch__Params.html">DMMSch_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="structDMMSch__Params.html" title="RF parameter struct DMM Scheduler parameters are used with the DMMSch_open() and DMMSch_Params_init()...">DMMSch_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to <a class="el" href="structDMMSch__Params.html" title="RF parameter struct DMM Scheduler parameters are used with the DMMSch_open() and DMMSch_Params_init()...">DMMSch_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Any initialized struct fields with invalid values must be further initialized by the caller before calling <a class="el" href="dmm__scheduler_8h.html#ad53b1679ba0e2557222075ceffa0c8ed" title="Open the DMMSch module. ">DMMSch_open()</a>.</dd></dl>
<p>Defaults values are:</p><ul>
<li>invalid <a class="el" href="structDMMSch__Params.html#a695b4f16387359e84063f6fc82e68ceb" title="Define the stacks that are supported by the scheduler. ">DMMSch_Params::stackRoles</a></li>
<li>NULL <a class="el" href="structDMMSch__Params.html#a037365501869c63066d9f780ff82a3e5" title="Define the index table for the scheduler. ">DMMSch_Params::indexTable</a> </li>
</ul>

</div>
</div>
<a id="a1628a99f53b1b2431cadfd83cd1b9823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1628a99f53b1b2431cadfd83cd1b9823">&sect;&nbsp;</a></span>DMMSch_registerClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMMSch_registerClient </td>
          <td>(</td>
          <td class="paramtype">Task_Handle *&#160;</td>
          <td class="paramname"><em>pTaskHndl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a>&#160;</td>
          <td class="paramname"><em>StackRole</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an DMM Scheduler client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTaskHndl</td><td>RTOS Thread handle that the stack is running in, used to map the RF Client handle to a stack role</td></tr>
    <tr><td class="paramname">StackRole</td><td>stack role associated with Task handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1a967bdc4b0a614834392971f21f530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a967bdc4b0a614834392971f21f530">&sect;&nbsp;</a></span>DMMSch_registerPreemptionCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMMSch_registerPreemptionCb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dmm__scheduler_8h.html#ab859531c7cd71e8bdfca0bb07226d7a2">DMMSch_PreemptionCb</a>&#160;</td>
          <td class="paramname"><em>dmmSchPreemptionCb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allows policy manager to register a callback on command preemption </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dmmSchPreemptionCb</td><td>callback to register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce9f0c869b26c108c182427346685ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce9f0c869b26c108c182427346685ef">&sect;&nbsp;</a></span>DMMSch_rfCancelCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_Stat DMMSch_rfCancelCmd </td>
          <td>(</td>
          <td class="paramtype">RF_Handle&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_CmdHandle&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort/stop/cancel single command in command queue. </p>
<p>If command is running, aborts/stops it and posts callback for the aborted/stopped command. <br />
 If command has not yet run, cancels it it and posts callback for the cancelled command. <br />
 If command has already run or been aborted/stopped/cancelled, has no effect.<br />
 If RF_cancelCmd is called from a Swi context with same or higher priority than RF Driver Swi, when the RF core is powered OFF -&gt; the cancel callback will be delayed until the next power-up cycle.<br />
</p>
<dl class="section note"><dt>Note</dt><dd>Calling context : Task/SWI</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Handle previously returned by RF_open() </td></tr>
    <tr><td class="paramname">ch</td><td>Command handle previously returned by RF_postCmd(). </td></tr>
    <tr><td class="paramname">mode</td><td>1: Stop gracefully, 0: abort abruptly </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RF_Stat indicates if command was successfully completed </dd></dl>

</div>
</div>
<a id="a57e881f2a1d91452777e9a9597ab71f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e881f2a1d91452777e9a9597ab71f0">&sect;&nbsp;</a></span>DMMSch_rfFlushCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_Stat DMMSch_rfFlushCmd </td>
          <td>(</td>
          <td class="paramtype">RF_Handle&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_CmdHandle&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort/stop/cancel command and any subsequent commands in command queue. </p>
<p>If command is running, aborts/stops it and then cancels all later commands in queue.<br />
 If command has not yet run, cancels it and all later commands in queue.<br />
 If command has already run or been aborted/stopped/cancelled, has no effect.<br />
 The callbacks for all cancelled commands are issued in chronological order.<br />
 If RF_flushCmd is called from a Swi context with same or higher priority than RF Driver Swi, when the RF core is powered OFF -&gt; the cancel callback will be delayed until the next power-up cycle.<br />
</p>
<dl class="section note"><dt>Note</dt><dd>Calling context : Task/SWI</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Handle previously returned by RF_open() </td></tr>
    <tr><td class="paramname">ch</td><td>Command handle previously returned by RF_postCmd(). </td></tr>
    <tr><td class="paramname">mode</td><td>1: Stop gracefully, 0: abort abruptly </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RF_Stat indicates if command was successfully completed </dd></dl>

</div>
</div>
<a id="af9d12f9aa1b47a5a3fb396fd731e5a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d12f9aa1b47a5a3fb396fd731e5a07">&sect;&nbsp;</a></span>DMMSch_rfOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_Handle DMMSch_rfOpen </td>
          <td>(</td>
          <td class="paramtype">RF_Object *&#160;</td>
          <td class="paramname"><em>pObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Mode *&#160;</td>
          <td class="paramname"><em>pRfMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_RadioSetup *&#160;</td>
          <td class="paramname"><em>pOpSetup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Params *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intercepts calls from a stack to RF_postCmd (re-mapped to DMMSch_rfOpen), The DMMSch module uses this to tie. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pObj</td><td>Pointer to RF Object </td></tr>
    <tr><td class="paramname">pRfMode</td><td>Pointer to RF Mode </td></tr>
    <tr><td class="paramname">pOpSetup</td><td>Pointer to Radio Setup </td></tr>
    <tr><td class="paramname">params</td><td>Pointer to RF params</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to DMMSch RF instance </dd></dl>

</div>
</div>
<a id="ab1a1402d5be04f038553f4b8971daaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a1402d5be04f038553f4b8971daaed">&sect;&nbsp;</a></span>DMMSch_rfPostCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_CmdHandle DMMSch_rfPostCmd </td>
          <td>(</td>
          <td class="paramtype">RF_Handle&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Op *&#160;</td>
          <td class="paramname"><em>pOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Priority&#160;</td>
          <td class="paramname"><em>ePri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Callback&#160;</td>
          <td class="paramname"><em>pCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_EventMask&#160;</td>
          <td class="paramname"><em>bmEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles calls from a stack to RF_postCmd (re-mapped to DMMSch_postCmd), adjusts timing as necessary and schedules then accordingly with RF_scheduleCmd. </p>
<dl class="section see"><dt>See also</dt><dd>RF_pendCmd(), RF_runCmd(), RF_scheduleCmd(), RF_RF_cancelCmd(), RF_flushCmd(), RF_getCmdOp()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Driver handle previously returned by RF_open() </td></tr>
    <tr><td class="paramname">pOp</td><td>Pointer to the RF operation command. </td></tr>
    <tr><td class="paramname">ePri</td><td>Priority of this RF command (used for arbitration in multi-client systems) </td></tr>
    <tr><td class="paramname">pCb</td><td>Callback function called during command execution and upon completion. If RF_postCmd() fails, no callback is made. </td></tr>
    <tr><td class="paramname">bmEvent</td><td>Bitmask of events that will trigger the callback or that can be pended on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the RF command. Return value of RF_ALLOC_ERROR indicates error. </dd></dl>

</div>
</div>
<a id="a093aeaf3232d19ec4e204d24bb39c49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093aeaf3232d19ec4e204d24bb39c49d">&sect;&nbsp;</a></span>DMMSch_rfRunCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_EventMask DMMSch_rfRunCmd </td>
          <td>(</td>
          <td class="paramtype">RF_Handle&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Op *&#160;</td>
          <td class="paramname"><em>pOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Priority&#160;</td>
          <td class="paramname"><em>ePri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Callback&#160;</td>
          <td class="paramname"><em>pCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_EventMask&#160;</td>
          <td class="paramname"><em>bmEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles calls from a stack to RF_runCmd (re-mapped to DMMSch_runCmd), adjusts timing as necessary and schedules then accordingly with RF_scheduleCmd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Driver handle previously returned by RF_open() </td></tr>
    <tr><td class="paramname">pOp</td><td>Pointer to the RF operation command. </td></tr>
    <tr><td class="paramname">ePri</td><td>Priority of this RF command (used for arbitration in multi-client systems) </td></tr>
    <tr><td class="paramname">pCb</td><td>Callback function called during command execution and upon completion. If RF_runCmd() fails, no callback is made. </td></tr>
    <tr><td class="paramname">bmEvent</td><td>Bitmask of events that will trigger the callback or that can be pended on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The relevant termination event. </dd></dl>

</div>
</div>
<a id="a15e233ac5222b453b88585b3980e170c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e233ac5222b453b88585b3980e170c">&sect;&nbsp;</a></span>DMMSch_rfRunDirectCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_Stat DMMSch_rfRunDirectCmd </td>
          <td>(</td>
          <td class="paramtype">RF_Handle&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send any Direct command. <br />
 </p>
<p>Direct Command value is send to RDBELL immediately, if radio is active and the RF_Handle point to the current client. <br />
 In other appropriate RF_Stat values are returned. <br />
</p>
<dl class="section note"><dt>Note</dt><dd>Calling context : Task/SWI/HWI</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Handle previously returned by RF_open() </td></tr>
    <tr><td class="paramname">cmd</td><td>Direct command value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RF_Stat indicates if command was successfully completed. </dd></dl>

</div>
</div>
<a id="aec66d7055e1df822bc91e7dfc53d707f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec66d7055e1df822bc91e7dfc53d707f">&sect;&nbsp;</a></span>DMMSch_rfRunImmediateCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_Stat DMMSch_rfRunImmediateCmd </td>
          <td>(</td>
          <td class="paramtype">RF_Handle&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pCmdStruct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send any Immediate command. <br />
 </p>
<p>Immediate Command is send to RDBELL, if radio is active and the RF_Handle points to the current client. <br />
 In other appropriate RF_Stat values are returned. <br />
</p>
<dl class="section note"><dt>Note</dt><dd>Calling context : Task/SWI/HWI</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Handle previously returned by RF_open() </td></tr>
    <tr><td class="paramname">pCmdStruct</td><td>Pointer to the immediate command structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RF_Stat indicates if command was successfully completed </dd></dl>

</div>
</div>
<a id="a208b337e52fcc3a69e7c9123cc6b00a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208b337e52fcc3a69e7c9123cc6b00a8">&sect;&nbsp;</a></span>DMMSch_rfRunScheduleCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_EventMask DMMSch_rfRunScheduleCmd </td>
          <td>(</td>
          <td class="paramtype">RF_Handle&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Op *&#160;</td>
          <td class="paramname"><em>pOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_ScheduleCmdParams *&#160;</td>
          <td class="paramname"><em>pSchParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Callback&#160;</td>
          <td class="paramname"><em>pCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_EventMask&#160;</td>
          <td class="paramname"><em>bmEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles calls from a stack to RF_runScheduleCmd (re-mapped to DMMSch_runScheduleCmd), adjusts timing as necessary and schedules then accordingly with RF_scheduleCmd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Handle previously returned by RF_open() </td></tr>
    <tr><td class="paramname">pOp</td><td>Pointer to the RF_Op. Must normally be in persistent and writeable memory </td></tr>
    <tr><td class="paramname">pSchParams</td><td>Pointer to the schedule command parameter structure </td></tr>
    <tr><td class="paramname">pCb</td><td>Callback function called upon command completion (and some other events). If RF_runScheduleCmd() fails, no callback is made. </td></tr>
    <tr><td class="paramname">bmEvent</td><td>Bitmask of events that will trigger the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The relevant command completed event. </dd></dl>

</div>
</div>
<a id="a4c9e8e73743fd34f577419b3ec20a56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9e8e73743fd34f577419b3ec20a56d">&sect;&nbsp;</a></span>DMMSch_rfScheduleCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF_CmdHandle DMMSch_rfScheduleCmd </td>
          <td>(</td>
          <td class="paramtype">RF_Handle&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Op *&#160;</td>
          <td class="paramname"><em>pOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_ScheduleCmdParams *&#160;</td>
          <td class="paramname"><em>pSchParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_Callback&#160;</td>
          <td class="paramname"><em>pCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF_EventMask&#160;</td>
          <td class="paramname"><em>bmEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles calls from a stack to RF_scheduleCmd (re-mapped to DMMSch_scheduleCmd), adjusts timing as necessary and schedules then accordingly with RF_scheduleCmd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Handle previously returned by RF_open() </td></tr>
    <tr><td class="paramname">pOp</td><td>Pointer to the RF_Op. Must normally be in persistent and writeable memory </td></tr>
    <tr><td class="paramname">pSchParams</td><td>Pointer to the schedule command parameter structure </td></tr>
    <tr><td class="paramname">pCb</td><td>Callback function called upon command completion (and some other events). If RF_scheduleCmd() fails no callback is made </td></tr>
    <tr><td class="paramname">bmEvent</td><td>Bitmask of events that will trigger the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the RF command. Return value of RF_ALLOC_ERROR indicates error. </dd></dl>

</div>
</div>
<a id="a2ce84a1f78a8d694cf513b5381bfb67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce84a1f78a8d694cf513b5381bfb67e">&sect;&nbsp;</a></span>DMMSch_setBlockModeOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DMMSch_setBlockModeOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a>&#160;</td>
          <td class="paramname"><em>stackRole</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn off Block mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stackRole</td><td>stack role associated with Task handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: success, false: the stack role cannot be found </dd></dl>

</div>
</div>
<a id="abab3e42436dde7fa66bb1c36ee551b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab3e42436dde7fa66bb1c36ee551b74">&sect;&nbsp;</a></span>DMMSch_setBlockModeOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DMMSch_setBlockModeOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dmm__policy_8h.html#a9b3ff96be7e4b8668995e1359f44789f">DMMPolicy_StackRole</a>&#160;</td>
          <td class="paramname"><em>stackRole</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on Block mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stackRole</td><td>stack role associated with Task handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true: success, false: the stack role cannot be found </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_2c72decbe2c74d6e417f502f5cbd5049.html">dmm</a></li><li class="navelem"><a class="el" href="dmm__scheduler_8h.html">dmm_scheduler.h</a></li>
  </ul>
</div>
</body>
</html>
