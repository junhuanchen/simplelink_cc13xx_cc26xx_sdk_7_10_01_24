<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>OpenThread: Array&lt; Type, kCapacityIncrements &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenThread
   &#160;<span id="projectnumber">1.05.03.02</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceot.html">ot</a></li><li class="navelem"><a class="el" href="namespaceot_1_1_heap.html">Heap</a></li><li class="navelem"><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Array&lt; Type, kCapacityIncrements &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="heap__array_8hpp_source.html">heap_array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ace3be4be4e50ec605ddb7153a617daf9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> = uint16_t</td></tr>
<tr class="separator:ace3be4be4e50ec605ddb7153a617daf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdfcb45f94888d0ffdf88e4dc33ed0f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#acdfcb45f94888d0ffdf88e4dc33ed0f4">Array</a> (void)</td></tr>
<tr class="separator:acdfcb45f94888d0ffdf88e4dc33ed0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01986e745b02344b26506b3f21ca2a5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a01986e745b02344b26506b3f21ca2a5c">Array</a> (const <a class="el" href="classot_1_1_heap_1_1_array.html">Array</a> &amp;)=delete</td></tr>
<tr class="separator:a01986e745b02344b26506b3f21ca2a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafe4dc5ea9546a2e5f764d8f3998825"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#aeafe4dc5ea9546a2e5f764d8f3998825">AsCArray</a> (void) const</td></tr>
<tr class="separator:aeafe4dc5ea9546a2e5f764d8f3998825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cc9b4063bf1cdec570bf662744bf8a"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a34cc9b4063bf1cdec570bf662744bf8a">At</a> (<a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> aIndex)</td></tr>
<tr class="separator:a34cc9b4063bf1cdec570bf662744bf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1878e9f0bc196f611230061fb821ac7"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ae1878e9f0bc196f611230061fb821ac7">At</a> (<a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> aIndex) const</td></tr>
<tr class="separator:ae1878e9f0bc196f611230061fb821ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77beec0ae8852a48aa80274fec1130f0"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a77beec0ae8852a48aa80274fec1130f0">Back</a> (void)</td></tr>
<tr class="separator:a77beec0ae8852a48aa80274fec1130f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2077cb28d33cec19496943bc05047e"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ada2077cb28d33cec19496943bc05047e">Back</a> (void) const</td></tr>
<tr class="separator:ada2077cb28d33cec19496943bc05047e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac519453bb78c4b14f6bfd45c6ea4752b"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ac519453bb78c4b14f6bfd45c6ea4752b">begin</a> (void)</td></tr>
<tr class="separator:ac519453bb78c4b14f6bfd45c6ea4752b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d51a3ccf6163833a5013682ce222cf5"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a1d51a3ccf6163833a5013682ce222cf5">begin</a> (void) const</td></tr>
<tr class="separator:a1d51a3ccf6163833a5013682ce222cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666736fbd0ebb8dc7e6ff3392423d6c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a666736fbd0ebb8dc7e6ff3392423d6c0">Clear</a> (void)</td></tr>
<tr class="separator:a666736fbd0ebb8dc7e6ff3392423d6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad04d8c5d396ed60b0de4e465db1bd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a5ad04d8c5d396ed60b0de4e465db1bd5">Contains</a> (const Type &amp;aEntry) const</td></tr>
<tr class="separator:a5ad04d8c5d396ed60b0de4e465db1bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f40d25eb396f625c15b9ba0ff472548"><td class="memTemplParams" colspan="2">template&lt;typename Indicator &gt; </td></tr>
<tr class="memitem:a0f40d25eb396f625c15b9ba0ff472548"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a0f40d25eb396f625c15b9ba0ff472548">ContainsMatching</a> (const Indicator &amp;aIndicator) const</td></tr>
<tr class="separator:a0f40d25eb396f625c15b9ba0ff472548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8337dfcfe001e93a48ac3b39ff6f2b4"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ab8337dfcfe001e93a48ac3b39ff6f2b4">end</a> (void)</td></tr>
<tr class="separator:ab8337dfcfe001e93a48ac3b39ff6f2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc59735ba91d0fa23be386c35af4cdd8"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#abc59735ba91d0fa23be386c35af4cdd8">end</a> (void) const</td></tr>
<tr class="separator:abc59735ba91d0fa23be386c35af4cdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27866b3d790595cc24b8e4eac337beb"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#aa27866b3d790595cc24b8e4eac337beb">Find</a> (const Type &amp;aEntry)</td></tr>
<tr class="separator:aa27866b3d790595cc24b8e4eac337beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc00ff5c2d6b8cdc92604c537f63e7"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a9ccc00ff5c2d6b8cdc92604c537f63e7">Find</a> (const Type &amp;aEntry) const</td></tr>
<tr class="separator:a9ccc00ff5c2d6b8cdc92604c537f63e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0337562aa3576b01cb5e6d74824b60f"><td class="memTemplParams" colspan="2">template&lt;typename Indicator &gt; </td></tr>
<tr class="memitem:ac0337562aa3576b01cb5e6d74824b60f"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ac0337562aa3576b01cb5e6d74824b60f">FindMatching</a> (const Indicator &amp;aIndicator)</td></tr>
<tr class="separator:ac0337562aa3576b01cb5e6d74824b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8ea6fc917075e37ae7b518ab4d0d32"><td class="memTemplParams" colspan="2">template&lt;typename Indicator &gt; </td></tr>
<tr class="memitem:a8f8ea6fc917075e37ae7b518ab4d0d32"><td class="memTemplItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a8f8ea6fc917075e37ae7b518ab4d0d32">FindMatching</a> (const Indicator &amp;aIndicator) const</td></tr>
<tr class="separator:a8f8ea6fc917075e37ae7b518ab4d0d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8c134d213041e117cd9868ca5ded23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#aee8c134d213041e117cd9868ca5ded23">Free</a> (void)</td></tr>
<tr class="separator:aee8c134d213041e117cd9868ca5ded23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea2625cc05349930bc430431a028e3a"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a2ea2625cc05349930bc430431a028e3a">Front</a> (void)</td></tr>
<tr class="separator:a2ea2625cc05349930bc430431a028e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e197b8cbd4930f4e3770fbda541405"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#af9e197b8cbd4930f4e3770fbda541405">Front</a> (void) const</td></tr>
<tr class="separator:af9e197b8cbd4930f4e3770fbda541405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60377d371947a3f295bea272a59daaa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a60377d371947a3f295bea272a59daaa1">GetCapacity</a> (void) const</td></tr>
<tr class="separator:a60377d371947a3f295bea272a59daaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544f95ffda7aca57a955134fca63d841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a544f95ffda7aca57a955134fca63d841">GetLength</a> (void) const</td></tr>
<tr class="separator:a544f95ffda7aca57a955134fca63d841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e18f335f8c1dc2578b42ed52f8e698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a64e18f335f8c1dc2578b42ed52f8e698">IndexOf</a> (const Type &amp;aElement) const</td></tr>
<tr class="separator:a64e18f335f8c1dc2578b42ed52f8e698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99982f36f1db6372b7c2f6f1b1dfed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ab99982f36f1db6372b7c2f6f1b1dfed4">operator=</a> (const <a class="el" href="classot_1_1_heap_1_1_array.html">Array</a> &amp;)=delete</td></tr>
<tr class="separator:ab99982f36f1db6372b7c2f6f1b1dfed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8657af9c2e2089848b0731e4a16d6"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ab3c8657af9c2e2089848b0731e4a16d6">operator[]</a> (<a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> aIndex)</td></tr>
<tr class="separator:ab3c8657af9c2e2089848b0731e4a16d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92f648491223d4465f9e0e0511536c4"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#aa92f648491223d4465f9e0e0511536c4">operator[]</a> (<a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> aIndex) const</td></tr>
<tr class="separator:aa92f648491223d4465f9e0e0511536c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a497ef248621fdd3a3767fea6654e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a12a497ef248621fdd3a3767fea6654e4">PopBack</a> (void)</td></tr>
<tr class="separator:a12a497ef248621fdd3a3767fea6654e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023352c76403a91d58dd390d880667cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceot.html#abe2a815f13046dbb91b0464c29ca6ae5">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a023352c76403a91d58dd390d880667cb">PushBack</a> (const Type &amp;aEntry)</td></tr>
<tr class="separator:a023352c76403a91d58dd390d880667cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6050685f50c2825cdcaf16eabf1bcd24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceot.html#abe2a815f13046dbb91b0464c29ca6ae5">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a6050685f50c2825cdcaf16eabf1bcd24">PushBack</a> (Type &amp;&amp;aEntry)</td></tr>
<tr class="separator:a6050685f50c2825cdcaf16eabf1bcd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f1682ff6654319a7ba15280641e1a3"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a14f1682ff6654319a7ba15280641e1a3">PushBack</a> (void)</td></tr>
<tr class="separator:a14f1682ff6654319a7ba15280641e1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a75340d48cc15bb5a370cfd494e1f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceot.html#abe2a815f13046dbb91b0464c29ca6ae5">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a8a75340d48cc15bb5a370cfd494e1f78">ReserveCapacity</a> (<a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> aCapacity)</td></tr>
<tr class="separator:a8a75340d48cc15bb5a370cfd494e1f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f0f2c6a9adbf4c00e14bde802aa61a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ac9f0f2c6a9adbf4c00e14bde802aa61a">TakeFrom</a> (<a class="el" href="classot_1_1_heap_1_1_array.html">Array</a> &amp;&amp;aOther)</td></tr>
<tr class="separator:ac9f0f2c6a9adbf4c00e14bde802aa61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6833577d43bda86e1e208ee98728f32e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a6833577d43bda86e1e208ee98728f32e">~Array</a> (void)</td></tr>
<tr class="separator:a6833577d43bda86e1e208ee98728f32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1391a5bfbb730f826a3257937f44c355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceot.html#abe2a815f13046dbb91b0464c29ca6ae5">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a1391a5bfbb730f826a3257937f44c355">Allocate</a> (<a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> aCapacity)</td></tr>
<tr class="separator:a1391a5bfbb730f826a3257937f44c355"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaf193430adc1b8eadefa6ff0cfb93766"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">mArray</a></td></tr>
<tr class="separator:aaf193430adc1b8eadefa6ff0cfb93766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab066b59178302f4c9d8125826fc08c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#ab066b59178302f4c9d8125826fc08c7e">mCapacity</a></td></tr>
<tr class="separator:ab066b59178302f4c9d8125826fc08c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5ffb48c06a28c13aa591cd71fe890a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">mLength</a></td></tr>
<tr class="separator:a1d5ffb48c06a28c13aa591cd71fe890a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, uint16_t kCapacityIncrements = 2&gt;<br />
class ot::Heap::Array&lt; Type, kCapacityIncrements &gt;</h3>

<p>This class represents a heap allocated array.</p>
<p>The buffer to store the elements is allocated from heap and is managed by the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Heap::Array</a></code> class itself. The <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> implementation will automatically grow the buffer when new entries are added. The <code><a class="el" href="classot_1_1_heap_1_1_array.html">Heap::Array</a></code> destructor will always free the allocated buffer.</p>
<p>The <code>Type</code> class MUST provide a move constructor <code>Type(Type &amp;&amp;aOther)</code> (or a copy constructor if no move constructor is provided). This constructor is used to move existing elements when array buffer is grown (new buffer is allocated) to make room for new elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The array element type. </td></tr>
    <tr><td class="paramname">kCapacityIncrements</td><td>Number of elements to allocate at a time when updating the array buffer. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ace3be4be4e50ec605ddb7153a617daf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3be4be4e50ec605ddb7153a617daf9">&sect;&nbsp;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> =  uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acdfcb45f94888d0ffdf88e4dc33ed0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfcb45f94888d0ffdf88e4dc33ed0f4">&sect;&nbsp;</a></span>Array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor initializes the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> as empty. </p>

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#abc59735ba91d0fa23be386c35af4cdd8">Array&lt; Type, kCapacityIncrements &gt;::end()</a>.</p>

</div>
</div>
<a id="a6833577d43bda86e1e208ee98728f32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6833577d43bda86e1e208ee98728f32e">&sect;&nbsp;</a></span>~Array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classot_1_1_heap_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the destructor for <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> object. </p>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aee8c134d213041e117cd9868ca5ded23">Array&lt; Type, kCapacityIncrements &gt;::Free()</a>.</p>

</div>
</div>
<a id="a01986e745b02344b26506b3f21ca2a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01986e745b02344b26506b3f21ca2a5c">&sect;&nbsp;</a></span>Array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classot_1_1_heap_1_1_array.html">Array</a>&lt; Type, kCapacityIncrements &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aee8c134d213041e117cd9868ca5ded23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8c134d213041e117cd9868ca5ded23">&sect;&nbsp;</a></span>Free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method frees any buffer allocated by the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code>.</p>
<p>The <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> destructor will automatically call <code><a class="el" href="classot_1_1_heap_1_1_array.html#aee8c134d213041e117cd9868ca5ded23">Free()</a></code>. This method allows caller to free buffer explicitly. </p>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a666736fbd0ebb8dc7e6ff3392423d6c0">Array&lt; Type, kCapacityIncrements &gt;::Clear()</a>, <a class="el" href="namespaceot_1_1_heap.html#a81e9cf86528c02550749f3b4484a5d79">ot::Heap::Free()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#ab066b59178302f4c9d8125826fc08c7e">Array&lt; Type, kCapacityIncrements &gt;::mCapacity</a>.</p>

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#ac9f0f2c6a9adbf4c00e14bde802aa61a">Array&lt; Type, kCapacityIncrements &gt;::TakeFrom()</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a6833577d43bda86e1e208ee98728f32e">Array&lt; Type, kCapacityIncrements &gt;::~Array()</a>.</p>

</div>
</div>
<a id="a666736fbd0ebb8dc7e6ff3392423d6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666736fbd0ebb8dc7e6ff3392423d6c0">&sect;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method clears the array.</p>
<p>Note that <code><a class="el" href="classot_1_1_heap_1_1_array.html#a666736fbd0ebb8dc7e6ff3392423d6c0">Clear()</a></code> method (unlike <code><a class="el" href="classot_1_1_heap_1_1_array.html#aee8c134d213041e117cd9868ca5ded23">Free()</a></code>) does not free the allocated buffer and therefore does not change the current capacity of the array.</p>
<p>This method invokes <code>Type</code> destructor on all cleared existing elements of array. </p>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#aee8c134d213041e117cd9868ca5ded23">Array&lt; Type, kCapacityIncrements &gt;::Free()</a>.</p>

</div>
</div>
<a id="a544f95ffda7aca57a955134fca63d841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544f95ffda7aca57a955134fca63d841">&sect;&nbsp;</a></span>GetLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> GetLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the current array length (number of elements in the array).</p>
<dl class="section return"><dt>Returns</dt><dd>The array length. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="aeafe4dc5ea9546a2e5f764d8f3998825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafe4dc5ea9546a2e5f764d8f3998825">&sect;&nbsp;</a></span>AsCArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* AsCArray </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a raw pointer to the array buffer.</p>
<p>The returned raw pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the array buffer or <code>nullptr</code> if the array is empty. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="a60377d371947a3f295bea272a59daaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60377d371947a3f295bea272a59daaa1">&sect;&nbsp;</a></span>GetCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> GetCapacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the current capacity of array (number of elements that can fit in current allocated buffer).</p>
<p>The allocated buffer and array capacity are automatically increased (by the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> itself) when new elements are added to array. Removing elements does not change the buffer and the capacity. A desired capacity can be reserved using <code><a class="el" href="classot_1_1_heap_1_1_array.html#a8a75340d48cc15bb5a370cfd494e1f78">ReserveCapacity()</a></code> method.</p>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of the array. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#ab066b59178302f4c9d8125826fc08c7e">Array&lt; Type, kCapacityIncrements &gt;::mCapacity</a>.</p>

</div>
</div>
<a id="a8a75340d48cc15bb5a370cfd494e1f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a75340d48cc15bb5a370cfd494e1f78">&sect;&nbsp;</a></span>ReserveCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceot.html#abe2a815f13046dbb91b0464c29ca6ae5">Error</a> ReserveCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td>
          <td class="paramname"><em>aCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method allocates buffer to reserve a given capacity for array.</p>
<p>If the requested <code>aCapacity</code> is smaller than the current length of the array, capacity remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aCapacity</td><td>The target capacity for the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kErrorNone</td><td><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a> was successfully updated to support <code>aCapacity</code>. </td></tr>
    <tr><td class="paramname">kErrorNoBufs</td><td>Could not allocate buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a1391a5bfbb730f826a3257937f44c355">Array&lt; Type, kCapacityIncrements &gt;::Allocate()</a>.</p>

</div>
</div>
<a id="ac9f0f2c6a9adbf4c00e14bde802aa61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f0f2c6a9adbf4c00e14bde802aa61a">&sect;&nbsp;</a></span>TakeFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TakeFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a>&lt; Type, kCapacityIncrements &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>aOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the array by taking the buffer from another given array (using move semantics).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aOther</td><td>The other <code><a class="el" href="classot_1_1_heap_1_1_array.html">Heap::Array</a></code> to take from (rvalue reference). </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aee8c134d213041e117cd9868ca5ded23">Array&lt; Type, kCapacityIncrements &gt;::Free()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ab066b59178302f4c9d8125826fc08c7e">Array&lt; Type, kCapacityIncrements &gt;::mCapacity</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="ab3c8657af9c2e2089848b0731e4a16d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c8657af9c2e2089848b0731e4a16d6">&sect;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overloads the <code>[]</code> operator to get the element at a given index.</p>
<p>This method does not perform index bounds checking. Behavior is undefined if <code>aIndex</code> is not valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>The index to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element in array at <code>aIndex</code>. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>.</p>

</div>
</div>
<a id="aa92f648491223d4465f9e0e0511536c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92f648491223d4465f9e0e0511536c4">&sect;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overloads the <code>[]</code> operator to get the element at a given index.</p>
<p>This method does not perform index bounds checking. Behavior is undefined if <code>aIndex</code> is not valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>The index to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element in array at <code>aIndex</code>. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>.</p>

</div>
</div>
<a id="a34cc9b4063bf1cdec570bf662744bf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cc9b4063bf1cdec570bf662744bf8a">&sect;&nbsp;</a></span>At() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* At </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets a pointer to the element at a given index.</p>
<p>Unlike <code>operator[]</code>, this method checks <code>aIndex</code> to be valid and within the current length. The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>The index to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to element in array at <code>aIndex</code> or <code>nullptr</code> if <code>aIndex</code> is not valid. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#a2ea2625cc05349930bc430431a028e3a">Array&lt; Type, kCapacityIncrements &gt;::Front()</a>.</p>

</div>
</div>
<a id="ae1878e9f0bc196f611230061fb821ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1878e9f0bc196f611230061fb821ac7">&sect;&nbsp;</a></span>At() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* At </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets a pointer to the element at a given index.</p>
<p>Unlike <code>operator[]</code>, this method checks <code>aIndex</code> to be valid and within the current length. The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>The index to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to element in array at <code>aIndex</code> or <code>nullptr</code> if <code>aIndex</code> is not valid. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="a2ea2625cc05349930bc430431a028e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea2625cc05349930bc430431a028e3a">&sect;&nbsp;</a></span>Front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* Front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets a pointer to the element at the front of the array (first element).</p>
<p>The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the front element or <code>nullptr</code> if array is empty. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a34cc9b4063bf1cdec570bf662744bf8a">Array&lt; Type, kCapacityIncrements &gt;::At()</a>.</p>

</div>
</div>
<a id="af9e197b8cbd4930f4e3770fbda541405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e197b8cbd4930f4e3770fbda541405">&sect;&nbsp;</a></span>Front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* Front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets a pointer to the element at the front of the array (first element).</p>
<p>The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the front element or <code>nullptr</code> if array is empty. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a34cc9b4063bf1cdec570bf662744bf8a">Array&lt; Type, kCapacityIncrements &gt;::At()</a>.</p>

</div>
</div>
<a id="a77beec0ae8852a48aa80274fec1130f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77beec0ae8852a48aa80274fec1130f0">&sect;&nbsp;</a></span>Back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* Back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets a pointer to the element at the back of the array (last element).</p>
<p>The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the back element or <code>nullptr</code> if array is empty. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="ada2077cb28d33cec19496943bc05047e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2077cb28d33cec19496943bc05047e">&sect;&nbsp;</a></span>Back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* Back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets a pointer to the element at the back of the array (last element).</p>
<p>The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the back element or <code>nullptr</code> if array is empty. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="a023352c76403a91d58dd390d880667cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023352c76403a91d58dd390d880667cb">&sect;&nbsp;</a></span>PushBack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceot.html#abe2a815f13046dbb91b0464c29ca6ae5">Error</a> PushBack </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>aEntry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method appends a new entry to the end of the array.</p>
<p>This method requires the <code>Type</code> to provide a copy constructor of format <code>Type(const Type &amp;aOther)</code> to init the new element in the array from <code>aEntry</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEntry</td><td>The new entry to push back.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kErrorNone</td><td>Successfully pushed back <code>aEntry</code> to the end of the array. </td></tr>
    <tr><td class="paramname">kErrorNoBufs</td><td>Could not allocate buffer to grow the array. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a1391a5bfbb730f826a3257937f44c355">Array&lt; Type, kCapacityIncrements &gt;::Allocate()</a>, <a class="el" href="namespaceot.html#ad03a63f93c558265b9ba384c6c4ebc9f">ot::kErrorNone</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ab066b59178302f4c9d8125826fc08c7e">Array&lt; Type, kCapacityIncrements &gt;::mCapacity</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>, and <a class="el" href="code__utils_8hpp.html#ae0d90ad12fb508f30107b1931f970ab1">SuccessOrExit</a>.</p>

</div>
</div>
<a id="a6050685f50c2825cdcaf16eabf1bcd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6050685f50c2825cdcaf16eabf1bcd24">&sect;&nbsp;</a></span>PushBack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceot.html#abe2a815f13046dbb91b0464c29ca6ae5">Error</a> PushBack </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>aEntry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method appends a new entry to the end of the array.</p>
<p>This method requires the <code>Type</code> to provide a copy constructor of format <code>Type(Type &amp;&amp;aOther)</code> to init the new element in the array from <code>aEntry</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEntry</td><td>The new entry to push back (an rvalue reference)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kErrorNone</td><td>Successfully pushed back <code>aEntry</code> to the end of the array. </td></tr>
    <tr><td class="paramname">kErrorNoBufs</td><td>Could not allocate buffer to grow the array. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a1391a5bfbb730f826a3257937f44c355">Array&lt; Type, kCapacityIncrements &gt;::Allocate()</a>, <a class="el" href="namespaceot.html#ad03a63f93c558265b9ba384c6c4ebc9f">ot::kErrorNone</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ab066b59178302f4c9d8125826fc08c7e">Array&lt; Type, kCapacityIncrements &gt;::mCapacity</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>, and <a class="el" href="code__utils_8hpp.html#ae0d90ad12fb508f30107b1931f970ab1">SuccessOrExit</a>.</p>

</div>
</div>
<a id="a14f1682ff6654319a7ba15280641e1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f1682ff6654319a7ba15280641e1a3">&sect;&nbsp;</a></span>PushBack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* PushBack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method appends a new entry to the end of the array.</p>
<p>On success, this method returns a pointer to the newly appended element in the array for the caller to initialize and use. This method uses the <code>Type(void)</code> default constructor on the newly appended element (if not <code>nullptr</code>).</p>
<p>The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly appended element or <code>nullptr</code> if could not allocate buffer to grow the array </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#a1391a5bfbb730f826a3257937f44c355">Array&lt; Type, kCapacityIncrements &gt;::Allocate()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ab066b59178302f4c9d8125826fc08c7e">Array&lt; Type, kCapacityIncrements &gt;::mCapacity</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>, and <a class="el" href="code__utils_8hpp.html#ae0d90ad12fb508f30107b1931f970ab1">SuccessOrExit</a>.</p>

</div>
</div>
<a id="a12a497ef248621fdd3a3767fea6654e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a497ef248621fdd3a3767fea6654e4">&sect;&nbsp;</a></span>PopBack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PopBack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method removes the last element in the array.</p>
<p>This method will invoke the <code>Type</code> destructor on the removed element. </p>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="a64e18f335f8c1dc2578b42ed52f8e698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e18f335f8c1dc2578b42ed52f8e698">&sect;&nbsp;</a></span>IndexOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> IndexOf </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>aElement</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the index of an element in the array.</p>
<p>The <code>aElement</code> MUST be from the array, otherwise the behavior of this method is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aElement</td><td>A reference to an element in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of <code>aElement</code> in the array. </dd></dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>.</p>

</div>
</div>
<a id="aa27866b3d790595cc24b8e4eac337beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27866b3d790595cc24b8e4eac337beb">&sect;&nbsp;</a></span>Find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* Find </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>aEntry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method finds the first match of a given entry in the array.</p>
<p>This method uses <code>==</code> operator on <code>Type</code> to compare the array element with <code>aEntry</code>. The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEntry</td><td>The entry to search for within the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to matched array element, or <code>nullptr</code> if a match could not be found. </dd></dl>

<p>References <a class="el" href="namespaceot.html#ad85c7c816c7da6a11ed40ca56e1230e1">ot::AsConst()</a>, <a class="el" href="namespaceot.html#a3ead9657c8759c1d5bde27141894f841">ot::AsNonConst()</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#aa27866b3d790595cc24b8e4eac337beb">Array&lt; Type, kCapacityIncrements &gt;::Find()</a>.</p>

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#a5ad04d8c5d396ed60b0de4e465db1bd5">Array&lt; Type, kCapacityIncrements &gt;::Contains()</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#aa27866b3d790595cc24b8e4eac337beb">Array&lt; Type, kCapacityIncrements &gt;::Find()</a>.</p>

</div>
</div>
<a id="a9ccc00ff5c2d6b8cdc92604c537f63e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccc00ff5c2d6b8cdc92604c537f63e7">&sect;&nbsp;</a></span>Find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* Find </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>aEntry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method finds the first match of a given entry in the array.</p>
<p>This method uses <code>==</code> operator to compare the array elements with <code>aEntry</code>. The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEntry</td><td>The entry to search for within the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to matched array element, or <code>nullptr</code> if a match could not be found. </dd></dl>

</div>
</div>
<a id="a5ad04d8c5d396ed60b0de4e465db1bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad04d8c5d396ed60b0de4e465db1bd5">&sect;&nbsp;</a></span>Contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Contains </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>aEntry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method indicates whether or not a match to given entry exists in the array.</p>
<p>This method uses <code>==</code> operator on <code>Type</code> to compare the array elements with <code>aEntry</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEntry</td><td>The entry to search for within the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>The array contains a matching element with <code>aEntry</code>. </td></tr>
    <tr><td class="paramname">FALSE</td><td>The array does not contain a matching element with <code>aEntry</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aa27866b3d790595cc24b8e4eac337beb">Array&lt; Type, kCapacityIncrements &gt;::Find()</a>.</p>

</div>
</div>
<a id="ac0337562aa3576b01cb5e6d74824b60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0337562aa3576b01cb5e6d74824b60f">&sect;&nbsp;</a></span>FindMatching() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* FindMatching </td>
          <td>(</td>
          <td class="paramtype">const Indicator &amp;&#160;</td>
          <td class="paramname"><em>aIndicator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This template method finds the first element in the array matching a given indicator.</p>
<p>The template type <code>Indicator</code> specifies the type of <code>aIndicator</code> object which is used to match against elements in the array. To check that an element matches the given indicator, the <code>Matches()</code> method is invoked on each <code>Type</code> element in the array. The <code>Matches()</code> method should be provided by <code>Type</code> class accordingly: </p><pre class="fragment">bool Type::Matches(const Indicator &amp;aIndicator) const
</pre><p>The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndicator</td><td>An indicator to match with elements in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched array element, or <code>nullptr</code> if a match could not be found. </dd></dl>

<p>References <a class="el" href="namespaceot.html#ad85c7c816c7da6a11ed40ca56e1230e1">ot::AsConst()</a>, and <a class="el" href="namespaceot.html#a3ead9657c8759c1d5bde27141894f841">ot::AsNonConst()</a>.</p>

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#a0f40d25eb396f625c15b9ba0ff472548">Array&lt; Type, kCapacityIncrements &gt;::ContainsMatching()</a>.</p>

</div>
</div>
<a id="a8f8ea6fc917075e37ae7b518ab4d0d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8ea6fc917075e37ae7b518ab4d0d32">&sect;&nbsp;</a></span>FindMatching() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* FindMatching </td>
          <td>(</td>
          <td class="paramtype">const Indicator &amp;&#160;</td>
          <td class="paramname"><em>aIndicator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This template method finds the first element in the array matching a given indicator.</p>
<p>The template type <code>Indicator</code> specifies the type of <code>aIndicator</code> object which is used to match against elements in the array. To check that an element matches the given indicator, the <code>Matches()</code> method is invoked on each <code>Type</code> element in the array. The <code>Matches()</code> method should be provided by <code>Type</code> class accordingly: </p><pre class="fragment">bool Type::Matches(const Indicator &amp;aIndicator) const
</pre><p>The returned pointer is valid only while the <code><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a></code> remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndicator</td><td>An indicator to match with elements in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched array element, or <code>nullptr</code> if a match could not be found. </dd></dl>

</div>
</div>
<a id="a0f40d25eb396f625c15b9ba0ff472548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f40d25eb396f625c15b9ba0ff472548">&sect;&nbsp;</a></span>ContainsMatching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsMatching </td>
          <td>(</td>
          <td class="paramtype">const Indicator &amp;&#160;</td>
          <td class="paramname"><em>aIndicator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This template method indicates whether or not the array contains an element matching a given indicator.</p>
<p>The template type <code>Indicator</code> specifies the type of <code>aIndicator</code> object which is used to match against elements in the array. To check that an element matches the given indicator, the <code>Matches()</code> method is invoked on each <code>Type</code> element in the array. The <code>Matches()</code> method should be provided by <code>Type</code> class accordingly: </p><pre class="fragment">bool Type::Matches(const Indicator &amp;aIndicator) const
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndicator</td><td>An indicator to match with elements in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>The array contains a matching element with <code>aIndicator</code>. </td></tr>
    <tr><td class="paramname">FALSE</td><td>The array does not contain a matching element with <code>aIndicator</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#ac0337562aa3576b01cb5e6d74824b60f">Array&lt; Type, kCapacityIncrements &gt;::FindMatching()</a>.</p>

</div>
</div>
<a id="ac519453bb78c4b14f6bfd45c6ea4752b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac519453bb78c4b14f6bfd45c6ea4752b">&sect;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="ab8337dfcfe001e93a48ac3b39ff6f2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8337dfcfe001e93a48ac3b39ff6f2b4">&sect;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="a1d51a3ccf6163833a5013682ce222cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d51a3ccf6163833a5013682ce222cf5">&sect;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>.</p>

</div>
</div>
<a id="abc59735ba91d0fa23be386c35af4cdd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc59735ba91d0fa23be386c35af4cdd8">&sect;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classot_1_1_heap_1_1_array.html#acdfcb45f94888d0ffdf88e4dc33ed0f4">Array&lt; Type, kCapacityIncrements &gt;::Array()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#ab99982f36f1db6372b7c2f6f1b1dfed4">Array&lt; Type, kCapacityIncrements &gt;::operator=()</a>.</p>

</div>
</div>
<a id="ab99982f36f1db6372b7c2f6f1b1dfed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99982f36f1db6372b7c2f6f1b1dfed4">&sect;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1_heap_1_1_array.html">Array</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classot_1_1_heap_1_1_array.html">Array</a>&lt; Type, kCapacityIncrements &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#abc59735ba91d0fa23be386c35af4cdd8">Array&lt; Type, kCapacityIncrements &gt;::end()</a>.</p>

</div>
</div>
<a id="a1391a5bfbb730f826a3257937f44c355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1391a5bfbb730f826a3257937f44c355">&sect;&nbsp;</a></span>Allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceot.html#abe2a815f13046dbb91b0464c29ca6ae5">Error</a> Allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a>&#160;</td>
          <td class="paramname"><em>aCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="namespaceot_1_1_heap.html#a56a243cecb6915e1c2b7064af97ef396">ot::Heap::CAlloc()</a>, <a class="el" href="namespaceot_1_1_heap.html#a81e9cf86528c02550749f3b4484a5d79">ot::Heap::Free()</a>, <a class="el" href="namespaceot.html#a6d74a507375c9860e43c81786f066539">ot::kErrorNoBufs</a>, <a class="el" href="namespaceot.html#ad03a63f93c558265b9ba384c6c4ebc9f">ot::kErrorNone</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aaf193430adc1b8eadefa6ff0cfb93766">Array&lt; Type, kCapacityIncrements &gt;::mArray</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ab066b59178302f4c9d8125826fc08c7e">Array&lt; Type, kCapacityIncrements &gt;::mCapacity</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a1d5ffb48c06a28c13aa591cd71fe890a">Array&lt; Type, kCapacityIncrements &gt;::mLength</a>, and <a class="el" href="code__utils_8hpp.html#a248acc051932ea3d763494b55c40b3d6">VerifyOrExit</a>.</p>

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#a023352c76403a91d58dd390d880667cb">Array&lt; Type, kCapacityIncrements &gt;::PushBack()</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#a8a75340d48cc15bb5a370cfd494e1f78">Array&lt; Type, kCapacityIncrements &gt;::ReserveCapacity()</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="aaf193430adc1b8eadefa6ff0cfb93766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf193430adc1b8eadefa6ff0cfb93766">&sect;&nbsp;</a></span>mArray</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* mArray</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#a1391a5bfbb730f826a3257937f44c355">Array&lt; Type, kCapacityIncrements &gt;::Allocate()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aeafe4dc5ea9546a2e5f764d8f3998825">Array&lt; Type, kCapacityIncrements &gt;::AsCArray()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a34cc9b4063bf1cdec570bf662744bf8a">Array&lt; Type, kCapacityIncrements &gt;::At()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a77beec0ae8852a48aa80274fec1130f0">Array&lt; Type, kCapacityIncrements &gt;::Back()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ac519453bb78c4b14f6bfd45c6ea4752b">Array&lt; Type, kCapacityIncrements &gt;::begin()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ab8337dfcfe001e93a48ac3b39ff6f2b4">Array&lt; Type, kCapacityIncrements &gt;::end()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aee8c134d213041e117cd9868ca5ded23">Array&lt; Type, kCapacityIncrements &gt;::Free()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a64e18f335f8c1dc2578b42ed52f8e698">Array&lt; Type, kCapacityIncrements &gt;::IndexOf()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ab3c8657af9c2e2089848b0731e4a16d6">Array&lt; Type, kCapacityIncrements &gt;::operator[]()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a12a497ef248621fdd3a3767fea6654e4">Array&lt; Type, kCapacityIncrements &gt;::PopBack()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a023352c76403a91d58dd390d880667cb">Array&lt; Type, kCapacityIncrements &gt;::PushBack()</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#ac9f0f2c6a9adbf4c00e14bde802aa61a">Array&lt; Type, kCapacityIncrements &gt;::TakeFrom()</a>.</p>

</div>
</div>
<a id="a1d5ffb48c06a28c13aa591cd71fe890a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5ffb48c06a28c13aa591cd71fe890a">&sect;&nbsp;</a></span>mLength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> mLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#a1391a5bfbb730f826a3257937f44c355">Array&lt; Type, kCapacityIncrements &gt;::Allocate()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aeafe4dc5ea9546a2e5f764d8f3998825">Array&lt; Type, kCapacityIncrements &gt;::AsCArray()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a34cc9b4063bf1cdec570bf662744bf8a">Array&lt; Type, kCapacityIncrements &gt;::At()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a77beec0ae8852a48aa80274fec1130f0">Array&lt; Type, kCapacityIncrements &gt;::Back()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ac519453bb78c4b14f6bfd45c6ea4752b">Array&lt; Type, kCapacityIncrements &gt;::begin()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a666736fbd0ebb8dc7e6ff3392423d6c0">Array&lt; Type, kCapacityIncrements &gt;::Clear()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#ab8337dfcfe001e93a48ac3b39ff6f2b4">Array&lt; Type, kCapacityIncrements &gt;::end()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a544f95ffda7aca57a955134fca63d841">Array&lt; Type, kCapacityIncrements &gt;::GetLength()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a12a497ef248621fdd3a3767fea6654e4">Array&lt; Type, kCapacityIncrements &gt;::PopBack()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a023352c76403a91d58dd390d880667cb">Array&lt; Type, kCapacityIncrements &gt;::PushBack()</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#ac9f0f2c6a9adbf4c00e14bde802aa61a">Array&lt; Type, kCapacityIncrements &gt;::TakeFrom()</a>.</p>

</div>
</div>
<a id="ab066b59178302f4c9d8125826fc08c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab066b59178302f4c9d8125826fc08c7e">&sect;&nbsp;</a></span>mCapacity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1_heap_1_1_array.html#ace3be4be4e50ec605ddb7153a617daf9">IndexType</a> mCapacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classot_1_1_heap_1_1_array.html#a1391a5bfbb730f826a3257937f44c355">Array&lt; Type, kCapacityIncrements &gt;::Allocate()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#aee8c134d213041e117cd9868ca5ded23">Array&lt; Type, kCapacityIncrements &gt;::Free()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a60377d371947a3f295bea272a59daaa1">Array&lt; Type, kCapacityIncrements &gt;::GetCapacity()</a>, <a class="el" href="classot_1_1_heap_1_1_array.html#a023352c76403a91d58dd390d880667cb">Array&lt; Type, kCapacityIncrements &gt;::PushBack()</a>, and <a class="el" href="classot_1_1_heap_1_1_array.html#ac9f0f2c6a9adbf4c00e14bde802aa61a">Array&lt; Type, kCapacityIncrements &gt;::TakeFrom()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="heap__array_8hpp_source.html">heap_array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2022</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
