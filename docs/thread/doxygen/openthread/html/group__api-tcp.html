<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>OpenThread: TCP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenThread
   &#160;<span id="projectnumber">1.05.03.02</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TCP<div class="ingroups"><a class="el" href="group__api.html">API</a> &raquo; <a class="el" href="group__api-net.html">IPv6 Networking</a> &raquo; <a class="el" href="group__api-tcp-group.html">TCP</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This module includes functions that control TCP communication.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for TCP:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><img src="group__api-tcp.png" border="0" alt="" usemap="#group____api-tcp"/>
<map name="group____api-tcp" id="group____api-tcp">
<area shape="rect" id="node1" href="group__api-tcp-group.html" title="TCP" alt="" coords="5,5,52,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structot_tcp_endpoint_initialize_args.html">otTcpEndpointInitializeArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structot_tcp_listener.html">otTcpListener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structot_tcp_listener_initialize_args.html">otTcpListenerInitializeArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga880da2e4907c94d271ce28fb3cccae22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga880da2e4907c94d271ce28fb3cccae22">OT_TCP_ENDPOINT_TCB_NUM_PTR</a>&#160;&#160;&#160;36</td></tr>
<tr class="separator:ga880da2e4907c94d271ce28fb3cccae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82629c770c4bb6a2919cd1aed657b69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaa82629c770c4bb6a2919cd1aed657b69">OT_TCP_ENDPOINT_TCB_SIZE_BASE</a>&#160;&#160;&#160;368</td></tr>
<tr class="separator:gaa82629c770c4bb6a2919cd1aed657b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe6ab4e74e7fe7760e08e5a9e53b31c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga2fe6ab4e74e7fe7760e08e5a9e53b31c">OT_TCP_LISTENER_TCB_NUM_PTR</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga2fe6ab4e74e7fe7760e08e5a9e53b31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d78d4a040b42dce00443cf8f704065"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga28d78d4a040b42dce00443cf8f704065">OT_TCP_LISTENER_TCB_SIZE_BASE</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ga28d78d4a040b42dce00443cf8f704065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88304ad88257ec1ec57c124d486ed8d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga88304ad88257ec1ec57c124d486ed8d1">OT_TCP_RECEIVE_BUFFER_SIZE_FEW_HOPS</a>&#160;&#160;&#160;2598</td></tr>
<tr class="separator:ga88304ad88257ec1ec57c124d486ed8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee4e4eba102333eb69a3641896c0116"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaaee4e4eba102333eb69a3641896c0116">OT_TCP_RECEIVE_BUFFER_SIZE_MANY_HOPS</a>&#160;&#160;&#160;4157</td></tr>
<tr class="separator:gaaee4e4eba102333eb69a3641896c0116"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga49f3950b5fe6b1f466f8b6ade923cfb4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga49f3950b5fe6b1f466f8b6ade923cfb4">otLinkedBuffer</a></td></tr>
<tr class="separator:ga49f3950b5fe6b1f466f8b6ade923cfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d7a462451ac720d5a6c685e3204066"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga49d7a462451ac720d5a6c685e3204066">otTcpAcceptDone</a>) (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener, <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *aPeer)</td></tr>
<tr class="separator:ga49d7a462451ac720d5a6c685e3204066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613840e8b9ea3f201cd0a73702970af2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__api-tcp.html#gaad21b37b5f4d9fbc97e86b9a026237b0">otTcpIncomingConnectionAction</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga613840e8b9ea3f201cd0a73702970af2">otTcpAcceptReady</a>) (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener, const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *aPeer, <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> **aAcceptInto)</td></tr>
<tr class="separator:ga613840e8b9ea3f201cd0a73702970af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa453ad1382ed09405b06ba5a58a7fe27"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaa453ad1382ed09405b06ba5a58a7fe27">otTcpDisconnected</a>) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, <a class="el" href="group__api-tcp.html#ga2dea5fb99241c1b9efe73dc79dbe30ea">otTcpDisconnectedReason</a> aReason)</td></tr>
<tr class="separator:gaa453ad1382ed09405b06ba5a58a7fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3d813dd1a8968bf0f60312e32a4263"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__api-tcp.html#ga2dea5fb99241c1b9efe73dc79dbe30ea">otTcpDisconnectedReason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaba3d813dd1a8968bf0f60312e32a4263">otTcpDisconnectedReason</a></td></tr>
<tr class="separator:gaba3d813dd1a8968bf0f60312e32a4263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b25068e9277d21122c7421e0efb909d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga9b25068e9277d21122c7421e0efb909d">otTcpEndpoint</a></td></tr>
<tr class="separator:ga9b25068e9277d21122c7421e0efb909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe706402a5c796bd699f0046aa9632b3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structot_tcp_endpoint_initialize_args.html">otTcpEndpointInitializeArgs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gafe706402a5c796bd699f0046aa9632b3">otTcpEndpointInitializeArgs</a></td></tr>
<tr class="separator:gafe706402a5c796bd699f0046aa9632b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61149a925aab16e64dbca802c9af8e55"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga61149a925aab16e64dbca802c9af8e55">otTcpEstablished</a>) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:ga61149a925aab16e64dbca802c9af8e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4cad185c5776fe15092694de1472a5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga3a4cad185c5776fe15092694de1472a5">otTcpForwardProgress</a>) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, size_t aInSendBuffer, size_t aBacklog)</td></tr>
<tr class="separator:ga3a4cad185c5776fe15092694de1472a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbf4ac01a179c45fb595462fb2a7673"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__api-tcp.html#gaad21b37b5f4d9fbc97e86b9a026237b0">otTcpIncomingConnectionAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaabbf4ac01a179c45fb595462fb2a7673">otTcpIncomingConnectionAction</a></td></tr>
<tr class="separator:gaabbf4ac01a179c45fb595462fb2a7673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525b81e6a10ffac54fa6d86b39841611"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structot_tcp_listener.html">otTcpListener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga525b81e6a10ffac54fa6d86b39841611">otTcpListener</a></td></tr>
<tr class="separator:ga525b81e6a10ffac54fa6d86b39841611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86fdfebf1988c213634a8c6768c977ff"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structot_tcp_listener_initialize_args.html">otTcpListenerInitializeArgs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga86fdfebf1988c213634a8c6768c977ff">otTcpListenerInitializeArgs</a></td></tr>
<tr class="separator:ga86fdfebf1988c213634a8c6768c977ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e36d56c9c8700d53e15c5043d1790d9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga5e36d56c9c8700d53e15c5043d1790d9">otTcpReceiveAvailable</a>) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, size_t aBytesAvailable, bool aEndOfStream, size_t aBytesRemaining)</td></tr>
<tr class="separator:ga5e36d56c9c8700d53e15c5043d1790d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3cd165f8c8698e7d7e286e22ef89c1a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gac3cd165f8c8698e7d7e286e22ef89c1a">otTcpSendDone</a>) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> *aData)</td></tr>
<tr class="separator:gac3cd165f8c8698e7d7e286e22ef89c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga4f126a0a9b1d8c6a8f46a051ef8830bb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__api-tcp.html#gga4f126a0a9b1d8c6a8f46a051ef8830bbad8c47e04ce728e986ee716857816ad32">OT_TCP_CONNECT_NO_FAST_OPEN</a> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="separator:ga4f126a0a9b1d8c6a8f46a051ef8830bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbaf9202177df73e6880eab6e6aab329"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__api-tcp.html#ggadbaf9202177df73e6880eab6e6aab329aedc77e0c7644f2ced86d481c1325fe3a">OT_TCP_SEND_MORE_TO_COME</a> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="separator:gadbaf9202177df73e6880eab6e6aab329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dea5fb99241c1b9efe73dc79dbe30ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga2dea5fb99241c1b9efe73dc79dbe30ea">otTcpDisconnectedReason</a> { <br />
&#160;&#160;<a class="el" href="group__api-tcp.html#gga2dea5fb99241c1b9efe73dc79dbe30eaad9f09ab6f258ca89db3feecbc43e53d6">OT_TCP_DISCONNECTED_REASON_NORMAL</a>, 
<a class="el" href="group__api-tcp.html#gga2dea5fb99241c1b9efe73dc79dbe30eaaa7b9c8c6eb76ecec5931b3a8868690f4">OT_TCP_DISCONNECTED_REASON_REFUSED</a>, 
<a class="el" href="group__api-tcp.html#gga2dea5fb99241c1b9efe73dc79dbe30eaa562f5a5f387d17f20686979cb7bcbdba">OT_TCP_DISCONNECTED_REASON_RESET</a>, 
<a class="el" href="group__api-tcp.html#gga2dea5fb99241c1b9efe73dc79dbe30eaa4be8bf19da153a8298acb031f6e6bbee">OT_TCP_DISCONNECTED_REASON_TIME_WAIT</a>, 
<br />
&#160;&#160;<a class="el" href="group__api-tcp.html#gga2dea5fb99241c1b9efe73dc79dbe30eaacfa11732004edbd8b974f99b4d040c50">OT_TCP_DISCONNECTED_REASON_TIMED_OUT</a>
<br />
 }</td></tr>
<tr class="separator:ga2dea5fb99241c1b9efe73dc79dbe30ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad21b37b5f4d9fbc97e86b9a026237b0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaad21b37b5f4d9fbc97e86b9a026237b0">otTcpIncomingConnectionAction</a> { <a class="el" href="group__api-tcp.html#ggaad21b37b5f4d9fbc97e86b9a026237b0a3c412f0e31a6e5d4dc90cce7388cf5c4">OT_TCP_INCOMING_CONNECTION_ACTION_ACCEPT</a>, 
<a class="el" href="group__api-tcp.html#ggaad21b37b5f4d9fbc97e86b9a026237b0a73f6209e2015242f880c65634f671449">OT_TCP_INCOMING_CONNECTION_ACTION_DEFER</a>, 
<a class="el" href="group__api-tcp.html#ggaad21b37b5f4d9fbc97e86b9a026237b0a2194e1854e3f1c7d51039b25bbfa7044">OT_TCP_INCOMING_CONNECTION_ACTION_REFUSE</a>
 }</td></tr>
<tr class="separator:gaad21b37b5f4d9fbc97e86b9a026237b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga11edfbb1feaab02ba9e8cb65bfa39491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga11edfbb1feaab02ba9e8cb65bfa39491">otTcpAbort</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:ga11edfbb1feaab02ba9e8cb65bfa39491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d0811860150c56632ad641a71100a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga5d0811860150c56632ad641a71100a5a">otTcpBind</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *aSockName)</td></tr>
<tr class="separator:ga5d0811860150c56632ad641a71100a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee5105795fcdf332bb255e252eeed74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga0ee5105795fcdf332bb255e252eeed74">otTcpCommitReceive</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, size_t aNumBytes, uint32_t aFlags)</td></tr>
<tr class="separator:ga0ee5105795fcdf332bb255e252eeed74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc39aeb3514e836dfb1d74e824e1cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga3bc39aeb3514e836dfb1d74e824e1cce">otTcpConnect</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *aSockName, uint32_t aFlags)</td></tr>
<tr class="separator:ga3bc39aeb3514e836dfb1d74e824e1cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d5c30636461e320a8fd77c8da49881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gac3d5c30636461e320a8fd77c8da49881">otTcpEndpointDeinitialize</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:gac3d5c30636461e320a8fd77c8da49881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da77ed858448152d8f02f9e01f4e5f4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga4da77ed858448152d8f02f9e01f4e5f4">otTcpEndpointGetContext</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:ga4da77ed858448152d8f02f9e01f4e5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b8afb5269f4d3491cd413d219dc5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structot_instance.html">otInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga58b8afb5269f4d3491cd413d219dc5f2">otTcpEndpointGetInstance</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:ga58b8afb5269f4d3491cd413d219dc5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ca008dbb9657f10692612f3051dd55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga46ca008dbb9657f10692612f3051dd55">otTcpEndpointInitialize</a> (<a class="el" href="structot_instance.html">otInstance</a> *aInstance, <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, const <a class="el" href="structot_tcp_endpoint_initialize_args.html">otTcpEndpointInitializeArgs</a> *aArgs)</td></tr>
<tr class="separator:ga46ca008dbb9657f10692612f3051dd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cde3ffdf74d08820bb1f80345929d33"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga9cde3ffdf74d08820bb1f80345929d33">otTcpGetLocalAddress</a> (const <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:ga9cde3ffdf74d08820bb1f80345929d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac348d019a2252ecb2d00344c84360ce6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gac348d019a2252ecb2d00344c84360ce6">otTcpGetPeerAddress</a> (const <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:gac348d019a2252ecb2d00344c84360ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b2d66fc32d24aab66868383a089a1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga51b2d66fc32d24aab66868383a089a1e">otTcpListen</a> (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener, const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *aSockName)</td></tr>
<tr class="separator:ga51b2d66fc32d24aab66868383a089a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4035a8f92bab14eb1adeb8c0a768f60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gae4035a8f92bab14eb1adeb8c0a768f60">otTcpListenerDeinitialize</a> (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener)</td></tr>
<tr class="separator:gae4035a8f92bab14eb1adeb8c0a768f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71933392bec496e86903c9de2758e6c3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga71933392bec496e86903c9de2758e6c3">otTcpListenerGetContext</a> (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener)</td></tr>
<tr class="separator:ga71933392bec496e86903c9de2758e6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd51d612e6c5290c1eba030265599fc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structot_instance.html">otInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gadd51d612e6c5290c1eba030265599fc4">otTcpListenerGetInstance</a> (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener)</td></tr>
<tr class="separator:gadd51d612e6c5290c1eba030265599fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1415bd34cc64f1745ca4b3364d7804bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga1415bd34cc64f1745ca4b3364d7804bb">otTcpListenerInitialize</a> (<a class="el" href="structot_instance.html">otInstance</a> *aInstance, <a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener, const <a class="el" href="structot_tcp_listener_initialize_args.html">otTcpListenerInitializeArgs</a> *aArgs)</td></tr>
<tr class="separator:ga1415bd34cc64f1745ca4b3364d7804bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3773930ab3cade5ff57dfe6da7726847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga3773930ab3cade5ff57dfe6da7726847">otTcpReceiveByReference</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, const <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> **aBuffer)</td></tr>
<tr class="separator:ga3773930ab3cade5ff57dfe6da7726847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4755a0481eb9e7c279cfb031641c128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaf4755a0481eb9e7c279cfb031641c128">otTcpReceiveContiguify</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:gaf4755a0481eb9e7c279cfb031641c128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c8ad89d113b0b40778be6ca5d3cde8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaf4c8ad89d113b0b40778be6ca5d3cde8">otTcpSendByExtension</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, size_t aNumBytes, uint32_t aFlags)</td></tr>
<tr class="separator:gaf4c8ad89d113b0b40778be6ca5d3cde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75f4bd44478f8a09a41b49544a96dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaa75f4bd44478f8a09a41b49544a96dfb">otTcpSendByReference</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> *aBuffer, uint32_t aFlags)</td></tr>
<tr class="separator:gaa75f4bd44478f8a09a41b49544a96dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e928aa3c9957c5d5f636c6e4c9f6e6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#ga9e928aa3c9957c5d5f636c6e4c9f6e6d">otTcpSendEndOfStream</a> (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td></tr>
<tr class="separator:ga9e928aa3c9957c5d5f636c6e4c9f6e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ec44353fa7f24229b772298863f198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api-tcp.html#gaa1ec44353fa7f24229b772298863f198">otTcpStopListening</a> (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener)</td></tr>
<tr class="separator:gaa1ec44353fa7f24229b772298863f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module includes functions that control TCP communication. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa82629c770c4bb6a2919cd1aed657b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa82629c770c4bb6a2919cd1aed657b69">&sect;&nbsp;</a></span>OT_TCP_ENDPOINT_TCB_SIZE_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OT_TCP_ENDPOINT_TCB_SIZE_BASE&#160;&#160;&#160;368</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OT_TCP_ENDPOINT_TCB_SIZE_BASE and OT_TCP_ENDPOINT_TCB_NUM_POINTERS are chosen such that the mTcb field of <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> has the same size as struct tcpcb in TCPlp. This is necessary because the mTcb field, although opaque in its declaration, is treated as struct tcpcb in the TCP implementation. </p>

</div>
</div>
<a id="ga880da2e4907c94d271ce28fb3cccae22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga880da2e4907c94d271ce28fb3cccae22">&sect;&nbsp;</a></span>OT_TCP_ENDPOINT_TCB_NUM_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OT_TCP_ENDPOINT_TCB_NUM_PTR&#160;&#160;&#160;36</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga88304ad88257ec1ec57c124d486ed8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88304ad88257ec1ec57c124d486ed8d1">&sect;&nbsp;</a></span>OT_TCP_RECEIVE_BUFFER_SIZE_FEW_HOPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OT_TCP_RECEIVE_BUFFER_SIZE_FEW_HOPS&#160;&#160;&#160;2598</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recommended buffer size for TCP connections that traverse about 3 wireless hops or fewer.</p>
<p>On platforms where memory is particularly constrained and in situations where high bandwidth is not necessary, it may be desirable to manually select a smaller buffer size. </p>

</div>
</div>
<a id="gaaee4e4eba102333eb69a3641896c0116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee4e4eba102333eb69a3641896c0116">&sect;&nbsp;</a></span>OT_TCP_RECEIVE_BUFFER_SIZE_MANY_HOPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OT_TCP_RECEIVE_BUFFER_SIZE_MANY_HOPS&#160;&#160;&#160;4157</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recommended buffer size for TCP connections that traverse many wireless hops.</p>
<p>If the TCP connection traverses a very large number of hops (more than 6 or so), then it may be advisable to select a large buffer size manually. </p>

</div>
</div>
<a id="ga28d78d4a040b42dce00443cf8f704065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d78d4a040b42dce00443cf8f704065">&sect;&nbsp;</a></span>OT_TCP_LISTENER_TCB_SIZE_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OT_TCP_LISTENER_TCB_SIZE_BASE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OT_TCP_LISTENER_TCB_SIZE_BASE and OT_TCP_LISTENER_TCB_NUM_POINTERS are chosen such that the mTcbListener field of <a class="el" href="structot_tcp_listener.html">otTcpListener</a> has the same size as struct tcpcb_listen in TCPlp. This is necessary because the mTcbListen field, though opaque in its declaration, is treated as struct tcpcb in the TCP implementation. </p>

</div>
</div>
<a id="ga2fe6ab4e74e7fe7760e08e5a9e53b31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe6ab4e74e7fe7760e08e5a9e53b31c">&sect;&nbsp;</a></span>OT_TCP_LISTENER_TCB_NUM_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OT_TCP_LISTENER_TCB_NUM_PTR&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga49f3950b5fe6b1f466f8b6ade923cfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f3950b5fe6b1f466f8b6ade923cfb4">&sect;&nbsp;</a></span>otLinkedBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a>  <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A linked buffer structure for use with TCP.</p>
<p>A single <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> structure references an array of bytes in memory, via mData and mLength. The mNext field is used to form a chain of <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> structures. </p>

</div>
</div>
<a id="ga9b25068e9277d21122c7421e0efb909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b25068e9277d21122c7421e0efb909d">&sect;&nbsp;</a></span>otTcpEndpoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga61149a925aab16e64dbca802c9af8e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61149a925aab16e64dbca802c9af8e55">&sect;&nbsp;</a></span>otTcpEstablished</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* otTcpEstablished) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback informs the application that the TCP 3-way handshake is complete and that the connection is now established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint whose connection is now established. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3cd165f8c8698e7d7e286e22ef89c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3cd165f8c8698e7d7e286e22ef89c1a">&sect;&nbsp;</a></span>otTcpSendDone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* otTcpSendDone) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> *aData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback informs the application that data in the provided <code>aData</code> have been acknowledged by the connection peer and that <code>aData</code> and the data it contains can be reclaimed by the application.</p>
<p>The <code>aData</code> are guaranteed to be identical to those passed in to TCP via <a class="el" href="group__api-tcp.html#gaa75f4bd44478f8a09a41b49544a96dfb">otTcpSendByReference()</a>, including any extensions effected via <a class="el" href="group__api-tcp.html#gaf4c8ad89d113b0b40778be6ca5d3cde8">otTcpSendByExtension()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint for the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aData</td><td>A pointer to the <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> that can be reclaimed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a4cad185c5776fe15092694de1472a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a4cad185c5776fe15092694de1472a5">&sect;&nbsp;</a></span>otTcpForwardProgress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* otTcpForwardProgress) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, size_t aInSendBuffer, size_t aBacklog)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback informs the application if forward progress has been made in transferring data from the send buffer to the recipient. This callback is not necessary for correct TCP operation. Most applications can just rely on the <a class="el" href="group__api-tcp.html#gac3cd165f8c8698e7d7e286e22ef89c1a">otTcpSendDone()</a> callback to reclaim linked buffers once the TCP stack is done using them. The purpose of this callback is to support advanced applications that benefit from finer-grained information about how the the connection is making forward progress in transferring data to the connection peer.</p>
<p>This callback's operation is closely tied to TCP's send buffer. The send buffer can be understood as having two regions. First, there is the "in-flight" region at the head (front) of the send buffer. It corresponds to data which has been sent to the recipient, but is not yet acknowledged. Second, there is the "backlog" region, which consists of all data in the send buffer that is not in the "in-flight" region. The "backlog" region corresponds to data that is queued for sending, but has not yet been sent.</p>
<p>The callback is invoked in response to two types of events. First, the "in-flight" region of the send buffer may shrink (e.g., when the recipient acknowledges data that we sent earlier). Second, the "backlog" region of the send buffer may shrink (e.g., new data was sent out). These two conditions often occur at the same time, in response to an ACK segment from the connection peer, which is why they are combined in a single callback.</p>
<p>The TCP stack only uses the <code>aInSendBuffer</code> bytes at the tail of the send buffer; when <code>aInSendBuffer</code> decreases by an amount x, it means that x additional bytes that were formerly at the head of the send buffer are no longer part of the send buffer and can now be reclaimed (i.e., overwritten) by the application. Note that the <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> structure itself can only be reclaimed once all bytes that it references are no longer part of the send buffer.</p>
<p>This callback subsumes <a class="el" href="group__api-tcp.html#gac3cd165f8c8698e7d7e286e22ef89c1a">otTcpSendDone()</a>, in the following sense: applications can determine when linked buffers can be reclaimed by comparing <code>aInSendBuffer</code> with how many bytes are in each linked buffer. However, we expect <a class="el" href="group__api-tcp.html#gac3cd165f8c8698e7d7e286e22ef89c1a">otTcpSendDone()</a>, which directly conveys which otLinkedBuffers can be reclaimed, to be much simpler to use. If both callbacks are registered and are triggered by the same event (e.g., the same ACK segment received), then the <a class="el" href="group__api-tcp.html#gac3cd165f8c8698e7d7e286e22ef89c1a">otTcpSendDone()</a> callback will be triggered first, followed by this callback.</p>
<p>Additionally, this callback provides <code>aBacklog</code>, which indicates how many bytes of data in the send buffer are not yet in flight. For applications that only want to add data to the send buffer when there is an assurance that it will be sent out soon, it may be desirable to only send out data when <code>aBacklog</code> is suitably small (0 or close to 0). For example, an application may use <code>aBacklog</code> so that it can react to queue buildup by dropping or aggregating data to avoid creating a backlog of data.</p>
<p>After a call to <a class="el" href="group__api-tcp.html#gaa75f4bd44478f8a09a41b49544a96dfb">otTcpSendByReference()</a> or <a class="el" href="group__api-tcp.html#gaf4c8ad89d113b0b40778be6ca5d3cde8">otTcpSendByExtension()</a> with a positive number of bytes, the <a class="el" href="group__api-tcp.html#ga3a4cad185c5776fe15092694de1472a5">otTcpForwardProgress()</a> callback is guaranteed to be called, to indicate when the bytes that were added to the send buffer are sent out. The call to <a class="el" href="group__api-tcp.html#ga3a4cad185c5776fe15092694de1472a5">otTcpForwardProgress()</a> may be made immediately after the bytes are added to the send buffer (if some of those bytes are immediately sent out, reducing the backlog), or sometime in the future (once the connection sends out some or all of the data, reducing the backlog). By "immediately," we mean that the callback is immediately scheduled for execution in a tasklet; to avoid reentrancy-related complexity, the <a class="el" href="group__api-tcp.html#ga3a4cad185c5776fe15092694de1472a5">otTcpForwardProgress()</a> callback is never directly called from the <a class="el" href="group__api-tcp.html#gaa75f4bd44478f8a09a41b49544a96dfb">otTcpSendByReference()</a> or <a class="el" href="group__api-tcp.html#gaf4c8ad89d113b0b40778be6ca5d3cde8">otTcpSendByExtension()</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint for the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aInSendBuffer</td><td>The number of bytes in the send buffer (sum of "in-flight" and "backlog" regions). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBacklog</td><td>The number of bytes that are queued for sending but have not yet been sent (the "backlog" region). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e36d56c9c8700d53e15c5043d1790d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e36d56c9c8700d53e15c5043d1790d9">&sect;&nbsp;</a></span>otTcpReceiveAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* otTcpReceiveAvailable) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, size_t aBytesAvailable, bool aEndOfStream, size_t aBytesRemaining)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback indicates the number of bytes available for consumption from the receive buffer.</p>
<p>It is called whenever bytes are added to the receive buffer and when the end of stream is reached. If the end of the stream has been reached (i.e., if no more data will become available to read because the connection peer has closed their end of the connection for writing), then <code>aEndOfStream</code> is true. Finally, <code>aBytesRemaining</code> indicates how much capacity is left in the receive buffer to hold additional data that arrives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint for the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBytesAvailable</td><td>The number of bytes in the connection's receive buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndOfStream</td><td>Indicates if additional data, beyond what is already in the connection's receive buffer, can be received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBytesRemaining</td><td>The number of additional bytes that can be received before the receive buffer becomes full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba3d813dd1a8968bf0f60312e32a4263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba3d813dd1a8968bf0f60312e32a4263">&sect;&nbsp;</a></span>otTcpDisconnectedReason</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__api-tcp.html#ga2dea5fb99241c1b9efe73dc79dbe30ea">otTcpDisconnectedReason</a>  <a class="el" href="group__api-tcp.html#ga2dea5fb99241c1b9efe73dc79dbe30ea">otTcpDisconnectedReason</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa453ad1382ed09405b06ba5a58a7fe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa453ad1382ed09405b06ba5a58a7fe27">&sect;&nbsp;</a></span>otTcpDisconnected</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* otTcpDisconnected) (<a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, <a class="el" href="group__api-tcp.html#ga2dea5fb99241c1b9efe73dc79dbe30ea">otTcpDisconnectedReason</a> aReason)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback indicates that the connection was broken and should no longer be used, or that a connection has entered the TIME-WAIT state.</p>
<p>It can occur if a connection establishment attempt (initiated by calling <a class="el" href="group__api-tcp.html#ga3bc39aeb3514e836dfb1d74e824e1cce">otTcpConnect()</a>) fails, or any point thereafter (e.g., if the connection times out or an RST segment is received from the connection peer). Once this callback fires, all resources that the application provided for this connection (i.e., any <code>otLinkedBuffers</code> and memory they reference, but not the TCP endpoint itself or space for the receive buffers) can be reclaimed. In the case of a connection entering the TIME-WAIT state, this callback is called twice, once upon entry into the TIME-WAIT state (with OT_TCP_DISCONNECTED_REASON_TIME_WAIT, and again when the TIME-WAIT state expires (with OT_TCP_DISCONNECTED_REASON_NORMAL).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint whose connection has been lost. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aReason</td><td>The reason why the connection was lost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe706402a5c796bd699f0046aa9632b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe706402a5c796bd699f0046aa9632b3">&sect;&nbsp;</a></span>otTcpEndpointInitializeArgs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structot_tcp_endpoint_initialize_args.html">otTcpEndpointInitializeArgs</a>  <a class="el" href="structot_tcp_endpoint_initialize_args.html">otTcpEndpointInitializeArgs</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure contains arguments to the <a class="el" href="group__api-tcp.html#ga46ca008dbb9657f10692612f3051dd55">otTcpEndpointInitialize()</a> function. </p>

</div>
</div>
<a id="ga525b81e6a10ffac54fa6d86b39841611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga525b81e6a10ffac54fa6d86b39841611">&sect;&nbsp;</a></span>otTcpListener</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structot_tcp_listener.html">otTcpListener</a> <a class="el" href="structot_tcp_listener.html">otTcpListener</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaabbf4ac01a179c45fb595462fb2a7673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabbf4ac01a179c45fb595462fb2a7673">&sect;&nbsp;</a></span>otTcpIncomingConnectionAction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__api-tcp.html#gaad21b37b5f4d9fbc97e86b9a026237b0">otTcpIncomingConnectionAction</a>  <a class="el" href="group__api-tcp.html#gaad21b37b5f4d9fbc97e86b9a026237b0">otTcpIncomingConnectionAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines incoming connection actions.</p>
<p>This is used in <a class="el" href="group__api-tcp.html#ga613840e8b9ea3f201cd0a73702970af2">otTcpAcceptReady()</a> callback. </p>

</div>
</div>
<a id="ga613840e8b9ea3f201cd0a73702970af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga613840e8b9ea3f201cd0a73702970af2">&sect;&nbsp;</a></span>otTcpAcceptReady</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__api-tcp.html#gaad21b37b5f4d9fbc97e86b9a026237b0">otTcpIncomingConnectionAction</a>(* otTcpAcceptReady) (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener, const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *aPeer, <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> **aAcceptInto)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback indicates that an incoming connection that matches this TCP listener has arrived.</p>
<p>The typical response is for the application to accept the incoming connection. It does so by populating <code>aAcceptInto</code> with a pointer to the <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> into which to accept the incoming connection. This <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> must already be initialized using <a class="el" href="group__api-tcp.html#ga46ca008dbb9657f10692612f3051dd55">otTcpEndpointInitialize()</a>. Then, the application returns OT_TCP_INCOMING_CONNECTION_ACTION_ACCEPT.</p>
<p>Alternatively, the application can decline to accept the incoming connection. There are two ways for the application to do this. First, if the application returns OT_TCP_INCOMING_CONNECTION_ACTION_DEFER, then OpenThread silently ignores the connection establishment request; the connection peer will likely retransmit the request, at which point the callback will be called again. This is valuable if resources are not presently available to accept the connection, but they may be available when the connection peer retransmits its connection establishment attempt. Second, if the application returns OT_TCP_INCOMING_CONNECTION_ACTION_REFUSE, then OpenThread sends a "connection refused" message to the host that attempted to establish a connection. If the application declines the incoming connection, it is not required to populate <code>aAcceptInto</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aListener</td><td>The TCP listener that matches the incoming connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPeer</td><td>The host and port from which the incoming connection originates. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aAcceptInto</td><td>The TCP endpoint into which to accept the incoming connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Description of how to handle the incoming connection. </dd></dl>

</div>
</div>
<a id="ga49d7a462451ac720d5a6c685e3204066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49d7a462451ac720d5a6c685e3204066">&sect;&nbsp;</a></span>otTcpAcceptDone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* otTcpAcceptDone) (<a class="el" href="structot_tcp_listener.html">otTcpListener</a> *aListener, <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *aEndpoint, const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *aPeer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback indicates that the TCP connection is now ready for two-way communication.</p>
<p>In the case of TCP Fast Open, this may be before the TCP connection handshake has actually completed. The application is provided with the context pointers both for the TCP listener that accepted the connection and the TCP endpoint into which it was accepted. The provided context is the one associated with the TCP listener.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aListener</td><td>The TCP listener that matches the incoming connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint into which the incoming connection was accepted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPeer</td><td>the host and port from which the incoming connection originated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86fdfebf1988c213634a8c6768c977ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86fdfebf1988c213634a8c6768c977ff">&sect;&nbsp;</a></span>otTcpListenerInitializeArgs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structot_tcp_listener_initialize_args.html">otTcpListenerInitializeArgs</a>  <a class="el" href="structot_tcp_listener_initialize_args.html">otTcpListenerInitializeArgs</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure contains arguments to the <a class="el" href="group__api-tcp.html#ga1415bd34cc64f1745ca4b3364d7804bb">otTcpListenerInitialize()</a> function. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2dea5fb99241c1b9efe73dc79dbe30ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dea5fb99241c1b9efe73dc79dbe30ea">&sect;&nbsp;</a></span>otTcpDisconnectedReason</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__api-tcp.html#ga2dea5fb99241c1b9efe73dc79dbe30ea">otTcpDisconnectedReason</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2dea5fb99241c1b9efe73dc79dbe30eaad9f09ab6f258ca89db3feecbc43e53d6"></a>OT_TCP_DISCONNECTED_REASON_NORMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2dea5fb99241c1b9efe73dc79dbe30eaaa7b9c8c6eb76ecec5931b3a8868690f4"></a>OT_TCP_DISCONNECTED_REASON_REFUSED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2dea5fb99241c1b9efe73dc79dbe30eaa562f5a5f387d17f20686979cb7bcbdba"></a>OT_TCP_DISCONNECTED_REASON_RESET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2dea5fb99241c1b9efe73dc79dbe30eaa4be8bf19da153a8298acb031f6e6bbee"></a>OT_TCP_DISCONNECTED_REASON_TIME_WAIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2dea5fb99241c1b9efe73dc79dbe30eaacfa11732004edbd8b974f99b4d040c50"></a>OT_TCP_DISCONNECTED_REASON_TIMED_OUT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga4f126a0a9b1d8c6a8f46a051ef8830bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f126a0a9b1d8c6a8f46a051ef8830bb">&sect;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines flags passed to <a class="el" href="group__api-tcp.html#ga3bc39aeb3514e836dfb1d74e824e1cce">otTcpConnect()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4f126a0a9b1d8c6a8f46a051ef8830bbad8c47e04ce728e986ee716857816ad32"></a>OT_TCP_CONNECT_NO_FAST_OPEN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gadbaf9202177df73e6880eab6e6aab329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbaf9202177df73e6880eab6e6aab329">&sect;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines flags passed to <code>otTcpSendByReference</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadbaf9202177df73e6880eab6e6aab329aedc77e0c7644f2ced86d481c1325fe3a"></a>OT_TCP_SEND_MORE_TO_COME&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gaad21b37b5f4d9fbc97e86b9a026237b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad21b37b5f4d9fbc97e86b9a026237b0">&sect;&nbsp;</a></span>otTcpIncomingConnectionAction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__api-tcp.html#gaad21b37b5f4d9fbc97e86b9a026237b0">otTcpIncomingConnectionAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines incoming connection actions.</p>
<p>This is used in <a class="el" href="group__api-tcp.html#ga613840e8b9ea3f201cd0a73702970af2">otTcpAcceptReady()</a> callback. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaad21b37b5f4d9fbc97e86b9a026237b0a3c412f0e31a6e5d4dc90cce7388cf5c4"></a>OT_TCP_INCOMING_CONNECTION_ACTION_ACCEPT&#160;</td><td class="fielddoc"><p>Accept the incoming connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaad21b37b5f4d9fbc97e86b9a026237b0a73f6209e2015242f880c65634f671449"></a>OT_TCP_INCOMING_CONNECTION_ACTION_DEFER&#160;</td><td class="fielddoc"><p>Defer (silently ignore) the incoming connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaad21b37b5f4d9fbc97e86b9a026237b0a2194e1854e3f1c7d51039b25bbfa7044"></a>OT_TCP_INCOMING_CONNECTION_ACTION_REFUSE&#160;</td><td class="fielddoc"><p>Refuse the incoming connection. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga46ca008dbb9657f10692612f3051dd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46ca008dbb9657f10692612f3051dd55">&sect;&nbsp;</a></span>otTcpEndpointInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpEndpointInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_instance.html">otInstance</a> *&#160;</td>
          <td class="paramname"><em>aInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structot_tcp_endpoint_initialize_args.html">otTcpEndpointInitializeArgs</a> *&#160;</td>
          <td class="paramname"><em>aArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a TCP endpoint.</p>
<p>Calling this function causes OpenThread to keep track of the TCP endpoint and store and retrieve TCP data inside the <code>aEndpoint</code>. The application should refrain from directly accessing or modifying the fields in <code>aEndpoint</code>. If the application needs to reclaim the memory backing <code>aEndpoint</code>, it should call <a class="el" href="group__api-tcp.html#gac3d5c30636461e320a8fd77c8da49881">otTcpEndpointDeinitialize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aInstance</td><td>A pointer to an OpenThread instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to a TCP endpoint structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aArgs</td><td>A pointer to a structure of arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully opened the TCP endpoint. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to open the TCP endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58b8afb5269f4d3491cd413d219dc5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b8afb5269f4d3491cd413d219dc5f2">&sect;&nbsp;</a></span>otTcpEndpointGetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structot_instance.html">otInstance</a>* otTcpEndpointGetInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the <a class="el" href="structot_instance.html">otInstance</a> that was associated with <code>aEndpoint</code> upon initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint whose instance to obtain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structot_instance.html">otInstance</a> pointer associated with <code>aEndpoint</code>. </dd></dl>

</div>
</div>
<a id="ga4da77ed858448152d8f02f9e01f4e5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da77ed858448152d8f02f9e01f4e5f4">&sect;&nbsp;</a></span>otTcpEndpointGetContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* otTcpEndpointGetContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the context pointer that was associated with <code>aEndpoint</code> upon initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint whose context to obtain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The context pointer associated with <code>aEndpoint</code>. </dd></dl>

</div>
</div>
<a id="ga9cde3ffdf74d08820bb1f80345929d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cde3ffdf74d08820bb1f80345929d33">&sect;&nbsp;</a></span>otTcpGetLocalAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structot_sock_addr.html">otSockAddr</a>* otTcpGetLocalAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains a pointer to a TCP endpoint's local host and port.</p>
<p>The contents of the host and port may be stale if this socket is not in a connected state and has not been bound after it was last disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint whose local host and port to obtain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local host and port of <code>aEndpoint</code>. </dd></dl>

</div>
</div>
<a id="gac348d019a2252ecb2d00344c84360ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac348d019a2252ecb2d00344c84360ce6">&sect;&nbsp;</a></span>otTcpGetPeerAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structot_sock_addr.html">otSockAddr</a>* otTcpGetPeerAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains a pointer to a TCP endpoint's peer's host and port.</p>
<p>The contents of the host and port may be stale if this socket is not in a connected state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>The TCP endpoint whose peer's host and port to obtain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host and port of the connection peer of <code>aEndpoint</code>. </dd></dl>

</div>
</div>
<a id="ga5d0811860150c56632ad641a71100a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d0811860150c56632ad641a71100a5a">&sect;&nbsp;</a></span>otTcpBind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpBind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *&#160;</td>
          <td class="paramname"><em>aSockName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds the TCP endpoint to an IP address and port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure to bind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSockName</td><td>The address and port to which to bind this TCP endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully bound the TCP endpoint. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to bind the TCP endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3bc39aeb3514e836dfb1d74e824e1cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bc39aeb3514e836dfb1d74e824e1cce">&sect;&nbsp;</a></span>otTcpConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *&#160;</td>
          <td class="paramname"><em>aSockName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records the remote host and port for this connection.</p>
<p>By default TCP Fast Open is used. This means that this function merely records the remote host and port, and that the TCP connection establishment handshake only happens on the first call to <a class="el" href="group__api-tcp.html#gaa75f4bd44478f8a09a41b49544a96dfb">otTcpSendByReference()</a>. TCP Fast Open can be explicitly disabled using <code>aFlags</code>, in which case the TCP connection establishment handshake is initiated immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSockName</td><td>The IP address and port of the host to which to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFlags</td><td>Flags specifying options for this operation (see enumeration above).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully completed the operation. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to complete the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa75f4bd44478f8a09a41b49544a96dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa75f4bd44478f8a09a41b49544a96dfb">&sect;&nbsp;</a></span>otTcpSendByReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpSendByReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> *&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds data referenced by the linked buffer pointed to by <code>aBuffer</code> to the send buffer.</p>
<p>Upon a successful call to this function, the linked buffer and data it references are owned by the TCP stack; they should not be modified by the application until a "send done" callback returns ownership of those objects to the application. It is acceptable to call this function to add another linked buffer to the send queue, even if the "send done" callback for a previous invocation of this function has not yet fired.</p>
<p>Note that <code>aBuffer</code> should not be chained; its mNext field should be NULL. If additional data will be added right after this call, then the OT_TCP_SEND_MORE_TO_COME flag should be used as a hint to the TCP implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure representing the TCP endpoint on which to send data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>A pointer to the linked buffer chain referencing data to add to the send buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFlags</td><td>Flags specifying options for this operation (see enumeration above).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully added data to the send buffer. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to add data to the send buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4c8ad89d113b0b40778be6ca5d3cde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4c8ad89d113b0b40778be6ca5d3cde8">&sect;&nbsp;</a></span>otTcpSendByExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpSendByExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>aNumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds data to the send buffer by extending the length of the final <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> in the send buffer by the specified amount.</p>
<p>If the send buffer is empty, then the operation fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure representing the TCP endpoint on which to send data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aNumBytes</td><td>The number of bytes by which to extend the length of the final linked buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFlags</td><td>Flags specifying options for this operation (see enumeration above).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully added data to the send buffer. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to add data to the send buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3773930ab3cade5ff57dfe6da7726847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3773930ab3cade5ff57dfe6da7726847">&sect;&nbsp;</a></span>otTcpReceiveByReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpReceiveByReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structot_linked_buffer.html">otLinkedBuffer</a> **&#160;</td>
          <td class="paramname"><em>aBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the application with a linked buffer chain referencing data currently in the TCP receive buffer.</p>
<p>The linked buffer chain is valid until the "receive ready" callback is next invoked, or until the next call to <a class="el" href="group__api-tcp.html#gaf4755a0481eb9e7c279cfb031641c128">otTcpReceiveContiguify()</a> or <a class="el" href="group__api-tcp.html#ga0ee5105795fcdf332bb255e252eeed74">otTcpCommitReceive()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure representing the TCP endpoint on which to receive data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aBuffer</td><td>A pointer to the linked buffer chain referencing data currently in the receive buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully completed the operation. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to complete the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4755a0481eb9e7c279cfb031641c128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4755a0481eb9e7c279cfb031641c128">&sect;&nbsp;</a></span>otTcpReceiveContiguify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpReceiveContiguify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reorganizes the receive buffer to be entirely contiguous in memory.</p>
<p>This is optional; an application can simply traverse the linked buffer chain obtained by calling <code>otTcpReceiveByReference</code>. Some applications may wish to call this function to make the receive buffer contiguous to simplify their data processing, but this comes at the expense of CPU time to reorganize the data in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint whose receive buffer to reorganize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully completed the operation. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to complete the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ee5105795fcdf332bb255e252eeed74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee5105795fcdf332bb255e252eeed74">&sect;&nbsp;</a></span>otTcpCommitReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpCommitReceive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>aNumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Informs the TCP stack that the application has finished processing <code>aNumBytes</code> bytes of data at the start of the receive buffer and that the TCP stack need not continue maintaining those bytes in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure representing the TCP endpoint on which to receive data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aNumBytes</td><td>The number of bytes consumed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFlags</td><td>Flags specifying options for this operation (none yet).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully completed the receive operation. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to complete the receive operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e928aa3c9957c5d5f636c6e4c9f6e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e928aa3c9957c5d5f636c6e4c9f6e6d">&sect;&nbsp;</a></span>otTcpSendEndOfStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpSendEndOfStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Informs the connection peer that this TCP endpoint will not send more data.</p>
<p>This should be used when the application has no more data to send to the connection peer. For this connection, future reads on the connection peer will result in the "end of stream" condition, and future writes on this connection endpoint will fail.</p>
<p>The "end of stream" condition only applies after any data previously provided to the TCP stack to send out has been received by the connection peer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure representing the TCP endpoint to shut down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully queued the "end of stream" condition for transmission. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to queue the "end of stream" condition for transmission. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11edfbb1feaab02ba9e8cb65bfa39491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11edfbb1feaab02ba9e8cb65bfa39491">&sect;&nbsp;</a></span>otTcpAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forcibly ends the TCP connection associated with this TCP endpoint.</p>
<p>This immediately makes the TCP endpoint free for use for another connection and empties the send and receive buffers, transferring ownership of any data provided by the application in <a class="el" href="group__api-tcp.html#gaa75f4bd44478f8a09a41b49544a96dfb">otTcpSendByReference()</a> and <a class="el" href="group__api-tcp.html#gaf4c8ad89d113b0b40778be6ca5d3cde8">otTcpSendByExtension()</a> calls back to the application. The TCP endpoint's callbacks and memory for the receive buffer remain associated with the TCP endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure representing the TCP endpoint to abort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully aborted the TCP endpoint's connection. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to abort the TCP endpoint's connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3d5c30636461e320a8fd77c8da49881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3d5c30636461e320a8fd77c8da49881">&sect;&nbsp;</a></span>otTcpEndpointDeinitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpEndpointDeinitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_endpoint.html">otTcpEndpoint</a> *&#160;</td>
          <td class="paramname"><em>aEndpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deinitializes this TCP endpoint.</p>
<p>This means that OpenThread no longer keeps track of this TCP endpoint and deallocates all resources it has internally allocated for this TCP endpoint. The application can reuse the memory backing the TCP endpoint as it sees fit.</p>
<p>If it corresponds to a live TCP connection, the connection is terminated unceremoniously (as in <a class="el" href="group__api-tcp.html#ga11edfbb1feaab02ba9e8cb65bfa39491">otTcpAbort()</a>). All resources the application has provided for this TCP endpoint (linked buffers for the send buffer, memory for the receive buffer, the <code>aEndpoint</code> structure itself, etc.) are immediately returned to the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEndpoint</td><td>A pointer to the TCP endpoint structure to deinitialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully deinitialized the TCP endpoint. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to deinitialize the TCP endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1415bd34cc64f1745ca4b3364d7804bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1415bd34cc64f1745ca4b3364d7804bb">&sect;&nbsp;</a></span>otTcpListenerInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpListenerInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_instance.html">otInstance</a> *&#160;</td>
          <td class="paramname"><em>aInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structot_tcp_listener.html">otTcpListener</a> *&#160;</td>
          <td class="paramname"><em>aListener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structot_tcp_listener_initialize_args.html">otTcpListenerInitializeArgs</a> *&#160;</td>
          <td class="paramname"><em>aArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a TCP listener.</p>
<p>Calling this function causes OpenThread to keep track of the TCP listener and store and retrieve TCP data inside <code>aListener</code>. The application should refrain from directly accessing or modifying the fields in <code>aListener</code>. If the application needs to reclaim the memory backing <code>aListener</code>, it should call <a class="el" href="group__api-tcp.html#gae4035a8f92bab14eb1adeb8c0a768f60">otTcpListenerDeinitialize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aInstance</td><td>A pointer to an OpenThread instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aListener</td><td>A pointer to a TCP listener structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aArgs</td><td>A pointer to a structure of arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully opened the TCP listener. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to open the TCP listener. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd51d612e6c5290c1eba030265599fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd51d612e6c5290c1eba030265599fc4">&sect;&nbsp;</a></span>otTcpListenerGetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structot_instance.html">otInstance</a>* otTcpListenerGetInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_listener.html">otTcpListener</a> *&#160;</td>
          <td class="paramname"><em>aListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the <a class="el" href="structot_instance.html">otInstance</a> that was associated with <code>aListener</code> upon initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aListener</td><td>The TCP listener whose instance to obtain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structot_instance.html">otInstance</a> pointer associated with <code>aListener</code>. </dd></dl>

</div>
</div>
<a id="ga71933392bec496e86903c9de2758e6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71933392bec496e86903c9de2758e6c3">&sect;&nbsp;</a></span>otTcpListenerGetContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* otTcpListenerGetContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_listener.html">otTcpListener</a> *&#160;</td>
          <td class="paramname"><em>aListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the context pointer that was associated with <code>aListener</code> upon initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aListener</td><td>The TCP listener whose context to obtain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The context pointer associated with <code>aListener</code>. </dd></dl>

</div>
</div>
<a id="ga51b2d66fc32d24aab66868383a089a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51b2d66fc32d24aab66868383a089a1e">&sect;&nbsp;</a></span>otTcpListen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpListen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_listener.html">otTcpListener</a> *&#160;</td>
          <td class="paramname"><em>aListener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structot_sock_addr.html">otSockAddr</a> *&#160;</td>
          <td class="paramname"><em>aSockName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes incoming TCP connections that match the specified IP address and port to trigger this TCP listener's callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aListener</td><td>A pointer to the TCP listener structure that should begin listening. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSockName</td><td>The address and port on which to listen for incoming connections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully initiated listening on the TCP listener. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to initiate listening on the TCP listener. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1ec44353fa7f24229b772298863f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1ec44353fa7f24229b772298863f198">&sect;&nbsp;</a></span>otTcpStopListening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpStopListening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_listener.html">otTcpListener</a> *&#160;</td>
          <td class="paramname"><em>aListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes this TCP listener to stop listening for incoming connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aListener</td><td>A pointer to the TCP listener structure that should stop listening.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully stopped listening on the TCP listener. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to stop listening on the TCP listener. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4035a8f92bab14eb1adeb8c0a768f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4035a8f92bab14eb1adeb8c0a768f60">&sect;&nbsp;</a></span>otTcpListenerDeinitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api-error.html#ga592639bfe12528759d7368a8c9645993">otError</a> otTcpListenerDeinitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structot_tcp_listener.html">otTcpListener</a> *&#160;</td>
          <td class="paramname"><em>aListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deinitializes this TCP listener.</p>
<p>This means that OpenThread no longer keeps track of this TCP listener and deallocates all resources it has internally allocated for this TCP listener. The application can reuse the memory backing the TCP listener as it sees fit.</p>
<p>If the TCP listener is currently listening, it stops listening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aListener</td><td>A pointer to the TCP listener structure to deinitialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OT_ERROR_NONE</td><td>Successfully deinitialized the TCP listener. </td></tr>
    <tr><td class="paramname">OT_ERROR_FAILED</td><td>Failed to deinitialize the TCP listener. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2022</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
