<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>CUI API: CUI API Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUI API
   &#160;<span id="projectnumber">1.00.00.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CUI API Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section rcs"><dt>Date</dt><dd>2018-12-18 12:13:13 -0800 (Tue, 18 Dec 2018) </dd></dl>
<dl class="section rcs"><dt>Revision</dt><dd>42528 </dd></dl>
<h1>Overview </h1>
<pre class="fragment">This file contains the interface of the Common User Interface or CUI.

The CUI controls the access to User Interface resources. On a launchpad
device, these resources are made up of Buttons, LEDs and UART i/o.

The CUI provides an API that can be used to request for access to resources
and then read/write to those resources. In order to request and acquire a
resource the notion of a 'client' is used. The Client handle is used to
successfully communicate with the CUI API. Once you open a client with the
CUI you may then request access to a resource. If the resource is available
the CUI will give the client access to the resource.
</pre><h1>Resource Types </h1>
<pre class="fragment">As described earlier, there are three different resources the CUI controls
access to. (Buttons, LEDs and UART i/o).

For Buttons and LEDs the process for requesting and using the resource is
quite simple and is nearly identical to how you would use the Button or LED
drivers to do the same.

For UART i/o there are two resources to consider. Firstly there is the
notion of a 'menu'. A menu specific to your application can be registered with
the CUI. The CUI will handle menu navigation, reading and writing. A menu
can be as simple or as complex as desired. The second UART i/o is the notion
of a 'status line'. Where the menu is designed to be a display
driven by the input of the user, the status lines are capable of displaying
the latest value of any particular set of information the developer chooses.
A great example of a menu item would be any sort of toggle led event your
device can perform or maybe a commissioning action and an example of a
status line could be current network status or any application state
information. More details on menus and status lines can be found below.
</pre><h1>Usage </h1>
<pre class="fragment">This documentation provides a basic usage summary and a set of examples in
the form of commented code fragments. Detailed descriptions of the APIs are
provided in subsequent sections.

Initilization is the first step.
</pre><div class="fragment"><div class="line"><span class="comment">// Import the CUI definitions</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cui_8h.html">cui.h</a>&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="struct_c_u_i__params__t.html">CUI_params_t</a> cuiParams;</div><div class="line"><a class="code" href="cui_8h.html#ad36347b9333ba6acf438a9addcc75392">CUI_paramsInit</a>(&amp;cuiParams);</div><div class="line"></div><div class="line"><span class="comment">// One-time initialization of the CUI</span></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082a791b590588509335ba8233d5c1f6da5f">CUI_SUCCESS</a> != <a class="code" href="cui_8h.html#a963806e0784146b81383bd7818b74b3b">CUI_init</a>(&amp;cuiParams)) {</div><div class="line">    <span class="comment">// handle failure</span></div><div class="line">}</div></div><!-- fragment --><p>By calling <a class="el" href="cui_8h.html#ad36347b9333ba6acf438a9addcc75392">CUI_paramsInit()</a> you are setting the cuiParams to their default values. </p><pre class="fragment">cuiParams.manageBtns = true
cuiParams.manageLeds = true
cuiParams.manageUart = true
</pre><p>If your application requires special management of buttons, leds, or uart the developer can set the parameters appropriately before calling <a class="el" href="cui_8h.html#a963806e0784146b81383bd7818b74b3b">CUI_init()</a></p>
<p>After the CUI has been initialized you can then open a client.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_c_u_i__client_params__t.html">CUI_clientParams_t</a> clientParams;</div><div class="line"><a class="code" href="cui_8h.html#a42f35e4db56609b72749882b0d3f8478">CUI_clientParamsInit</a>(&amp;clientParams);</div><div class="line"></div><div class="line">strncpy(clientParams.<a class="code" href="struct_c_u_i__client_params__t.html#a7aa9fbcaf497fbf05859f1d8b4033447">clientName</a>, <span class="stringliteral">&quot;My first CUI application&quot;</span>, <a class="code" href="cui_8h.html#a019862dfd4a2b73f703e6f4e026c3cc7">MAX_CLIENT_NAME_LEN</a>);</div><div class="line">clientParams.<a class="code" href="struct_c_u_i__client_params__t.html#a8b8987930463e7fba839824cd2fba6aa">maxStatusLines</a> = 5;</div><div class="line"></div><div class="line"><a class="code" href="cui_8h.html#ade18acc875b26ca6ecee3c2478ff83a3">CUI_clientHandle_t</a> clientHandle = <a class="code" href="cui_8h.html#ad906b41778c533a38354bccbd32598b8">CUI_clientOpen</a>(&amp;clientParams);</div><div class="line"><span class="keywordflow">if</span> (clientHandle == NULL) {</div><div class="line">    <span class="comment">// handle failure</span></div><div class="line">}</div></div><!-- fragment --><p>By Calling <a class="el" href="cui_8h.html#a42f35e4db56609b72749882b0d3f8478">CUI_clientParamsInit()</a> you are setting the clientParams to their default values. </p><pre class="fragment">strcpy(clientParams.clientName, "");
clientParams.maxStatusLines = 0;
</pre><p><b>It is currently required that your clientName not be empty.</b> It can be anything you would like as it is only used to create a simple hash value.</p>
<p>If you would like to add status lines to your application, you will need to update clientParams.maxStatusLines as the code snippet above shows.</p>
<p>Now that you have a valid client you may start requesting access to resources. When requesting a button resource you must specify which button you are requesting as well as a callback that the CUI can use to notify you of a button change event that matches the CUI_btnPressCB_t prototype.</p>
<div class="fragment"><div class="line">CUI_btnRequest_t rightBtnReq;</div><div class="line">rightBtnReq.index = CONFIG_BTN_RIGHT;</div><div class="line">rightBtnReq.appCB = myBtnChangeHandler;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082a791b590588509335ba8233d5c1f6da5f">CUI_SUCCESS</a> != CUI_btnResourceRequest(clientHandle, &amp;rightBtnReq) {</div><div class="line">    <span class="comment">//handle failure</span></div><div class="line">}</div></div><!-- fragment --><p>If the resource was available to acquire then you will now have access to the right button.</p>
<p>Alternatively, if you would like to read the button state without requiring an application callback, you can request the button in a sort of polling mode by using a NULL appCB. Then simply request the button's value whenever you require it.</p>
<div class="fragment"><div class="line">CUI_btnRequest_t rightBtnReq;</div><div class="line">rightBtnReq.index = CONFIG_BTN_RIGHT;</div><div class="line">rightBtnReq.appCB = NULL;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082a791b590588509335ba8233d5c1f6da5f">CUI_SUCCESS</a> != CUI_btnResourceRequest(clientHandle, &amp;rightBtnReq) {</div><div class="line">    <span class="comment">//handle failure</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> btnState = <span class="keyword">false</span>;</div><div class="line">retVal = CUI_btnGetValue(clientHandle, CONFIG_BTN_RIGHT, &amp;btnState);</div><div class="line"><span class="keywordflow">if</span> (!btnState) {</div><div class="line">    <span class="comment">//handle button logic</span></div><div class="line">}</div></div><!-- fragment --><p>If you would like to change the btnMode of a button you already have access to then you can use the CUI_btnSetCb() API. By using a non-NULL value for the third parameter you will be using a sort of call back mode. If you use a NULL value for the third parameter, you will be using a polling mode.</p>
<div class="fragment"><div class="line"><a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082">CUI_retVal</a> retVal;</div><div class="line">retVal = CUI_btnSetCb(clientHandle, CONFIG_BTN_RIGHT, appChangeKeyCB);</div><div class="line"><span class="keywordflow">if</span> (retVal != <a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082a791b590588509335ba8233d5c1f6da5f">CUI_SUCCESS</a>) {</div><div class="line">    <span class="comment">//handle failure</span></div><div class="line">}</div></div><!-- fragment --><p>Buttons are great but only part of the picture. Let's request a LED as well. This time the only information you need to provide is the index of the LED you wish to acquire.</p>
<div class="fragment"><div class="line">CUI_ledRequest_t greenLedReq;</div><div class="line">greenLedReq.index = CONFIG_LED_GREEN;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082a791b590588509335ba8233d5c1f6da5f">CUI_SUCCESS</a> != CUI_ledResourceRequest(clientHandle, &amp;greenLedReq) {</div><div class="line">    <span class="comment">// Handle failure</span></div><div class="line">}</div></div><!-- fragment --><p>If the led was available you will have gained access to it and when you wish to change the state of the led you need only to call the CUI LED APIs.</p>
<div class="fragment"><div class="line">CUI_ledToggle(clientHandle, CONFIG_LED_GREEN);</div><div class="line">CUI_ledBlink(clientHandle, CONFIG_LED_GREEN, 5);</div><div class="line">CUI_ledBlink(clientHandle, CONFIG_LED_GREEN, CUI_BLINK_CONTINUOUS);</div><div class="line">CUI_ledOn(clientHandle, CONFIG_LED_GREEN);</div><div class="line">CUI_ledOff(clientHandle, CONFIG_LED_GREEN);</div></div><!-- fragment --><p>One note on CUI_ledBlink is that you can choose to blink continuously or you can choose to blink a specific number of times. If you call CUI_ledBlink while the led is already blinking. The only thing that will happen is that the number of blinks will be reset to the new value.</p>
<p>Now you have full control over buttons and LEDs. But you may want to let the user know when you have joined a network for instance. Well this is the perfect use for a status line. First we must request access to an available status line. Status lines are handed out upon request in numeric order and the number of status lines available to you are determined by clientParams.maxStatusLines when you opened your client.</p>
<div class="fragment"><div class="line">uint32_t connStatusLine;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082a791b590588509335ba8233d5c1f6da5f">CUI_SUCCESS</a> != <a class="code" href="cui_8h.html#a1fa34e294cf64bfe9aebc415860ee63a">CUI_statusLineResourceRequest</a>(clientHandle, <span class="stringliteral">&quot;Conn Status&quot;</span>, &amp;connStatusLine) {</div><div class="line">    <span class="comment">// handle failure</span></div><div class="line">}</div></div><!-- fragment --><p>If clientParams.maxStatusLines haven't already been requested from the CUI you will have been given access to that line. When a status line is acquired, a default line value will be printed in the form of "LABEL: --". So in the example above we will see "Conn Status: --" printed on the screen.</p>
<p>If you wish to tell the user a different value for that status line you need to tell the CUI what that new value is. Using a variatic function you can pass in a format string and any number of optional items to be formated according to your format string. Similar to printf() if you are familiar.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> lineFormat[<a class="code" href="cui_8h.html#acc277ff12a793aa0c5fba7229dbfc699">MAX_STATUS_LINE_VALUE_LEN</a>];</div><div class="line">strncpy(lineFormat, <span class="stringliteral">&quot;Successfully Connected&quot;</span>, <a class="code" href="cui_8h.html#acc277ff12a793aa0c5fba7229dbfc699">MAX_STATUS_LINE_VALUE_LEN</a>);</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082a791b590588509335ba8233d5c1f6da5f">CUI_SUCCESS</a> != <a class="code" href="cui_8h.html#acb686b1bc2a87a45c2167aef67648bce">CUI_statusLinePrintf</a>(clientHandle, connStatusLine, lineFormat) {</div><div class="line">    <span class="comment">//handle failure</span></div><div class="line">}</div></div><!-- fragment --><p>Now you will see "Conn Status: Successfully Connected".</p>
<p>If you wish to spice your status lines up a bit more, there are a few color codes available to you by default. To make use of these, simply surround the text you wish to be given a color between a color macro and the reset macro.</p>
<div class="fragment"><div class="line"><a class="code" href="cui_8h.html#ab4bc8ca14939d8f05f2cf7348cc38e81">CUI_COLOR_RESET</a></div><div class="line"><a class="code" href="cui_8h.html#a9447eb519dad5dd15dc6a6b9aadbce71">CUI_COLOR_RED</a></div><div class="line"><a class="code" href="cui_8h.html#a1797386fafa486f505af19be96449748">CUI_COLOR_GREEN</a></div><div class="line"><a class="code" href="cui_8h.html#afa90ea23a1a9ae0373c9502741b494e9">CUI_COLOR_YELLOW</a></div><div class="line"><a class="code" href="cui_8h.html#a5bf416509062badf9b44a7be4b566dad">CUI_COLOR_MAGENTA</a></div><div class="line"><a class="code" href="cui_8h.html#a826a65b380f037a60475420b6b86976d">CUI_COLOR_CYAN</a></div><div class="line"><a class="code" href="cui_8h.html#ad3c42160cad2444aa54a9e0e6249450c">CUI_COLOR_WHITE</a></div></div><!-- fragment --><p>For instance, you could use red for something bad, and green for something good. These can be used for status lines or menu lines. Any text that is being displayed can be colored with these macros</p>
<div class="fragment"><div class="line"><a class="code" href="cui_8h.html#acb686b1bc2a87a45c2167aef67648bce">CUI_statusLinePrintf</a>(clientHandle, connStatusLine, <a class="code" href="cui_8h.html#a9447eb519dad5dd15dc6a6b9aadbce71">CUI_COLOR_RED</a> <span class="stringliteral">&quot;Connection Failure :(&quot;</span> <a class="code" href="cui_8h.html#ab4bc8ca14939d8f05f2cf7348cc38e81">CUI_COLOR_RESET</a>);</div><div class="line"></div><div class="line"><a class="code" href="cui_8h.html#acb686b1bc2a87a45c2167aef67648bce">CUI_statusLinePrintf</a>(clinetHandle, connStatusLine, <a class="code" href="cui_8h.html#a1797386fafa486f505af19be96449748">CUI_COLOR_GREEN</a> <span class="stringliteral">&quot;Connection Successful! :)&quot;</span> <a class="code" href="cui_8h.html#ab4bc8ca14939d8f05f2cf7348cc38e81">CUI_COLOR_RESET</a>);</div></div><!-- fragment --><p>Lastly in order to create a menu you must first declare your menu layout. A menu can be as simple or as complicated as you want. At the root of every application's menu though are three things. Main Menu Sub Menus Menu Actions</p>
<p>A Main menu as it sounds is the top level menu of your application, this is what you will use to register your entire menu with the CUI. Your main menu can consist of any number of sub menus and menu actions. In turn, those sub menus can consist of any number of sub menus and menu actions as well. This creates a tree topology that will go as far as you desire it.</p>
<p>A menu action can be of two variants. Either a normal action or an interceptable action. A normal action is used best for triggering sections of code via UART input. Say for instance you want to toggle the state of your led or trigger your device to connect to an open network. Then a normal action is exactly what you want. You may have several actions you want to perform that are very similar. A normal action can help with this by providing you with the itemEntry that is calling your action. This can be used in order to have a single action function in your code that can handle multiple different situations based upon the itemEntry that is received. Though if you want to do something more complex like modify your device's channel mask or panId, then an interceptable action is required.</p>
<p>Interceptable actions are created such that instead of triggering a one off section of code, they actually start to intercept the input from the UART. Say for instance you want to modify the channel mask. The user selects the action and then all UART input can be processed by your action code. You can handle this input however you want. Then when the user de-selects the action the UART input will be again handled by the CUI and menu navigation will continue as normal.</p>
<p>As menus can become rather complex this file provides some helpful macros in order to simplify menu definition. Here's an example of declaring a main menu that has a normal action as well as a sub menu. Within the sub menu there is an interceptable action.</p>
<div class="fragment"><div class="line"><a class="code" href="cui_8h.html#a12e13e4f0349a24dec221590319348f6">CUI_SUB_MENU</a>(mySubMenu, <span class="stringliteral">&quot; My Sub Menu &quot;</span>, 1, myMainMenu)</div><div class="line">    <a class="code" href="cui_8h.html#a3ba6deecdbfb08a495002dab6216243d">CUI_MENU_ITEM_INT_ACTION</a>(&quot;&lt; Edit Channel Mask &gt;&quot;, editChannelMaskFn)</div><div class="line"><a class="code" href="cui_8h.html#ab05b7def4c22fe64bcf4200ed9809d1a">CUI_SUB_MENU_END</a></div><div class="line"></div><div class="line"><a class="code" href="cui_8h.html#a70777c2111f47b923313790f2853bd0f">CUI_MAIN_MENU</a>(myMainMenu, &quot; My Main Menu &quot;, 2, processMenuUpdateFn)</div><div class="line">    <a class="code" href="cui_8h.html#a8a3a7bf2d2a146ac384e65b62e0e1a5e">CUI_MENU_ITEM_ACTION</a>(&quot;&lt;  Toggle LED   &gt;&quot;, toggleLedFn)</div><div class="line">    <a class="code" href="cui_8h.html#a50e207ed637bbb704b125a310c2d0bf8">CUI_MENU_ITEM_SUBMENU</a>(&amp;mySubMenu)</div><div class="line"><a class="code" href="cui_8h.html#a0098db8a0b87ef6727a5a38529a59950">CUI_MAIN_MENU_END</a></div></div><!-- fragment --><p>If you are wondering how the macros work you can look at the implementation. Here is the prototype for the CUI_MAIN_MENU and CUI_SUB_MENU macros though.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CUI_MAIN_MENU(_menuSymbol, _pMenuTitle, _numItems, _pMenuUpdateFn)</span></div><div class="line"><span class="preprocessor">#define CUI_SUB_MENU(_menuSymbol, _pMenuTitle, _numItems, _pUpperMenu)</span></div></div><!-- fragment --><p>Now you can see that the sub menu was defined to be the 'mySubMenu' symbol with a menu title of " My Sub Menu ", '1' menu item and it's parent menu is the 'myMainMenu' symbol.</p>
<p>Similarly the main menu was declared to be the 'myMainMenu' symbol with a menu title of " My Main Menu " and 2 menu items. The last parameter is different between them though because of two reasons. Firstly, a main menu has no notion of a parent menu because it is already the top level menu. Secondly, '_pMenuUpdateFn' is a parameter so that the CUI can gain processing context whenever menu processing needs to occur.</p>
<p>Since the CUI does not create an rtos task, it technically does not have it's own processing context. This means that if any CUI menu processing is to take place, such as the user navigating left and right through the different menus, some other rtos task must own the processing time for this to occur. This function simply needs to end up calling CUI_processMenuUpdate. Whether it does that directly or it posts an event to a semaphore so that the task can call <a class="el" href="cui_8h.html#a4e4912c7f7b20fdbec820abca6f079db">CUI_processMenuUpdate()</a> when there is time to do so is up to the developer. <b>To be clear, the '_pMenuUpdateFn' is required for your menu to operate correctly.</b> Without it the menu will fail to register.</p>
<p>Now that you have a main menu defined it still needs to be registered with the CUI.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="cui_8h.html#ad344ae0b9d2fdbb65b272976a33d1082a791b590588509335ba8233d5c1f6da5f">CUI_SUCCESS</a> != <a class="code" href="cui_8h.html#aeef2723418a661618b06eb9f2e213921">CUI_registerMenu</a>(clientHandle, &amp;myMainMenu) {</div><div class="line">    <span class="comment">//handle failure</span></div><div class="line">}</div></div><!-- fragment --><p>As long as no more than MAX_REGISTERED_MENUS have already been registered and your menu was defined correctly the registration will be successful and your main menu will appear over UART.</p>
<p>Notice how there is the capability to register MAX_REGISTERED_MENUS? This is a feature so that when two examples are merged together to create a DMM (Dynamic Multi protocol Manager) example, the menus of each standalone application's menu can exist safely without impacting the other menu. When multiple menus are registered the CUI will introduce a new top most main menu. This main menu will then have a sub menu for each menu that was registered with the CUI. The title of this new multi-menu will default to " TI DMM Application ", but can be changed by providing the address to a different valid c-string to the <a class="el" href="cui_8h.html#a099093fab10c4e87d892d20603c7e409">CUI_updateMultiMenuTitle()</a> function.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> newTitle[] = <span class="stringliteral">&quot; My First Multi Menu Project &quot;</span>;</div><div class="line"><a class="code" href="cui_8h.html#a099093fab10c4e87d892d20603c7e409">CUI_updateMultiMenuTitle</a>(newTitle);</div></div><!-- fragment --> <p>When developing an interceptable action, it is important to know what to expect to receive as input. Your interceptable action should match the CUI_pFnIntercept_t typdef. typedef void (<em>CUI_pFnIntercept_t)(const char _input, char</em> _lines[3], <a class="el" href="struct_c_u_i__cursor_info__t.html">CUI_cursorInfo_t</a> * _curInfo); The first parameter, _input, will be a single byte indicating what type of input the user has pressed. There are a few special input types for your use.</p>
<div class="fragment"><div class="line"><a class="code" href="cui_8h.html#a05ad45b7a726d193ee73fec1b7aacf6c">CUI_ITEM_PREVIEW</a></div><div class="line"><a class="code" href="cui_8h.html#a76fc2da5c8a665f310750cead3b5f862">CUI_ITEM_INTERCEPT_START</a></div><div class="line"><a class="code" href="cui_8h.html#a929ed9c83d6a46ff398daa0a95a1e873">CUI_ITEM_INTERCEPT_STOP</a></div><div class="line"><a class="code" href="cui_8h.html#a39e2a6d54e26087e5b12ffcbd25ee2b9">CUI_ITEM_INTERCEPT_CANCEL</a></div><div class="line"><a class="code" href="cui_8h.html#ad135aaeb07e319b61dab8aff3479cacf">CUI_INPUT_UP</a></div><div class="line"><a class="code" href="cui_8h.html#a60dbc42e3bf1b434ee8c206586dc929b">CUI_INPUT_DOWN</a></div><div class="line"><a class="code" href="cui_8h.html#a29557f58557240e8f494fc32d188c57f">CUI_INPUT_RIGHT</a></div><div class="line"><a class="code" href="cui_8h.html#acb4b0c7925ed15b702e7766b800fb31b">CUI_INPUT_LEFT</a></div><div class="line"><a class="code" href="cui_8h.html#ae7da8ceb506ece8abcd412695e513726">CUI_INPUT_BACK</a></div><div class="line"><a class="code" href="cui_8h.html#afd0e4dba562b79719b18523ccda9c2a1">CUI_INPUT_ESC</a></div></div><!-- fragment --><p>CUI_ITEM_PREVIEW allows your action to display some information on the menu without the user executing your action. This is useful for configurable application variables such as panId. When the user navigates over top of the theoretical "&lt; PAN ID &gt;" screen, it could also display what the current panId is without the need for the user to execute on the action. In the case of a CUI_ITEM_PREVIEW event, your interceptable action will only be able to provide a preview on the first two lines. The third line will be maintained by the cui to be the item's description regardless of what you put in the third line.</p>
<p>CUI_ITEM_INTERCEPT_START is an indication to your action that the user has decided to execute on your action. This is where you could perform some sort of setup steps for the lifetime of the action if necessary.</p>
<p>CUI_ITEM_INTERCEPT_STOP is an indication to your action that the user has completed their time in your action. This is where you could perform some clean up code or finalization code for the end of the action.</p>
<p>CUI_ITEM_INTERCEPT_CANCEL is an indication to your action that the user decided to cancel any current progress within your action. What should/can be done in this case depends on what your action is doing. (i.e) If your action is modifying the Pan ID. CUI_ITEM_INTERCEPT_START could clear the local copy of the pan ID, the user can modify the local copy. Then if you receive a CUI_ITEM_INTERCEPT_CANCEL input, you should clear out the local copy and make sure not to save the changes the user had made.</p>
<p>CUI_ITEM_INTERCEPT_START and CUI_ITEM_INTERCEPT_STOP are useful for configurable variables such as panID because when CUI_ITEM_INTERCEPT_START occurs you can obtain the latest panId from the stack and save a static local copy of it during the lifetime of the action. Then while the user is modifying the panId you are only updating the static local version of the variable. Finally, when the user has completed the modifications to the panId, CUI_ITEM_INTERCEPT_STOP will come through and you can set the new panId as the official panId in the stack. This process allows you to limit the number of stack APIs you need to call.</p>
<p>The UP, DOWN, RIGHT, LEFT inputs come directly from the arrow keys on the user's keyboard. Similarly, the BACK input is from the backspace key on the keyboard. As with all of these inputs. You as the developer of the interceptable action get to choose whether to act on them. They are only there if you want to use them.</p>
<p>Besides those special inputs, any ascii characters the user types will be provided to you via the same _input variable. It is again up to you as the developer to handle this input as you deem necessary. A few more macros are provided to you in order to simplify your logic. You can use these to determine if the input is what you expect or not. They will return TRUE or FALSE depending on the _input provided. <a class="el" href="cui_8h.html#a8fbe1856db024320f5fe80814c25e1eb">CUI_IS_INPUT_NUM(_input)</a> <a class="el" href="cui_8h.html#a0e7db7a9ef18dd29c3e6c05e094066e5">CUI_IS_INPUT_ALPHA(_input)</a> <a class="el" href="cui_8h.html#ab45dea8c73e3ac96d2fbdffff7c2958d">CUI_IS_INPUT_ALPHA_NUM(_input)</a> <a class="el" href="cui_8h.html#af0ca9baf24ab386b8916f39bbd25f3b9">CUI_IS_INPUT_HEX(_input)</a> <a class="el" href="cui_8h.html#a1b07b556b2613b836c43ece5c1badcc5">CUI_IS_INPUT_BINARY(_input)</a></p>
<p>The second param to CUI_pFnIntercept_t are the _pLines[3] that the menu will print out. By putting c strings in these buffers you can share any information with the user while they are either previewing your action or during the interceptable period of your action. When writing data to these buffers take care not to write more than MAX_MENU_LINE_LEN per line. This will cause undefined behavior and possibly cause your application to assert. These buffers are provided to you out of kindness, so treat them with the due respect and the CUI will behave accordingly :)</p>
<p>The last param to CUI_pFnIntercept_t is a pointer to a <a class="el" href="struct_c_u_i__cursor_info__t.html">CUI_cursorInfo_t</a> struct. This is here only if you want to use it. If you do not modify this struct then no behavior will change. Though if you would like a cursor to appear on the menu to indicate to the user where some information is, then you can set the cursor.col and cursor.row values. By doing this the CUI will maintain the cursor on the screen as you have requested. There is no need to turn the cursor off as after receiving an input of CUI_ITEM_INTERCEPT_STOP the CUI will automatically remove the cursor. In the case of CUI_ITEM_PREVIEW, the cursor will be ignored. This means that the cursor can only be on the screen as long as the user is currently using your interceptable item action. </p><hr/>
 </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
