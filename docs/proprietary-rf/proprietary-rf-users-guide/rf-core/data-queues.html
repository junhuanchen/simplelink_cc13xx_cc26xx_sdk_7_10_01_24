<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Working with Data Queues &mdash; 
SimpleLink™ CC13XX/CC26XX SDK
Proprietary RF User&#39;s Guide
 6.10.01 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Routing RF Core Signals to Physical Pins" href="signal-routing.html" />
    <link rel="prev" title="PHY Configuration" href="phy-configuration.html" />
    <script language="JavaScript">
        var tiPageName;
        tiPageName = "sug rf-core data-queues";

        if (location.protocol == "file:"){
            var ci_analytics_poc_load = true;
        }
    </script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../proprietary-rf-guide/index-cc13xx_cc26xx.html" class="icon icon-home"> 
SimpleLink™ CC13XX/CC26XX SDK
Proprietary RF User's Guide

          </a>
              <div class="version">
                6.10.01
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quickstart-guide/proprietary-rf-quick-start.html">Proprietary RF Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc13xx_cc26xx/index-platform.html">SimpleLink Wireless MCU CC13xx and CC26xx Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/examples-cc13xx_cc26xx.html">Examples User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/custom-hardware.html">Custom Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/tirtos-index-cc13xx_cc26xx.html">TI-RTOS7 (RTOS Kernel) Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/nortos-index.html">noRTOS Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../proprietary-rf-guide/rf-core-index.html">RF Core</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="commands.html">Command Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="radio-operation-commands.html">Radio operation commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="radio-operation-commands.html#start-and-end-triggers">Start and end triggers</a></li>
<li class="toctree-l2"><a class="reference internal" href="radio-operation-commands.html#conditional-execution-and-chaining">Conditional execution and chaining</a></li>
<li class="toctree-l2"><a class="reference internal" href="radio-operation-commands.html#callback-events">Callback events</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy-configuration.html">PHY Configuration</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Working with Data Queues</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#queue-entry-types">Queue Entry Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#single-packet-entries-rfc-dataentrygeneral-t">Single Packet Entries <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryGeneral_t</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointer-entries-rfc-dataentrypointer-t">Pointer Entries <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryPointer_t</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-entries-rfc-dataentrypartial">Partial Entries <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryPartial</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-queue">Creating a Queue</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-data-from-a-queue">Reading Data from a Queue</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="signal-routing.html">Routing RF Core Signals to Physical Pins</a></li>
<li class="toctree-l2"><a class="reference internal" href="signal-routing.html#routing-internal-signals-to-the-doorbell-register">Routing Internal Signals to the Doorbell Register</a></li>
<li class="toctree-l2"><a class="reference internal" href="signal-routing.html#routing-doorbell-signals-to-gpio-pins">Routing Doorbell Signals to GPIO Pins</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/physical-rf-layer-cc13xx_cc26xx.html">Physical Layer (PHY)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/debugging-index.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/memory-index.html">Memory overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/sysconfig-index.html">System Configuration Tool (SysConfig)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../energy-trace/energy-trace.html">EnergyTrace User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/migration-cc13xx_cc26xx.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/reference-cc13xx_cc26xx.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/glossary-cc13xx_cc26xx.html">Terms and acronyms</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../proprietary-rf-guide/index-cc13xx_cc26xx.html">
SimpleLink™ CC13XX/CC26XX SDK
Proprietary RF User's Guide
</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../proprietary-rf-guide/index-cc13xx_cc26xx.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../proprietary-rf-guide/rf-core-index.html">RF Core</a> &raquo;</li>
      <li>Working with Data Queues</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="working-with-data-queues">
<h1>Working with Data Queues<a class="headerlink" href="#working-with-data-queues" title="Permalink to this headline">¶</a></h1>
<p>Data queues are used for transferring packets from the RF core to the main CPU
and vice versa. They are implemented as linked lists of queue entries. This
document describes the available queue entry types and provides code snippets
to create queues and to interact with them.</p>
<div class="section" id="queue-entry-types">
<span id="rfc-dataentry-t"></span><h2>Queue Entry Types<a class="headerlink" href="#queue-entry-types" title="Permalink to this headline">¶</a></h2>
<p>The RF core supports 3 different kind of queue entries:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 21%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Single packet entry</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rfc_dataEntryGeneral_t</span></code></p></td>
<td><p>One packet per entry; data after the header.</p></td>
</tr>
<tr class="row-odd"><td><p>Pointer entry</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rfc_dataEntryPointer_t</span></code></p></td>
<td><p>One entry per packet; data at another memory location.</p></td>
</tr>
<tr class="row-even"><td><p>Partial entry</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rfc_dataEntryPartial_t</span></code></p></td>
<td><p>Stores packets with unknown or unlimited length; data after the header.</p></td>
</tr>
</tbody>
</table>
<p>All queue entries start with a common header part, containing a pointer to the
next entry, a configuration field and the length of the entry in bytes.</p>
<img alt="../_images/aafig-b36588106f9ae56487538aea25f15dc8aba90e2d.png" class="align-center" src="../_images/aafig-b36588106f9ae56487538aea25f15dc8aba90e2d.png" />
<p>It is very important that each queue entry is aligned to 4-byte boundaries.
Otherwise the RF core will fail to access the queue entry.</p>
<span id="tab-rfc-dataentry"></span><table class="docutils align-default" id="id3">
<caption><span class="caption-number">Table 5. </span><span class="caption-text">Description of <code class="docutils literal notranslate"><span class="pre">rfc_dataEntry_t</span></code> header fields.</span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 15%" />
<col style="width: 18%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="2"><p>pNextEntry</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8_t*</span></code></p></td>
<td><p>Points to the next queue entry.</p></td>
</tr>
<tr class="row-odd"><td colspan="2"><p>status</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span></code></p></td>
<td><p>Current status of the entry.</p>
<ol class="arabic simple" start="0">
<li><p><code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_PENDING</span></code>:  The entry is not yet in use by the RF
core. This status is written by the system CPU before submitting
the entry.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_ACTIVE</span></code>: The entry is currently opened for writing
(RX) or reading (TX) by the RF core.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_BUSY</span></code>: An ongoing radio operation is writing or
reading an unfinished packet. Modifications are forbidden.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_FINISHED</span></code>: The RF core has finished writing (RX)
or reading (TX) data. The system CPU may now access the packet.</p></li>
</ol>
<ol class="arabic simple" start="3">
<li><p><code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_UNFINISHED</span></code>: For partial RX entries only. The RF
has run out of entries and could not complete the packet.</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td rowspan="3"><p>config</p></td>
<td><p>type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">:</span> <span class="pre">2</span></code></p></td>
<td><p>Specifies the entry type.</p>
<ol class="arabic simple" start="0">
<li><p><code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_TYPE_GEN</span></code>: single packet entry</p></li>
<li><p>Reserved</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_TYPE_PTR</span></code> pointer entry</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_TYPE_PARTIAL</span></code>: partial read RX</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p id="lensz">lenSz</p>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">:</span> <span class="pre">2</span></code></p></td>
<td><p>Specifies the size of the packet length field in the data section.
This is used for variable packet length.</p>
<ol class="arabic simple" start="0">
<li><p>No separate length info. Packet has a known size.</p></li>
<li><p>One byte length field</p></li>
<li><p>Two byte length field</p></li>
<li><p>Reserved</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>irqIntv</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">:</span> <span class="pre">4</span></code></p></td>
<td><ul class="simple">
<li><p>Partial entries: The number of bytes between
<code class="docutils literal notranslate"><span class="pre">IRQ_RX_N_DATA_WRITTEN</span></code> interrupts
(<a class="reference external" href="../../../rflib/html/group__rf__driver__cc13x2__cc26x2.html#gaa9c1eb19ce791f4f9c4b917e10fbabdd">RF_EventNDataWritten</a> when using the RF driver).
0 means: 16 bytes.</p></li>
<li><p>ALl other entries: unused</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td colspan="2"><p>length</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint16_t</span></code></p></td>
<td><ul class="simple">
<li><p>Single packet entries: Number of bytes in the data section.</p></li>
<li><p>Multi packet entries: Number of additional header bytes + buffer
bytes in data section (not the packet size).</p></li>
<li><p>Pointer entries: Number of bytes in the data buffer pointed to.</p></li>
<li><p>Partial entries: Number of additional header bytes + buffer
bytes in data section (not the packet size).</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The current state of buffer entries during packet reception is kept in the
<code class="docutils literal notranslate"><span class="pre">status</span></code> field. Figure <a class="reference internal" href="#fig-entry-status"><span class="std std-numref">Figure 25.</span></a> shows a typical scenario
where the RF core writes to a queue entry and the application reads the packet
payload before it makes the entry writable again.</p>
<div class="figure align-center" id="id4">
<span id="fig-entry-status"></span><p class="plantuml">
<img src="../_images/plantuml-dd245680e3009e45cf9793adb4dea0f7fb8d2012.png" alt=" &#64;startuml
 scale 0.8

 state pending as &quot;DATA_ENTRY_PENDING&quot;
 state busy as &quot;DATA_ENTRY_BUSY&quot; : writePayload();
 state finished as &quot;DATA_ENTRY_FINISHED\n(DATA_ENTRY_UNFINISHED)&quot;

 [*] --&gt; pending : initialized
 pending -&gt; busy : syncword found
 busy --&gt; finished : packet done OR entry full /\nIRQ_RX_ENTRY_DONE
 finished --&gt; pending : application has\nfinished reading

 &#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 25. </span><span class="caption-text">The <code class="docutils literal notranslate"><span class="pre">status</span></code> field of queue entries during packet reception.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="single-packet-entries-rfc-dataentrygeneral-t">
<span id="sec-single-packet-entry"></span><h2>Single Packet Entries <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryGeneral_t</span></code><a class="headerlink" href="#single-packet-entries-rfc-dataentrygeneral-t" title="Permalink to this headline">¶</a></h2>
<p>Single packet entries contain one packet per entry and store the data directly
behind the header so that the whole queue can be allocated in a linear memory
section. They are the simplest entry type and sufficient for many
applications. The data section may contain the packet length, configured by
<code class="docutils literal notranslate"><span class="pre">config.lenSz</span></code>, the payload and optionally appended meta data, like the RX
timestamp or the CRC.</p>
<p>The length indicator at the begin of the data section may be omitted when the
packet size can be determined otherwise. For packets with variable length it
is necessary.</p>
<img alt="../_images/aafig-4b46122ac1b89736ff854a9f502906187efb0c70.png" class="align-center" src="../_images/aafig-4b46122ac1b89736ff854a9f502906187efb0c70.png" />
<span id="tab-rfc-dataentrygeneral-t"></span><table class="docutils align-default" id="id5">
<caption><span class="caption-number">Table 6. </span><span class="caption-text">Description of additional <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryGeneral_t</span></code> fields.</span><a class="headerlink" href="#id5" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 18%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>…</p></td>
<td><p><a class="reference internal" href="#rfc-dataentry-t"><code class="docutils literal notranslate"><span class="pre">rfc_dataEntry_t</span></code></a></p></td>
<td><p>Generic header described in <a class="reference internal" href="#tab-rfc-dataentry"><span class="std std-numref">Table 5.</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>data</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span></code></p></td>
<td><p>Dummy field representing the first byte in the data section.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pointer-entries-rfc-dataentrypointer-t">
<h2>Pointer Entries <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryPointer_t</span></code><a class="headerlink" href="#pointer-entries-rfc-dataentrypointer-t" title="Permalink to this headline">¶</a></h2>
<p>A pointer entry is similar to a <a class="reference internal" href="#sec-single-packet-entry"><span class="std std-ref">single packet entry</span></a>, but doesn’t contain the data after the header.
Instead, it holds a pointer to another memory location which contains the
data. This queue type is useful when you want to:</p>
<ul class="simple">
<li><p>keep the data storage separate from the queue entries share the same buffers</p></li>
<li><p>between different queues without recreating the queue structure move buffers</p></li>
<li><p>to another queue (for instance a custom queue implementation) without</p></li>
<li><p>copying the content</p></li>
</ul>
<img alt="../_images/aafig-c91c29277d64c9d0cf9c182c03d9785755f87639.png" class="align-center" src="../_images/aafig-c91c29277d64c9d0cf9c182c03d9785755f87639.png" />
<span id="tab-rfc-dataentrypointer-t"></span><table class="docutils align-default" id="id6">
<caption><span class="caption-number">Table 7. </span><span class="caption-text">Description of additional <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryPointer_t</span></code> fields.</span><a class="headerlink" href="#id6" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 18%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>…</p></td>
<td><p><a class="reference internal" href="#rfc-dataentry-t"><code class="docutils literal notranslate"><span class="pre">rfc_dataEntry_t</span></code></a></p></td>
<td><p>Generic header described in <a class="reference internal" href="#tab-rfc-dataentry"><span class="std std-numref">Table 5.</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>pData</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8_t*</span></code></p></td>
<td><p>Pointer to the physical data storage location</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="partial-entries-rfc-dataentrypartial">
<h2>Partial Entries <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryPartial</span></code><a class="headerlink" href="#partial-entries-rfc-dataentrypartial" title="Permalink to this headline">¶</a></h2>
<p>The proprietary PHY supports an entry type where the data can be accessed
before the entire packet is received over the air. It can be used for the
following purposes:</p>
<ul class="simple">
<li><p>When data must be read before the entire packet is received. For instance,
when the packet contains a length field that is incompatible to the
<a class="reference internal" href="../proprietary-rf/packet-format.html#tab-packet-format-comparison"><span class="std std-ref">supported packet formats</span></a>.</p></li>
<li><p>When the length of the packet is not known at the beginning of the packet.</p></li>
<li><p>When the length of the packet is too long for a single packet entry or
when using unlimited packet length.</p></li>
</ul>
<p>Partial entries may contain several packets. In this case, each packet in the
data section starts with a length field of size <a class="reference internal" href="#lensz"><span class="std std-ref">lenSz</span></a> which can
be used to calculate the start of the next packet within the same entry. The
field <code class="docutils literal notranslate"><span class="pre">nextIndex</span></code> contains the total number of written bytes in the entry.</p>
<span id="tab-rfc-dataentrypartial-t"></span><table class="docutils align-default" id="id7">
<caption><span class="caption-number">Table 8. </span><span class="caption-text">Description of additional <code class="docutils literal notranslate"><span class="pre">rfc_dataEntryPartial_t</span></code> fields.</span><a class="headerlink" href="#id7" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 15%" />
<col style="width: 18%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="2"><p>…</p></td>
<td><p><a class="reference internal" href="#rfc-dataentry-t"><code class="docutils literal notranslate"><span class="pre">rfc_dataEntry_t</span></code></a></p></td>
<td><p>Generic header described in <a class="reference internal" href="#tab-rfc-dataentry"><span class="std std-numref">Table 5.</span></a></p></td>
</tr>
<tr class="row-odd"><td rowspan="4"><p>pktStatus</p></td>
<td><p>numElements</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">:</span> <span class="pre">13</span></code></p></td>
<td><p>Number of packets committed to this entry.</p></td>
</tr>
<tr class="row-even"><td><p>bEntryOpen</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">:</span> <span class="pre">1</span></code></p></td>
<td><ol class="arabic simple" start="0">
<li><p>RF core access is finished.</p></li>
<li><p>The Entry contains an element that is still accessed by the RF
core.</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>bFirstCont</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">:</span> <span class="pre">1</span></code></p></td>
<td><ol class="arabic simple" start="0">
<li><p>The first element in the entry starts a new packet.</p></li>
<li><p>The first element in the entry continues a packet from the
previous entry.</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>bLastCont</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">:</span> <span class="pre">1</span></code></p></td>
<td><ol class="arabic simple" start="0">
<li><p>The last element in the entry marks the end of a packet.</p></li>
<li><p>The last element in the entry will be continued in the next
entry.</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td colspan="2"><p>nextIndex</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint16_t</span></code></p></td>
<td><p>The total number of committed bytes in the data section. This field
is constantly being updated by the RF core while receiving.</p></td>
</tr>
<tr class="row-even"><td colspan="2"><p>data</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span></code></p></td>
<td><p>Dummy field representing the first byte in the data section.</p></td>
</tr>
</tbody>
</table>
<p>The entry is updated as follows:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">nextIndex</span></code> field is updated whenever a new bytes is written to the
data section.</p></li>
<li><p>While a packet is being received, <code class="docutils literal notranslate"><span class="pre">pktStatus.bEntryOpen</span></code> is set to 1 by
the RF core.</p></li>
</ul>
<p>When an entry element is finished, either because the packet ended or because
the element reached the end of the entry, <code class="docutils literal notranslate"><span class="pre">pktStatus.bEntryOpen</span></code> is set to 0
by the RF core and <code class="docutils literal notranslate"><span class="pre">pktStatus.numElements</span></code> is incremented. If the packet
continues in the next entry, <code class="docutils literal notranslate"><span class="pre">pktStatus.bLastCont</span></code> is set to 1 by the radio
CPU. In this case, the <code class="docutils literal notranslate"><span class="pre">pktStatus.bFirstCont</span></code> bit of the next entry is also
set to 1 by the RF core. If no next entry is available, the status is set to
<code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_UNFINISHED</span></code>, otherwise it is set to <code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_FINISHED</span></code>.</p>
<p>Each entry element starts with a length info field (depending on
<code class="docutils literal notranslate"><span class="pre">config.lenSz</span></code>). If an entry contains a single packet, then the length info
is equal to the packet length. If the packet doesn’t fit into the current
entry, it is continued in the next entry. In this case, the length info
contains only the number of bytes within the current entry.</p>
<p>For a partial read RX entry, the RF core generates an Rx_Data_Written
interrupt to the system CPU whenever one or more bytes are written to the
entry. In addition, it generates an <code class="docutils literal notranslate"><span class="pre">IRQ_RX_N_DATA_WRITTEN</span></code> interrupt when
<code class="docutils literal notranslate"><span class="pre">config.irqIntv</span></code> bytes have been written since the last interrupt or since
the start of the entry element. The RF driver propagates this interrupt as
<a class="reference external" href="../../../rflib/html/group__rf__driver__cc13x2__cc26x2.html#gaa9c1eb19ce791f4f9c4b917e10fbabdd">RF_EventNDataWritten</a>.</p>
</div>
<div class="section" id="creating-a-queue">
<h2>Creating a Queue<a class="headerlink" href="#creating-a-queue" title="Permalink to this headline">¶</a></h2>
<p>In order to create a data queue, the following steps are necessary:</p>
<ol class="arabic simple">
<li><p>Allocate sufficient memory for all queue entries.</p></li>
<li><p>Initialize each queue entry header.</p></li>
<li><p>Create a queue object</p></li>
</ol>
<p>The object of the type <code class="docutils literal notranslate"><span class="pre">dataQueue_t</span></code> is defined in the header file
<code class="docutils literal notranslate"><span class="pre">&lt;ti/devices/${DEVICE_FAMILY}/driverlib/rf_mailbox.h&gt;</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// The queue structure</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pCurrEntry</span><span class="p">;</span><span class="w">   </span><span class="c1">// Points to the first entry, NULL for an empty queue</span>
<span class="w">   </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pLastEntry</span><span class="p">;</span><span class="w">   </span><span class="c1">// Pointer to the last entry, NULL for a circular queue</span>
<span class="p">}</span><span class="w"> </span><span class="n">dataQueue_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>It holds a pointer to the first and to the last entry and may either have a
fixed or unlimited size. In the former case <code class="docutils literal notranslate"><span class="pre">pLastEntry</span></code> points to the last
entry. In a circular queue, <code class="docutils literal notranslate"><span class="pre">pLastEntry</span></code> is a null pointer.</p>
<p>The following example explains how to create a circular queue of 4 single-
packet entries that can store up to 32 bytes.</p>
<ol class="arabic">
<li><p>As a first step, we need to allocate sufficient memory for
all queue entries:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ti/devices/DeviceFamily.h&gt;</span><span class="cp"></span>
<span class="cp">#include DeviceFamily_constructPath(driverlib/rfc_data_entry.h)</span>
<span class="cp">#include DeviceFamily_constructPath(driverlib/rfc_mailbox.h)</span>

<span class="cp">#define BUFFER_ENTRIES      4</span>

<span class="c1">// Must be word-aligned</span>
<span class="cp">#define DATA_SECTION_SIZE   32</span>

<span class="c1">// -1: Do not count the dummy data byte in the entry</span>
<span class="cp">#define ENTRY_HEADER_SIZE   (sizeof(rfc_dataEntryGeneral_t) - 1)</span>

<span class="cp">#define BUFFER_SIZE_BYTES   (BUFFER_ENTRIES * (ENTRY_HEADER_SIZE + DATA_SECTION_SIZE))</span>

<span class="c1">// Align the buffer to word boundaries. Example for GCC.</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE_BYTES</span><span class="p">]</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">aligned</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div><p>All queue entries need to be word-aligned. When the expected payload size is
not a multiple of 4, choose the next greater word-aligned value as
<code class="docutils literal notranslate"><span class="pre">DATA_SECTION_SIZE</span></code>.</p>
</div></blockquote>
<ol class="arabic" start="2">
<li><p>Prepare the entry headers and close the ring:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rfc_dataEntryGeneral_t</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BUFFER_ENTRIES</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">item</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DATA_ENTRY_TYPE_GEN</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">item</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DATA_SECTION_SIZE</span><span class="p">;</span><span class="w"> </span><span class="c1">// Note: When creating partial items, add 4</span>
<span class="w">                                      </span><span class="c1">// bytes for the additional header fields.</span>

<span class="w">    </span><span class="n">item</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DATA_ENTRY_PENDING</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">item</span><span class="o">-&gt;</span><span class="n">pNextEntry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ENTRY_HEADER_SIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">DATA_SECTION_SIZE</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Close the circle for the last item</span>
<span class="w">        </span><span class="n">item</span><span class="o">-&gt;</span><span class="n">pNextEntry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="p">)</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">pNextEntry</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Create a circular queue object:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dataQueue_t</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">pCurrEntry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">pLastEntry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="reading-data-from-a-queue">
<h2>Reading Data from a Queue<a class="headerlink" href="#reading-data-from-a-queue" title="Permalink to this headline">¶</a></h2>
<p>Whenever the RF core completes a packet, it raises the interrupt
<code class="docutils literal notranslate"><span class="pre">IRQ_RX_ENTRY_DONE</span></code> which maps to the event <a class="reference external" href="../../../rflib/html/group__rf__driver__cc13x2__cc26x2.html#ga7051110a4a1fdd459866195be774a2b0">RF_EventRxEntryDone</a>
in the RF driver. When handling the interrupt and executing the callback, the
packet data is read from entry and the <code class="docutils literal notranslate"><span class="pre">status</span></code> field must be set back to
<code class="docutils literal notranslate"><span class="pre">DATA_ENTRY_PENDING</span></code> before the RF core can re-used it.</p>
<p>Keep the current entry in a variable:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Initialize to the first entry</span>
<span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="w"> </span><span class="n">rxEntry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="p">)</span><span class="n">queue</span><span class="p">.</span><span class="n">pCurrEntry</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Read a packet from a single packet entry in an RX queue. This can either be
done within a RF driver callback or in the RX task:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// The current entry to be read.</span>
<span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="w"> </span><span class="n">rxEntry</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Packet starts with 1 byte length information (lenSz = 1)</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">packetLength</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">rxEntry</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Payload follows.</span>
<span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">packetDataPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">rxEntry</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">packetLength</span><span class="p">));</span><span class="w"></span>

<span class="c1">// Correct: Use memcpy to read the payload from the buffer.</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">myValue</span><span class="p">;</span><span class="w"></span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myValue</span><span class="p">,</span><span class="w"> </span><span class="n">packetDataPointer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">myValue</span><span class="p">));</span><span class="w"></span>

<span class="c1">// Dangerous: De-reference potentially misaligned pointers in the packet payload:</span>
<span class="c1">// myValue = *((uint32_t*)packetDataPointer);</span>
</pre></div>
</div>
<p>Set <code class="docutils literal notranslate"><span class="pre">rxEntry</span></code> to the next queue item for the next iteration:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Mark the entry as being read</span>
<span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="p">)</span><span class="n">rxEntry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DATA_ENTRY_PENDING</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Get the next entry</span>
<span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="w"> </span><span class="n">rxEntry</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">((</span><span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="p">)</span><span class="n">rxEntry</span><span class="o">-&gt;</span><span class="n">pNextEntry</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When interacting with queue entries while the RF core is accessing the
entry as well, you must make sure that the value being read by the system
CPU is up-to-date. For instance when writing loops, the compiler might
cache values in a register, especially when turning on optimization:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Wrong code: Might cause a deadlock</span>
<span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="w"> </span><span class="n">entry</span><span class="p">;</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DATA_ENTRY_FINISHED</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>Force the compiler to reload fields with concurrent access from memory on
every access:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Correct: status is being reloaded from memory on every access</span>
<span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="w"> </span><span class="n">entry</span><span class="p">;</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(((</span><span class="k">volatile</span><span class="w"> </span><span class="n">rfc_dataEntryGeneral_t</span><span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DATA_ENTRY_FINISHED</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="phy-configuration.html" class="btn btn-neutral float-left" title="PHY Configuration" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="signal-routing.html" class="btn btn-neutral float-right" title="Routing RF Core Signals to Physical Pins" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2023, Texas Instruments.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>