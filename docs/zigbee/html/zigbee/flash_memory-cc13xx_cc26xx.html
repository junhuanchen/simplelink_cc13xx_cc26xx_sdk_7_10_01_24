<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flash &mdash; 
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User&#39;s Guide
 7.10.01 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory Map" href="memory_map.html" />
    <link rel="prev" title="Z-Stack Overview" href="z-stack-overview.html" />
    <script language="JavaScript">
        var tiPageName;
        tiPageName = "sug zigbee flash_memory-cc13xx_cc26xx";

        if (location.protocol == "file:"){
            var ci_analytics_poc_load = true;
        }
    </script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../zigbee-guide/index-cc13xx_cc26xx.html" class="icon icon-home"> 
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User's Guide

          </a>
              <div class="version">
                7.10.01
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quickstart-guide/quickstart-intro-cc13xx_cc26xx.html">Introduction to the SimpleLink CC13xx/CC26xx SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc13xx_cc26xx/index-platform.html">SimpleLink Wireless MCU CC13xx and CC26xx Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/tirtos-index.html">TI-RTOS7 (RTOS Kernel) Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">SimpleLink CC13xx/CC26xx SDK Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="developing_zigbee_applications.html">Developing Zigbee Applications</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="application_overview.html">Application Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpd_application_overview.html">Green Power Application Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="z-stack-overview.html">Z-Stack Overview</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Flash</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#non-volatile-storage-architecture">Non-Volatile Storage Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#non-volatile-interface-nvintf">Non Volatile Interface (NVINTF)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-volatile-on-chip-multi-page-nvocmp-driver">Non Volatile On-Chip Multi Page (NVOCMP) Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-volatile-storage-nvs-driver">Non Volatile Storage (NVS) Driver</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#non-volatile-memory-items">Non-Volatile Memory Items</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#global-configuration-non-volatile-memory">Global Configuration Non-Volatile Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#network-layer-non-volatile-memory">Network Layer Non-Volatile Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-non-volatile-memory">Application Non-Volatile Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-volatile-memory-low-voltage-detection">Non-Volatile Memory Low Voltage Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modifying-non-volatile-memory-allocation">Modifying Non-Volatile Memory Allocation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="memory_map.html">Memory Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_applications.html">Running the Example Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="network_configuration.html">Network Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_configuration.html">Power Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="znp_interface.html">Zigbee Network Processor (ZNP) Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="mt_interface.html">MT Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="product_certification.html">Product Certification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cc13xx_cc26xx/fcc-certification.html">FCC Certification Considerations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cc13xx_cc26xx/custom-hardware-cc13xx_cc26xx.html">Custom Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/zigbee-ota-index.html">Zigbee Over-The-Air Firmware Upgrade</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coexistence/coexistence-ieee.html">Wi-Fi Coexistence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/debugging-index.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="packet_sniffer.html">Packet Sniffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/sysconfig-index.html">System Configuration (SysConfig)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../energy-trace/energy-trace.html">EnergyTrace User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/migration_guide.html">Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/references-cc13xx_cc26xx.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/glossary.html">Terms and Acronyms</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../zigbee-guide/index-cc13xx_cc26xx.html">
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User's Guide
</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../zigbee-guide/index-cc13xx_cc26xx.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="developing_zigbee_applications.html">Developing Zigbee Applications</a> &raquo;</li>
      <li>Flash</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="flash">
<span id="id5"></span><h1>Flash<a class="headerlink" href="#flash" title="Permalink to this headline">¶</a></h1>
<p>The flash is split into erasable pages of 8 kB. The various
sections of flash and their associate linker files are as follows.</p>
<ul class="simple">
<li><p><strong>Flash Reset Vector Table</strong>: This table holds the first 16 reset vectors
that are critical for booting up the device. These vectors are set at build
time and cannot be dynamically changed. See <span class="xref std std-ref">sec-flash-vector-table</span>
for more information.</p></li>
<li><p><strong>Non-volatile (NV) Area</strong>: used for nonvolatile memory storage by the
Zigbee network information and also available for use by the application. See
<a class="reference internal" href="#z-stack-overview-nv-memory-items"><span class="std std-ref">Non-Volatile Memory Items</span></a> for configuring NV.</p></li>
<li><p><strong>Application and Stack Image Code Space</strong>: A single region that contains
both application and stack code in flash.
This image is configured in the linker configuration file of the application:
&lt;device name&gt;_app_and_stack.icf (IAR) and &lt;device name&gt;_app.cmd (CCS).</p></li>
</ul>
<div class="section" id="non-volatile-storage-architecture">
<span id="using-nv"></span><h2>Non-Volatile Storage Architecture<a class="headerlink" href="#non-volatile-storage-architecture" title="Permalink to this headline">¶</a></h2>
<p>This section will describe the non volatile storage system that is implemented
and used on the CC13xx or CC26xx. This system provides access to non volatile storage
that can be safely shared between the user application and the protocol stack.</p>
<p>The system has the following properties and offers the following features:</p>
<blockquote>
<div><ul class="simple">
<li><p>Thread safe access to non volatile memory</p></li>
<li><p>ID based system that decouples a storage item from its address in memory</p></li>
<li><p>Space efficient storage with automatic compaction</p></li>
<li><p>Power loss tolerant data preservation</p></li>
</ul>
</div></blockquote>
<p>The implementation of this software system relies on several layers which are
illustrated below.</p>
<img alt="../_images/ditaa-d54ad0c27042b56ccadd5e15b9895c3895a91080.png" src="../_images/ditaa-d54ad0c27042b56ccadd5e15b9895c3895a91080.png" />
<div class="section" id="non-volatile-interface-nvintf">
<h3>Non Volatile Interface (NVINTF)<a class="headerlink" href="#non-volatile-interface-nvintf" title="Permalink to this headline">¶</a></h3>
<p>The NVINTF is an abstraction layer that defines a common set of APIs for
interacting with non volatile memory using a ID system. This common set of APIs
allow for new methods of NV storage to be implemented without changing the
API calls in the stack and application. The ID system is most efficient because
it decouples the data stored from its address in flash. This is necessary
because flash banks must have the entire sector erased before writing again.
(with the exception of clearing a bit). Using the ID system, when an NV item
needs to be updated, it can simply be invalidated and stored again at a
different address. Once the NV system becomes full of unused items, a compaction
will occur. A compaction is the removal of unused items.</p>
<p>The NVINTF is function pointer based, each underlying transport must plug
a function table and provide an implementation for the common set of APIs.</p>
<p>This interface is defined in <code class="docutils literal notranslate"><span class="pre">nvintf.h</span></code>. The NVINTF is not intended to be
changed by the customer, but instead used as is.</p>
</div>
<div class="section" id="non-volatile-on-chip-multi-page-nvocmp-driver">
<h3>Non Volatile On-Chip Multi Page (NVOCMP) Driver<a class="headerlink" href="#non-volatile-on-chip-multi-page-nvocmp-driver" title="Permalink to this headline">¶</a></h3>
<p>The NVOCMP driver implements a non-volatile memory system that utilizes
multiple consecutive pages of on-chip Flash memory. After initialization, all
pages except one are “active” and the remaining one page is available for
“compaction” when the active pages do not have enough empty space for data
write operation. Compaction can occur “just in time” during a data write
operation or “on demand” by application request. The compaction process
is designed to survive a power cycle before it completes. It will resume
where it was interrupted and complete the process. The number of NV pages
can be set by the <cite>NVOCMP_NVPAGES</cite> preprocessor define. If this is not set,
it will default to 2.</p>
<p>Each flash page contains a “page header” which indicates its current state. The
page header is located at the first byte of the flash page. Following the
page header is the “compact header”, which indicates the flash page’s
compaction state. The remainder of the flash page contains NV data items which
are packed together following the page header and compact header.</p>
<p>Each NV data item is unique and has two parts:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>A data block which is stored first (lower memory address)</p></li>
<li><p>An item header following the data block (higher memory address)</p></li>
</ol>
</div></blockquote>
<p>The item header (defined by <code class="docutils literal notranslate"><span class="pre">NVOCMP_itemHdr_t</span></code>) contains status information
required to traverse packed data items in the flash page. An example of the NV
item memory layout storing a single byte of data is illustrated below.</p>
<div class="figure align-center" id="fig-nvintf-header">
<img alt="../_images/nvintf_header.png" src="../_images/nvintf_header.png" />
</div>
<p><strong>NV Item Header:</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 21%" />
<col style="width: 63%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Field</strong></p></td>
<td><p><strong>Size (bits)</strong></p></td>
<td><p><strong>Purpose</strong></p></td>
</tr>
<tr class="row-even"><td><p>System ID</p></td>
<td><p>6</p></td>
<td><p>Indicates the system component identifier</p></td>
</tr>
<tr class="row-odd"><td><p>Item ID</p></td>
<td><p>10</p></td>
<td><p>Indicates the item data identifier</p></td>
</tr>
<tr class="row-even"><td><p>Sub ID</p></td>
<td><p>10</p></td>
<td><p>Identifier of the sub-data related to the NV item</p></td>
</tr>
<tr class="row-odd"><td><p>Length</p></td>
<td><p>12</p></td>
<td><p>Length of the data block</p></td>
</tr>
<tr class="row-even"><td><p>CRC</p></td>
<td><p>8</p></td>
<td><p>CRC value of NV item</p></td>
</tr>
<tr class="row-odd"><td><p>Status Bits</p></td>
<td><p>2</p></td>
<td><p>Indicates CRC integrity and if item is active</p></td>
</tr>
<tr class="row-even"><td><p>Signature</p></td>
<td><p>8</p></td>
<td><p>Used to detect presence of a NV item in flash</p></td>
</tr>
</tbody>
</table>
<p>For each NV item that is added or updated in NV storage, the item is written to
the next lowest available memory address in the active flash page. If the NV
item is being updated, the old NV item will be marked as inactive. Inactive
items are removed from memory when a memory compaction takes place.</p>
<p>For more information, see the API documentation in <cite>nvocmp.h</cite> and the design
description in <cite>nvocmp.c</cite>.</p>
</div>
<div class="section" id="non-volatile-storage-nvs-driver">
<h3>Non Volatile Storage (NVS) Driver<a class="headerlink" href="#non-volatile-storage-nvs-driver" title="Permalink to this headline">¶</a></h3>
<p>The NVS driver provides reentrant functions for writing to and reading from
flash. It also provides a common interface to both internal and external flash.
More information can be found in the TI Drivers documentation. The stack will
use internal NV, currently this is all that is supported.</p>
</div>
</div>
<div class="section" id="non-volatile-memory-items">
<span id="z-stack-overview-nv-memory-items"></span><h2>Non-Volatile Memory Items<a class="headerlink" href="#non-volatile-memory-items" title="Permalink to this headline">¶</a></h2>
<div class="section" id="global-configuration-non-volatile-memory">
<h3>Global Configuration Non-Volatile Memory<a class="headerlink" href="#global-configuration-non-volatile-memory" title="Permalink to this headline">¶</a></h3>
<p>Global device configuration items are stored in <code class="code docutils literal notranslate"><span class="pre">zglobals.c</span></code>. This includes
items such as PAN ID, key information, network settings, etc.
The default values for most of these items are specified in SysConfig.
These items are loaded to RAM at startup for quick access during
Z-Stack operation. To initialize the non-volatile memory area to store
these items, the compile flag <code class="code docutils literal notranslate"><span class="pre">NV_INIT</span></code> must be enabled in your project
(it is enabled by default in the sample applications).</p>
</div>
<div class="section" id="network-layer-non-volatile-memory">
<h3>Network Layer Non-Volatile Memory<a class="headerlink" href="#network-layer-non-volatile-memory" title="Permalink to this headline">¶</a></h3>
<p>A Zigbee device has lots of state information that needs to be stored in
non-volatile memory so that it can be recovered in case of an accidental
reset or power loss. Otherwise, it will not be able to rejoin the
network or function effectively.</p>
<p>This feature is enabled by default by the inclusion of the <code class="code docutils literal notranslate"><span class="pre">NV_RESTORE</span></code>
compile option. Note that this feature must be always enabled in a real
Zigbee network.
The ability to disable it is only intended for use in the development stage.</p>
<p>The ZDO layer is responsible for the saving and restoring of the Network
Layer’s vital information, but it is the BDB layer which will define
when to retrieve this information or when to clear and start as a “factory
new” device. This includes the Network Information Base (NIB -
Attributes required to manage the network layer of the device); the list
of child and parent devices; and the table containing the application
bindings. This is also used for security to store frame counters and
keys.</p>
<p>Upon reset, if the device is not meant to return to its factory new state,
then it will use this information to restore itself in the network.</p>
<p>Upon initializing, the BDB layer will check the attribute
if this device was commissioned to a network (<code class="code docutils literal notranslate"><span class="pre">bdbNodeIsOnANetwork</span></code>).
If it was commissioned to a network and it was also instructed
to resume operations in the same network, then the BDB layer will call
<code class="code docutils literal notranslate"><span class="pre">ZDOInitDeviceEx()</span></code>, which will handle the resume operation according to
the state and the logical device type.</p>
</div>
<div class="section" id="application-non-volatile-memory">
<span id="sec-application-nv-memory"></span><h3>Application Non-Volatile Memory<a class="headerlink" href="#application-non-volatile-memory" title="Permalink to this headline">¶</a></h3>
<p>In general, a device must have non-volatile memory enabled to be
certified, because it must remember its network configuration. In
addition to the stack ‘internal’ data, the NVM can also be used to store
application data.</p>
<p>Reading and writing to NV is done using the NV functions contained within
<code class="code docutils literal notranslate"><span class="pre">zstack_user0Cfg.nvFps</span></code>. The sample applications have access to these
functions via the global <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">NVINTF_nvFuncts_t</span> <span class="pre">*pfnZdlNV</span> <span class="pre">=</span> <span class="pre">NULL;</span></code></p>
<p>The NV area of flash is used for storing persistent data for the application.
For more information on the NV On-Chip Multi-Page (NVOCMP) driver please refer
to <code class="docutils literal notranslate"><span class="pre">nvocmp.c</span></code> which describes the implementation details of the multi-page NV
and lists the maximum values of custom NV IDs available to the applications as such:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Maximum ID parameters - must be coordinated with header compression,</span>
<span class="c1">// Increasing these limits requires modification of the readHdr() function</span>
<span class="cp">#define NVOCMP_MAXSYSID   0x003F  </span><span class="c1">//  6 bits</span>
<span class="cp">#define NVOCMP_MAXITEMID  0x03FF  </span><span class="c1">// 10 bits</span>
<span class="cp">#define NVOCMP_MAXSUBID   0x03FF  </span><span class="c1">// 10 bits</span>
<span class="cp">#define NVOCMP_MAXLEN     0x03FF  </span><span class="c1">// 10 bits</span>
</pre></div>
</div>
<p>The last page in flash is the CCA page, the pages before that are reserved for the NV
area as defined by <code class="docutils literal notranslate"><span class="pre">NVOCMP_NVPAGES</span></code>. The example projects use the NV driver with
the API defined in <code class="docutils literal notranslate"><span class="pre">nvintf.h</span></code>.  The NV driver is set up in <code class="docutils literal notranslate"><span class="pre">main.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef NV_RESTORE</span>
<span class="w">    </span><span class="cm">/* Setup the NV driver */</span><span class="w"></span>
<span class="w">    </span><span class="n">NVOCMP_loadApiPtrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zstack_user0Cfg</span><span class="p">.</span><span class="n">nvFps</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">zstack_user0Cfg</span><span class="p">.</span><span class="n">nvFps</span><span class="p">.</span><span class="n">initNV</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">zstack_user0Cfg</span><span class="p">.</span><span class="n">nvFps</span><span class="p">.</span><span class="n">initNV</span><span class="p">(</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Then the applications use the function pointers in <code class="docutils literal notranslate"><span class="pre">zstack_user0Cfg</span></code> to call the NV
functions defined in <code class="docutils literal notranslate"><span class="pre">nvintf.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Structure of NV API function pointers</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">nvintf_nvfuncts_t</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Initialization function</span>
<span class="w">    </span><span class="n">NVINTF_initNV</span><span class="w"> </span><span class="n">initNV</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Compact NV function</span>
<span class="w">    </span><span class="n">NVINTF_compactNV</span><span class="w"> </span><span class="n">compactNV</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Create item function</span>
<span class="w">    </span><span class="n">NVINTF_createItem</span><span class="w"> </span><span class="n">createItem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Delete NV item function</span>
<span class="w">    </span><span class="n">NVINTF_deleteItem</span><span class="w"> </span><span class="n">deleteItem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Read item function</span>
<span class="w">    </span><span class="n">NVINTF_readItem</span><span class="w"> </span><span class="n">readItem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Write item function</span>
<span class="w">    </span><span class="n">NVINTF_writeItem</span><span class="w"> </span><span class="n">writeItem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Write existing item function</span>
<span class="w">    </span><span class="n">NVINTF_writeItemEx</span><span class="w"> </span><span class="n">writeItemEx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Get item length function</span>
<span class="w">    </span><span class="n">NVINTF_getItemLen</span><span class="w"> </span><span class="n">getItemLen</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">NVINTF_nvFuncts_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The following is an example of NV memory registration from <code class="docutils literal notranslate"><span class="pre">zcl_sampledoorlock.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">sampleApp_task</span><span class="p">(</span><span class="n">NVINTF_nvFuncts_t</span><span class="w"> </span><span class="o">*</span><span class="n">pfnNV</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Save and register the function pointers to the NV drivers</span>
<span class="w">  </span><span class="n">pfnZdlNV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pfnNV</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">zclport_registerNV</span><span class="p">(</span><span class="n">pfnZdlNV</span><span class="p">,</span><span class="w"> </span><span class="n">ZCL_PORT_SCENE_TABLE_NV_ID</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Initialize application</span>
<span class="w">  </span><span class="n">zclSampleDoorLock_initialization</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// No return from task process</span>
<span class="w">  </span><span class="n">zclSampleDoorLock_process_loop</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following is an example of a NV read from <code class="docutils literal notranslate"><span class="pre">zclSampleDoorLock_Init</span></code>
of <code class="docutils literal notranslate"><span class="pre">zcl_sampledoorlock.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Initialize NVM for storing PIN information</span>
<span class="k">if</span><span class="p">(</span><span class="n">pfnZdlNV</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">NVINTF_itemID_t</span><span class="w"> </span><span class="n">nvId</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nvErr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NVINTF_NOTFOUND</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Fill in the NV ID header</span>
<span class="w">    </span><span class="n">nvId</span><span class="p">.</span><span class="n">systemID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NVINTF_SYSID_APP</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">nvId</span><span class="p">.</span><span class="n">itemID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">DLSAPP_NV_DOORLOCK_PIN</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">nvId</span><span class="p">.</span><span class="n">subID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Read the PIN from NV</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">pfnZdlNV</span><span class="o">-&gt;</span><span class="n">readItem</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">nvErr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pfnZdlNV</span><span class="o">-&gt;</span><span class="n">readItem</span><span class="p">(</span><span class="n">nvId</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">DLSAPP_NV_DOORLOCK_PIN_LEN</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="n">aiDoorLockMasterPINCode</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// If the PIN doesn&#39;t exist in NV, create it</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">nvErr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NVINTF_NOTFOUND</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfnZdlNV</span><span class="o">-&gt;</span><span class="n">createItem</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">pfnZdlNV</span><span class="o">-&gt;</span><span class="n">createItem</span><span class="p">(</span><span class="n">nvId</span><span class="p">,</span><span class="w"> </span><span class="n">DLSAPP_NV_DOORLOCK_PIN_LEN</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">aiDoorLockMasterPINCode</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following is an example of a NV write from <code class="docutils literal notranslate"><span class="pre">zclSampleDoorLock_UiActionChangePin</span></code>
of <code class="docutils literal notranslate"><span class="pre">zcl_sampledoorlock.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">pfnZdlNV</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfnZdlNV</span><span class="o">-&gt;</span><span class="n">writeItem</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">NVINTF_itemID_t</span><span class="w"> </span><span class="n">nvId</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">nvId</span><span class="p">.</span><span class="n">systemID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NVINTF_SYSID_APP</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">nvId</span><span class="p">.</span><span class="n">itemID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">DLSAPP_NV_DOORLOCK_PIN</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">nvId</span><span class="p">.</span><span class="n">subID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">pfnZdlNV</span><span class="o">-&gt;</span><span class="n">writeItemEx</span><span class="p">(</span><span class="n">nvId</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">DLSAPP_NV_DOORLOCK_PIN_LEN</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">aiDoorLockMasterPINCode</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The NV system is a collection of NV items. Each item is unique and have the
following pieces to it (defined in <code class="docutils literal notranslate"><span class="pre">nvintf.h</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">*  NV Item Identification structure</span>
<span class="cm">*/</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">nvintf_itemid_t</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! NV System ID - identifies system (ZStack, BLE, App, OAD...)</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">systemID</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! NV Item ID</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">itemID</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! NV Item sub ID</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">subID</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">NVINTF_itemID_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If migrating a project from Z-Stack 3.4.0 or earlier to 3.5.0 or later,
<code class="docutils literal notranslate"><span class="pre">ZSTACK_NVOCMP_MIGRATION</span></code> must be defined in the 3.5.0+ project in order to
compensate for the changes involved with upgrading from the NVOCTP to the
NVOCMP driver.  This only applies to field upgrades where no factory reset is
intended so that the NV memory is retained in order to keep network settings.
The values modified in <code class="docutils literal notranslate"><span class="pre">zgUpgradeNvDriver</span></code> should not change
size between versions or else <code class="docutils literal notranslate"><span class="pre">zgUpgradeNvDriver</span></code> itself will need to be
altered to accomodate.  These include:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ZDSECMGR_TC_DEVICE_MAX</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ZDSECMGR_TC_DEVICE_IC_MAX</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ZDSECMGR_ENTRY_MAX</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MAX_NWK_SEC_MATERIAL_TABLE_ENTRIES</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GPP_MAX_PROXY_TABLE_ENTRIES</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GPS_MAX_SINK_TABLE_ENTRIES</span></code></p></li>
</ul>
</div></blockquote>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If using APS groups and upgrading a project from Z-Stack 4.4.0 or earlier
to 5.1.0 or later using the OTA method, <code class="docutils literal notranslate"><span class="pre">ZSTACK_NVOCMP_MIGRATION</span></code> must be
defined in the 5.1.0+ project to account for a new feature in which each group
table has been separated into its own NV ID subset.</p>
<p>Likewise, for upgrading from Z-Stack 5.2.0-, <code class="docutils literal notranslate"><span class="pre">ZSTACK_5_30_NV_MIGRATION</span></code> and
<code class="docutils literal notranslate"><span class="pre">ZSTACK_NV_FORMAT_UPDATE</span></code> need to be defined for the 5.3.0+ project due to
the new format of TCLK items.  If upgrading from Z-Stack 3.4.0- or using APS
groups with Z-Stack 4.4.0-, then incremental upgrades are necessary to
transition between all of the required changes.</p>
</div>
</div>
<div class="section" id="non-volatile-memory-low-voltage-detection">
<span id="sec-nv-memory-low-voltage-detection"></span><h3>Non-Volatile Memory Low Voltage Detection<a class="headerlink" href="#non-volatile-memory-low-voltage-detection" title="Permalink to this headline">¶</a></h3>
<p>Z-Stack utilizes the on-chip battery monitor to make sure the device’s power
level is above a given theshold before writing contents to the NV memory.  This
prevents flash memory corruption during low voltage operation.  The aforementioned
detection threshold is determined by <code class="code docutils literal notranslate"><span class="pre">NVOCMP_MIN_VDD_FLASH_MV</span></code> and is
represented in units of millivolts.  A value of at least 2000 is recommended for
typical Z-Stack applications.  If any NV operations are prevented due to this
feature then the application can be notified by a callback such as
<code class="code docutils literal notranslate"><span class="pre">Main_lowVoltageCb</span></code> used in <code class="code docutils literal notranslate"><span class="pre">main.c</span></code> of the Z-Stack sample applications:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm"> * @brief       Callback function when voltage is lower than NVOCMP_MIN_VDD_FLASH_MV</span>
<span class="cm"> *              during an NV write operation</span>
<span class="cm"> *</span>
<span class="cm"> * @param       voltage - Measured device voltage</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#ifdef NVOCMP_MIN_VDD_FLASH_MV</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Main_lowVoltageCb</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">voltage</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Implement any safety precautions for application due to low voltage detected */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>
<div class="section" id="modifying-non-volatile-memory-allocation">
<span id="sec-modifying-nv-memory"></span><h3>Modifying Non-Volatile Memory Allocation<a class="headerlink" href="#modifying-non-volatile-memory-allocation" title="Permalink to this headline">¶</a></h3>
<p>By default, Z-Stack projects allocate two flash pages for non-volatile (NV)
memory with the pre-define <code class="code docutils literal notranslate"><span class="pre">NVOCMP_NVPAGES=2</span></code>.  This is located in
the Projects Properties’ <em>Build</em> → <em>Arm Compiler</em> →
<em>Predefined Symbols</em> as well as <em>Build</em> → <em>Arm Linker</em> →
<em>Advanced Options</em> → <em>Command File Preprocessing</em> and the value
from both locations should always match. The purpose of these definitions
is to allow one dedicated page for compaction and other pages for storage.
In some use cases, for example a Zigbee Coordinator Trust Center with a
large number of devices connected (see <a class="reference internal" href="network_configuration.html#network-config"><span class="std std-ref">Network Configurations</span></a> for applicable
changes), it may be necessary to increase the number of NV storage pages.
Users will also need to modify the aforementioned <code class="code docutils literal notranslate"><span class="pre">NVOCMP_NVPAGES=2</span></code>
locations along with <strong>Region Base</strong> and <strong>Region Size</strong> settings in the
project’s .syscfg file <em>TI Drivers</em> → <em>NVS</em> → <em>Internal Flash</em>.
The command linker (<code class="code docutils literal notranslate"><span class="pre">.cmd</span></code>) file accounts for changes automatically:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef NVOCMP_NVPAGES</span>
<span class="cp">#define NVOCMP_NVPAGES 2</span>
<span class="cp">#endif</span>

<span class="cp">#define FLASH_BASE 0x00000000</span>
<span class="cp">#define FLASH_SIZE (0x56000 - (NVOCMP_NVPAGES * 0x2000))</span>
<span class="cp">#define FLASH_NV_BASE (0x56000 - (NVOCMP_NVPAGES * 0x2000))</span>
<span class="cp">#define FLASH_NV_SIZE (NVOCMP_NVPAGES * 0x2000)</span>
<span class="cp">#define FLASH_LAST_BASE 0x56000</span>
<span class="cp">#define FLASH_LAST_SIZE 0x2000</span>
</pre></div>
</div>
<p>For example, if <code class="code docutils literal notranslate"><span class="pre">NVOCMP_NVPAGES</span></code> was increased to three (two pages
for storage and one for compaction) then <code class="code docutils literal notranslate"><span class="pre">FLASH_SIZE</span></code>,
<code class="code docutils literal notranslate"><span class="pre">FLASH_NV_BASE</span></code>, and <em>Region Base</em> would decrease to 0x50000 and
<code class="code docutils literal notranslate"><span class="pre">FLASH_NV_SIZE</span></code> and <em>Region Size</em> would increase to 0x6000 (since
one page of flash is 0x2000 bytes).</p>
<p>The amount of required NV memory greatly depends on the definitions
provided in the table below.  Total NV allocation required for a Z-Stack
project can be estimated by multiplying the bytes per entry by the value
of the definition then adding them all together along with ~2.3 kB for
remaining NV items which aren’t as liable to fluctuate depending on
network settings.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 33%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Definition</strong></p></th>
<th class="head"><p><strong>Bytes per entry</strong></p></th>
<th class="head"><p><strong>Default value</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NWK_MAX_DEVICE_LIST</p></td>
<td><p>23</p></td>
<td><p>20</p></td>
</tr>
<tr class="row-odd"><td><p>ZDSECMGR_TC_DEVICE_MAX</p></td>
<td><p>27</p></td>
<td><p>40</p></td>
</tr>
<tr class="row-even"><td><p>NWK_MAX_ADDRESSES</p></td>
<td><p>19</p></td>
<td><p>70</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The maximum value of <code class="code docutils literal notranslate"><span class="pre">NVOCMP_NVPAGES</span></code> allowed is five,
which equals one compaction page (0x2000 bytes) and four storage
pages (0x8000 bytes).</p>
</div>
<p>For IAR projects the user does not have to modify the linker command
(<code class="code docutils literal notranslate"><span class="pre">.icf</span></code>) file. The required sizes will be calculated by the compiler.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="z-stack-overview.html" class="btn btn-neutral float-left" title="Z-Stack Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="memory_map.html" class="btn btn-neutral float-right" title="Memory Map" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2022, Texas Instruments.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>