<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Z-Stack Overview &mdash; 
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User&#39;s Guide
 7.10.01 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Flash" href="flash_memory-cc13xx_cc26xx.html" />
    <link rel="prev" title="Green Power Application Overview" href="gpd_application_overview.html" />
    <script language="JavaScript">
        var tiPageName;
        tiPageName = "sug zigbee z-stack-overview";

        if (location.protocol == "file:"){
            var ci_analytics_poc_load = true;
        }
    </script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../zigbee-guide/index-cc13xx_cc26xx.html" class="icon icon-home"> 
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User's Guide

          </a>
              <div class="version">
                7.10.01
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quickstart-guide/quickstart-intro-cc13xx_cc26xx.html">Introduction to the SimpleLink CC13xx/CC26xx SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc13xx_cc26xx/index-platform.html">SimpleLink Wireless MCU CC13xx and CC26xx Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/tirtos-index.html">TI-RTOS7 (RTOS Kernel) Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">SimpleLink CC13xx/CC26xx SDK Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="developing_zigbee_applications.html">Developing Zigbee Applications</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="application_overview.html">Application Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpd_application_overview.html">Green Power Application Overview</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Z-Stack Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#purpose">Purpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scope">Scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="#definitions-abbreviations-and-acronyms">Definitions, Abbreviations and Acronyms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reference-documents">Reference Documents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#zigbee">Zigbee</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#logical-device-types">Logical Device Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stack-profile">Stack Profile</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#addressing">Addressing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#address-types">Address Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#network-address-assignment">Network Address Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#addressing-in-z-stack">Addressing in Z-Stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#important-device-addresses">Important Device Addresses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#binding">Binding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#building-a-binding-table">Building a Binding Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuring-source-binding">Configuring Source Binding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#routing">Routing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#routing-protocol">Routing Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="#table-storage">Table Storage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#many-to-one-routing-protocol">Many-to-One Routing Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="#routing-settings-quick-reference">Routing Settings Quick Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#router-off-network-association-cleanup">Router Off-Network Association Cleanup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#zdo-message-requests">ZDO Message Requests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#portable-devices">Portable Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#end-to-end-acknowledgements">End-to-End Acknowledgements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous">Miscellaneous</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#configuring-channel">Configuring Channel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuring-the-pan-id-and-network-to-join">Configuring the PAN ID and Network to Join</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maximum-payload-size">Maximum Payload Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="#leave-network">Leave Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#descriptors">Descriptors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asynchronous-links">Asynchronous Links</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multicast-messages">Multicast Messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fragmentation">Fragmentation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extended-pan-ids">Extended PAN IDs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rejoining-with-pre-commissioned-network-parameters">Rejoining with Pre-Commissioned Network Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#child-management">Child Management</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#security">Security</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#centralized-security-network">Centralized Security Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#distributed-security-network">Distributed Security Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#link-key-types">Link Key Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unsecure-join-to-a-network">Unsecure Join to a Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#touchlink-joining">Touchlink Joining</a></li>
<li class="toctree-l4"><a class="reference internal" href="#backwards-interoperability">Backwards Interoperability</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">Quick Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#clusters-commands-and-attributes">Clusters, Commands, and Attributes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#attributes">Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adding-an-attribute-example">Adding an Attribute Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializing-clusters">Initializing Clusters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cluster-architecture">Cluster Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cluster-callbacks-example">Cluster Callbacks Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attribute-reporting-functionality">Attribute Reporting Functionality</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#commissioning">Commissioning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bdb-notifications">BDB Notifications</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initialization-procedure">Initialization Procedure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parent-lost">Parent Lost</a></li>
<li class="toctree-l4"><a class="reference internal" href="#network-steering-procedure-for-a-node-on-a-network">Network Steering Procedure for a Node on a Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#network-steering-procedure-for-a-node-not-on-a-network">Network Steering Procedure for a Node not on a Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#network-formation">Network Formation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#z-stack-overview-finding-binding">Finding and Binding</a></li>
<li class="toctree-l4"><a class="reference internal" href="#touchlink-commissioning">Touchlink Commissioning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reset-procedures">Reset Procedures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#network-manager">Network Manager</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#channel-interference">Channel Interference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pan-id-conflict">PAN ID Conflict</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#green-power">Green Power</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#green-power-data-frames-gpdf">Green Power Data Frames (GPDF)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zigbee-green-power-stub">Zigbee Green Power Stub</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-green-power-network">Basic Green Power Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#green-power-device">Green Power Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#green-power-basic-proxy">Green Power Basic Proxy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#green-power-sink">Green Power Sink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#commissioning-a-green-power-device">Commissioning a Green Power Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#green-power-security">Green Power Security</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#inter-pan-transmission">Inter-PAN Transmission</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-exchange">Data Exchange</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#zmac-lqi-adjustment">ZMAC LQI Adjustment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id13">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lqi-adjustment-modes">LQI Adjustment Modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-lqi-adjustment">Using LQI Adjustment</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="flash_memory-cc13xx_cc26xx.html">Flash</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory_map.html">Memory Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_applications.html">Running the Example Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="network_configuration.html">Network Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_configuration.html">Power Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="znp_interface.html">Zigbee Network Processor (ZNP) Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="mt_interface.html">MT Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="product_certification.html">Product Certification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cc13xx_cc26xx/fcc-certification.html">FCC Certification Considerations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cc13xx_cc26xx/custom-hardware-cc13xx_cc26xx.html">Custom Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/zigbee-ota-index.html">Zigbee Over-The-Air Firmware Upgrade</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coexistence/coexistence-ieee.html">Wi-Fi Coexistence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/debugging-index.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="packet_sniffer.html">Packet Sniffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/sysconfig-index.html">System Configuration (SysConfig)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../energy-trace/energy-trace.html">EnergyTrace User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/migration_guide.html">Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/references-cc13xx_cc26xx.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/glossary.html">Terms and Acronyms</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../zigbee-guide/index-cc13xx_cc26xx.html">
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User's Guide
</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../zigbee-guide/index-cc13xx_cc26xx.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="developing_zigbee_applications.html">Developing Zigbee Applications</a> &raquo;</li>
      <li>Z-Stack Overview</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="stack-overview">
<span id="z-stack-overview"></span><h1>Z-Stack Overview<a class="headerlink" href="#stack-overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="purpose">
<h3>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h3>
<p>This document explains some of the components of the Texas Instruments
Zigbee stack and their functioning. It explains the configurable
parameters in the Zigbee stack and how they may be changed by the
application developer to suit the application requirements.</p>
</div>
<div class="section" id="scope">
<h3>Scope<a class="headerlink" href="#scope" title="Permalink to this headline">¶</a></h3>
<p>This document describes concepts and settings for the Texas Instruments
Z-Stack™ Release. This is a Zigbee PRO 2017 (R22) certified stack
for the Zigbee and Zigbee PRO stack profiles. It also exlains the added
features of the Zigbee 3.0 specification and how they can be used
for compatibility with Zigbee 3.0 or legacy devices.</p>
</div>
<div class="section" id="definitions-abbreviations-and-acronyms">
<h3>Definitions, Abbreviations and Acronyms<a class="headerlink" href="#definitions-abbreviations-and-acronyms" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Term</strong></p></th>
<th class="head"><p><strong>Definition</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AF</p></td>
<td><p>Application Framework</p></td>
</tr>
<tr class="row-odd"><td><p>AES</p></td>
<td><p>Advanced Encryption Standard</p></td>
</tr>
<tr class="row-even"><td><p>AIB</p></td>
<td><p>APS Information Base</p></td>
</tr>
<tr class="row-odd"><td><p>API</p></td>
<td><p>Application Programming Interface</p></td>
</tr>
<tr class="row-even"><td><p>APS</p></td>
<td><p>Application Support Sub-Layer</p></td>
</tr>
<tr class="row-odd"><td><p>APSDE</p></td>
<td><p>APS Date Entity</p></td>
</tr>
<tr class="row-even"><td><p>APSME</p></td>
<td><p>APS Management Entity</p></td>
</tr>
<tr class="row-odd"><td><p>ASDU</p></td>
<td><p>APS Service Datagram Unit</p></td>
</tr>
<tr class="row-even"><td><p>BDB</p></td>
<td><p>Base Device Behavior</p></td>
</tr>
<tr class="row-odd"><td><p>BSP</p></td>
<td><p>Board Support Package – taken together, HAL &amp;
OSAL comprise a rudimentary operating system
commonly referred to as a BSP</p></td>
</tr>
<tr class="row-even"><td><p>CCM*</p></td>
<td><p>Enhanced counter with CBC-MAC mode of
operation</p></td>
</tr>
<tr class="row-odd"><td><p>EPID</p></td>
<td><p>Extended PAN ID</p></td>
</tr>
<tr class="row-even"><td><p>GP</p></td>
<td><p>Green Power</p></td>
</tr>
<tr class="row-odd"><td><p>GPD</p></td>
<td><p>Green Power Device</p></td>
</tr>
<tr class="row-even"><td><p>HAL</p></td>
<td><p>Hardware (H/W) Abstraction Layer</p></td>
</tr>
<tr class="row-odd"><td><p>MSG</p></td>
<td><p>Message</p></td>
</tr>
<tr class="row-even"><td><p>MT</p></td>
<td><p>Z-Stack’s Monitor and Test Layer</p></td>
</tr>
<tr class="row-odd"><td><p>NHLE</p></td>
<td><p>Next Higher Layer Entity</p></td>
</tr>
<tr class="row-even"><td><p>NIB</p></td>
<td><p>Network Information Base</p></td>
</tr>
<tr class="row-odd"><td><p>NWK</p></td>
<td><p>Network</p></td>
</tr>
<tr class="row-even"><td><p>OSAL</p></td>
<td><p>Z-Stack’s Operating System Abstraction Layer</p></td>
</tr>
<tr class="row-odd"><td><p>OTA</p></td>
<td><p>Over-the-Air</p></td>
</tr>
<tr class="row-even"><td><p>PAN</p></td>
<td><p>Personal Area Network</p></td>
</tr>
<tr class="row-odd"><td><p>RSSI</p></td>
<td><p>Received Signal Strength Indication</p></td>
</tr>
<tr class="row-even"><td><p>TC</p></td>
<td><p>Trust Center</p></td>
</tr>
<tr class="row-odd"><td><p>TCLK</p></td>
<td><p>Trust Center Link Key</p></td>
</tr>
<tr class="row-even"><td><p>ZCL</p></td>
<td><p>Zigbee Cluster Library</p></td>
</tr>
<tr class="row-odd"><td><p>ZDO</p></td>
<td><p>Zigbee Device Object</p></td>
</tr>
<tr class="row-even"><td><p>ZHA</p></td>
<td><p>Zigbee Home Automation</p></td>
</tr>
<tr class="row-odd"><td><p>ZC</p></td>
<td><p>Zigbee Coordinator</p></td>
</tr>
<tr class="row-even"><td><p>ZR</p></td>
<td><p>Zigbee Router</p></td>
</tr>
<tr class="row-odd"><td><p>ZED</p></td>
<td><p>Zigbee End Device</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reference-documents">
<h3>Reference Documents<a class="headerlink" href="#reference-documents" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Zigbee document 05-3474-22 Zigbee PRO 2017 (R22) Specification</p></li>
<li><p>Zigbee document 07-5123-07 Zigbee Cluster Library 7 Specification</p></li>
<li><p>Zigbee document 13-0402-13 Zigbee Base Device Behavior</p></li>
<li><p>Zigbee document 14-0563-16 Zigbee Green Power specification</p></li>
</ol>
</div>
</div>
<div class="section" id="zigbee">
<h2>Zigbee<a class="headerlink" href="#zigbee" title="Permalink to this headline">¶</a></h2>
<p>A Zigbee network is a multi-hop network of mains-powered or battery-powered devices.
This means that successful communication between two devices may require
intermediate devices to relay messages.
Due to the cooperative nature of the network,
each device is required to perform specific networking functions and
configure certain parameters to specific
values.
The role of a device is determined by the set of networking functions it performs
and is called the <strong>logical device type</strong>.
The set of parameters that need to be configured to
specific values, along with those values, is called the <strong>stack profile</strong>.</p>
<div class="section" id="logical-device-types">
<span id="z-stack-overview-logical-device-types"></span><h3>Logical Device Types<a class="headerlink" href="#logical-device-types" title="Permalink to this headline">¶</a></h3>
<p>The three logical device types in a Zigbee network are
<em>Coordinator</em>, <em>Router</em>, and <em>End Device</em>. A Zigbee network consists
of a device with network formation capabilities (such as Coordinator or Router)
and multiple Router and End Device nodes. Note that the device type does
not in any way restrict the type of application that may run on the
particular device.</p>
<div class="figure align-center" id="id14">
<span id="fig-typical-zigbee-nwk"></span><img alt="../_images/figure1.png" src="../_images/figure1.png" />
<p class="caption"><span class="caption-number">Figure 47. </span><span class="caption-text">Example of typical Zigbee network</span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></p>
</div>
<p><a class="reference internal" href="#fig-typical-zigbee-nwk"><span class="std std-ref">Example of typical Zigbee network</span></a> shows a typical Zigbee network with the Zigbee
<em>Coordinator</em> (black), the <em>Routers</em> (red), and the <em>End Devices</em> (white).</p>
<p>An application can be defined as any of these three logical devices depending
on the configuration flags enabled in the project.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Logical Device</strong></p></th>
<th class="head"><p><strong>Compilation flags needed</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>Coordinator</em></p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">ZDO_COORDINATOR</span></code> and <code class="code docutils literal notranslate"><span class="pre">RTR_NWK</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>Router</em></p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">RTR_NWK</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>End Device</em></p></td>
<td><p>None</p></td>
</tr>
</tbody>
</table>
<div class="section" id="coordinator">
<span id="z-stack-overview-logical-device-coordinator"></span><h4>Coordinator<a class="headerlink" href="#coordinator" title="Permalink to this headline">¶</a></h4>
<p>A coordinator is a device with network formation capabilities, but
without network joining capabilities. This means the device can only create its
own network, but not join existing networks. To create a network, the
coordinator node scans the RF environment for existing networks, chooses
a channel and a network identifier (also called PAN ID) and then starts
the network. In Zigbee 3.0 this device creates a Centralized security network
and is mandated to behave as the Trust Center of this network, which
means that this device is responsible for managing security of the
network and is the only device capable of distributing keys and
allowing devices to join the network it has created.</p>
<p>The coordinator node can also be used, optionally, to assist in setting
up application-level bindings in the network.</p>
<p>The role of the coordinator is mainly related to starting the network
and managing the keys. Besides that, it behaves like a router device.
Note that the Coordinator must handle the network procedures
related to devices joining or leaving the network,
so it cannot be absent of its own network.
Further details on security schema are available in <a class="reference internal" href="#z-stack-overview-security"><span class="std std-ref">Security</span></a>.</p>
</div>
<div class="section" id="router">
<span id="z-stack-overview-logical-device-router"></span><h4>Router<a class="headerlink" href="#router" title="Permalink to this headline">¶</a></h4>
<p>A router performs functions for allowing other devices to join the
network, for multi-hop routing,
and for assisting its child end devices with communication.
In Zigbee 3.0 this device has been granted with formation
capabilities that allow it to create a Distributed security network.
This formation capability allows the router device to create a network
that does not have a security manager. This means that once the network
has been created, the router which created it does not have any special
role in this network. More details are available in <a class="reference internal" href="#z-stack-overview-security"><span class="std std-ref">Security</span></a>.</p>
<p>In general, Routers are expected to be active all the time and thus have
to be mains-powered.</p>
</div>
<div class="section" id="end-device">
<span id="z-stack-overview-logical-device-end-device"></span><h4>End Device<a class="headerlink" href="#end-device" title="Permalink to this headline">¶</a></h4>
<p>An end device has no specific responsibility for maintaining the network
infrastructure, so it can sleep and wake up as it chooses. This device can
be a battery-powered node. Generally, the memory requirements (especially
RAM requirements) are lower for an end device.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In Z-Stack all sample application projects are provided with the needed
pre-include files to build each device type according to the project.</p>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="stack-profile">
<span id="z-stack-overview-stack-profile"></span><h3>Stack Profile<a class="headerlink" href="#stack-profile" title="Permalink to this headline">¶</a></h3>
<p>The set of stack parameters that need to be configured to specific
values, along with the above device type values, is called a <strong>stack
profile</strong>. The parameters that comprise the stack profile are defined
by the Zigbee Alliance.</p>
<p>All devices in a network must conform to the same stack profile (i.e.,
all devices must have the stack profile parameters configured to the
same values).</p>
<p>If application developers choose to change the settings for any of these
parameters, they can do so with the caveat that those devices will no
longer be able to interoperate with devices from other vendors that
choose to follow the Zigbee specified stack profile. Thus, developers of
“closed networks” may choose to change the settings of the stack profile
variables. These stack profiles are called “network-specific” stack
profiles.</p>
<p>The stack profile identifier that a device conforms to is present in the
beacon transmitted by that device. This enables a device to determine
the stack profile of a network before joining to it. The
“network-specific” stack profile has an ID of 0, the legacy Zigbee
stack profile has ID of 1, and the Zigbee PRO stack profile (which is used
for Zigbee 3.0) has ID of 2. The stack profile is configured by the
<code class="code docutils literal notranslate"><span class="pre">STACK_PROFILE_ID</span></code> parameter in the <code class="code docutils literal notranslate"><span class="pre">nwk_globals.h</span></code> file.
The stack profile ID of 3 is reserved for Green Power devices, and it
appears in the respective frames.</p>
</div>
</div>
<div class="section" id="addressing">
<span id="z-stack-overview-addressing"></span><h2>Addressing<a class="headerlink" href="#addressing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="address-types">
<span id="z-stack-overview-address-types"></span><h3>Address Types<a class="headerlink" href="#address-types" title="Permalink to this headline">¶</a></h3>
<p>Zigbee devices have two types of addresses. A 64-bit <em>IEEE address</em>
(also called <em>MAC address</em> or <em>Extended address</em>) and a 16-bit <em>network
address</em> (also called <em>logical address</em> or <em>short address</em>).</p>
<p>The 64-bit address is a globally unique address and is assigned to the
device for its lifetime. It is usually set by the manufacturer or during
installation. These addresses are maintained and allocated by the IEEE.
More information on how to acquire a block of these addresses is
available at <a class="reference external" href="https://standards.ieee.org/products-services/regauth/index.html">IEEE Registration Authority</a>.</p>
<p>The 16-bit address is assigned to a device when it joins a network.
Within that network, it is unique and used for identifying devices and sending data.</p>
</div>
<div class="section" id="network-address-assignment">
<span id="z-stack-overview-network-address-assignment"></span><h3>Network Address Assignment<a class="headerlink" href="#network-address-assignment" title="Permalink to this headline">¶</a></h3>
<div class="section" id="stochastic-addressing">
<h4>Stochastic Addressing<a class="headerlink" href="#stochastic-addressing" title="Permalink to this headline">¶</a></h4>
<p>Zigbee PRO uses a stochastic (random) addressing scheme for assigning
the network addresses. This addressing scheme randomly assigns short
addresses to new devices, and then uses the rest of the devices in the
network to ensure there are no duplicate addresses. When a device
joins, it receives its randomly generated address from its parent. The
new network node then generates a “Device Announce” frame (which contains its
new short address and its extended address) to the rest of the network.
If there is another device with the same short address, a router node
in the network will send out a broadcast “Network Status – Address
Conflict” to the entire network and all devices with the conflicting
short address will change its short address. When the conflicted devices
change their address, they issue their own “Device Announce” to check
their new address for conflicts within the network.</p>
<p>End devices do not participate in the “Address Conflict”. Their parents
do that for them. If an “Address Conflict” occurs for an end device, its
parent will issue the end device a “Rejoin Response” message to change
the end device’s short address and the end device issues a “Device
Announce” to check their new address for conflicts within the network.</p>
<p>When a “Device Announce” is received, the association and binding tables
are updated with the new short address, but routing table information is not
updated (new routes must be established). If a parent determines that
the “Device Announce” pertains to one of its end device children, but it
didn’t come directly from the child, the parent will assume that the
child moved to another parent.</p>
</div>
</div>
<div class="section" id="addressing-in-z-stack">
<span id="z-stack-overview-addressing-in-z-stack"></span><h3>Addressing in Z-Stack<a class="headerlink" href="#addressing-in-z-stack" title="Permalink to this headline">¶</a></h3>
<p>In order to send data to a device on the Zigbee network, the application
generally uses the <code class="code docutils literal notranslate"><span class="pre">Zstackapi_AfDataReq()</span></code> function. The destination device to
which the packet is to be sent is of type <code class="code docutils literal notranslate"><span class="pre">zstack_AFAddr_t</span></code> (defined in
<code class="code docutils literal notranslate"><span class="pre">zstack.h</span></code>)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">_zstack_afaddr_t</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/** Address Mode */</span><span class="w"></span>
<span class="w">    </span><span class="n">zstack_AFAddrMode</span><span class="w"> </span><span class="n">addrMode</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/** Address union of 16 bit short address and 64 bit IEEE address */</span><span class="w"></span>
<span class="w">    </span><span class="k">union</span>
    <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/** 16 bit network address */</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">shortAddr</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="cm">/** 64 bit IEEE address */</span><span class="w"></span>
<span class="w">        </span><span class="n">zstack_LongAddr_t</span><span class="w"> </span><span class="n">extAddr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/** Endpoint address element, optional if addressing to the endpoint,</span>
<span class="cm">     * can be 0xFF to address all endpoints in a device.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">endpoint</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/** PAN ID - for use with Inter-PAN */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">panID</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">zstack_AFAddr_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Note that in addition to the network address, the address mode parameter
also needs to be specified. The destination address mode can take one of
the following values (AF address modes are also defined in <code class="code docutils literal notranslate"><span class="pre">zstack.h</span></code>)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/** Address types */</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Address not present</span>
<span class="w">    </span><span class="n">zstack_AFAddrMode_NONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Group Address (uint16_t)</span>
<span class="w">    </span><span class="n">zstack_AFAddrMode_GROUP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Short Address (uint16_t)</span>
<span class="w">    </span><span class="n">zstack_AFAddrMode_SHORT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Extended Address (8 bytes/64 bits)</span>
<span class="w">    </span><span class="n">zstack_AFAddrMode_EXT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">//! Broadcast Address (uint16_t)</span>
<span class="w">    </span><span class="n">zstack_AFAddrMode_BROADCAST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">zstack_AFAddrMode</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The address mode parameter is necessary because, in Zigbee, packets can
be unicast, multicast, or broadcast. A unicast packet is sent to a single
device, a multicast packet is destined to a group of devices and a
broadcast packet is generally sent to all devices in the network. An indirect packet is used
when the application does not explicitly know the destination of the packet. This
is explained in more detail below.</p>
<div class="section" id="unicast">
<h4>Unicast<a class="headerlink" href="#unicast" title="Permalink to this headline">¶</a></h4>
<p>This is the normal addressing mode and is used to send a packet to a
single device whose network address is known. The addrMode is set to
<code class="code docutils literal notranslate"><span class="pre">zstack_AFAddrMode_SHORT</span></code> and the destination network address is carried in the packet.</p>
</div>
<div class="section" id="indirect">
<h4>Indirect<a class="headerlink" href="#indirect" title="Permalink to this headline">¶</a></h4>
<p>This is when the application is not aware of the final destination of
the packet. The mode is set to <code class="code docutils literal notranslate"><span class="pre">zstack_AFAddrMode_NONE</span></code> and the destination
address is not specified. Instead, the destination is looked up from a
<em>binding table</em> that resides in the stack of the sending device. This
feature is called Source binding (see <a class="reference internal" href="#z-stack-overview-binding"><span class="std std-ref">Binding</span></a>).</p>
<p>When the packet is sent down to the stack, the destination address and
end point is looked up from the binding table and used. The packet is
then treated as a regular unicast packet. If more than one destination
device is found in the binding table, a copy of the packet is sent to
each of them. If no binding entry is found, the packet will not be sent.</p>
</div>
<div class="section" id="broadcast">
<h4>Broadcast<a class="headerlink" href="#broadcast" title="Permalink to this headline">¶</a></h4>
<p>This address mode is used when the application wants to send a packet to
all devices in the network. The address mode is set to <code class="code docutils literal notranslate"><span class="pre">zstack_AFAddrMode_BROADCAST</span></code> and
the destination address can be set to one of the following broadcast
addresses:</p>
<p><code class="code docutils literal notranslate"><span class="pre">NWK_BROADCAST_SHORTADDR_DEVALL</span></code> (0xFFFF) – the message will be sent to
all devices in the network (includes sleeping devices). For sleeping
devices, the message is held at its parent until the sleeping device
polls for it or the message is timed out (<code class="code docutils literal notranslate"><span class="pre">NWK_INDIRECT_MSG_TIMEOUT</span></code> in
<code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code>, as generated from the project’s .syscfg file
<em>RF STACKS</em> → <em>Z-Stack</em> → <em>Advanced</em> → <em>Routing</em>).</p>
<p><code class="code docutils literal notranslate"><span class="pre">NWK_BROADCAST_SHORTADDR_DEVRXON</span></code> (0xFFFD) – the message will be sent
to all devices that have the receiver on when idle (RXONWHENIDLE), that
is, all non-sleepy devices.</p>
<p><code class="code docutils literal notranslate"><span class="pre">NWK_BROADCAST_SHORTADDR_DEVZCZR</span></code> (0xFFFC) – the message is sent to all
routers (including the coordinator).</p>
</div>
<div class="section" id="group-addressing">
<h4>Group Addressing<a class="headerlink" href="#group-addressing" title="Permalink to this headline">¶</a></h4>
<p>This address mode is used when the application wants to send a packet to
a group of devices. The address mode is set to <code class="code docutils literal notranslate"><span class="pre">zstack_AFAddrMode_GROUP</span></code> and the parameter
<code class="code docutils literal notranslate"><span class="pre">addr.shortAddr</span></code> must be set set with the group identifier.</p>
<p>Before using this feature, groups must be defined in the network (see
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_ApsAddGroupReq()</span></code> in the <a class="reference external" href="../../../zigbee/zstack-apis.html">Z-Stack API</a>).</p>
<p>Note that groups can also be used in conjunction with indirect
addressing. The destination address found in the binding table can be
either a unicast or a group address. Also note that broadcast addressing
is simply a special case of group addressing where the groups are set up
ahead of time and defined by Zigbee Alliance.</p>
<p>Sample code for a device to add itself to a group with identifier <code class="code docutils literal notranslate"><span class="pre">0x0001</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GROUP_NAME &quot;Group1&quot;</span>
<span class="n">zstack_apsAddGroup_t</span><span class="w"> </span><span class="n">group</span><span class="p">;</span><span class="w"></span>

<span class="n">group</span><span class="p">.</span><span class="n">endpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SAMPLEAPP_ENDPOINT</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* Assign yourself to group 1 */</span><span class="w"></span>
<span class="n">group</span><span class="p">.</span><span class="n">groupID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0001</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* First byte is string length */</span><span class="w"></span>
<span class="n">group</span><span class="p">.</span><span class="n">n_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">GROUP_NAME</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">group</span><span class="p">.</span><span class="n">pName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GROUP_NAME</span><span class="p">;</span><span class="w"></span>

<span class="n">Zstackapi_ApsAddGroupReq</span><span class="p">(</span><span class="n">appServiceTaskId</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">group</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="important-device-addresses">
<h3>Important Device Addresses<a class="headerlink" href="#important-device-addresses" title="Permalink to this headline">¶</a></h3>
<p>An application may want to know the address of a device (self or remote device).
Use the following functions to get the addresses.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_ZdoNwkAddrReq()</span></code> – Use IEEE address to retrieve the short address.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_ZdoIeeeAddrReq()</span></code> – Use Short address to retrieve the IEEE address.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The responses to this messages are provided by the stack with the command IDs <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_ZDO_NWK_ADDR_RSP</span></code> and <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_ZDO_IEEE_ADDR_RSP</span></code></p>
</div>
</div>
</div>
<div class="section" id="binding">
<span id="z-stack-overview-binding"></span><h2>Binding<a class="headerlink" href="#binding" title="Permalink to this headline">¶</a></h2>
<p>Binding is a mechanism to control the flow of messages from one
application to another application (or multiple applications). The
binding mechanism is implemented in all devices and is called source
binding.</p>
<p>Binding allows an application to send a packet without knowing the
destination address, the APS layer determines the destination address
from its binding table, and then forwards the message to the
destination application (or multiple applications) or group.</p>
<div class="section" id="building-a-binding-table">
<span id="z-stack-overview-building-binding-table"></span><h3>Building a Binding Table<a class="headerlink" href="#building-a-binding-table" title="Permalink to this headline">¶</a></h3>
<p>There are 3 ways to build a binding table:</p>
<ul class="simple">
<li><p>Zigbee Device Object Bind Request – a commissioning tool can tell the
device to make a binding record.</p></li>
<li><p>Zigbee Device Object End Device Bind Request – 2 devices can tell the
coordinator that they would like to setup a binding table record. The
coordinator will make the match up and create the binding table
entries in the 2 devices.</p></li>
<li><p>Finding and Binding commissioning process for initiator devices.</p></li>
</ul>
<div class="section" id="zigbee-device-object-bind-request">
<h4>Zigbee Device Object Bind Request<a class="headerlink" href="#zigbee-device-object-bind-request" title="Permalink to this headline">¶</a></h4>
<p>Any device or application can send a ZDO message to another device (over
the air) to build a binding record for that other device in the network.
This is called Assisted Binding and it will create a binding entry for
the sending device.</p>
<div class="section" id="the-commissioning-application">
<h5>The Commissioning Application<a class="headerlink" href="#the-commissioning-application" title="Permalink to this headline">¶</a></h5>
<p>An application can create a bind between two remote devices by calling <code class="code docutils literal notranslate"><span class="pre">Zstackapi_ZdoBindReq()</span></code>
defined in <code class="code docutils literal notranslate"><span class="pre">zstackapi.h</span></code> for which are needed the addresses, endpoints, and the
cluster ID wanted in the binding record. The first parameter (target dstAddr)
is the short address of the binding’s source address (where the binding record will be stored) .
The remaining parameters are of the remote application device
that the bind will use to send frames.
Calling <code class="code docutils literal notranslate"><span class="pre">Zstackapi_ZdoUnbindReq()</span></code> can be used,
with the same parameters, to remove the binding record.</p>
<p>The target device will send back a Zigbee Device Object Bind or Unbind
Response message. The ZDO code on the coordinator will parse this and
notify the application with the message <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_ZDO_BIND_RSP</span></code> or
<code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_ZDO_UNBIND_RSP</span></code>.</p>
<p>For the Bind Response, the status returned from the coordinator will be
<code class="code docutils literal notranslate"><span class="pre">ZDP_SUCCESS</span></code>, <code class="code docutils literal notranslate"><span class="pre">ZDP_TABLE_FULL</span></code>, <code class="code docutils literal notranslate"><span class="pre">ZDP_INVALID_EP</span></code>, or
<code class="code docutils literal notranslate"><span class="pre">ZDP_NOT_SUPPORTED</span></code>.</p>
<p>For the Unbind Response, the status returned from the coordinator will
be <code class="code docutils literal notranslate"><span class="pre">ZDP_SUCCESS</span></code>, <code class="code docutils literal notranslate"><span class="pre">ZDP_NO_ENTRY</span></code>, <code class="code docutils literal notranslate"><span class="pre">ZDP_INVALID_EP</span></code>, or
<code class="code docutils literal notranslate"><span class="pre">ZDP_NOT_SUPPORTED</span></code>.</p>
</div>
</div>
<div class="section" id="zigbee-device-object-end-device-bind-request">
<h4>Zigbee Device Object End Device Bind Request<a class="headerlink" href="#zigbee-device-object-end-device-bind-request" title="Permalink to this headline">¶</a></h4>
<p>This mechanism uses a button press or other similar action at the
selected devices to bind within a specific timeout period. The End
Device Bind Request messages are collected at the coordinator within the
timeout period and a resulting Binding Table entry is created based on
the agreement of profile ID and cluster ID. The default end device
binding timeout is 16 seconds
(see <code class="code docutils literal notranslate"><span class="pre">APS_DEFAULT_MAXBINDING_TIME</span></code> in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>),
but can be changed if added as a compile flag.</p>
<p>Coordinator end device binding is a toggle process. The
first time you go through the process, it will create a binding entry in
the requesting devices. Then, when you go through the process again, it
will remove the bindings in the requesting devices.</p>
<p>When the coordinator receives 2 matching End Device Bind Requests, it
will start the process of creating source binding entries in the
requesting devices. The coordinator performs the following process,
assuming matches were found in the ZDO End Device Bind Requests:</p>
<ol class="arabic simple">
<li><p>Send a ZDO Unbind Request to the first device. The End Device Bind is a
toggle process, so the unbind is sent first to remove an existing
bind entry.</p></li>
<li><p>Wait for the ZDO Unbind Response. If the response status is
<code class="code docutils literal notranslate"><span class="pre">ZDP_NO_ENTRY</span></code>, send a ZDO Bind Request to make the binding entry in
the source device. If the response status is <code class="code docutils literal notranslate"><span class="pre">ZDP_SUCCESS</span></code>, move on to
the cluster ID for the first device (the unbind removed the entry –
toggle).</p></li>
<li><p>Wait for the ZDO Bind Response. When received, move on to the next
cluster ID for the first device.</p></li>
<li><p>When the first device is done, do the same process with the second
device.</p></li>
<li><p>When the second device is done, send the ZDO End Device Bind Response
messages to both the first and second device.</p></li>
</ol>
<p>End Device Binding process is already built in the coordinator stack and
does not require application interaction.</p>
</div>
<div class="section" id="finding-and-binding">
<h4>Finding and Binding<a class="headerlink" href="#finding-and-binding" title="Permalink to this headline">¶</a></h4>
<p>Base Device Behavior has defined a commissioning method called Finding
and Binding, which is a process that relies on the usage of the Identify
cluster and ZDO messages to allow the commissioned device to find
devices with matching application clusters. This mechanism is usually
triggered by the user to specify which devices need to “Find and Bind”
each other so that these pairs of devices can communicate more effectively.
Refer to section <a class="reference internal" href="#z-stack-overview-finding-binding"><span class="std std-ref">Finding and Binding</span></a> for further details on this commissioning method.</p>
</div>
</div>
<div class="section" id="configuring-source-binding">
<span id="z-stack-overview-configuring-source-binding"></span><h3>Configuring Source Binding<a class="headerlink" href="#configuring-source-binding" title="Permalink to this headline">¶</a></h3>
<p>In the project’s .syscfg file, look at the binding
configuration item <em>Binding Table Size</em>
(in <em>RF STACKS</em> → <em>Z-Stack</em> → <em>Advanced</em> → <em>Max Table Sizes</em>).
<em>Binding Table Size</em> is the maximum number of entries in the binding table.
After building the project, this value corresponds to <code class="code docutils literal notranslate"><span class="pre">NWK_MAX_BINDING_ENTRIES</span></code> in <code class="docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code> (see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>).</p>
<p>The binding table is maintained in static RAM (not allocated), so the number of entries directly impacts the amount of RAM used.
The size of each binding table entry is 14 bytes and allows up to 4 cluster IDs.
The binding table also affects the number of entries in the address manager.</p>
</div>
</div>
<div class="section" id="routing">
<span id="z-stack-overview-routing-overview"></span><h2>Routing<a class="headerlink" href="#routing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>A mesh network is described as a network in which the routing of
messages is performed as a decentralized, cooperative process involving
many peer devices routing on each others’ behalf.</p>
<p>The routing is completely hidden from the application layer.
The application simply sends data destined to any device down to the stack
which is then responsible for finding a route. In other words, the application
is unaware of the fact that it is operating in a multi-hop network.</p>
<p>Routing also enables the “self healing” nature of Zigbee networks. If a
particular wireless link is down, the routing functions will eventually
find a new route that avoids that particular broken link. This greatly
enhances the reliability of the wireless network and is one of the key
features of Zigbee.</p>
<p>Many-to-One routing is a special routing scheme that handles the
scenario where centralized traffic is involved. It is part of the Zigbee
PRO feature set to help minimize traffic particularly when all the
devices in the network are sending packets to a gateway or data
concentrator. Many-to-One route discovery is described in detail in
section <a class="reference internal" href="#z-stack-overview-many-to-one-routing-protocol"><span class="std std-ref">Many-to-One Routing Protocol</span></a>.</p>
</div>
<div class="section" id="routing-protocol">
<span id="z-stack-overview-routing-protocol"></span><h3>Routing Protocol<a class="headerlink" href="#routing-protocol" title="Permalink to this headline">¶</a></h3>
<p>Zigbee uses a routing protocol that is based on the AODV (Ad-hoc
On-demand Distance Vector) routing protocol for ad-hoc networks.
Simplified for use in sensor networks, the Zigbee routing protocol
facilitates an environment capable of supporting mobile nodes, link
failures and packet losses.</p>
<p>Neighbor routers are routers that are within radio range of each other.
Each router keeps track of their neighbors in a “neighbor table”, and
the “neighbor table” is updated when the router receives any message
from a neighbor router (unicast, broadcast, or beacon).</p>
<p>When a router receives a unicast packet, from its application or from
another device, the NWK layer forwards it according to the following
procedure. If the destination is one of the neighbors of the router
(including its child devices) the packet will be transmitted directly to
the destination device. Otherwise, the router will check its routing
table for an entry corresponding to the routing destination of the
packet. If there is an active routing table entry for the destination
address, the packet will be relayed to the next hop address stored in
the routing entry. If a single transmission attempt fails, the NWK layer
will repeat the process of transmitting the packet and waiting for the
acknowledgement, up to a maximum of <code class="code docutils literal notranslate"><span class="pre">NWK_MAX_DATA_RETRIES</span></code> times.
The maximum data retries in the NWK layer is configured in the project’s .syscfg file:
<em>RF STACKS</em> → <em>Z-Stack</em> → <em>Advanced</em> → <em>Packet Sending</em> → <em>Max Data Retries</em> (see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>).
If an active entry cannot be found in the routing table
or using an entry failed after the maximum number of retries, a route
discovery is initiated and the packet is buffered until that process is
completed.</p>
<p>Zigbee End Devices do not perform any routing functions. An end device
wishing to send a packet to any device simply forwards it to its parent
device which will perform the routing on its behalf. Similarly, when any
device wishes to send a packet to an end device and initiate route
discovery, the parent of the end device responds on its behalf.</p>
<p>Also in Z-Stack, the routing implementation has optimized the routing
table storage. In general, a routing table entry is needed for each
destination device. But by combining all the entries for end devices of
a particular parent with the entry for that parent device, storage is
optimized without loss of any functionality.</p>
<p>Zigbee routers, including the coordinator, perform the following routing
functions:
-  Route discovery and selection
-  Route maintenance
-  Route expiry
These are explained in more detail below.</p>
<div class="section" id="route-discovery-and-selection">
<h4>Route Discovery and Selection<a class="headerlink" href="#route-discovery-and-selection" title="Permalink to this headline">¶</a></h4>
<p>Route discovery is the procedure whereby network devices cooperate to
find and establish routes through the network. A route discovery can be
initiated by any router device and is always performed in regard to a
particular destination device. The route discovery mechanism searches
all possible routes between the source and destination devices and tries
to select the best possible route.</p>
<p>Route selection is performed by choosing the route with the least
possible cost. Each node constantly keeps track of “link costs” to all
of its neighbors. The link cost is typically a function of the strength
of the received signal. By adding up the link costs for all the links
along a route, a “route cost” is derived for the whole route. The
routing algorithm tries to choose the route with the least “route cost”.</p>
<p>Routes are discovered by using request/response packets. A source device
requests a route for a destination address by broadcasting a Route
Request (RREQ) packet to its neighbors. When a node receives an RREQ
packet it in turn rebroadcasts the RREQ packet. But before doing that,
it updates the cost field in the RREQ packet by adding the link cost for
the latest link and makes an entry in its <a class="reference internal" href="#z-stack-overview-route-discovery-table"><span class="std std-ref">Route Discovery Table</span></a>.</p>
<p>This way, the RREQ packet carries the sum of the link costs along all
the links that it traverses. This process repeats until the RREQ reaches
the destination device. Many copies of the RREQ will reach the
destination device traveling via different possible routes. Each of
these RREQ packets will contain the total route cost along the route
that it traveled. The destination device selects the best RREQ packet
and sends back a Route Reply (RREP) back to the source.</p>
<p>The RREP is unicast along the reverse routes of the intermediate nodes
until it reaches the original requesting node. As the RREP packet
travels back to the source, the intermediate nodes update their routing
tables to indicate the route to the destination. The Route Discovery
Table, at each intermediate node, is used to determine the next hop of
the RREP traveling back to the source of the RREQ and to make the entry
in to the Routing Table.</p>
<p>Once a route is created, data packets can be sent. When a node loses
connectivity to its next hop (it doesn’t receive a MAC ACK when sending
data packets), the node invalidates its route by sending an RERR to all
nodes that potentially received its RREP and marks the link as bad in
its Neighbor Table. Upon receiving a RREQ, RREP, or RERR, the nodes
update their routing tables.</p>
</div>
<div class="section" id="route-maintenance">
<h4>Route Maintenance<a class="headerlink" href="#route-maintenance" title="Permalink to this headline">¶</a></h4>
<p>Mesh networks provide route maintenance and self healing. Intermediate
nodes keep track of transmission failures along a link. If a link
(between neighbors) is determined as bad, the upstream node will
initiate route repair for all routes that use that link. This is done by
initiating a rediscovery of the route the next time a data packet
arrives for that route. If the route rediscovery cannot be initiated, or
it fails for some reason, a route error (RERR) packet is sent back to
source of the data packet, which is then responsible for initiating the
new route discovery. Either way the route gets re-established
automatically.</p>
</div>
<div class="section" id="route-expiry">
<h4>Route Expiry<a class="headerlink" href="#route-expiry" title="Permalink to this headline">¶</a></h4>
<p>The routing table maintains entries for established routes. If no data
packets are sent along a route for a period of time, the route will be
marked as expired. Expired routes are not deleted until space is needed.
Thus routes are not deleted until it is absolutely necessary.
The automatic route expiry time can be configured in SysConfig: <em>RF STACKS</em> → <em>Z-Stack</em> → <em>Advanced</em> → <em>Routing</em> (see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>).
Units are in seconds. To disable this feature, set this value to 0.</p>
</div>
</div>
<div class="section" id="table-storage">
<span id="z-stack-overview-routing-table-storage"></span><h3>Table Storage<a class="headerlink" href="#table-storage" title="Permalink to this headline">¶</a></h3>
<p>The routing functions require the routers to maintain some tables.</p>
<div class="section" id="routing-table">
<h4>Routing Table<a class="headerlink" href="#routing-table" title="Permalink to this headline">¶</a></h4>
<p>Each Zigbee router, including the Zigbee coordinator, contains a routing
table in which the device stores information required to participate in
the routing of packets. Each routing table entry contains the
destination address, the next hop node, and the link status. All packets
sent to the destination address are routed through the next hop node.
Also entries in the routing table can expire in order to reclaim table
space from entries that are no longer in use.</p>
<p>Routing table capacity indicates that a device routing table has a free
routing table entry or it already has a routing table entry
corresponding to the destination address. The routing table size is
configured in the project’s .syscfg file (see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>).
This corresponds to <code class="code docutils literal notranslate"><span class="pre">MAX_RTG_ENTRIES</span></code> in the generated <code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code> file.
See the section on Route Maintenance for
route expiration details.</p>
</div>
<div class="section" id="route-discovery-table">
<span id="z-stack-overview-route-discovery-table"></span><h4>Route Discovery Table<a class="headerlink" href="#route-discovery-table" title="Permalink to this headline">¶</a></h4>
<p>Router devices involved in route discovery, maintain a route discovery
table. This table is used to store temporary information while a route
discovery is in progress. These entries only last for the duration of
the route discovery operation. Once an entry expires it can be used for
another route discovery operation. Thus this value determines the
maximum number of route discoveries that can be simultaneously performed
in the network.
This value is configured in the project’s .syscfg file:
<em>RF STACKS</em> → <em>Z-Stack</em> → <em>Advanced</em> → <em>Routing</em> → <em>Max Route Request Entries</em>.
(See <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>).</p>
</div>
</div>
<div class="section" id="many-to-one-routing-protocol">
<span id="z-stack-overview-many-to-one-routing-protocol"></span><h3>Many-to-One Routing Protocol<a class="headerlink" href="#many-to-one-routing-protocol" title="Permalink to this headline">¶</a></h3>
<p>The following explains Many-to-One and source routing procedure for
users’ better understanding of Zigbee routing protocol. In reality, all
routings are taken care in the network layer and transparent to the
application. Issuing Many-to-One route discovery and route maintenance
are application decisions.</p>
<div class="section" id="many-to-one-routing-overview">
<h4>Many-to-One Routing Overview<a class="headerlink" href="#many-to-one-routing-overview" title="Permalink to this headline">¶</a></h4>
<p>Many-to-One routing is adopted in Zigbee PRO to help minimize traffic
particularly when centralized nodes are involved. It is common for low
power wireless networks to have a device acting as a gateway or data
concentrator. All nodes in the networks shall maintain at least one
valid route to the central node. To achieve this, all nodes have to
initiate route discovery for the concentrator, relying on the existing
Zigbee AODV based routing solution. The route request broadcasts will
add up and produce huge network traffic overhead. To better optimize the
routing solution, Many-to-One routing is adopted to allow a data
concentrator to establish routes from all nodes in the network with one
single route discovery and minimize the route discovery broadcast storm.</p>
<p>Source routing is part of the Many-to-One routing that provides an
efficient way for concentrator to send response or acknowledgement back
to the destination. The concentrator places the complete route
information from the concentrator to the destination into the data frame
which needs to be transmitted. It minimizes the routing table size and
route discovery traffic in the network.</p>
</div>
<div class="section" id="many-to-one-route-discovery">
<h4>Many-to-One Route Discovery<a class="headerlink" href="#many-to-one-route-discovery" title="Permalink to this headline">¶</a></h4>
<p>The following figure shows an example of the Many-to-One route discovery
procedure. To initiate Many-to-One route discovery, the concentrator
broadcast a Many-to-One route request to the entire network. Upon
receipt of the route request, every device adds a route table entry for
the concentrator and stores the one hop neighbor that relays the request
as the next hop address. No route reply will be generated.</p>
<div class="figure align-center" id="id15">
<img alt="../_images/figure2.png" src="../_images/figure2.png" />
<p class="caption"><span class="caption-number">Figure 48. </span><span class="caption-text">Many-to-One route discovery illustration</span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></p>
</div>
<p>Many-to-One route request command is similar to unicast route request
command with same command ID and payload frame format. The option field
in route request is Many-to-One and the destination address is 0xFFFC.
The following <a class="reference external" href="../../../zigbee/zstack-apis.html">Z-Stack API</a> can be used for the concentrator to send out
Many-to-One route request. Please refer to the <a class="reference external" href="../../../zigbee/zstack-apis.html">Z-Stack API</a>
documentation for detailed usage about this API.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zstack_ZStatusValues</span><span class="w"> </span><span class="n">Zstackapi_DevNwkRouteReq</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">appServiceTaskId</span><span class="p">,</span><span class="w"> </span><span class="n">zstack_devNwkRouteReq_t</span><span class="w"> </span><span class="o">*</span><span class="n">pReq</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The option field is a bitmask to specify options for the route request.
It can have the following values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Value</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00</p></td>
<td><p>Unicast route discovery</p></td>
</tr>
<tr class="row-odd"><td><p>0x01</p></td>
<td><p>Many-to-One route discovery with route cache (the concentrator
does not have memory constraints).</p></td>
</tr>
<tr class="row-even"><td><p>0x03</p></td>
<td><p>Many-to-One route discovery with no route cache (the concentrator
has memory constraints)</p></td>
</tr>
</tbody>
</table>
<p>When the option field has value 0x01 or 0x03, the DstAddress field will
be overwritten with the Many-to-One destination address 0xFFFC.
Therefore, in a Many-to-One request, it is irrelevant what value the application sets the DstAddress to.</p>
</div>
<div class="section" id="route-record-command">
<h4>Route Record Command<a class="headerlink" href="#route-record-command" title="Permalink to this headline">¶</a></h4>
<p>The above Many-to-One route discovery procedure establishes routes from
all devices to the concentrator. The reverse routing (from concentrator
to other devices) is done by route record command (source routing
scheme). The procedure is provided in the <a class="reference internal" href="#fig-figure3"><span class="std std-ref">Route record command (source routing) illustration</span></a>. <em>R1</em>
sends data packet DATA to the concentrator using the previously
established Many-to-One route and expects an acknowledgement back. To
provide a route for the concentrator to send the ACK back, <em>R1</em> sends
route record command along with the data packet which records the
routing path the data packet goes through and offers the concentrator a
reverse path to send the ACK back.</p>
<div class="figure align-center" id="id16">
<span id="fig-figure3"></span><img alt="../_images/figure3.png" src="../_images/figure3.png" />
<p class="caption"><span class="caption-number">Figure 49. </span><span class="caption-text">Route record command (source routing) illustration</span><a class="headerlink" href="#id16" title="Permalink to this image">¶</a></p>
</div>
<p>Upon receipt of the route record command, devices on the relay path will
append their own network addresses to the relay list in the route record
command payload. By the time the route record command reaches the
concentrator, it includes the complete routing path through which the
data packet is relayed to the concentrator. Whenever the concentrator sends
an APS ACK to <em>R1</em> in response to a data frame (not due to a route record
command itself), it shall include the source route (relay list) in the
network layer header of the packet. All devices receiving the packet
shall relay the packet to the next hop device according to the source
route.</p>
<p>A concentrator with no memory constraints can store all route
record entries it receives and use them to send packets to the source
devices in the future. Therefore, devices only need to send a route record
command once. However, for a concentrator without source route caching
capability, devices always need to send route record commands along with
data packets. The concentrator will store the source route temporarily
in the memory and then discard it after usage.</p>
<p>In brief, Many-to-One routing is an efficient enhancement to the regular
Zigbee unicast routing when most devices in the network are funneling
traffic to a single device. As part of the Many-to-One routing, source
routing is only utilized under certain circumstances. First, it is used
when the concentrator is responding to a request initiated by the source
device. Second, the concentrator should store the source route
information for all devices if it has sufficient memory. If not,
whenever devices issue requests to the concentrator, they should also
send a route record along with it.</p>
</div>
<div class="section" id="many-to-one-route-maintenance">
<h4>Many-to-One Route Maintenance<a class="headerlink" href="#many-to-one-route-maintenance" title="Permalink to this headline">¶</a></h4>
<p>If a link failure is encountered while a device is forwarding a
Many-to-One routed frame (notice that a Many-to-One routed frame itself
has no difference from a regular unicast data packet, however, the
routing table entry has a field to specify that the destination is a
concentrator), the device will generate a network status command with
code “Many-to-One route failure”. The network status command will be
relayed to the concentrator through a random neighbor and hopefully that
neighbor still has a valid route to the concentrator. When the
concentrator receives the route failure, the application will decide
whether or not to re-issue a Many-to-One route request.</p>
<p>When the concentrator receives network status command indicating
Many-to-One route failure, it passes the indication to the ZDO layer and
the <code class="code docutils literal notranslate"><span class="pre">ZDO_ManytoOneFailureIndicationCB</span></code> function in <code class="code docutils literal notranslate"><span class="pre">zd_app.c</span></code>
is called.</p>
<p>By default, this function will redo a Many-to-One route discovery to
recover the routes. You can modify this function if you want a more
complicated process other than the default.</p>
</div>
</div>
<div class="section" id="routing-settings-quick-reference">
<span id="z-stack-overview-routing-settings-quick-reference"></span><h3>Routing Settings Quick Reference<a class="headerlink" href="#routing-settings-quick-reference" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a> for macros generated from SysConfig.</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 49%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Setting Routing Table Size</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">MAX_RTG_ENTRIES</span></code> in SysConfig</p>
<p>Note: the value must be greater than 4.</p>
</td>
</tr>
<tr class="row-even"><td><p>Setting Route Expiry Time</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">ROUTE_EXPIRY_TIME</span></code> in SysConfig
to expiry time in seconds. Set to 255/0xFF in
order to turn off route expiry.</p></td>
</tr>
<tr class="row-odd"><td><p>Setting Route Discovery Table Size</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">MAX_RREQ_ENTRIES</span></code> in SysConfig to
the maximum number of simultaneous route
discoveries enabled in the network.</p></td>
</tr>
<tr class="row-even"><td><p>Enable Concentrator</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">CONCENTRATOR_ENABLE</span></code>
(See <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p>Setting Concentrator Property – With Route Cache</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">CONCENTRATOR_ROUTE_CACHE</span></code>
(See <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p>Setting Source Routing Table Size</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">MAX_RTG_SRC_ENTRIES</span></code>
(See <code class="code docutils literal notranslate"><span class="pre">nwk_globals.h</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p>Setting Default Concentrator Broadcast Radius</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">CONCENTRATOR_RADIUS</span></code>
(See <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="router-off-network-association-cleanup">
<span id="z-stack-overview-routing-off-network-association-cleanup"></span><h3>Router Off-Network Association Cleanup<a class="headerlink" href="#router-off-network-association-cleanup" title="Permalink to this headline">¶</a></h3>
<p>In case a Zigbee Router gets off network for a long period of time, its
children will try to join an alternative parent. When the router is back
online, the children will still appear in its child table, preventing
proper routing of egress traffic to them.</p>
<p>In order to avoid this, it is recommended that routers prone to get off
and on the network will have <code class="code docutils literal notranslate"><span class="pre">zgRouterOffAssocCleanup</span></code> flag set to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>
(mapped to NV item: <code class="code docutils literal notranslate"><span class="pre">ZCD_NV_ROUTER_OFF_ASSOC_CLEANUP</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">zgRouterOffAssocCleanup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span><span class="w"></span>

<span class="n">zgSetItem</span><span class="p">(</span><span class="w"> </span><span class="n">ZCD_NV_ROUTER_OFF_ASSOC_CLEANUP</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">cleanupChildTable</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cleanupChildTable</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>When enabled, deprecated end device entries will be removed from the
child table if traffic received from them was routed by another parent.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This will also be handled by <a class="reference internal" href="#sec-parent-annce"><span class="std std-ref">Parent Annce</span></a> functionality</p>
</div>
</div>
</div>
<div class="section" id="zdo-message-requests">
<span id="z-stack-overview-zdo-message-request"></span><h2>ZDO Message Requests<a class="headerlink" href="#zdo-message-requests" title="Permalink to this headline">¶</a></h2>
<p>The ZDO module provides functions to send ZDO service discovery request
messages and receive ZDO service discovery response messages. The
following flow diagram illustrates the function calls need to issue an
IEEE Address Request and receive the IEEE Address Response for an
application, as it is managed by the stack.</p>
<div class="figure align-center" id="id17">
<p class="plantuml">
<img src="../_images/plantuml-48ff9d6273d97209a71af01dd8f61b4b756885f2.png" alt="&#64;startuml
participant &quot;Other Devices&quot;
participant &quot;ZDO Layer&quot;
participant &quot;Application Layer&quot;
&quot;Application Layer&quot;-&gt;&quot;ZDO Layer&quot;: ZDO_RegisterForZDOMsg(taskID,IEEE_addr_rsp)
note right: Register with ZDO that you want all ZDO\n IEEE Address Response

&quot;Application Layer&quot;-&gt;&quot;ZDO Layer&quot;: ZDP_IEEEAddrReq(devAddr,...)
note right: Request a ZDO IEEE Address

&quot;ZDO Layer&quot;-&gt;&quot;Other Devices&quot;: Over the Air Request
activate &quot;Other Devices&quot;
&quot;Other Devices&quot;--&gt;&quot;ZDO Layer&quot;: Over the Air Response
deactivate &quot;Other Devices&quot;

&quot;ZDO Layer&quot;-&gt;&quot;Application Layer&quot;: OsalMsg(ZDO_CB_MSG) for ZDO_IEEE_Addr_Rsp
activate &quot;Application Layer&quot;
note right: Message Delivered to the application's event\nprocessor as an OSAL message
&quot;Application Layer&quot;&lt;-&gt;&quot;ZDO Layer&quot;: ZDO_ParseAddrRsp(inMsg)
note right
Parse the incoming message. The function
returns an allocated structure that contains
the IEEE Address Response fields.
end note
&quot;Application Layer&quot;--&gt;&quot;ZDO Layer&quot;: ZDO_RemoveRegisteredCB(taskID,IEEE_addr_rsp)
note right: Remove the registration for incoming\nIEEE Address Response
deactivate &quot;Application Layer&quot;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 50. </span><span class="caption-text">ZDO IEEE Address Request and Response</span><a class="headerlink" href="#id17" title="Permalink to this image">¶</a></p>
</div>
<p>In the following example, an application would like to know when any new
devices join the network. The application would like to receive all ZDO
Device Announce (Device_annce) messages.</p>
<div class="figure align-center" id="id18">
<p class="plantuml">
<img src="../_images/plantuml-f3edf2501c00096b26a70f71103773f0df7e2398.png" alt="&#64;startuml
participant &quot;Other Devices&quot;
participant &quot;ZDO Layer&quot;
participant &quot;Application Layer&quot;
&quot;Application Layer&quot;-&gt;&quot;ZDO Layer&quot;: ZDO_RegisterForZDOMsg(taskID,Device_annce)
note right: Register with ZDO that you want all ZDO\n Device Announce Messages
&quot;ZDO Layer&quot;-&gt;&quot;Other Devices&quot;: Device Announce
&quot;ZDO Layer&quot;--&gt;&quot;Application Layer&quot;: OsalMsg(ZDO_CB_MSG) for Device Announce
activate &quot;Application Layer&quot;
note right: This message is delivered to the application's\nevent processor as an OSAL message
&quot;Application Layer&quot;-&gt;&quot;ZDO Layer&quot;: ZDO_ParseDeviceAnnce(inMsg, pAnnce)
note right
Parse the incoming message. The application passes
into the function a pointer to Device Announce structure.
The parsing function will fill the structure with the
message data.
end note
deactivate &quot;Application Layer&quot;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 51. </span><span class="caption-text">ZDO Device Announce Delivered to an Application</span><a class="headerlink" href="#id18" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="portable-devices">
<span id="z-stack-overview-portable-devices"></span><h2>Portable Devices<a class="headerlink" href="#portable-devices" title="Permalink to this headline">¶</a></h2>
<p>An End Device detects that a parent isn’t responding either through
polling (MAC data requests) failures and/or through data message
failures. The sensitivity to the failures (amount of consecutive errors)
is controlled by calling <code class="code docutils literal notranslate"><span class="pre">Zstackapi_sysConfigWriteReq()</span></code>. In the
<code class="code docutils literal notranslate"><span class="pre">zstack_sysConfigWriteReq_t</span></code> argument, set <code class="code docutils literal notranslate"><span class="pre">has_maxMissingMacAckLinkFailure</span></code>
to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code> and <code class="code docutils literal notranslate"><span class="pre">maxMissingMacAckLinkFailure</span></code> to the number of failures (the
higher the number, the less sensitive and the longer it will take to rejoin).
The default value is determined by <code class="code docutils literal notranslate"><span class="pre">MAX_MISSING_MAC_ACK_LINK_FAILURE</span></code>
inside <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>.</p>
<p>When the network layer detects that its parent isn’t responding, it will
notify the application that it has lost its parent through the BDB
interface (see <a class="reference internal" href="#z-stack-overview-parent-lost"><span class="std std-ref">Parent Lost</span></a>). The application
is responsible for managing the rejoining of the device by using the BDB API
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbRecoverNwkReq()</span></code>, which will trigger the
process of scanning the channel in which this device was commissioned,
in order to search another suitable parent device. It is recommended
that as soon as an end device loses its parent, it should try to
recover. If recovery fails, the device should try once again after a
short delay, and if it still fails, it should retry periodically with a
larger waiting period. This practice allows for better power usage on
the end device and does not interfere with other networks that may be on
the same channel.</p>
<p>In secure networks, it is assumed that the device already has a key and
a new key isn’t issued to the device.</p>
<p>The end device’s short address is retained when it moves from parent to
parent; routes to such end devices are re-established automatically.</p>
</div>
<div class="section" id="end-to-end-acknowledgements">
<span id="z-stack-overview-end-toend-ack"></span><h2>End-to-End Acknowledgements<a class="headerlink" href="#end-to-end-acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>For non-broadcast messages, there are basically 2 types of message
retries: end-to-end acknowledgement (APS ACK) and single-hop
acknowledgement (MAC ACK). MAC ACKs are always on by default and are
usually sufficient to guarantee a high degree of reliability in the
network. To provide additional reliability, as well as to enable the sending device
to get confirmation that a packet has been delivered to its destination,
APS acknowledgements may be used.</p>
<p>APS acknowledgement is done at the APS layer and is an acknowledgement
system from the destination device to the source device. The sending
device will hold the message until the destination device sends an APS
ACK message indicating that it received the message.
When sending a message with <code class="code docutils literal notranslate"><span class="pre">AF_DataRequest</span></code>, APS ACK for that message
can be enabled by setting the <code class="code docutils literal notranslate"><span class="pre">AF_ACK_REQUEST</span></code> bit in the <code class="code docutils literal notranslate"><span class="pre">options</span></code> argument.
The number of times that the message is retried (if APS ACK
message isn’t received) and the timeout between retries are
configuration items in <code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code>.
<code class="code docutils literal notranslate"><span class="pre">APSC_MAX_FRAME_RETRIES</span></code> is the maximum number of times the APS layer will
retry sending a message if it doesn’t receive an APS ACK,
this is configured in the project’s .syscfg file: <em>RF STACKS</em> → <em>Z-Stack</em> → <em>Advanced</em> → <em>Packet Sending</em> → <em>APS Retries</em>).
<code class="code docutils literal notranslate"><span class="pre">APSC_ACK_WAIT_DURATION_POLLED</span></code> is the amount of time between retries
(this is configured in the project’s .syscfg file: <em>RF STACKS</em> → <em>Z-Stack</em> → <em>Advanced</em> → <em>Packet Sending</em> → <em>APS ACK Wait Duration</em>).</p>
<p>The following examples demonstrate how end-to-end acknowledgements can be configured
and handled within a <code class="code docutils literal notranslate"><span class="pre">zcl_samplesw</span></code> project.</p>
<ul>
<li><p>Add a zcl options struct</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">zclOptionRec_t</span><span class="w"> </span><span class="n">zclOptions</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ZCL_CLUSTER_ID_GENERAL_ON_OFF</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="n">AF_ACK_REQUEST</span><span class="w"> </span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Define a global variable to save APS counter, <code class="code docutils literal notranslate"><span class="pre">uint8</span> <span class="pre">savedAPSCount;</span></code></p></li>
<li><p>Place <code class="code docutils literal notranslate"><span class="pre">zcl_registerClusterOptionList(SAMPLESW_ENDPOINT,1,zclOptions);</span></code>
inside of <code class="code docutils literal notranslate"><span class="pre">zclSampleSw_Init()</span></code> to register the cluster options.</p></li>
<li><p>Save the APS counter (<code class="code docutils literal notranslate"><span class="pre">savedAPSCount</span> <span class="pre">=</span> <span class="pre">APS_Counter;</span></code>) before sending the toggle command
(<code class="code docutils literal notranslate"><span class="pre">zclGeneral_SendOnOff_CmdToggle(</span> <span class="pre">SAMPLESW_ENDPOINT,</span> <span class="pre">&amp;zclSampleSw_DstAddr,</span> <span class="pre">FALSE,</span> <span class="pre">Rsp.zclFrameCounter</span> <span class="pre">);</span></code>)</p></li>
<li><p>Add <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_AF_DATA_CONFIRM_IND</span></code> processing to <code class="code docutils literal notranslate"><span class="pre">zclSampleSw_processZStackMsgs()</span></code></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="nl">zstackmsg_CmdIDs_AF_DATA_CONFIRM_IND</span><span class="p">:</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">zstackmsg_afDataConfirmInd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pInd</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">zstackmsg_afDataConfirmInd_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">pMsg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">savedAPSCount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pInd</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">transID</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// PERFORM ACTION HERE</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">break</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>All APS layer commands will generate an AF data confirm. The difference between using the <code class="code docutils literal notranslate"><span class="pre">APS_ACK_REQUEST</span></code> flag
is that a <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_AF_DATA_CONFIRM_IND</span></code> is received only when the APS ACK indication arrives.
Otherwise, with the APS ACK flag disabled, <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_AF_DATA_CONFIRM_IND</span></code> occurs whenever the stack sends
out an APS layer frame successfully or will return a fail message to notify the application of an issue.  These can
include <code class="code docutils literal notranslate"><span class="pre">ZMacTxAborted</span></code> (buffer queue could be full or another RF stack maintains priority),
<code class="code docutils literal notranslate"><span class="pre">ZMacCHannelAccessFailure</span></code> (CSMA/CA protocol failed due to network traffic or interference), and
<code class="code docutils literal notranslate"><span class="pre">ZMacTransactionExpired</span></code> (timeout occurred before sleepy ZED sent a data poll).</p>
</div>
<div class="section" id="miscellaneous">
<span id="z-stack-overview-miscellaneous"></span><h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuring-channel">
<span id="z-stack-overview-configuring-channel"></span><h3>Configuring Channel<a class="headerlink" href="#configuring-channel" title="Permalink to this headline">¶</a></h3>
<p>Every Zigbee 3.0 device has a primary channel mask configuration
(<code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_PRIMARY_CHANNEL_SET</span></code>) and a secondary channel mask
configuration (<code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_SECONDARY_CHANNEL_SET</span></code>).
For devices with formation capabilities that were instructed to create a network, these
channels masks are used when scanning for a channel with the least
number of networks to create the new network on. For devices with joining
capabilities that were instructed to join a network, these channel masks
are used when scanning for existing networks to join. The device will
try first with all the channels defined in the primary channel mask.
If the process is not successful
(the network was not created or no network to join was found),
then the secondary channel mask is used.
These two channel masks can be configured by the application as needed. A
value of 0 in one of these masks will disable the respective channel
scanning phase (primary or secondary).</p>
<p>The default primary channel mask is defined as
<code class="code docutils literal notranslate"><span class="pre">DEFAULT_CHANLIST</span></code>,
and the secondary channel mask is defined as
<code class="code docutils literal notranslate"><span class="pre">SECONDARY_CHANLIST</span></code>.
Both channel masks are in <code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code>,
which is generated from the project’s .syscfg (<em>RF STACKS</em> → <em>Z-Stack</em> → <em>Radio</em>).
The <a class="reference internal" href="#z-stack-overview-commissioning"><span class="std std-ref">Commissioning</span></a> section
provides more details on the commissioning methods.</p>
</div>
<div class="section" id="configuring-the-pan-id-and-network-to-join">
<span id="z-stack-overview-configuring-pan-id-and-network-joining"></span><h3>Configuring the PAN ID and Network to Join<a class="headerlink" href="#configuring-the-pan-id-and-network-to-join" title="Permalink to this headline">¶</a></h3>
<p>The 16-bit PANID of a network is determined by the <code class="code docutils literal notranslate"><span class="pre">ZDAPP_CONFIG_PAN_ID</span></code> parameter in <code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code>,
as generated by the .syscfg file of the project (see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>).</p>
<p>If set to a value between 0x0000 and 0xFFFE (inclusive),
a coordinator or a network-forming router will use this value as the PAN ID of the network when instructed to create a network, and
a joining router or end device will only join a network that has a PAN ID which matches the value of this parameter.</p>
<p>If set to 0xFFFF,
a newly formed network will have a random PAN ID, and
a joining device will be able to join any network regardless of its PAN ID.</p>
<p>This is an optional configuration item to control which network a Zigbee
Router or End Device will join. It can also be used to pre-set the PAN
ID of a new network that a coordinator or router will create.</p>
<p>The network discovery process is managed by the Network Steering
commissioning process, which is explained in <a class="reference internal" href="#z-stack-overview-nwk-steering-not-on-nwk"><span class="std std-ref">Network Steering Procedure for a Node not on a Network</span></a>.
It allows filtering of the discovered networks.
After the scan (using either primary or secondary channel masks) is complete,
the application receives a list of network descriptors of the networks
found during the scan
(signified by a BDB Z-stack message <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_BDB_FILTER_NWK_DESCRIPTOR_IND</span></code>).
The application may skip attempting to join specific networks
by freeing the corresponding network descriptors using
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbNwkDescFreeReq()</span></code>.</p>
<p>For further control of the joining procedure, the
<code class="code docutils literal notranslate"><span class="pre">ZDO_NetworkDiscoveryConfirmCB</span></code> function in the <code class="code docutils literal notranslate"><span class="pre">zd_app.c</span></code> should be
modified. This function is called when the network layer has finished the Network Discovery process.
The Network Discovery process can be started by calling <code class="code docutils literal notranslate"><span class="pre">NLME_NetworkDiscoveryRequest()</span></code>,
detailed in the <a class="reference external" href="../../../zigbee/zstack-apis.html">Z-Stack API</a> document.</p>
</div>
<div class="section" id="maximum-payload-size">
<span id="z-stack-overview-maximum-payload-size"></span><h3>Maximum Payload Size<a class="headerlink" href="#maximum-payload-size" title="Permalink to this headline">¶</a></h3>
<p>The maximum payload size for an application is based on several factors.
The MAC layer provides a constant payload length of 125 bytes (see <code class="code docutils literal notranslate"><span class="pre">MAC_MAX_FRAME_SIZE</span></code> in
<code class="code docutils literal notranslate"><span class="pre">mac_api.h</span></code>). The NWK layer requires a
fixed header size, one size with security and one without security. The
APS layer has a required, but variable, header size based on a variety
of settings, including the Zigbee Protocol Version, APS frame control
settings, etc. Ultimately, the user does not have to calculate the
maximum payload size using the aforementioned factors.
The AF module provides an API (see <code class="code docutils literal notranslate"><span class="pre">afDataReqMTU()</span></code> in <code class="code docutils literal notranslate"><span class="pre">AF.h</span></code>)
that allows the user to query the stack for the maximum payload size, or the maximum transport unit (MTU).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">kvp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">APSDE_DataReqMTU_t</span><span class="w"> </span><span class="n">aps</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">afDataReqMTU_t</span><span class="p">;</span><span class="w"></span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">afDataReqMTU</span><span class="p">(</span><span class="n">afDataReqMTU_t</span><span class="w"> </span><span class="o">*</span><span class="n">fields</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Currently the only field that should be set in the <code class="code docutils literal notranslate"><span class="pre">afDataReqMTU_t</span></code>
structure is kvp, which indicates whether KVP is being used.
This field should be set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>. The aps field is reserved for future use.</p>
</div>
<div class="section" id="leave-network">
<span id="z-stack-overview-leave-nwk"></span><h3>Leave Network<a class="headerlink" href="#leave-network" title="Permalink to this headline">¶</a></h3>
<p>The ZDO Management implements the function <code class="code docutils literal notranslate"><span class="pre">ZDO_ProcessMgmtLeaveReq()</span></code>,
which provides access to the “NLME-LEAVE.request” primitive.
“NLME-LEAVE.request” allows a device to remove itself or a remote
device from the network. The <code class="code docutils literal notranslate"><span class="pre">ZDO_ProcessMgmtLeaveReq()</span></code> removes the
device based on the provided IEEE address. When a device removes itself,
it will wait for <code class="code docutils literal notranslate"><span class="pre">LEAVE_RESET_DELAY</span></code> (5 seconds by default in <code class="code docutils literal notranslate"><span class="pre">zd_app.c</span></code>)
and then reset. When a device removes a child device, it also removes the device
from the local “association table”. The NWK address will only be reused
in the case where a child device is a Zigbee End Device. In the case of
a child Zigbee Router, the NWK address will not be reused.</p>
<p>If the parent of a child device leaves the network, the child will stay
on the network.</p>
<p>Since R21 of the Zigbee PRO specification, processing of “NWK Leave
Request” has been configurable for Routers. The application controls this
feature by setting the <code class="code docutils literal notranslate"><span class="pre">zgNwkLeaveRequestAllowed</span></code> variable to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>
(default value) to allow a Router to leave the network when a “NWK Leave Request”
is received. <code class="code docutils literal notranslate"><span class="pre">zgNwkLeaveRequestAllowed</span></code> is defined and initialized in
<code class="code docutils literal notranslate"><span class="pre">zglobals.c</span></code>, and the corresponding NV item,
<code class="code docutils literal notranslate"><span class="pre">ZCD_NV_NWK_LEAVE_REQ_ALLOWED</span></code>, is defined in <code class="code docutils literal notranslate"><span class="pre">zcomdef.h</span></code>. Processing
of these commands, depending on the logical device type, has also changed:
Coordinators do not process leave commands, Router devices process leave
commands from <em>any</em> device in the network (if allowed as mentioned
above), and end devices only process leave commands from their parent
device.</p>
<p>In the Base Device Behavior Specification, it is also stated that if any
device receives a valid leave request with rejoin set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> (meaning
that this device shall not rejoin the network), then that device is
forced to perform a Factory New reset. In this case, Z-Stack clears all
the Zigbee persistent data, while it is up to the application to clear
the relevant application data from NV.</p>
</div>
<div class="section" id="descriptors">
<span id="z-stack-overview-descriptors"></span><h3>Descriptors<a class="headerlink" href="#descriptors" title="Permalink to this headline">¶</a></h3>
<p>All devices in a Zigbee network have descriptors that describe the type
of device and its applications. This information is available to be
discovered by other devices in the network.</p>
<p>Configuration items are setup and defined in <code class="code docutils literal notranslate"><span class="pre">zd_config.c</span></code> and <code class="code docutils literal notranslate"><span class="pre">zd_config.h</span></code>.
These 2 files also contain the Node, Power Descriptors, and default User Descriptor.
Make sure to change these descriptors to define your device.</p>
</div>
<div class="section" id="asynchronous-links">
<span id="sec-asynchronous-links"></span><h3>Asynchronous Links<a class="headerlink" href="#asynchronous-links" title="Permalink to this headline">¶</a></h3>
<p>An asynchronous link occurs when a node can receive packets from another
node but it can’t send packets to that node. Whenever this happens, this
link is not a good link to route packets.</p>
<p>In Zigbee PRO, this problem is overcome by the use of the Network Link
Status message. Every router in a Zigbee PRO network sends a periodic
Link Status message. This message is a one hop broadcast message that
contains the sending device’s neighbor list. The idea is this – if you
receive your neighbor’s Link Status and you are either missing from the
neighbor list or your receive cost is too low (in the list), you can
assume that the link between you and this neighbor is an asynchronous
link and you should not use it for routing.</p>
<p>To change the time between Link Status messages you can change the
compile flag <code class="code docutils literal notranslate"><span class="pre">NWK_LINK_STATUS_PERIOD</span></code>, which is used to initialize
<code class="code docutils literal notranslate"><span class="pre">_NIB.nwkLinkStatusPeriod</span></code>. You can also change <code class="code docutils literal notranslate"><span class="pre">_NIB.nwkLinkStatusPeriod</span></code>
directly. Remember that only PRO routers send the link status message
and that every router in the network must have the same Link Status time
period.</p>
<p><code class="code docutils literal notranslate"><span class="pre">_NIB.nwkLinkStatusPeriod</span></code> contains the number of seconds between Link
Status messages, 15 by default.</p>
<p>Another parameter that affects the Link Status message is
<code class="code docutils literal notranslate"><span class="pre">_NIB.nwkRouterAgeLimit</span></code> (defaulted to <code class="code docutils literal notranslate"><span class="pre">NWK_ROUTE_AGE_LIMIT</span></code> of 3). This
represents the number of Link Status periods that a router can remain in
a device’s neighbor list, without receiving a Link Status from that
device, before it becomes aged out of the list. If a device doesn’t received a
Link Status message from a neighbor within (<code class="code docutils literal notranslate"><span class="pre">_NIB.nwkRouterAgeLimit</span></code> *
<code class="code docutils literal notranslate"><span class="pre">_NIB.nwkLinkStatusPeriod</span></code>), the device will age the neighbor out and assume that
this neighbor is missing or that it’s an asynchronous link and not use it.</p>
</div>
<div class="section" id="multicast-messages">
<h3>Multicast Messages<a class="headerlink" href="#multicast-messages" title="Permalink to this headline">¶</a></h3>
<p>This feature is a Zigbee PRO only feature (must have <code class="code docutils literal notranslate"><span class="pre">ZIGBEEPRO_PROFILE</span></code> as
the <code class="code docutils literal notranslate"><span class="pre">STACK_PROFILE_ID</span></code>). This feature is similar to sending to an APS Group, but
at the network layer.</p>
<p>A multicast message is sent from a device to a group as a MAC broadcast
message, which includes a non-member radius field. The receiving device will determine if it is part of that
group. If it isn’t part of the group, then it will decrement the non-member
radius and rebroadcast. If it is part of the group, then it will first set the non-member radius equal to
the group radius, and then rebroadcast the message. If the non-member radius is
decremented to 0, the message isn’t rebroadcast.</p>
<p>The difference between multicast and APS group messages can only be seen
in very large networks, where the non-member radius will limit the number
of hops away from the group.</p>
<p><code class="code docutils literal notranslate"><span class="pre">_NIB.nwkUseMultiCast</span></code> is used by the network layer to enable multicast
for all Group messages. <code class="code docutils literal notranslate"><span class="pre">MULTICAST_ENABLED</span></code> is defined in <code class="code docutils literal notranslate"><span class="pre">nwk_globals.h</span></code> as
the default setting but changes to <code class="code docutils literal notranslate"><span class="pre">nwkUseMultiCast</span></code> based on a
<code class="code docutils literal notranslate"><span class="pre">DEV_STATE_CHANGE</span></code> in <code class="code docutils literal notranslate"><span class="pre">zstacktask.c</span></code>.  If this field is <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>,
then the APS Group message is sent as a normal broadcast network message.</p>
<p><code class="code docutils literal notranslate"><span class="pre">APS_DEFAULT_NONMEMBER_RADIUS</span></code> is the value of the group radius and
the initial value of the non-member radius.
The application should use this variable to control the broadcast distribution.
If this number is too high, the effect will be the same as an APS group message.
This variable is defined in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>, and
<code class="code docutils literal notranslate"><span class="pre">ZCD_NV_APS_NONMEMBER_RADIUS</span></code> (defined in <code class="code docutils literal notranslate"><span class="pre">zcomdef.h</span></code>) is the NV item.</p>
</div>
<div class="section" id="fragmentation">
<h3>Fragmentation<a class="headerlink" href="#fragmentation" title="Permalink to this headline">¶</a></h3>
<p>Message Fragmentation is a process where a large message – too large to
send in one APS packet – is broken down and transmitted as smaller
fragments. The fragments of the larger message are then reassembled by
the receiving device.</p>
<p>To turn on the APS Fragmentation feature in your Z-Stack project include
the <code class="code docutils literal notranslate"><span class="pre">ZIGBEE_FRAGMENTATION</span></code> compile flag. By default, all
<code class="code docutils literal notranslate"><span class="pre">ZIGBEEPRO_PROFILE</span></code> projects include fragmentation, and there is no need to add
the <code class="code docutils literal notranslate"><span class="pre">ZIGBEE_FRAGMENTATION</span></code> compile flag. All applications using
fragmentation will include the APS Fragmentation task <code class="code docutils literal notranslate"><span class="pre">APSF_Init()</span></code> and
<code class="code docutils literal notranslate"><span class="pre">APSF_ProcessEvent()</span></code>.
If you have an existing application, make sure the
code in the <code class="code docutils literal notranslate"><span class="pre">zstackstartup.c</span></code> of your application has the following:</p>
<p>The header file <code class="code docutils literal notranslate"><span class="pre">aps_frag.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#if defined ( ZIGBEE_FRAGMENTATION )</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;aps_frag.h&quot;</span><span class="cp"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>An entry for <code class="code docutils literal notranslate"><span class="pre">APSF_ProcessEvent()</span></code> in <code class="code docutils literal notranslate"><span class="pre">zstackTasksArr[]</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">pTaskEventHandlerFn</span><span class="w"> </span><span class="n">zstackTasksArr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef NPI</span>
<span class="w">  </span><span class="n">MT_ProcessEvent</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="n">ZMacEventLoop</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">nwk_event_loop</span><span class="p">,</span><span class="w"></span>
<span class="cp">#if !defined (DISABLE_GREENPOWER_BASIC_PROXY) &amp;&amp; (ZG_BUILD_RTR_TYPE)</span>
<span class="w">  </span><span class="n">gp_event_loop</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="n">APS_event_loop</span><span class="p">,</span><span class="w"></span>
<span class="cp">#if defined ( ZIGBEE_FRAGMENTATION )</span>
<span class="w">  </span><span class="n">APSF_ProcessEvent</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="n">ZDApp_event_loop</span><span class="p">,</span><span class="w"></span>
<span class="cp">#if defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT )</span>
<span class="w">  </span><span class="n">ZDNwkMgr_event_loop</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="c1">//Added to include TouchLink functionality</span>
<span class="cp">#if defined ( INTER_PAN ) || defined ( BDB_TL_INITIATOR ) || defined ( BDB_TL_TARGET )</span>
<span class="w">  </span><span class="n">StubAPS_ProcessEvent</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="c1">// Added to include TouchLink initiator functionality</span>
<span class="cp">#if defined ( BDB_TL_INITIATOR )</span>
<span class="w">  </span><span class="n">touchLinkInitiator_event_loop</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="c1">// Added to include TouchLink target functionality</span>
<span class="cp">#if defined ( BDB_TL_TARGET )</span>
<span class="w">  </span><span class="n">touchLinkTarget_event_loop</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">bdb_event_loop</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ZStackTaskProcessEvent</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>And a call to <code class="code docutils literal notranslate"><span class="pre">APSF_Init()</span></code> in <code class="code docutils literal notranslate"><span class="pre">stackServiceFxnsInit()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">stackServiceFxnsInit</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">tmpServiceId</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">pTasksEvents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OsalPort_malloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">zstackTasksCnt</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef NPI</span>
<span class="w">    </span><span class="n">tmpServiceId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OsalPort_registerTask</span><span class="p">(</span><span class="n">stackTaskHndl</span><span class="p">,</span><span class="w"> </span><span class="n">stackSemHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mtServiceEvents</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MT_TaskInit</span><span class="p">(</span><span class="w"> </span><span class="n">tmpServiceId</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTasksEvents</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mtServiceEvents</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="c1">// ...</span>

<span class="cp">#if defined ( ZIGBEE_FRAGMENTATION )</span>
<span class="w">    </span><span class="n">tmpServiceId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OsalPort_registerTask</span><span class="p">(</span><span class="n">stackTaskHndl</span><span class="p">,</span><span class="w"> </span><span class="n">stackSemHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">apsfServiceEvents</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">APSF_Init</span><span class="p">(</span><span class="w"> </span><span class="n">tmpServiceId</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTasksEvents</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">apsfServiceEvents</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="c1">// ...</span>

<span class="w">    </span><span class="n">stackServiceId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OsalPort_registerTask</span><span class="p">(</span><span class="n">stackTaskHndl</span><span class="p">,</span><span class="w"> </span><span class="n">stackSemHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zstackServiceEvents</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ZStackTaskInit</span><span class="p">(</span><span class="w"> </span><span class="n">stackServiceId</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTasksEvents</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zstackServiceEvents</span><span class="p">;</span><span class="w"></span>

<span class="cp">#if defined(FLASH_ROM_BUILD)</span>
<span class="w">  </span><span class="c1">// initialize the Common ROM</span>
<span class="w">  </span><span class="n">CommonROM_Init</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// initialize the TIMAC ROM</span>
<span class="w">  </span><span class="n">ROM_Init</span><span class="p">();</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* FLASH_ROM_BUILD */</span><span class="cp"></span>

<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>When APS Fragmentation is turned on, sending a data request with a
payload larger than a normal data request payload will automatically
trigger fragmentation.</p>
<p>Fragmentation parameters are in the structure <code class="code docutils literal notranslate"><span class="pre">afAPSF_Config_t</span></code>, which
is part of the Endpoint Descriptor list <code class="code docutils literal notranslate"><span class="pre">epList_t</span></code> defined in <code class="code docutils literal notranslate"><span class="pre">AF.h</span></code>.
Default values for these parameters are used when calling <code class="code docutils literal notranslate"><span class="pre">Zstackapi_AfRegisterReq()</span></code>
to register the Application’s Endpoint Descriptor.
The default values <code class="code docutils literal notranslate"><span class="pre">APSF_DEFAULT_WINDOW_SIZE</span></code> and <code class="code docutils literal notranslate"><span class="pre">APSF_DEFAULT_INTERFRAME_DELAY</span></code>
are defined in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">APSF_DEFAULT_WINDOW_SIZE</span></code> - The size of a Tx window when using
fragmentation. This is the number of fragments that are sent before
an APS Fragmentation ACK is expected. For example, if the message is broken up
into 10 fragments and the max window size is 5, then an ACK will be
sent by the receiving device after 5 fragments are received. If one
packet of the window size isn’t received, the ACK is not sent and all
the packets (within that window) are resent.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">APSF_DEFAULT_INTERFRAME_DELAY</span></code> – The delay between fragments within
a window. This is used by the sending device.</p></li>
</ul>
<p>The application can read and set these values by calling
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_AfConfigGetReq()</span></code> and <code class="code docutils literal notranslate"><span class="pre">Zstackapi_AfConfigSetReq()</span></code>, respectively.</p>
<p>It is recommended that the application/profile update the
<code class="code docutils literal notranslate"><span class="pre">MaxInTransferSize</span></code> and <code class="code docutils literal notranslate"><span class="pre">MaxOutTransferSize</span></code> of the ZDO Node Descriptor for
the device (see <code class="code docutils literal notranslate"><span class="pre">ZDConfig_UpdateNodeDescriptor()</span></code> in <code class="code docutils literal notranslate"><span class="pre">zd_config.c</span></code>).
These fields are initialized with <code class="code docutils literal notranslate"><span class="pre">MAX_TRANSFER_SIZE</span></code> (defined in <code class="code docutils literal notranslate"><span class="pre">zd_config.h</span></code>).
These values are not used in the APS layer as maximums; they are information only.</p>
<div class="section" id="quick-reference">
<h4>Quick Reference<a class="headerlink" href="#quick-reference" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Compile flag to activate the feature</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">ZIGBEE_FRAGMENTATION</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Maximum fragments in a window default value</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">APSF_DEFAULT_WINDOW_SIZE</span></code> (defined in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p>Interframe delay default value</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">APSF_DEFAULT_INTERFRAME_DELAY</span></code> (defined in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p>Application/Profile maximum buffer size</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">MAX_TRANSFER_SIZE</span></code> (defined in <code class="code docutils literal notranslate"><span class="pre">zd_config.h</span></code>)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="extended-pan-ids">
<span id="extended-pan-id"></span><h3>Extended PAN IDs<a class="headerlink" href="#extended-pan-ids" title="Permalink to this headline">¶</a></h3>
<p>By default, the 64-bit Extended PAN ID (EPID) is set to the device’s own IEEE address.
If a pre-determined EPID is required, the developer changes this in the project’s .syscfg file.</p>
<p>There are two Extended PAN ID (EPID) items used in the Z-Stack:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">zgApsUseExtendedPANID</span></code>: If a valid EPID, this is the 64-bit PAN identifier of the
network to join or form, and may be modified at run time with Zstackapi_sysConfigWriteReq.
However, the default value is 0x0000000000000000, indicating that for network formation, zgExtendedPANID is the next EPID candidate,
and that for network joining, it is acceptable to join a network with any valid EPID.
Corresponds to the <code class="code docutils literal notranslate"><span class="pre">ZCD_NV_APS_USE_EXT_PANID</span></code> NV item.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">zgExtendedPANID</span></code>:
Possible EPID candidate for network formation.
This corresponds to the <code class="code docutils literal notranslate"><span class="pre">ZCD_NV_EXTENDED_PAN_ID</span></code> NV item.</p></li>
</ul>
</div>
<div class="section" id="rejoining-with-pre-commissioned-network-parameters">
<h3>Rejoining with Pre-Commissioned Network Parameters<a class="headerlink" href="#rejoining-with-pre-commissioned-network-parameters" title="Permalink to this headline">¶</a></h3>
<p>In previous Zigbee stacks, it was possible for a rejoining device to use
a pre-configured network address. As of today, the Base Device Behavior
specification has not addressed this topic (whether this is allowed or
not). TI encourages the use of the Base Device Behavior commissioning
methods described in <a class="reference internal" href="#z-stack-overview-commissioning"><span class="std std-ref">Commissioning</span></a> for rejoining the network.</p>
</div>
<div class="section" id="child-management">
<span id="sec-child-management"></span><h3>Child Management<a class="headerlink" href="#child-management" title="Permalink to this headline">¶</a></h3>
<p>The Child Management feature allows mobility in end devices and saves space
within parent devices’ association tables.When an end device joins/rejoins, it
will send an EndDeviceTimeout NWK command, which contains a timeout period. If
their parent does not receive a keep-alive message from the end device within
the timeout period, it will remove the end device from its association table and
send that end device a leave request.</p>
<p>The parent device will answer the EndDeviceTimeout NWK command with a response
stating which methods it supports for receiving the keep-alive messages.There
are two keep-alive methods, MAC polling <code class="code docutils literal notranslate"><span class="pre">NWK_PARENT_INFO_MAC_DATA_POLL</span></code>
and timeout message <code class="code docutils literal notranslate"><span class="pre">NWK_PARENT_INFO_END_DEVICE_TIMEOUT_MSG</span></code>. An end
device timeout message is preferred for Zigbee 3.0 devices where power
consumption is important as it does not require the end device to constantly
send data request frames other than needed by polling data from parent. MAC
polling is compatible with end devices who implement any Zigbee specification
prior to Zigbee 3.0 without the need for specific child aging support.</p>
<p>If a legacy device joins an R21 or later parent device, the parent will assign a
default timeout to expire this device if this legacy device fails to poll in a
timely manner. Additionally, if a parent device is polled by an end device which
is not its child (due to being expired or not being its child at all), then the
parent device must request this end device to leave the network with rejoin set
to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>.Then this device can rejoin the network and find a new parent
(which could be the same router or another one).</p>
<div class="section" id="configuring-child-management-for-parent-device">
<h4>Configuring Child Management for Parent Device<a class="headerlink" href="#configuring-child-management-for-parent-device" title="Permalink to this headline">¶</a></h4>
<p>A default end device timeout can be defined in the parent device by modifying
<code class="code docutils literal notranslate"><span class="pre">END_DEV_TIMEOUT_VALUE</span></code>. This timeout will be overwritten by joining
devices if they state their own timeout using the EndDeviceTimeout command.</p>
<p>Parent devices must keep track of devices that it should send leave requests to.
To do this, parent devices must queue leave requests in the MAC layer.
The number of devices that can be kept track of at the
same time is defined by <code class="code docutils literal notranslate"><span class="pre">MAX_NOT_MYCHILD_DEVICES</span></code> (in <code class="code docutils literal notranslate"><span class="pre">nwk_globals.h</span></code>).
These devices will be tracked for a period of time defined by
<code class="code docutils literal notranslate"><span class="pre">NWK_END_DEVICE_LEAVE_TIMEOUT</span></code> (in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>).</p>
</div>
<div class="section" id="configuring-child-management-for-child-devices">
<h4>Configuring Child Management for Child Devices<a class="headerlink" href="#configuring-child-management-for-child-devices" title="Permalink to this headline">¶</a></h4>
<p>The timeout that the child device will indicate to its parent device
is defined by <code class="code docutils literal notranslate"><span class="pre">END_DEV_TIMEOUT_VALUE</span></code> (see <em>RF STACKS</em> → <em>Z-Stack</em> →
<em>Network</em> → <em>End Device Timeout</em> (see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>).
Its suggested value should be at least 3 times greater than the MAC polling time
(set by <code class="code docutils literal notranslate"><span class="pre">POLL_RATE</span></code> in <code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code>)
to avoid being expired if there is interference when the end device is polling.
The minimum allowable application poll rate is determined by <code class="code docutils literal notranslate"><span class="pre">MINIMUM_APP_POLL_RATE</span></code>
in <code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code> but polling can be disabled by calling
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_sysConfigWriteReq</span></code> with <code class="code docutils literal notranslate"><span class="pre">has_disablePollRate</span></code>
and <code class="code docutils literal notranslate"><span class="pre">disablePollRate</span></code> both set to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zstack_sysConfigWriteReq_t</span><span class="w"> </span><span class="n">writeReq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">writeReq</span><span class="p">.</span><span class="n">has_disablePollRate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="n">writeReq</span><span class="p">.</span><span class="n">disablePollRate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="n">Zstackapi_sysConfigWriteReq</span><span class="p">(</span><span class="n">appServiceTaskId</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">writeReq</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="parent-annce">
<span id="sec-parent-annce"></span><h4>Parent Annce<a class="headerlink" href="#parent-annce" title="Permalink to this headline">¶</a></h4>
<p>The child management functionality includes the usage of Parent Annce ZDO messages.
A parent broadcasts this message only when forming a network or when reset,
after 10 seconds plus a random jitter of up to 10 seconds.
The message contains the 64-bit IEEE addresses of all end devices in the parent’s association table.
If another parent device receives this message, it will check if any of the reported children
is also listed in its own association table.
If there are any matches, then this parent device will respond to the originator of the message
with a list of all matches. The originator will then remove those children from its association table.
The usage of this message can be illustrated with the following example:</p>
<ol class="arabic simple">
<li><p>Parent device ‘A’ has a child device ‘c’.</p></li>
<li><p>Parent device ‘A’ is power cycled.</p></li>
<li><p>Child device ‘c’ finds parent device ‘B’ and joins it.</p></li>
<li><p>When parent device ‘A’ restores its network parameters, it starts a
timer to send parent annce (of 10 seconds plus random jitter of up to
10 seconds.)</p></li>
<li><p>After the timeout, parent device ‘A’ broadcasts parent annce
containing IEEE address of child ‘c’.</p></li>
<li><p>Parent device ‘B’ finds a match with its children and responds with a
parent annce response containing the IEEE address of child ‘c’.</p></li>
<li><p>Parent device ‘A’ removes child ‘c’ from its table.</p></li>
</ol>
</div>
</div>
</div>
<div class="section" id="security">
<span id="z-stack-overview-security"></span><h2>Security<a class="headerlink" href="#security" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3>Overview<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>Zigbee security is built with the AES block cipher and the CCM mode of
operation as the underlying security primitive. AES/CCM security
algorithms were developed by external researchers outside of Zigbee
Alliance and are also used widely in other communication protocols.</p>
<p>Zigbee specification defines two types of networks, based on the
security schema that those networks use: Centralized security network
and Distributed security network.</p>
<p>By default, networks are closed for new devices. In both types of
networks, the network can only be opened for a maximum of 254 seconds at
a time, after which the network will be closed for joining. Zigbee 3.0
networks cannot remain open indefinitely.   The default value for Z-Stack
is 180 seconds as determined by <code class="code docutils literal notranslate"><span class="pre">BDBC_MIN_COMMISSIONING_TIME</span></code> in
<code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code>.  The duration for which devices
may attempt to join a network is reflected in the beacon packets sent by
any existing networks in response to a joining device’s beacon requests.</p>
<p>Zigbee offers the following security features:</p>
<ul class="simple">
<li><p>Infrastructure security</p></li>
<li><p>Network access control</p></li>
<li><p>Application data security (only for centralized security networks)</p></li>
</ul>
</div>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h3>
<p>Network layer security is mandatory in Zigbee 3.0 and cannot be disabled in Z-Stack.</p>
<p>The default key for network layer encryption (<code class="code docutils literal notranslate"><span class="pre">defaultKey</span></code> defined in
<code class="code docutils literal notranslate"><span class="pre">nwk_globals.c</span></code>) is distributed to each joining
device over-the-air as they join the network. This is chosen via the
<code class="code docutils literal notranslate"><span class="pre">zgPreConfigKeys</span></code> option in <code class="code docutils literal notranslate"><span class="pre">zglobals.c</span></code>, where it is set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>
such that the default key parameter needs to be set only on the device forming the
network. This default key is initialized with the macro definition <code class="code docutils literal notranslate"><span class="pre">DEFAULT_KEY</span></code>
in <code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code>.
The developer specifies <code class="code docutils literal notranslate"><span class="pre">DEFAULT_KEY</span></code> in the project’s .syscfg file
(see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>). If this key is set to 0 upon initialization,
then a random key will be generated. In Zigbee 3.0 this key is transmitted over-the-air
to joining devices using APS layer encryption.</p>
</div>
<div class="section" id="centralized-security-network">
<h3>Centralized Security Network<a class="headerlink" href="#centralized-security-network" title="Permalink to this headline">¶</a></h3>
<p>This network type is formed by coordinator devices, in which the
coordinator assumes the role of Trust Center (TC). In this type of network only the TC
can deliver the network key to joining devices and allow them to be part of the network.
The coordinator can configure different sets of TC policies
that allow control of the security level of the network. These policies
will be presented in <a class="reference internal" href="#sec-trust-center-policies"><span class="std std-ref">Trust Center Policies</span></a>. When a device performs an
association directly to the TC, the TC will evaluate the TC policies and
validate if the device is allowed to join the network or not. When a
device joins through a router device, the parent device notifies the TC
via an APS Update Device command, and then the joining device will go
through the same TC policy validations. If a device passes the
validations, the TC will deliver the network key to the joining device
through either a direct APS Transport Key command or an APS Tunnel
Transport Key command, depending on the device’s joining topology. If the
joining device does not pass the TC policy validations, it will be
kicked out of the network with a network leave command.</p>
<p>It is also important to note that if the TC is not available (power
cycled or not in the network), new devices will not be able to join the
network since no other device is allowed to deliver the network key or
validate TC policies.</p>
<div class="section" id="trust-center-policies">
<span id="sec-trust-center-policies"></span><h4>Trust Center Policies<a class="headerlink" href="#trust-center-policies" title="Permalink to this headline">¶</a></h4>
<div class="section" id="zgallowremotetcpolicychange">
<h5>zgAllowRemoteTCPolicyChange<a class="headerlink" href="#zgallowremotetcpolicychange" title="Permalink to this headline">¶</a></h5>
<p>If <code class="code docutils literal notranslate"><span class="pre">zgAllowRemoteTCPolicyChange</span></code> of <code class="code docutils literal notranslate"><span class="pre">zglobals.c</span></code> is set to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>
(default), other devices in the network may modify
the permit joining policy of the Trust Center, which could allow other
devices to join the network. If set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>, remote devices will not be
able to change the permit joining policy on the coordinator, which will
cause the TC to not deliver the network key and kick out any devices
attempting to join the network through an intermediate router which may
have locally enabled permit join.</p>
</div>
<div class="section" id="bdbjoinusesinstallcodekey">
<h5>bdbJoinUsesInstallCodeKey<a class="headerlink" href="#bdbjoinusesinstallcodekey" title="Permalink to this headline">¶</a></h5>
<p>If <code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_JOIN_USES_INSTALL_CODE_KEY</span></code> from <code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code> is
set to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>, then the network key will be delivered only to those joining
devices that do have an install code associated. If
<code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_JOIN_USES_INSTALL_CODE_KEY</span></code> is set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> (default),
joining devices may use install codes. The usage of install codes is described
in <a class="reference internal" href="#sec-install-code-usage"><span class="std std-ref">Install Code Derived Trust Center Link Key</span></a>.</p>
</div>
<div class="section" id="bdbtrustcenterrequirekeyexchange">
<span id="sec-bdbtrustcenterrequirekeyexchange"></span><h5>bdbTrustCenterRequireKeyExchange<a class="headerlink" href="#bdbtrustcenterrequirekeyexchange" title="Permalink to this headline">¶</a></h5>
<p>If <code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_TC_REQUIRE_KEY_EXCHANGE</span></code> in <code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code> is set
to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>, then all the joining devices are mandated to perform the
TCLK exchange procedure. Devices that do not perform this procedure will
be kicked out of the network after <code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_TC_NODE_JOIN_TIMEOUT</span></code> seconds
(15 by default). If this policy set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> (default), joining devices will not
be required to perform a TCLK update, but they will be allowed to do so.
The TCLK exchange procedure is described in <a class="reference internal" href="#sec-unsecure-join-centralized-network"><span class="std std-ref">Unsecure Join to a Centralized Network</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Legacy devices (implementing R20 or before)
will not be able to perform the TCLK exchange process, so if this policy
is set to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>, legacy devices will not be able to join this network.</p>
</div>
</div>
</div>
<div class="section" id="key-updates">
<h4>Key Updates<a class="headerlink" href="#key-updates" title="Permalink to this headline">¶</a></h4>
<p>The Trust Center can update the common Network key at its discretion. An
example policy would be to update the Network key at regular periodic
intervals. Another would be to update the NWK key upon user input (like
a button-press). The ZDO Security Manager <code class="code docutils literal notranslate"><span class="pre">zd_sec_mgr.c</span></code> API provides this
functionality via <code class="code docutils literal notranslate"><span class="pre">ZDSecMgrUpdateNwkKey()</span></code> and <code class="code docutils literal notranslate"><span class="pre">ZDSecMgrSwitchNwkKey()</span></code>.
<code class="code docutils literal notranslate"><span class="pre">ZDSecMgrUpdateNwkKey()</span></code> allows the Trust Center to send a new Network key
to the dstAddr on the network. At this point the new Network key is
stored as an alternate key in the destination device(s).
Once the Trust Center calls <code class="code docutils literal notranslate"><span class="pre">ZDSecMgrSwitchNwkKey()</span></code> with the dstAddr of the device or devices,
all destination devices will use their alternate key.</p>
<p>The application may use the <code class="code docutils literal notranslate"><span class="pre">Zstackapi_sec*</span></code> functions to request ZDO
Security Manager features. Here is a list of functions available to the
application:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_secNwkKeyGetReq()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_secNwkKeySetReq()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_secNwkKeyUpdateReq()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_secNwkKeySwitchReq()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_secApsLinkKeyGetReq()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_secApsLinkKeySetReq()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_secApsLinkKeyRemoveReq()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Zstackapi_secApsRemoveReq()</span></code></p></li>
</ul>
</div></blockquote>
<p>Since the R21 revision of the Zigbee specification,
the network frame counter is mandated to be persistent across factory new resets.
However, it can be reset to 0 if the network frame counter is larger than half of its max value (0x8000000)
prior to performing a network key update. Performing the update will then reset the frame counter to 0.</p>
</div>
</div>
<div class="section" id="distributed-security-network">
<span id="sec-distributed-security-network"></span><h3>Distributed Security Network<a class="headerlink" href="#distributed-security-network" title="Permalink to this headline">¶</a></h3>
<p>This network type can be formed by network-forming router devices. In
this network topology, all the nodes have the ability to open the
network for joining and any router device can deliver the network key to
a joining device. The network key will be encrypted at APS layer with a
Default Distributed Global key (detailed in <a class="reference internal" href="#sec-distributed-global-key"><span class="std std-ref">Distributed Security Global Link Key</span></a>).
This network key will
be delivered via an APS Transport Key Command in which the TC address
will be set to 0xFFFFFFFFFFFFFFFF, which tells the joining device that it is
joining a distributed security network. The application can consult the
value of <code class="code docutils literal notranslate"><span class="pre">AIB_apsTrustCenterAddress</span></code> to see if it has joined a
distributed network.</p>
<p>It is important to note that after a distributed network is formed, the
network key cannot be updated because there is no defined method of
securely distributing a network key in a network with this topology.</p>
</div>
<div class="section" id="link-key-types">
<h3>Link Key Types<a class="headerlink" href="#link-key-types" title="Permalink to this headline">¶</a></h3>
<p>Each node must support a way to use the following link key types:</p>
<ol class="arabic simple">
<li><p>The default global Trust Center link key (Used by Z-Stack
automatically).</p></li>
<li><p>An install code derived Trust Center link key (when
<code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_JOIN_USES_INSTALL_CODE_KEY</span></code> is <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>).</p></li>
<li><p>The distributed security global link key (Used by Z-Stack
automatically).</p></li>
<li><p>The touchlink preconfigured link key (if touchlink enabled).</p></li>
</ol>
<div class="section" id="default-global-trust-center-link-key">
<span id="sec-default-global-tclk"></span><h4>Default Global Trust Center Link Key<a class="headerlink" href="#default-global-trust-center-link-key" title="Permalink to this headline">¶</a></h4>
<p>All devices share a default global Trust Center Link Key. This is an APS
layer key and is the first key to be used when joining a network, if no
other link key is specified. This key is defined by SysConfig and cannot
be modified if interoperability with other Zigbee 3.0 devices is desired.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 64%" />
<col style="width: 7%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Default global Trust Center link key (0:15)</p></td>
<td><p>=</p></td>
<td><p>0x5a 0x69 0x67 0x42
0x65 0x65 0x41 0x6c
0x6c 0x69 0x61 0x6e
0x63 0x65 0x30 0x39</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="install-code-derived-trust-center-link-key">
<span id="sec-install-code-usage"></span><h4>Install Code Derived Trust Center Link Key<a class="headerlink" href="#install-code-derived-trust-center-link-key" title="Permalink to this headline">¶</a></h4>
<p>An Install Code is a sequence of 16 bytes followed by 2 bytes of CRC. A
complete 18 bytes sequence is needed to generate a unique TCLK. The
usage of install codes defined in Zigbee 3.0 was added to allow a generalized
out-of-band key delivery method for network commissioning. It works as
follows:</p>
<ol class="arabic simple">
<li><p>TC gets the install code and the 64-bit IEEE address of the device
that will use this install code to join, via any user interface
(serial, display, switches, etc.). The install code must be
physically provided with the joining device.</p></li>
<li><p>TC validates the CRC of the install code introduced. If this is valid
then a TCLK entry is added into the TC with the derived key and the
address of the corresponding device.</p></li>
<li><p>The joining device is instructed to use its install code to generate
the corresponding TCLK.</p></li>
<li><p>The network is opened.</p></li>
<li><p>The joining device performs association and the Trust Center delivers
the network key encrypted in APS layer with the install code derived
key.</p></li>
<li><p>After this, the joining device must perform the update of its TCLK as
BDB specification requires.</p></li>
</ol>
<p>This is accomplished by setting <code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_JOIN_USES_INSTALL_CODE_KEY</span></code>
to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code> in <code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code> and using the
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbAddInstallCodeReq()</span></code> API.  For further details on how to generate
the install codes, see the Base Device Behavior Specification. This is supported
only by R21 or later revisions, so to allow backwards compatibility the application
must have a way to attempt joining networks without the usage of Install Codes.</p>
</div>
<div class="section" id="distributed-security-global-link-key">
<span id="sec-distributed-global-key"></span><h4>Distributed Security Global Link Key<a class="headerlink" href="#distributed-security-global-link-key" title="Permalink to this headline">¶</a></h4>
<p>When a device joins a distributed security network (no TC),
the parent router device sends the network key after encrypting it in the
APS layer using the Distributed Global link key, defined in SysConfig.
This key cannot be modified if interoperability with other Zigbee 3.0
devices is desired.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 59%" />
<col style="width: 7%" />
<col style="width: 35%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Distributed Trust Center link key (0:15)</p></td>
<td><p>=</p></td>
<td><p>0xd0 0xd1 0xd2 0xd3 0xd4
0xd5 0xd6 0xd7 0xd8 0xd9
0xda 0xdb 0xdc 0xdd 0xde
0xdf</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="touchlink-preconfigured-link-key">
<h4>Touchlink Preconfigured Link Key<a class="headerlink" href="#touchlink-preconfigured-link-key" title="Permalink to this headline">¶</a></h4>
<p>This key is used for development of a device that will join a network
using the Touchlink commissioning procedure, defined by
<code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_CERTIFICATION_ENC_KEY</span></code> of <code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 58%" />
<col style="width: 7%" />
<col style="width: 35%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Touchlink preconfigured link key (0:15)</p></td>
<td><p>=</p></td>
<td><p>0xc0 0xc1 0xc2 0xc3 0xc4
0xc5 0xc6 0xc7 0xc8 0xc9
0xca 0xcb 0xcc 0xcd 0xce
0xcf</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="unsecure-join-to-a-network">
<h3>Unsecure Join to a Network<a class="headerlink" href="#unsecure-join-to-a-network" title="Permalink to this headline">¶</a></h3>
<p>Base Device Behavior has defined the procedure in which a device has to commission itself
into a network from a factory new state.
The procedure specifies how the joining device discovers networks across one set of channels,
and how it can fall back to discover additional networks in the remaining channels, refer to
<a class="reference internal" href="#z-stack-overview-nwk-steering-not-on-nwk"><span class="std std-ref">Network Steering Procedure for a Node not on a Network</span></a>.
Once the device has selected a suitable network,
the joining device determines if it has joined a Centralized or Distributed security network.
These networks use different keys to encrypt the APS Transport command.
The specific secure procedures to join these types of secure networks
will be explained in the following subsections.</p>
<div class="section" id="unsecure-join-to-a-centralized-network">
<span id="sec-unsecure-join-centralized-network"></span><h4>Unsecure Join to a Centralized Network<a class="headerlink" href="#unsecure-join-to-a-centralized-network" title="Permalink to this headline">¶</a></h4>
<p>Once the joining device receives the transport key,
it will proceed to check the source address of that transport key command.
In this case the 64-bit IEEE address will be different from all 00’s or FF’s
since the TC exists in this network.
The following steps describe the unsecure joining process to a Centralized network.
The joining process into a Zigbee 3.0 Centralized network directly to the TC is illustrated in
<a class="reference internal" href="#fig-direct-join-tc"><span class="std std-numref">Figure 52.</span></a>.</p>
<ol class="arabic simple">
<li><p>Joining device sends association request.</p></li>
<li><p>Parent device sends association response.</p></li>
<li><p>Trust Center delivers the network key in a Transport key command.
This transport key command is APS encrypted either with
<a class="reference internal" href="#sec-default-global-tclk"><span class="std std-ref">Default Global Trust Center Link Key</span></a> or an
<a class="reference internal" href="#sec-install-code-usage"><span class="std std-ref">Install Code Derived Trust Center Link Key</span></a>.</p></li>
<li><p>Joining device is able to get the network key from the encrypted
Transport Key command and announces itself with a ZDO device announce
command.</p></li>
<li><p>The joining device then queries the ZDO Node Descriptor from the
Trust Center.</p></li>
<li><p>The joining device parses the Node Descriptor to look at the stack
version revision (this field has been added since the R21 version of Zigbee
specification).</p>
<ol class="loweralpha simple">
<li><p>If the stack version supported by the TC is not present (0x00),
this means it supports a version from before to R21, so the
joining process will finish at this step.</p></li>
<li><p>If the TC of the joined network is R21 or later, the joining
device must update its APS Key by sending an APS Request Key command.</p></li>
</ol>
</li>
<li><p>The TC will deliver the Unique Trust Center link key with an APS
Transport Key command.</p></li>
<li><p>The joining device will update its key status from <em>Default</em> or
<em>Provisional</em> (if an install code was used) to <em>Unverified</em>, after
which the key must be verified. To verify the key, the joining device
will send an APS Verify Key command to the TC containing the <em>Unique</em>
key hashed (to avoid sending the key in plain text).</p></li>
<li><p>The TC hashes the key associated to this device and compares against
the hashed key received. If they are the same, it will send an APS Confirm
Key command with status <em>Success</em>, after which the TCLK exchange
procedure is finished for the joining device.</p></li>
</ol>
<p>If any steps between 1 and 4 fail, the joining device will reattempt steps 1 to 4
up to <code class="code docutils literal notranslate"><span class="pre">BDBC_REC_SAME_NETWORK_RETRY_ATTEMPS</span></code> (<code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code>) times
with the same network. If there are no successes within these attempts, the joining
device will retry with the next suitable network in the network descriptor list.
Similarly, if any steps between 5 and 8 fail, the joining device will reattempt
those steps up to <code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_TC_LINK_KEY_EXCHANGE_ATTEMPS_MAX</span></code>
(<code class="code docutils literal notranslate"><span class="pre">bdb.h</span></code>) times. If there are no successes, then the device will perform a
Factory New reset to erase the network parameters and keys obtained at the failing step.
The application will receive a notification of these, as detailed in <a class="reference internal" href="#sec-bdb-notifications"><span class="std std-ref">BDB Notifications</span></a>.</p>
<div class="figure align-center" id="id19">
<span id="fig-direct-join-tc"></span><p class="plantuml">
<img src="../_images/plantuml-82d3498e766049c88b0d7246cd88aaf0de392665.png" alt="&#64;startuml
&quot;Trust Center&quot; &lt;- &quot;Joining Device&quot;: Association Request
activate &quot;Trust Center&quot;
&quot;Joining Device&quot; &lt;-- &quot;Trust Center&quot;: Association Response
deactivate &quot;Trust Center&quot;

&quot;Trust Center&quot; &lt;- &quot;Trust Center&quot;: Trust Center use Default TCLK or\nderived key from install code
&quot;Joining Device&quot; &lt;- &quot;Trust Center&quot;: Transport Key
&quot;Trust Center&quot; &lt;- &quot;Joining Device&quot;: Device Announce
&quot;Trust Center&quot; &lt;- &quot;Joining Device&quot;: Node Descriptor Request

activate &quot;Trust Center&quot;
&quot;Joining Device&quot; &lt;-- &quot;Trust Center&quot;: Node Descriptor Response
deactivate &quot;Trust Center&quot;
&quot;Joining Device&quot; &lt;- &quot;Joining Device&quot;: Get trust center capabilities and stack revision

&quot;Trust Center&quot; &lt;- &quot;Joining Device&quot;: Request Key
activate &quot;Trust Center&quot;
note right: Requesting Key Type: [0x04] Trust Center Key
&quot;Joining Device&quot; &lt;-- &quot;Trust Center&quot;: Transport Key
deactivate &quot;Trust Center&quot;

&quot;Trust Center&quot; &lt;- &quot;Joining Device&quot;: Verify Key
activate &quot;Trust Center&quot;
&quot;Trust Center&quot; &lt;- &quot;Trust Center&quot;: Process key hash to verify the APS key
&quot;Joining Device&quot; &lt;-- &quot;Trust Center&quot;: Confirm Key
deactivate &quot;Trust Center&quot;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 52. </span><span class="caption-text">Joining Directly to Trust Center</span><a class="headerlink" href="#id19" title="Permalink to this image">¶</a></p>
</div>
<p>A similar process occurs when the device joins through a parent device
that is not the TC. The parent device sends APS Update device commands
to the TC to notify it about the new device. Afterwards, the parent device
only relays the frames between the joining device and the TC as
illustrated in <a class="reference internal" href="#fig-indirect-join-tc"><span class="std std-numref">Figure 53.</span></a>.</p>
<div class="figure align-center" id="id20">
<span id="fig-indirect-join-tc"></span><p class="plantuml">
<img src="../_images/plantuml-006331800bc0e530dd4c4c9567ef48db2116fced.png" alt="&#64;startuml
participant &quot;Trust Center&quot;
participant &quot;Parent Router&quot;
participant &quot;Joining Device&quot;

&quot;Joining Device&quot;-&gt;&quot;Parent Router&quot;: Association Request
activate &quot;Parent Router&quot;
&quot;Parent Router&quot;--&gt;&quot;Joining Device&quot;: Association Response
deactivate &quot;Parent Router&quot;

&quot;Trust Center&quot;-&gt;&quot;Trust Center&quot;: Trust Center use Default TCLK or\nderived key from install code
&quot;Parent Router&quot;-&gt;&quot;Trust Center&quot;: Update Device
activate &quot;Trust Center&quot;
&quot;Trust Center&quot;--&gt;&quot;Parent Router&quot;: Tunnel: Transport Key
deactivate &quot;Trust Center&quot;

&quot;Parent Router&quot;-&gt;&quot;Joining Device&quot;: Transport Key
&quot;Joining Device&quot;--&gt;&quot;Parent Router&quot;: Device Announce
&quot;Parent Router&quot;--&gt;&quot;Trust Center&quot;: Device Announce

&quot;Joining Device&quot;-&gt;&quot;Parent Router&quot;: Node Descriptor Request
activate &quot;Parent Router&quot;
&quot;Parent Router&quot;-&gt;&quot;Trust Center&quot;: Node Descriptor Request
activate &quot;Trust Center&quot;
&quot;Trust Center&quot;--&gt;&quot;Parent Router&quot;: Node Descriptor Response
deactivate &quot;Trust Center&quot;
&quot;Parent Router&quot;--&gt;&quot;Joining Device&quot;: Node Descriptor Response
deactivate &quot;Parent Router&quot;
&quot;Joining Device&quot;-&gt;&quot;Joining Device&quot;: Get trust center capabilities and stack revision

&quot;Joining Device&quot;-&gt;&quot;Parent Router&quot;: Request Key
activate &quot;Parent Router&quot;
note right: Requesting Key Type: [0x04] Trust Center Key
&quot;Parent Router&quot;-&gt;&quot;Trust Center&quot;: Request Key
activate &quot;Trust Center&quot;
&quot;Trust Center&quot;--&gt;&quot;Parent Router&quot;: Transport Key
deactivate &quot;Trust Center&quot;
&quot;Parent Router&quot;--&gt;&quot;Joining Device&quot;: Transport Key
deactivate &quot;Parent Router&quot;

&quot;Joining Device&quot;-&gt;&quot;Parent Router&quot;: Verify Key
activate &quot;Parent Router&quot;
&quot;Parent Router&quot;-&gt;&quot;Trust Center&quot;: Verify Key
activate &quot;Trust Center&quot;
&quot;Trust Center&quot;-&gt;&quot;Trust Center&quot;: Process key hash to verify the APS key
&quot;Trust Center&quot;--&gt;&quot;Parent Router&quot;: Confirm Key
deactivate &quot;Trust Center&quot;
&quot;Parent Router&quot;--&gt;&quot;Joining Device&quot;: Confirm Key
deactivate &quot;Parent Router&quot;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 53. </span><span class="caption-text">Joining When Parent is not the Trust Center</span><a class="headerlink" href="#id20" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="trust-center-tc-rejoin">
<h4>Trust Center (TC) Rejoin<a class="headerlink" href="#trust-center-tc-rejoin" title="Permalink to this headline">¶</a></h4>
<p>Although secure rejoins (NWK encrypted) are preferred, in some situations a device may no longer have knowledge of the NWK key of its current network.
In this case, a TC rejoin (unsecure) could be performed.
The Rejoin Request would be unencrypted.
Depending on its policies, the TC may choose to transport the current NWK key (APS encrypted) to the joining device.
If this device had previously joined, the TC would use the unique TCLK for that joining device.
Otherwise, the TC may use the well-known global TCLK.</p>
<p>This feature is tuned with the following macros/variables:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">zgAllowRejoinsWithWellKnownKey</span></code> (in <code class="code docutils literal notranslate"><span class="pre">zglobals.c</span></code>): determines whether well-known TCLK (ZigbeeAlliance09) may be used for rejoins</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">BDB_ATTEMPT_UNSECURE_REJOIN</span></code> (in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>): determines whether or not this device will attempt to perform unsecure rejoins</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">BDB_SECURE_REJOIN_ATTEMPTS</span></code> (in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>): number of secure rejoin attempts before trying unsecure rejoin (if <code class="code docutils literal notranslate"><span class="pre">BDB_ATTEMPT_UNSECURE_REJOIN</span></code> is <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>)</p></li>
</ul>
</div></blockquote>
<div class="figure align-center" id="id21">
<span id="fig-tc-rejoin"></span><p class="plantuml">
<img src="../_images/plantuml-4799856648165ab1d105bfcba12f4940f72e0181.png" alt="&#64;startuml
participant &quot;Trust Center&quot;
participant &quot;Parent Router&quot;
participant &quot;Joining Device&quot;

&quot;Joining Device&quot;-&gt;&quot;Parent Router&quot;: Rejoin Request (no NWK encryption)
activate &quot;Parent Router&quot;
&quot;Parent Router&quot;-&gt;&quot;Joining Device&quot;: Rejoin Response (no NWK encryption)
deactivate &quot;Parent Router&quot;

&quot;Parent Router&quot;-&gt;&quot;Trust Center&quot;: Update Device
activate &quot;Trust Center&quot;
&quot;Trust Center&quot;-&gt;&quot;Trust Center&quot;: Decision to accept TC rejoin
deactivate &quot;Trust Center&quot;

&quot;Trust Center&quot;-&gt;&quot;Parent Router&quot;: Transport Key (APS encrypted)
note right: Transport Key Type: [0x01] NWK Key
&quot;Parent Router&quot;-&gt;&quot;Joining Device&quot;: Transport Key
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 54. </span><span class="caption-text">TC Rejoin</span><a class="headerlink" href="#id21" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="unsecure-join-to-a-distributed-network">
<h4>Unsecure Join to a Distributed Network<a class="headerlink" href="#unsecure-join-to-a-distributed-network" title="Permalink to this headline">¶</a></h4>
<p>Once the transport key is received by the joining device, it will
proceed to check the source address of this transport key command. In
this case, the 64-bit IEEE address will be all FF’s, indicating that this is
a distributed network. Also, there are no additional procedures
to perform updates of keys, since there is no TC that can handle this.
The joining process into a Zigbee 3.0 Distributed network is illustrated in
<a class="reference internal" href="#fig-join-distributed-nwk"><span class="std std-numref">Figure 55.</span></a>.</p>
<div class="figure align-center" id="id22">
<span id="fig-join-distributed-nwk"></span><p class="plantuml">
<img src="../_images/plantuml-bf9c2edffa99b9fe0f7878d8a337fadb896aed25.png" alt="&#64;startuml
participant &quot;Parent Router&quot;
participant &quot;Joining Device&quot;
    &quot;Joining Device&quot;-&gt;&quot;Parent Router&quot;: Association Request
    &quot;Parent Router&quot;--&gt;&quot;Joining Device&quot;: Association Response
    &quot;Parent Router&quot;-&gt;&quot;Parent Router&quot;: Trust Center use Distributed Key
    &quot;Parent Router&quot;-&gt;&quot;Joining Device&quot;: Transport Key
    &quot;Joining Device&quot;--&gt;&quot;Parent Router&quot;: Device Announce
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 55. </span><span class="caption-text">Distributed Security Joining</span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</div>
<p>The joining device will attempt up to
<code class="code docutils literal notranslate"><span class="pre">BDBC_REC_SAME_NETWORK_RETRY_ATTEMPS</span></code> to join this network. If it
cannot be authenticated (receives the network key), then it will try the
next network in the network descriptor list.</p>
</div>
<div class="section" id="z-stack-security-considerations">
<h4>Z-Stack Security Considerations<a class="headerlink" href="#z-stack-security-considerations" title="Permalink to this headline">¶</a></h4>
<div class="section" id="for-trust-center-tc-devices">
<span id="sec-tc-joining"></span><h5>For Trust Center (TC) Devices<a class="headerlink" href="#for-trust-center-tc-devices" title="Permalink to this headline">¶</a></h5>
<p>Trust center devices have a TCLK manager which stores the APS secure
information related to a particular joining device (IEEE address, frame
counters, key, key status). Each TCLK entry is defined by the structure
<code class="code docutils literal notranslate"><span class="pre">APSME_TCLKDevEntry_t</span></code> (in <code class="code docutils literal notranslate"><span class="pre">aps_mede.h</span></code>). They are
stored in NV, up to a maximum defined by <code class="code docutils literal notranslate"><span class="pre">ZDSECMGR_TC_DEVICE_MAX</span></code>, (in <code class="code docutils literal notranslate"><span class="pre">zd_sec_mgr.h</span></code>).
A TCLK entry is created for each joining device that the TC sends the network key to.
This limits the number of devices in the network to the number of TCLK entries that the TC has.
A TCLK entry is also used when an Install Code is introduced to the TC for a joining device,
but the Install Code key is saved in a separate table of NV whose size
is controlled by <code class="code docutils literal notranslate"><span class="pre">ZDSECMGR_TC_DEVICE_IC_MAX</span></code> (in <code class="code docutils literal notranslate"><span class="pre">zd_sec_mgr.h</span></code>).
When the TCLK exchange is complete for a joining device,
the TC frees the corresponding Install Code key entry from NV, but continues using the TCLK entry.
However, since the TCLK entries are used to keep track of the APS Key,
which is not updated from the Global Default Centralized Key by legacy devices (R20 or before),
it does not make sense to keep TCLK entries for legacy devices.
For this reason the TC will erase the TCLK entry.
Then it will either kick that device out of the network or leave it in the network (depending on
the configuration of <code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_TC_REQUIRE_KEY_EXCHANGE</span></code> (<a class="reference internal" href="#sec-bdbtrustcenterrequirekeyexchange"><span class="std std-ref">bdbTrustCenterRequireKeyExchange</span></a>).
This optimization allows a Zigbee 3.0 TC device to form a network of up to
<code class="code docutils literal notranslate"><span class="pre">ZDSECMGR_TC_DEVICE_MAX</span></code> Zigbee 3.0 devices and as many legacy devices as possible
(limited by other parameters or topology configurations).  This setting is configured
from the project’s .syscfg file <em>RF STACKS</em> → <em>Z-Stack</em> → <em>Network</em>.</p>
</div>
<div class="section" id="for-joining-devices">
<h5>For Joining Devices<a class="headerlink" href="#for-joining-devices" title="Permalink to this headline">¶</a></h5>
<p>When a factory new device receives an APS Transport Key command, it must decrypt the contents
of the command to determine which type of network it’s joining (centralized or distributed).
The device first assumes a centralized network, thus using its Install Code (if loaded through
BDB API) or the Global Default Centralized Key to decrypt. If the decryption fails, Z-Stack
will automatically try decrypting with the Global Default Distributed Key.</p>
<p>The secure procedures to join Centralized or Distributed networks are
already implemented by the BDB layer.</p>
<p>Joining devices must consider that the APS TCLK exchange will involve
NV reads/writes of the APS security material by the TC,
so if multiple devices are meant to be commissioned at the same time as
Factory New, a jitter must be implemented to allow the TC to process the
joining procedures of all the devices.</p>
<p>A joining device without a user interface to configure its joining
mechanism can be configured to try all the preconfigured keys
(Install Code, Global Default Centralized Key, and Global Default Distributed Key) upon joining,
by setting <code class="code docutils literal notranslate"><span class="pre">ZDSECMGR_TC_ATTEMPT_DEFAULT_KEY</span></code> to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>.
However, if the device is intended only to join networks which only use Install Codes,
then this policy must be set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> (default from <code class="code docutils literal notranslate"><span class="pre">zd_sec_mgr.h</span></code>).</p>
<p>Joining devices may skip the TCLK exchange procedure by setting
<code class="code docutils literal notranslate"><span class="pre">requestNewTrustCenterLinkKey</span></code> inside <code class="code docutils literal notranslate"><span class="pre">zd_sec_mgr.h</span></code> to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> (non-default).
This allows Zigbee 3.0 devices to deploy a large custom network
without requiring big tables of TCLK entries in Coordinator devices.
However, this should not be used if interoperability with certified Zigbee 3.0 devices is intended.</p>
</div>
</div>
</div>
<div class="section" id="touchlink-joining">
<h3>Touchlink Joining<a class="headerlink" href="#touchlink-joining" title="Permalink to this headline">¶</a></h3>
<p>Touchlink commissioning is a distributed security joining procedure that requires physical proximity
and uses its own preconfigured link key.
For this procedure, a touchlink initiator starts a scan request over all enabled channels
looking for a touchlink target.
If a target responds and is selected,
it will be asked to form a new network for the initiator or join the initiator’s network.</p>
<div class="figure align-center" id="id23">
<p class="plantuml">
<img src="../_images/plantuml-1e4af4f2a3a9f2ad31c7c23f9bea86b3c016ff05.png" alt="&#64;startuml
group Commissioning
Initiator-&gt;Target: Scan Request
activate &quot;Target&quot;
Target--&gt;Initiator: Scan Response
deactivate &quot;Target&quot;

Initiator-&gt;Initiator: Initiator selects a target to\ncontinue the procedure
Initiator-&gt;Target: Network Join Request
activate &quot;Target&quot;
Target--&gt;Initiator: Network Join Response
deactivate &quot;Target&quot;
Target-&gt;Target: Initiator gets required\nnetwork information
end

Initiator-&gt;Target: Beacon Request
activate &quot;Target&quot;
Initiator-&gt;Initiator: Initiator asks for join
Target--&gt;Initiator: Beacon
deactivate &quot;Target&quot;

Initiator-&gt;Target: Device Announce
Initiator-&gt;Target: Simple Descriptor Request
activate &quot;Target&quot;
Target--&gt;Initiator: Simple Descriptor Response
deactivate &quot;Target&quot;
Initiator-&gt;Initiator: Initiator establishes binds with common clusters
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 56. </span><span class="caption-text">Asking to join with Touchlink commissioning</span><a class="headerlink" href="#id23" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id24">
<p class="plantuml">
<img src="../_images/plantuml-9a921f5e07151d4ad73ccd1bd92d29a67b149f96.png" alt="&#64;startuml
group Commissioning
Initiator-&gt;Target: Scan Request
activate &quot;Target&quot;
Target--&gt;Initiator: Scan Response
deactivate &quot;Target&quot;

Initiator-&gt;Initiator: Initiator selects a target to\ncontinue the procedure
Initiator-&gt;Target: Network Start Request
activate &quot;Target&quot;
Target--&gt;Initiator: Network Start Response
deactivate &quot;Target&quot;

Target-&gt;Target: Initiator gets required\nnetwork information
end
Initiator-&gt;Target: Rejoin Request
activate &quot;Target&quot;
Initiator-&gt;Initiator: Initiator asks for join
Target--&gt;Initiator: Rejoin Response
deactivate &quot;Target&quot;

Initiator-&gt;Target: Device Announce
Initiator-&gt;Target: Simple Descriptor Request
activate &quot;Target&quot;
Target--&gt;Initiator: Simple Descriptor Response
deactivate &quot;Target&quot;
Initiator-&gt;Initiator: Initiator establishes binds with common clusters
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 57. </span><span class="caption-text">Asking to start network with Touchlink commissioning</span><a class="headerlink" href="#id24" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="backwards-interoperability">
<h3>Backwards Interoperability<a class="headerlink" href="#backwards-interoperability" title="Permalink to this headline">¶</a></h3>
<p>There is a known interoperability issue that arises when Unique Link Key Type is
used and the Trust Center, running R20 Z-Stack, is in a network with older devices (R19).
In version 20 of the Zigbee Specification, it is required that the TC only allows APS
command messages with APS encryption, but Zigbee Routers running older versions of Z-Stack
send APS command messages with NWK encryption only. To overcome that issue, there is a
configuration control item, <code class="code docutils literal notranslate"><span class="pre">zgApsAllowR19Sec</span></code> in <code class="code docutils literal notranslate"><span class="pre">zglobals.c</span></code>, that the
application can set to allow R19 devices to join the network (<code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> by default).
The corresponding NV item is <code class="code docutils literal notranslate"><span class="pre">ZCD_NV_APS_ALLOW_R19_SECURITY</span></code> (in <code class="code docutils literal notranslate"><span class="pre">zcomdef.h</span></code>).</p>
</div>
<div class="section" id="id6">
<h3>Quick Reference<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Setting preconfigured Network key</p></td>
<td><p>Set in SysConfig</p></td>
</tr>
<tr class="row-even"><td><p>Enabling/disabling joining permissions</p></td>
<td><p>Call <code class="code docutils literal notranslate"><span class="pre">Zstackapi_ZdoMgmtPermitJoinReq()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Specific device validation during joining</p></td>
<td><p>Modify <code class="code docutils literal notranslate"><span class="pre">ZDSecMgrDeviceValidate</span></code> (in <code class="code docutils literal notranslate"><span class="pre">zd_sec_mgr.c</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p>Network key updates</p></td>
<td><p>Call <code class="code docutils literal notranslate"><span class="pre">Zstackapi_secNwkKeyUpdateReq()</span></code> and
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_secNwkKeySwitchReq()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Use Global Trust Center Link Key</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">zgApsLinkKeyType</span></code> = <code class="code docutils literal notranslate"><span class="pre">ZG_GLOBAL_LINK_KEY</span></code>
(in <code class="code docutils literal notranslate"><span class="pre">zglobals.c</span></code>). The NV item for this global
is <code class="code docutils literal notranslate"><span class="pre">ZCD_NV_APS_LINK_KEY_TYPE</span></code>
(defined in <code class="code docutils literal notranslate"><span class="pre">zcomdef.h</span></code>).</p></td>
</tr>
<tr class="row-even"><td><p>Use Unique Trust Center Link Keys</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">zgApsLinkKeyType</span></code> = <code class="code docutils literal notranslate"><span class="pre">ZG_UNIQUE_LINK_KEY</span></code>
(in <code class="code docutils literal notranslate"><span class="pre">zglobals.c</span></code>). The NV item for this global
is <code class="code docutils literal notranslate"><span class="pre">ZCD_NV_APS_LINK_KEY_TYPE</span></code>.
(in <code class="code docutils literal notranslate"><span class="pre">zcomdef.h</span></code>). Configure a preconfigured
Trust Center link key for each device joining
the network via the <code class="code docutils literal notranslate"><span class="pre">SYS_OSAL_NV_WRITE</span></code> command in a MT
interface.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="clusters-commands-and-attributes">
<h2>Clusters, Commands, and Attributes<a class="headerlink" href="#clusters-commands-and-attributes" title="Permalink to this headline">¶</a></h2>
<p>Each application supports a certain number of clusters. Think of a
cluster as an object containing both methods (commands) and data
(attributes).</p>
<p>Each cluster may have zero or more commands. Commands are further
divided into Server and Client-side commands. Commands cause action, or
generate a response.</p>
<p>Each cluster may have zero or more attributes. All of the attributes can
be found in the <code class="code docutils literal notranslate"><span class="pre">zcl_sampleapp_data.c</span></code> file, where “sampleapp” is
replaced with the given sample application (e.g. <code class="code docutils literal notranslate"><span class="pre">zcl_samplesw_data.c</span></code> for
the sample on/off light switch). Attributes describe the current state
of the device, or provide information about the device, such as whether
a light is currently on or off.</p>
<p>All clusters and attributes are defined either in the Zigbee Cluster
Library specification.</p>
<div class="section" id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<p>Attributes are found in a single list called <code class="code docutils literal notranslate"><span class="pre">zclSampleApp_Attrs[</span> <span class="pre">]</span></code>, in
the <code class="code docutils literal notranslate"><span class="pre">zcl_sampleapp_data.c</span></code> file. Each attribute entry is initialized to
a type and value, and contains a pointer to the attribute data.
Attribute data types can be found in the Zigbee Cluster Library 7 Specification.</p>
<p>The attributes must be registered using the <code class="code docutils literal notranslate"><span class="pre">zcl_registerAttrList(</span> <span class="pre">)</span></code>
function during application initialization, one per application
endpoint.</p>
<p>Each attribute has a data type, as defined by Zigbee (such as <code class="code docutils literal notranslate"><span class="pre">UINT8</span></code>,
<code class="code docutils literal notranslate"><span class="pre">INT32</span></code>, etc.). Each attribute record contains an attribute type and a
pointer to the actual data for the attribute. Read-only data can be
shared across endpoints. Data that is unique to an endpoint (such as the
OnOff attribute state of the light) should have a unique C variable.</p>
<p>All attributes can be read. Some attributes can be written. Some
attributes are reportable (can be automatically sent to a destination
based on time or change in attribute via the attribute reporting
functionality). Some attributes are saved as part of a “scene” that can
later be recalled to set the device to a particular state (such as a
light on or off). The attribute access is controlled through a field in
the attribute structure.</p>
<p>To store an attribute in non-volatile memory (to be preserved across
reboots) refer to <a class="reference internal" href="flash_memory-cc13xx_cc26xx.html#sec-application-nv-memory"><span class="std std-ref">Application Non-Volatile Memory</span></a>.</p>
</div>
<div class="section" id="adding-an-attribute-example">
<h3>Adding an Attribute Example<a class="headerlink" href="#adding-an-attribute-example" title="Permalink to this headline">¶</a></h3>
<p>To add an additional attribute to a project, refer to the attributes
information within the ZCL 7 Specification. Using the DoorLock cluster
as an example, the following will show how to add the “Max PIN Code
Length” attribute to the DoorLock project. This process can be
replicated across all Zigbee 3.0 sample projects.</p>
<p>All attributes that an application uses are defined within <code class="code docutils literal notranslate"><span class="pre">zcl_sampleapp_data.c</span></code>
file. For this DoorLock example, this data file is: <code class="code docutils literal notranslate"><span class="pre">zcl_sampledoorlock_data.c</span></code>.
Locate the section defined as <em>Attribute Definitions</em> and include the “Max PIN Code
Length” attribute using this format:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// Attribute record</span>
<span class="w">        </span><span class="n">ATTRID_DOOR_LOCK_MAX_PIN_CODE_LENGTH</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">ZCL_DATATYPE_UINT8</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">ACCESS_CONTROL_READ</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">zclSampleDoorLock_MaxPinCodeLength</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">},</span><span class="w"></span>
</pre></div>
</div>
<p>Line 2 represents the cluster ID, line 4 represents the attribute ID,
line 5 the data type, line 6 the read/write attribute, and line 7 the
pointer to the variable used within the application.
When modifying the attribute list, keep in mind that the order of attributes in the attribute list is important.
For correct processing of discovery commands, attributes of a cluster must be listed in ascending order.
In other words, attributes of the same cluster must be listed one after the other,
from lower attribute ID to higher.</p>
<p>The cluster ID can be found in the <code class="code docutils literal notranslate"><span class="pre">zcl.h</span></code> file, the attribute ID
can be found within the (in this case) <code class="code docutils literal notranslate"><span class="pre">zcl_closures.h</span></code> file, and the
remaining information from the ZCL 7 Specification.</p>
<p>By including the attribute within this list, devices are able to interact with the attributes on other devices.
Within the <code class="code docutils literal notranslate"><span class="pre">zcl_sampledoorlock.h</span></code> file, define the external variable using proper coding conventions,
i.e. <code class="code docutils literal notranslate"><span class="pre">extern</span> <span class="pre">uint8_t</span> <span class="pre">zclSampleDoorLock_MaxPinCodeLength;</span></code>.</p>
<p>Finally, define the variable within <code class="code docutils literal notranslate"><span class="pre">zcl_sampledoorlock.c</span></code> to be used
by the application. Note the default value and valid range of the
variable in the ZCL 7 Specification.</p>
</div>
<div class="section" id="initializing-clusters">
<h3>Initializing Clusters<a class="headerlink" href="#initializing-clusters" title="Permalink to this headline">¶</a></h3>
<p>For the application to interact with a cluster, the cluster’s compile
flag must be enabled (if applicable to the cluster) in the project’s
configuration and the cluster’s source file must be added to the
project’s Profile to the Workspace.</p>
<p>Once enabled, the cluster’s callbacks can be registered within the
application (refer to <a class="reference internal" href="#sec-cluster-callback-examples"><span class="std std-ref">Cluster Callbacks Example</span></a>).</p>
</div>
<div class="section" id="cluster-architecture">
<h3>Cluster Architecture<a class="headerlink" href="#cluster-architecture" title="Permalink to this headline">¶</a></h3>
<p>All clusters follow the same architecture.</p>
<p>The cluster library within Z-Stack take care of converting the structures passed from native
format to over-the-air format, as required by Zigbee. All application
interaction with clusters takes place in native format.</p>
<p>They all have the following functions:</p>
<ul class="simple">
<li><p><strong>Send</strong> – This group of commands allows various commands to be
send on a cluster</p></li>
<li><p><strong>ProcessIn</strong> – This function processes incoming commands.</p></li>
</ul>
<p>There is usually one send function for each command. The <strong>Send</strong>
function has either a set of parameters or a specific structure for the
command.</p>
<p>If the application has registered callback functions, then the
<strong>ProcessIn</strong> will direct the command (after it’s converted to native
form) to the application callback for that command.</p>
</div>
<div class="section" id="cluster-callbacks-example">
<span id="sec-cluster-callback-examples"></span><h3>Cluster Callbacks Example<a class="headerlink" href="#cluster-callbacks-example" title="Permalink to this headline">¶</a></h3>
<p>Callbacks are used so that the application can perform the expected
behavior on a given incoming cluster command. It is up to the
application to send a response as appropriate. Z-Stack provides the
parsing, but it is up to the application to perform the work.</p>
<p>A cluster’s callback functions are registered within the application’s
initialization function by including the application’s endpoint and a
pointer to the callback record within a register commands callback
function. <a class="reference internal" href="#fig-cluster-callback-example"><span class="std std-numref">Listing 18.</span></a> shows an example of the general cluster’s callback
record list. The commands are registered to their respective callback
functions as defined within the cluster’s profile.</p>
<p>As an example, once a BasicReset command reaches the application layer
on a device, the cluster’s callback record list points the command to
the BasicReset callback function: <code class="code docutils literal notranslate"><span class="pre">zclSampleLight_BasicResetCB</span></code>. The
application reset command can then reset all data back to Factory New
defaults.</p>
<p>The callback function in an application provides additional processing
of a command that is specific to that application. These callback
functions work alongside the response to the incoming command, if a
response is appropriate.</p>
<div class="literal-block-wrapper docutils container" id="id25">
<span id="fig-cluster-callback-example"></span><div class="code-block-caption"><span class="caption-number">Listing 18. </span><span class="caption-text">Cluster Callbacks Example</span><a class="headerlink" href="#id25" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">zclGeneral_AppCallbacks_t</span><span class="w"> </span><span class="n">zclSampleLight_CmdCallbacks</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">zclSampleLight_BasicResetCB</span><span class="p">,</span><span class="w">            </span><span class="c1">// Basic Cluster Reset command</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                   </span><span class="c1">// Identfiy cmd</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                   </span><span class="c1">// Identify Query command</span>
<span class="w">  </span><span class="n">zclSampleLight_IdentifyQueryRspCB</span><span class="p">,</span><span class="w">      </span><span class="c1">// Identify Query Response command</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                   </span><span class="c1">// Identify Trigger Effect command</span>
<span class="cp">#ifdef ZCL_ON_OFF</span>
<span class="w">  </span><span class="n">zclSampleLight_OnOffCB</span><span class="p">,</span><span class="w">                 </span><span class="c1">// On/Off cluster commands</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                   </span><span class="c1">// On/Off cluster enhanced command Off with Effect</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                   </span><span class="c1">// On/Off cluster enhanced command On with Recall Global Scene</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                   </span><span class="c1">// On/Off cluster enhanced command On with Timed Off</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ZCL_LEVEL_CTRL</span>
<span class="w">  </span><span class="n">zclSampleLight_LevelControlMoveToLevelCB</span><span class="p">,</span><span class="w">             </span><span class="c1">// Level Control Move to Level command</span>
<span class="w">  </span><span class="n">zclSampleLight_LevelControlMoveCB</span><span class="p">,</span><span class="w">                    </span><span class="c1">// Level Control Move command</span>
<span class="w">  </span><span class="n">zclSampleLight_LevelControlStepCB</span><span class="p">,</span><span class="w">                    </span><span class="c1">// Level Control Step command</span>
<span class="w">  </span><span class="n">zclSampleLight_LevelControlStopCB</span><span class="p">,</span><span class="w">                    </span><span class="c1">// Level Control Stop command</span>
<span class="w">  </span><span class="n">zclSampleLight_LevelControlMoveToClosestFrequencyCB</span><span class="p">,</span><span class="w">  </span><span class="c1">// Level Control Stop command</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ZCL_GROUPS</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                   </span><span class="c1">// Group Response commands</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ZCL_SCENES</span>
<span class="w">  </span><span class="n">zclSampleLight_SceneStoreCB</span><span class="p">,</span><span class="w">           </span><span class="c1">// Scene Store Request command</span>
<span class="w">  </span><span class="n">zclSampleLight_SceneRecallCB</span><span class="p">,</span><span class="w">          </span><span class="c1">// Scene Recall Request command</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                  </span><span class="c1">// Scene Response command</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ZCL_ALARMS</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                  </span><span class="c1">// Alarm (Response) commands</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SE_UK_EXT</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                  </span><span class="c1">// Get Event Log command</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                  </span><span class="c1">// Publish Event Log command</span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                  </span><span class="c1">// RSSI Location command</span>
<span class="w">  </span><span class="nb">NULL</span><span class="w">                                   </span><span class="c1">// RSSI Location Response command</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="attribute-reporting-functionality">
<h3>Attribute Reporting Functionality<a class="headerlink" href="#attribute-reporting-functionality" title="Permalink to this headline">¶</a></h3>
<p>The Attribute Reporting module takes care of periodically sending the
ZCL Report Attributes command messages for all reportable attributes
defined in the application. The module also processes the ZCL Configure
Reporting and Read Reporting Configuration commands. Multiple
independent compilation flags control the reporting functionality, so
unneeded functionality can be omitted from the code to save resources.</p>
<ul class="simple">
<li><p>To enable BDB <strong>report sending</strong> functionality on a device, include
the <code class="code docutils literal notranslate"><span class="pre">BDB_REPORTING</span></code> compile option.</p></li>
<li><p>To enable BDB <strong>report receiving/processing</strong> functionality, include
the <code class="code docutils literal notranslate"><span class="pre">ZCL_REPORT_DESTINATION_DEVICE</span></code> compile option.</p></li>
<li><p>To enable <strong>configuring reporting parameters</strong> of remote devices, include
the <code class="code docutils literal notranslate"><span class="pre">ZCL_REPORT_CONFIGURING_DEVICE</span></code> compile option.</p></li>
</ul>
<p>The <strong>report sending</strong> functionality implementation is in
<code class="code docutils literal notranslate"><span class="pre">bdb_reporting.c</span></code></p>
<p>The Attribute Reporting functionality was implemented as described in the ZCL 7 Specification.
However, in order to optimize the number of Report Attributes command messages sent over the air,
a consolidation was made for attributes in the same cluster: all reportable attributes of the same cluster share
one Minimum Reporting Interval and one Maximum Reporting Interval.
The shared Minimum Reporting Interval is equal to the lowest of the minimum reporting intervals
of the cluster’s reportable attributes.
Similarly, the Maximum Reporting Interval is equal to the lowest of the maximum reporting intervals.
Refer to section 2.5.11.2.5 of the ZCL 7 Specification
for further details on consolidation of reportable attributes.</p>
<p>The Attribute Reporting module automatically looks into the attribute
definitions registered in the application for all the attributes with
the <code class="code docutils literal notranslate"><span class="pre">ACCESS_REPORTABLE</span></code> flag. Each of these reportable attributes will
have a corresponding Attribute Reporting Configuration record later set
with some default values. The Attribute Reporting module automatically
starts (or stops) the reporting of the attributes in a cluster of an
endpoint when the endpoint’s bind is added (or removed).</p>
<p>In the BDB API (in <code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code>) there is a
method called <code class="code docutils literal notranslate"><span class="pre">bdb_RepAddAttrCfgRecordDefaultToList</span></code>
that adds default Attribute Reporting Configuration record values for each reportable attribute of a cluster.
This API is internal to the stack, but can be accessed by the application through
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbRepAddAttrCfgRecordDefaultToListReq()</span></code>.
This method must be called before the device starts the BDB Commissioning.
If the application does not add default values for a given Attribute
Reporting Configuration record, then global defaults values will be assigned.
Global default MACROS are located in <code class="code docutils literal notranslate"><span class="pre">bdb_reporting.h</span></code>.</p>
<p>When the BDB state machine starts commissioning, the Attribute Reporting
module either loads the previously saved Attribute Reporting Configuration records from NV,
or finds the application’s reportable attributes (from the attribute list) and constructs
the necessary Attribute Reporting Configuration records.
Then the module will consolidate the reportable attributes in each cluster of every endpoint,
in order to trigger the periodic sending of the Report Attributes
command messages using the Maximum Reporting Interval values.</p>
<p>At runtime, the Attribute Reporting module listens for Configure Reporting Command messages
and reconsolidates the cluster’s Reporting Interval values with the records contained in those messages.
Calls to the <code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbRepAddAttrCfgRecordDefaultToListReq</span></code> method after
the BDB Commissioning has started will have no effect on the current Attribute
Reporting Configuration records.</p>
<p>In order for the Attribute Reporting module to manage the sending of
Report Attributes commands when a attribute changes value, the
application must inform the module when any reportable attribute has a
new value. This notification must be made by calling the
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbRepChangedAttrValueReq()</span></code> method of the Z-Stack API. The Attribute Reporting
module will get the current value of the attribute from the callback
defined in the application attribute definitions, meaning that the new
value must be set before calling the notification method.</p>
</div>
</div>
<div class="section" id="commissioning">
<span id="z-stack-overview-commissioning"></span><h2>Commissioning<a class="headerlink" href="#commissioning" title="Permalink to this headline">¶</a></h2>
<p>The BDB commissioning method provides a mechanism to invoke a series of
procedures that provides the ability to easily connect devices together.
Depending on the commissioning methods invoked, devices will perform
actions like forming networks, joining existing networks, and binding
application endpoints.</p>
<p>The source files that control the commissioning procedures are located
in the BDB folder. The API interface is located
in <code class="code docutils literal notranslate"><span class="pre">zstackapi.h</span></code> with the prefix <code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdb*</span></code>.
The default configuration of BDB functionality is found in <code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code>.
BDB functionality may be modified at run time through the API.</p>
<p>The BDB interface provides an API to trigger one or more commissioning
procedures defined as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#if ZG_BUILD_COORDINATOR_TYPE</span>
<span class="c1">//By default, Coordiantor has Formation selected in the UI menu</span>
<span class="cp">#define DEFAULT_COMISSIONING_MODE (BDB_COMMISSIONING_MODE_NWK_STEERING | BDB_COMMISSIONING_MODE_NWK_FORMATION | BDB_COMMISSIONING_MODE_FINDING_BINDING)</span>
<span class="cp">#else</span>
<span class="c1">//By default, joining devices such as Router and ZED do not have formation selected. It can be enabled in the UI if needed.</span>
<span class="cp">#define DEFAULT_COMISSIONING_MODE (BDB_COMMISSIONING_MODE_NWK_STEERING | BDB_COMMISSIONING_MODE_FINDING_BINDING)</span>
<span class="cp">#endif</span>

<span class="p">...</span><span class="w"></span>

<span class="cp">#if defined(USE_DMM) || !defined(CUI_DISABLE)</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">zclSampleSw_BdbCommissioningModes</span><span class="p">;</span><span class="w"></span>
<span class="n">zclSampleSw_BdbCommissioningModes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_COMISSIONING_MODE</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="p">...</span><span class="w"></span>

<span class="n">zstack_bdbStartCommissioningReq_t</span><span class="w"> </span><span class="n">zstack_bdbStartCommissioningReq</span><span class="p">;</span><span class="w"></span>
<span class="n">zstack_bdbStartCommissioningReq</span><span class="p">.</span><span class="n">commissioning_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zclSampleSw_BdbCommissioningModes</span><span class="p">;</span><span class="w"></span>
<span class="n">Zstackapi_bdbStartCommissioningReq</span><span class="p">(</span><span class="n">appServiceTaskId</span><span class="p">,</span><span class="o">&amp;</span><span class="n">zstack_bdbStartCommissioningReq</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">zclSample_BdbCommissioningModes</span></code> (the switch application is used as an example)
is the bitmask for the commissioning modes to be executed and defined as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BDB_COMMISSIONING_MODE_INITIATOR_TL</span><span class="w">     </span><span class="mb">0b00000001</span><span class="w"></span>
<span class="n">BDB_COMMISSIONING_MODE_NWK_STEERING</span><span class="w">     </span><span class="mb">0b00000010</span><span class="w"></span>
<span class="n">BDB_COMMISSIONING_MODE_NWK_FORMATION</span><span class="w">    </span><span class="mb">0b00000100</span><span class="w"></span>
<span class="n">BDB_COMMISSIONING_MODE_FINDING_BINDING</span><span class="w">  </span><span class="mb">0b00001000</span><span class="w"></span>
</pre></div>
</div>
<p>This commissioning mask is appended to the current commissioning modes being executed.
The tasks are also executed with the priority listed above
(TL as initiator first, then Nwk steering, then Formation, and lastly Finding and Binding).
The priority of the tasks are checked when the current task is finished.
The tasks can be appended at any time (e. g. in response to a commissioning notification).
For example, suppose Nwk steering and Formation are requested. Nwk steering will start running.
If TL as initiator is requested before Nwk steering is finished,
then TL as initiator will start after Nwk steering is finished but before Formation starts.</p>
<p>There are other commissioning modes that the BDB machine state handles:
<strong>BDB_COMMISSIONING_MODE_INITIALIZATION</strong>  and <strong>BDB_COMMISSIONING_MODE_PARENT_LOST</strong>.
These states should not be directly used by the application.</p>
<div class="section" id="bdb-notifications">
<span id="sec-bdb-notifications"></span><h3>BDB Notifications<a class="headerlink" href="#bdb-notifications" title="Permalink to this headline">¶</a></h3>
<p>The application will receive BDB notifications from the stack automatically and
will have the ID <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_BDB_NOTIFICATION</span></code>.
The application can trigger another commissioning method upon receiving
a certain notification. For example, a router device may start network steering
to search for a suitable network and count the number of times this process
fails. If this process fails ‘x’ times in a row, then it may decide to change
the channel mask to search networks in other channels or to form its own network.
The full API is described in <a class="reference external" href="../../../zigbee/zstack-apis.html">Z-Stack API</a>.</p>
<p>The notifications are called when certain tasks start or finish.
Different logical devices may handle and interpret the notifications differently.</p>
<p>Every notification will have a pointer to a structure of type
<code class="code docutils literal notranslate"><span class="pre">bdbCommissioningModeMsg_t</span></code>, which contains the commissioning mode being
reported, the status, and the mask of the remaining commissioning modes
to be executed. The notifications (commissioning modes and statuses) are defined in
<code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code>. The same information is documented in the following table.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 31%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Commissioning mode (<strong>BDB_COMMISSIONING_mode</strong>)</p></td>
<td><p>Status reported (<strong>BDB_COMMISSIONING_status</strong>)</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p><strong>INITIALIZATION</strong></p></td>
<td><p><strong>NETWORK_RESTORED</strong></p></td>
<td><p>Only send if the device did restore its network parameters.
On end devices, if no parent is found with the restored
network parameters, a <em>Parent Lost</em> mode is with status
<em>No Network</em> is notified.</p></td>
</tr>
<tr class="row-odd"><td rowspan="4"><p><strong>NWK_STEERING</strong> (for Router and End Devices)</p></td>
<td><p><strong>IN_PROGRESS</strong></p></td>
<td><p>Notifies when network steering is started (only if the
device is not in a network, otherwise reports <em>success</em>)</p></td>
</tr>
<tr class="row-even"><td><p><strong>NO_NETWORK</strong></p></td>
<td><p>No suitable network was found in primary channel or
secondary channel masks or the joining process did fail in
the attempted networks.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>TCLK_EX_FAILURE</strong></p></td>
<td><p>The device successfully joined the network, but could not
perform the Trust Center Link Key exchange process. The
device will reset to factory new after this notification is
reported to the application.</p></td>
</tr>
<tr class="row-even"><td><p><strong>SUCCESS</strong></p></td>
<td><p>The device is now on a network and broadcasted a Management
Permit Joining ZDO frame.</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p><strong>NWK_STEERING</strong> (for Coordinators)</p></td>
<td><p><strong>NO_NETWORK</strong></p></td>
<td><p>The device is not on a network, so it cannot perform this
action.</p></td>
</tr>
<tr class="row-even"><td><p><strong>SUCCESS</strong></p></td>
<td><p>The device is in a network and has broadcasted a Management
Permit Joining ZDO frame.</p></td>
</tr>
<tr class="row-odd"><td rowspan="3"><p><strong>FORMATION</strong></p></td>
<td><p><strong>IN_PROGRESS</strong></p></td>
<td><p>Notifies when formation process is started.</p></td>
</tr>
<tr class="row-even"><td><p><strong>SUCCESS</strong></p></td>
<td><p>The network has been created successfully.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>FORMATION_FAILURE</strong></p></td>
<td><p>The device could not create the network with the given
parameters.</p></td>
</tr>
<tr class="row-even"><td rowspan="5"><p><strong>FINDING_BINDING</strong></p></td>
<td><p><strong>FB_TARGET_IN_PROGRESS</strong></p></td>
<td><p>Indicates the start of the Finding and Binding as target. No
notification is given by this callback when the process ends</p></td>
</tr>
<tr class="row-odd"><td><p><strong>FB_INITITATOR_IN_PROGRESS</strong></p></td>
<td><p>Indicates the start of the Finding and Binding as Initiator.</p></td>
</tr>
<tr class="row-even"><td><p><strong>FB_NO_IDENTIFY_QUERY_RESPONSE</strong></p></td>
<td><p>After complete the Finding and Binding process as initiator
(single attempt of periodic attempt), no identify query
responses were received.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>FB_BINDING_TABLE_FULL</strong></p></td>
<td><p>During the Finding and Binding process the binding table got
full, so the process stops and no additional binds can be
added.</p></td>
</tr>
<tr class="row-even"><td><p><strong>FAILURE</strong></p></td>
<td><p>No endpoint was found to perform Finding and Binding, or the
endpoint did not have implemented the Identify cluster
properly.</p></td>
</tr>
<tr class="row-odd"><td rowspan="4"><p><strong>TOUCHLINK</strong></p></td>
<td><p><strong>TL_TARGET_FAILURE</strong></p></td>
<td><p>A node has not joined a network when requested during
touchlink.</p></td>
</tr>
<tr class="row-even"><td><p><strong>TL_NOT_AA_CAPABLE</strong></p></td>
<td><p>The initiator is not address assignment capable during
touchlink</p></td>
</tr>
<tr class="row-odd"><td><p><strong>TL_NO_SCAN_RESPONSE</strong></p></td>
<td><p>No response to a Scan Request inter-PAN command has been
received during touchlink</p></td>
</tr>
<tr class="row-even"><td><p><strong>TL_NOT_PERMITTED</strong></p></td>
<td><p>A touchlink steal attempt was made when a node is already
connected to a centralized security network.</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p><strong>PARENT_LOST</strong> (Only for End Devices)</p></td>
<td><p><strong>NO_NETWORK</strong></p></td>
<td><p>This is notified if the end device does lose contact with
the parent device or if after initialization it cannot find
a parent device in the commissioned network.</p></td>
</tr>
<tr class="row-even"><td><p><strong>NETWORK_RESTORED</strong></p></td>
<td><p>Notification that a suitable parent device got found and the
rejoin process was successful.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="initialization-procedure">
<h3>Initialization Procedure<a class="headerlink" href="#initialization-procedure" title="Permalink to this headline">¶</a></h3>
<p>The BDB interface will perform an initialization when <code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbStartCommissioningReq()</span></code>
is called after a power cycle. Any commissioning mode mask may be used,
and the power cycle is detected by the global RAM variable <code class="code docutils literal notranslate"><span class="pre">bdb_initialization</span></code>.
If the attribute <code class="code docutils literal notranslate"><span class="pre">bdbNodeIsOnANetwork</span></code> is <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>,
the initialization procedure retrieves the network parameters from NV.
Coordinator and router devices will rejoin the network and resume operations as if they never left.
Upon rejoining, they will send and process parent annce messages (see <a class="reference internal" href="#sec-parent-annce"><span class="std std-ref">Parent Annce</span></a>).
End devices will restore the network parameters and try to perform a rejoin on
any parent available in the same network only one time.
This procedure is illustrated in <a class="reference internal" href="#fig-initialization-restore-router-coordinator"><span class="std std-numref">Figure 58.</span></a> and
<a class="reference internal" href="#fig-initialization-restore-end-device"><span class="std std-numref">Figure 59.</span></a>.</p>
<div class="figure align-center" id="id26">
<span id="fig-initialization-restore-router-coordinator"></span><p class="plantuml">
<img src="../_images/plantuml-34023fba4089ae41675af5fb6d739747bb22aaba.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Begin;
if (Is bdb_initialization = FALSE?) then (Yes)
    if (Is bdbNodeIsOnANetwork = TRUE?) then (Yes)
    :Restore network parameters]
    :Notify NETWORK_RESTORED/
    else (No)
    endif
else (No)
endif
:End;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 58. </span><span class="caption-text">Initialization Procedure for a Router/Coordinator</span><a class="headerlink" href="#id26" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id27">
<span id="fig-initialization-restore-end-device"></span><p class="plantuml">
<img src="../_images/plantuml-1ec46702795e9462a6a8f6c81137cbc3c0f3a3b9.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Begin;
if (Is bdb_initialization = FALSE?) then (Yes)
    if (Is bdbNodeIsOnANetwork = TRUE?) then (Yes)
    :Restore network parameters]
    :Attempt rejoin to any parent with the network parameters restored]
    if (Suitable parent device found with the network parameters?) then (Yes)
    :Notify NETWORK_RESTORED/
    else (No)
    :Notify PARENT_LOST/
    endif
    else (No)
    endif
else (No)
endif
:End;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 59. </span><span class="caption-text">Initialization Procedure for a End Device</span><a class="headerlink" href="#id27" title="Permalink to this image">¶</a></p>
</div>
<p>If <code class="code docutils literal notranslate"><span class="pre">ZR_SILENT_REJOIN</span></code> is set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> in <code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code> then routers will perform
a non-silent rejoin, in which case they send the Rejoin Request to commission back into the network.
This will also start the TC rejoin process if the network key has been switched.</p>
<p>Note that if the initialization process fails for an end device it will
notify the application of a <code class="code docutils literal notranslate"><span class="pre">PARENT_LOST</span></code> status. Refer to <a class="reference internal" href="#z-stack-overview-parent-lost"><span class="std std-ref">Parent Lost</span></a>
on how to restore the network or <a class="reference internal" href="#sec-reset-procedures"><span class="std std-ref">Reset Procedures</span></a> to reset the device to
factory new.</p>
</div>
<div class="section" id="parent-lost">
<span id="z-stack-overview-parent-lost"></span><h3>Parent Lost<a class="headerlink" href="#parent-lost" title="Permalink to this headline">¶</a></h3>
<p>If an end device loses contact with its parent device
or is reset while joined to a network,
the BDB module will send the application a
<code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_PARENT_LOST</span></code> notification,
after which the end device cannot perform any other commissioning method.
The device must either restore its network or
reset to factory new and be commissioned again.
To restore the network, the device must call
<code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbZedAttemptRecoverNwkReq()</span></code>,
which performs a single active scan in the network for a suitable parent
(same Extended PAN ID and child device capacity).
This means that the device sends a single beacon request.
If no suitable parent device is found, then
another <code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_PARENT_LOST</span></code> notification is sent to the application.
The application is responsible for attempting to restore the network.
The interval between these attempts should increase to reduce power consumption.
If Finding and Binding was in progress when the device lost its parent,
it will keep running and resume its operation for the remaining time after the device restores its operation.</p>
</div>
<div class="section" id="network-steering-procedure-for-a-node-on-a-network">
<h3>Network Steering Procedure for a Node on a Network<a class="headerlink" href="#network-steering-procedure-for-a-node-on-a-network" title="Permalink to this headline">¶</a></h3>
<p>If network steering is invoked by a device that is already on a network
(<code class="code docutils literal notranslate"><span class="pre">bdbNodeIsOnANetwork</span></code> set to <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>), it will broadcast a permit joining
request for 180 seconds (<code class="code docutils literal notranslate"><span class="pre">BDBC_MIN_COMMISSIONING_TIME</span></code>), after which
the device will notify the application of <code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_SUCCESS</span></code>.</p>
<div class="figure align-center" id="id28">
<p class="plantuml">
<img src="../_images/plantuml-b67bfbd7ba7ca87b78e573b4c772baca85a8c23a.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Start;
:Broadcast ZDP_MgmtPermitJoinReq]
if (Logical Type ZC/ZR?) then (Yes)
:Enable permit join for ≥\nBDBC_MIN_COMMISSIONING_TIME;
else (No)
endif
:Notify SUCCESS/
:End;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 60. </span><span class="caption-text">Network Steering Procedure for a Node On a Network</span><a class="headerlink" href="#id28" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="network-steering-procedure-for-a-node-not-on-a-network">
<span id="z-stack-overview-nwk-steering-not-on-nwk"></span><h3>Network Steering Procedure for a Node not on a Network<a class="headerlink" href="#network-steering-procedure-for-a-node-not-on-a-network" title="Permalink to this headline">¶</a></h3>
<p>This procedure is performed when Network Steering is requested and the
device is not on a network (<code class="code docutils literal notranslate"><span class="pre">bdbNodeIsOnANetwork</span></code> set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>).
This will cause the device to start looking for suitable networks to join. The
procedure is illustrated in <a class="reference internal" href="#fig-nwk-steering-not-in-a-network"><span class="std std-numref">Figure 61.</span></a> and
described as follows:</p>
<ol class="arabic simple">
<li><p>The device will perform a scan in all channels defined in
<code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_PRIMARY_CHANNEL_SET</span></code>, searching for any suitable
network and creating a network descriptor list of the networks found.</p>
<ol class="loweralpha simple">
<li><p>The application will receive a <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_BDB_FILTER_NWK_DESCRIPTOR_IND</span></code>
message, which contains a list of network descriptors of the networks found
during the scan. It can use Zstackapi_bdbNwkDescFreeReq() to remove network
descriptors of networks that it will not attempt to join.</p></li>
<li><p>If no suitable networks are found or the device cannot perform
joining on the networks found (association was not successful or
could not get the network key), then the device will proceed to perform
the same steps but with the channel mask defined in
<code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_SECONDARY_CHANNEL_SET</span></code>.</p></li>
<li><p>Only non-zero channel masks are used for network discovery.</p></li>
</ol>
</li>
<li><p>The BDB state machine will try to perform association and
authentication in the suitable networks discovered using the security
keys for Centralized networks (default key or Install Code) or
Distributed networks as defined in <a class="reference internal" href="#z-stack-overview-security"><span class="std std-ref">Security</span></a>. For Centralized
networks it will also perform the TCLK exchange.</p></li>
<li><p>If the joining procedure is completed, then the joining device will broadcast a permit joining request
to refresh the joining timeout for other devices trying to join simultaneously.
The network manager can close the network for joining by sending a permit join request with timeout = 0.</p></li>
</ol>
<div class="figure align-center" id="id29">
<span id="fig-nwk-steering-not-in-a-network"></span><p class="plantuml">
<img src="../_images/plantuml-cbb42520bce06417b0ce11bf5acd5d79a53135b7.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Start;
:Notify IN_PROGRESS/
:Nwk discovery over \nbdbPrimaryChannelSet]
:A;
if (Was discovery \nsuccessful?) then (Yes)
    :Determine a list of \nsuitable networks]
    if (Was a suitable \nnwk found?) then (Yes)
        :B;
        :Try MAC association]
        if (Was the join successful?) then (Yes)
            :Wait for nwk key]
            if (Was the nwk key received successfully?) then (Yes)
                :Broadcast device announce]
                if (Is the TC addr = 0xFFFFFFFFFFFFFFFF?) then (No)
                    :Retrieve a new TCLK|
                    if (Was the nwk key received successfully?) then (No)
                        :Leave the nwk and reset nwk parameters]
                        :Notify TCLK_EX_FAILURE/
                        :End;
                        detach
                    else (Yes)
                    endif
                 else (Yes)
                 endif
            :Broadcast ZDP_MgmtPermitJoinReq]
            :Notify SUCCESS/
            :End;
            detach
            else (No)
            :Reset nwk parameters]
            :C;
            detach
            endif
        else (No)
            :C;
            if (More networks to try?) then (Yes)
                :B;
                detach
            else (No)
                :D;
                detach
            endif
        endif
     else (No)
        :D;
        detach
     endif
else (No)
     :D;
     if (Is bdbSecondaryChannelSet = 0 \nor has already been attempted?) then (Yes)
        :Notify NO_NETWORK/
        :End;
        detach
     else (No)
        :Nwkdiscovery over \nbdbSecondaryChannelSet]
        :A;
        detach
endif
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 61. </span><span class="caption-text">Network Steering Procedure for a Node Not on a Network</span><a class="headerlink" href="#id29" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="network-formation">
<h3>Network Formation<a class="headerlink" href="#network-formation" title="Permalink to this headline">¶</a></h3>
<p>This procedure defines the steps to take when a device with formation
capabilities is instructed to form a network (coordinator or router). If
an end device is instructed to perform formation, then it will report a
failure.</p>
<p>The formation process for devices with formation capabilities consists
of a first attempt to create the network in any of the channels selected
in the primary channel mask, and if for any reason it cannot perform the
formation in those channels (channel mask invalid or selected PAN ID
already found in the same channel) the device will try to perform
formation in the secondary channel mask. If both of these procedures
fail, it will report a <code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_FORMATION_FAILURE</span></code> to the
application. If formation is performed successfully then a
<code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_FORMATION_SUCCESS</span></code> is sent instead.
After a successful network formation,
the application can open the network for joining with the network steering procedure.</p>
<div class="figure align-center" id="id30">
<p class="plantuml">
<img src="../_images/plantuml-94255b81dc2fffbe4767a1cba3ab5738851a7fa7.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Start;
:Notify IN_PROGRESS/
:Network Discovery over\nbdbPrimaryChannelSet]
while (Formation Successful?) is (No)
if (Is bdbSecondaryChannelSet=0?\nOr has already been attempted?) then (Yes)
    :Notify FORMATION_FAILURE/
    :End;
    detach
else (No)
    :Network Discovery over\nbdbSeconaryChannelSet]
endif
endwhile (Yes)
if (Logical Type ZC?) then (Yes)
:Initiate Trust Center\nfunctionality]
else (No)
endif
:Notify SUCCESS;
:End;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 62. </span><span class="caption-text">Network Formation</span><a class="headerlink" href="#id30" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="z-stack-overview-finding-binding">
<span id="id7"></span><h3>Finding and Binding<a class="headerlink" href="#z-stack-overview-finding-binding" title="Permalink to this headline">¶</a></h3>
<p>The Finding and Binding procedure can be performed as initiator, target, or both,
depending on the clusters of the endpoint performing the Finding and Binding procedure.
For example, if an endpoint has a cluster that is meant to be initiator,
the Finding and Binding process for this endpoint will be executed as initiator.
The definitions for initiator or target on clusters can be found in Zigbee ZCL 7 Specification.</p>
<p>The application must specify with which endpoint it wants to perform the
finding and binding procedure by calling <code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbSetIdentifyActiveEndpointReq()</span></code>.
Note that the endpoint indicated must contain the Identify cluster in order
to perform the procedure.</p>
<div class="section" id="finding-binding-procedure-for-a-target-endpoint">
<h4>Finding &amp; Binding Procedure for a Target Endpoint<a class="headerlink" href="#finding-binding-procedure-for-a-target-endpoint" title="Permalink to this headline">¶</a></h4>
<p>When finding and binding is triggered on a target endpoint, the endpoint
identifies itself for a finite period of time and handles the identify
query commands from the initiator device.
This commissioning procedure sends a <code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_FB_INITIATOR_IN_PROGRESS</span></code>
notification when it starts and a zstackmsg <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_BDB_IDENTIFY_TIME_CB</span></code> when it finishes.</p>
<div class="figure align-center" id="id31">
<p class="plantuml">
<img src="../_images/plantuml-9b509f0abe42aa263012bb3fe9a1907d942bf520.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Begin;
:Notify FB_INITIATOR_IN_PROGRESS/
:Enable permit join for ≥
BDBC_MIN_COMMISSIONING_TIME]
repeat
  :Handle Identify Query Request]
repeat while (Identify Time Expired?) is (No)
-&gt;Yes;
:End;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 63. </span><span class="caption-text">Finding &amp; Binding Procedure for a Target Endpoint</span><a class="headerlink" href="#id31" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="finding-and-binding-procedure-for-an-initiator-endpoint">
<h4>Finding and Binding Procedure for an Initiator Endpoint<a class="headerlink" href="#finding-and-binding-procedure-for-an-initiator-endpoint" title="Permalink to this headline">¶</a></h4>
<p>In this procedure, the initiator will search for identifying endpoints
by broadcasting identify query commands and requesting a simple descriptor for each node found.
Then the binds for matching application clusters are created in the initiator.
If group bind is requested, the initiator endpoint configures a group membership of the target endpoints.</p>
<p>The finding and binding process for an initiator device is illustrated
in <a class="reference internal" href="#fig-finding-binding-initiator"><span class="std std-numref">Figure 64.</span></a> and described here:</p>
<ol class="arabic simple">
<li><p>The application is notified about the commissioning method starting,
and the local device broadcasts an Identify Query command.</p>
<ol class="loweralpha simple">
<li><p>If no identify query responses are received over the process, then
the application receives a <code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_FB_NO_IDENTIFY_QUERY_RESPONSE</span></code> and the process finishes.</p></li>
<li><p>If the device receives one or more responses then the device
creates a list of the device responses (respondent devices).</p></li>
</ol>
</li>
<li><p>The local device sends a ZDO simple descriptor request to each respondent device one at a time.
If no response is received, the local device will send a ZDO simple descriptor request
to the next respondent in the list.
If no response from a respondent is received after FINDING_AND_BINDING_MAX_ATTEMPTS attempts,
the local device marks that respondent as completely processed.
This step repeats until all respondents are completely processed.</p></li>
<li><p>Upon the reception of a simple descriptor response,
the local device will search for application clusters compatible with the endpoint in the local device
that is performing the Finding and Binding procedure.</p></li>
<li><p>If the device is performing unicast binds (<code class="code docutils literal notranslate"><span class="pre">BDB_DEFAULT_COMMISSIONING_GROUP_ID</span> <span class="pre">==</span> <span class="pre">0xFFFF</span></code>),
it searches for the IEEE address of the respondent device in the address manager.
If not found, it sends a ZDO IEEE address request command.
The device reattempts this process until the IEEE address response is received from the respondent
and the bind entry is created for the matching clusters.
After FINDING_AND_BINDING_MAX_ATTEMPTS attempts, this respondent is marked as processed without adding any bind.
Group binds are created if any match is found.
For the definition of application clusters, refer to the Zigbee ZCL 7 Specification.</p>
<ol class="loweralpha simple">
<li><p>The application will receive bind notifications via a zstackmsg of ID
<code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_BDB_BIND_NOTIFICATION_CB</span></code>.</p></li>
<li><p>If the bind table gets full during this process the application
will receive a <code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_FB_TABLE_FULL</span></code> notification and
the process will be finished.</p></li>
</ol>
</li>
<li><p>The local device will repeat steps 2 to 4 until all respondents are marked as processed.
Then it will send a <code class="code docutils literal notranslate"><span class="pre">BDB_COMMISSIONING_SUCCESS</span></code> notification to the application.</p></li>
</ol>
<p>The Finding and Binding procedure for groups enables APS Acknowledgements
to increase reliability of creating the group membership at the remote device.</p>
<p>The finding and binding process for an initiator device can be
configured to perform periodically every
<code class="code docutils literal notranslate"><span class="pre">FINDING_AND_BINDING_PERIODIC_TIME</span></code> seconds instead of
<code class="code docutils literal notranslate"><span class="pre">BDBC_MIN_COMMISSIONING_TIME</span></code> (180) seconds. This configuration is determined by
<code class="code docutils literal notranslate"><span class="pre">FINDING_AND_BINDING_PERIODIC_ENABLE</span></code> (default value is
<code class="code docutils literal notranslate"><span class="pre">TRUE</span></code>).
In this case, multiple identify query command responses from the same device
will not be duplicated in the respondent list.
The Finding and Binding process can be terminated early
by calling <code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbStopInitiatorFindingBindingReq()</span></code>.</p>
<div class="figure align-center" id="id32">
<span id="fig-finding-binding-initiator"></span><p class="plantuml">
<img src="../_images/plantuml-e656f674a5a0c1bc920361fb886e8074d825cca1.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Begin;
:Notify FB_TARGET_IN_PROGRESS/
:Broadcast identify query]
if (Identify Query Response received?) then (Yes)
repeat
:Request Simple Descriptor for the next endpoint]
if (Valid Simple Descriptor Response received?) then (Yes)
    repeat
    if (Next Cluster Match?) then (Yes)
        :Attempt creating entry in Binding Table
        with next matching cluster]
        if (Binding Table full?) then (Yes)
        :Notify BINDING_TABLE_FULL/
        :End;
        detach
        else (No)
        endif
    else (No)
    endif
    repeat while (Other Clusters to try?) is (Yes)
    -&gt;No;
    :Configure bdbCommissioningGroupID Group
    on the respondent]
else (No)
endif
repeat while (Other Endpoints to try?) is (Yes)
-&gt;No;
:Notify SUCCESS/
else (No)
:Notify NO_IDENTIFY_QUERY_RESPONSE/
endif
:End;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 64. </span><span class="caption-text">Finding &amp; Binding Procedure for an Initiator Endpoint</span><a class="headerlink" href="#id32" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="touchlink-commissioning">
<span id="z-stack-overview-touchlink-commissioning"></span><h3>Touchlink Commissioning<a class="headerlink" href="#touchlink-commissioning" title="Permalink to this headline">¶</a></h3>
<p>Touchlink commissioning is an optional commissioning mechanism defined in the Zigbee BDB specification,
where nodes are commissioned using inter-PAN communication. It requires physical proximity between devices.</p>
<div class="section" id="configurations">
<h4>Configurations<a class="headerlink" href="#configurations" title="Permalink to this headline">¶</a></h4>
<p>The configurations in the following sections must be modified by the user to create a
valid Touchlink device. They are all found in the file <code class="code docutils literal notranslate"><span class="pre">bdb_interface.h</span></code> except for the assignment
of <code class="code docutils literal notranslate"><span class="pre">BDB_TL_INITIATOR</span></code> and <code class="code docutils literal notranslate"><span class="pre">BDB_TL_TARGET</span></code> modes which are selected through the SysConfig
<em>RF STACKS</em> → <em>Z-Stack</em> → <em>Touchlink Commissioning Endpoint</em> interface.</p>
<div class="section" id="key-installation">
<h5>Key Installation<a class="headerlink" href="#key-installation" title="Permalink to this headline">¶</a></h5>
<p>All commercial Touchlink products use the “Touchlink master key” and the
“Touchlink pre-installed link key” set. This set of keys could be
available to manufacturers which have a successfully certified Touchlink product,
using the certification keys set provided by default.</p>
<p>Note that any Touchlink implementation will not be able to interoperate
with commercial Touchlink devices without the Touchlink master keys.
Once the Touchlink master keys have been achieved, they should be
installed in the code with the following modifications:</p>
<blockquote>
<div><p>1. Overwrite the <code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_CERTIFICATION_ENC_KEY</span></code> and
<code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_CERTIFICATION_LINK_KEY</span></code> with the actual secret
values.</p>
<p>2. Change the <code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_KEY_INDEX</span></code> definition to
<code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_KEY_INDEX_MASTER</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="constants">
<h5>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h5>
<p>The BDB defines constants and internal attribute defaults to allow a
device to manage how the Touchlink device operates (see
Base Device Behavior Specification).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 39%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Definition</strong></p></th>
<th class="head"><p><strong>Specification’s Constant /
Attribute default</strong></p></th>
<th class="head"><p><strong>Value</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BDBCTL_INTER_PAN_TRANS_ID_LIFETIME</p></td>
<td><p><em>bdbcTLInterPANTransIdLifetime</em></p></td>
<td><p>8000</p></td>
</tr>
<tr class="row-odd"><td><p>BDBCTL_MIN_STARTUP_DELAY_TIME</p></td>
<td><p><em>bdbcTLMinStartupDelayTime</em></p></td>
<td><p>2000</p></td>
</tr>
<tr class="row-even"><td><p>BDBCTL_PRIMARY_CHANNEL_LIST</p></td>
<td><p><em>bdbcTLPrimaryChannelSet</em></p></td>
<td><p>0x02108800</p></td>
</tr>
<tr class="row-odd"><td><p>BDBCTL_RX_WINDOW_DURATION</p></td>
<td><p><em>bdbcTLRxWindowDuration</em></p></td>
<td><p>5000</p></td>
</tr>
<tr class="row-even"><td><p>BDBCTL_SCAN_TIME_BASE_DURATION</p></td>
<td><p><em>bdbcTLScanTimeBaseDuration</em></p></td>
<td><p>250</p></td>
</tr>
<tr class="row-odd"><td><p>BDBCTL_SECONDARY_CHANNEL_LIST</p></td>
<td><p><em>bdbcTLSecondaryChannelSet</em></p></td>
<td><p>0x05EF7000</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="endpoint-setup">
<h5>Endpoint Setup<a class="headerlink" href="#endpoint-setup" title="Permalink to this headline">¶</a></h5>
<p>Since the Touchlink commissioning is managed by a dedicated task separate from the applications,
its endpoint and device ID may be re-defined.
The endpoint must be a valid value that is not used by the device’s other endpoints.
The device ID must not equal any valid device ID (to prevent accidental matches).  By default,
<code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_INTERNAL_ENDPOINT</span></code> is 13 and <code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_INTERNAL_DEVICE_ID</span></code> is = 0xE15E.</p>
</div>
<div class="section" id="identify-sequence-time-interval">
<h5>Identify Sequence Time Interval<a class="headerlink" href="#identify-sequence-time-interval" title="Permalink to this headline">¶</a></h5>
<p>In the Touchlink commissioning sequence, if an appropriate scan response
command is received, the initiator will send an Identify command to the
chosen target and then wait for a time interval defined by <code class="code docutils literal notranslate"><span class="pre">BDB_TL_IDENTIFY_TIME</span></code>
(in milliseconds) before sending a network start or network join command.</p>
<p>When an Identify Request command is received with identify duration
field value set to 0xffff (default time known by the receiver), the
application’s Identify callback function will be called with a duration
value set according to the <code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_DEFAULT_IDENTIFY_TIME</span></code> (default 3 seconds):</p>
<p>It is possible to gracefully abort a touch-link process (see
Base Device Behavior Specification), until the end of this time
interval. Beyond that, target state may change irreversibly. If abort is
employed and controlled by a human interaction, it is recommended to
increase this value (e.g. to 2000). Please note that increasing it to a
higher value than the default also increases the risk of atouch-link
failure due to transaction lifetime expiration, especially if done on
the secondary channel set.</p>
</div>
<div class="section" id="free-ranges-split-thresholds">
<h5>Free Ranges Split Thresholds<a class="headerlink" href="#free-ranges-split-thresholds" title="Permalink to this headline">¶</a></h5>
<p>When initiating Touchlink commissioning with devices which are capable
of assigning addresses, ranges of free network addresses and group
identifiers held by the initiator could be split and passed to the
target.</p>
<p>The initiator can split its ranges as long as the remaining range and
the target range are no less than the minimum size, defined by
<code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_ADDR_THRESHOLD</span></code> (the minimum size of addresses range,
default 10) and <code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_GRP_ID_THRESHOLD</span></code> (the minimum size
of group identifiers range, default 10).</p>
</div>
<div class="section" id="application-selective-target-touchlink">
<h5>Application Selective Target TouchLink<a class="headerlink" href="#application-selective-target-touchlink" title="Permalink to this headline">¶</a></h5>
<p>This feature allows overriding the default RSSI-based target selection
during Touchlink with an application-specific selection function. An
application selection function could be used in scenarios where multiple
targets are expected to have similar RSSI (e.g. multiple lights bundled
together), and allows integrating other parameters in the selection
(e.g. Factory New state, previously selected device, etc.).</p>
</div>
</div>
<div class="section" id="development-only-parameters">
<h4>Development-Only Parameters<a class="headerlink" href="#development-only-parameters" title="Permalink to this headline">¶</a></h4>
<p>The following parameters, if enabled, will break Touchlink conformity
and security rules. They may be used to assist during development, but
must be disabled before release. All the parameters could be uncommented
in <code class="code docutils literal notranslate"><span class="pre">bdb.h</span></code> file, instead of being defined globally in the project.</p>
<div class="section" id="channel-offset">
<h5>Channel Offset<a class="headerlink" href="#channel-offset" title="Permalink to this headline">¶</a></h5>
<p>The flags <code class="code docutils literal notranslate"><span class="pre">Ch_Plus_1</span></code>, <code class="code docutils literal notranslate"><span class="pre">Ch_Plus_2</span></code>, or <code class="code docutils literal notranslate"><span class="pre">Ch_Plus_3</span></code> can be set in the
<code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_CH_OFFSET</span></code> definition in <code class="code docutils literal notranslate"><span class="pre">bdb.h</span></code> to shift the primary channel set,
which will allow testing of multiple Touchlink devices
set in the same space without interference.
This should be used for testing purposes only.
<code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_CH_OFFSET</span></code> is defined by default as <code class="code docutils literal notranslate"><span class="pre">No_Ch_offset</span></code>,
which means that no shift is applied to the primary channel set.</p>
</div>
<div class="section" id="fixed-first-channel-selection">
<h5>Fixed First Channel Selection<a class="headerlink" href="#fixed-first-channel-selection" title="Permalink to this headline">¶</a></h5>
<p>The flag <code class="code docutils literal notranslate"><span class="pre">TOUCHLINK_DEV_SELECT_FIRST_CHANNEL</span></code>, if enabled during
compilation, will override the random channel selection mechanism
employed by the Touchlink device, and will set it to always select the
first primary channel.</p>
</div>
</div>
<div class="section" id="touchlink-commissioning-procedure-for-an-initiator">
<h4>Touchlink Commissioning Procedure for an Initiator<a class="headerlink" href="#touchlink-commissioning-procedure-for-an-initiator" title="Permalink to this headline">¶</a></h4>
<p>In this procedure the initiator scans for nodes that support touchlink,
and if any are found, the touchlink commissioning procedure establishes
a new distributed network with the target.</p>
<div class="figure align-center" id="id33">
<p class="plantuml">
<img src="../_images/plantuml-8ca407f23a1fee37d1609e0e529391c451f08cba.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Begin;
:Notify IN_PROGRESS/
:Send scan request over bdbPrimaryChannelSet]
while (Is primary scan done or bdbSecondaryChannelSet = 0?) is (Yes)
    :Send scan request over bdbPrimaryChannelSet]
endwhile (No)
if (Valid scan response received?) then (Yes)
    :Determine the list of potential targets]
    :Optionally send device information or identity]
    if (Is the target on the same \nnetwork as the initiator?) then (Yes)
        :Update target or \ninitiator nwkUpdated and \nchannel as necessary]
        :A;
        detach
    else (No)
        if (Is the initiator on a \ncentralized nwk?) then (Yes)
            :Notify TL_NOT_PERMITTED/
            detach
        else (No)
            if (Is the initiator addr \nassignment capable?) then (Yes)
                :Notify TL_NOT_AA_CAPABLE/
                detach
            else (No)
                :Node on a network;
                detach
            endif
        endif
    endif
else (No)
    :Notify TL_NO_SCAN_RESPONSE/
    :End;
    detach
endif
detach
:Node on a network;
if (bdbNodeIsOnANetwork = TRUE?) then (Yes)
    :B;
    detach
else (No)
if (Logical type router?) then (Yes)
    :Start a new network]
    :B;
    :Send network join router/end device command]
    if (Valid network join response received?) then (Yes)
        :Wait for the target to join the network]
        :A;
        detach
    else (No)
        :Notify TL_TARGET_FAILURE/
        :End;
        detach
    endif
else (No)
    if (Is the target a router?) then (Yes)
        :Send network start request]
        if (Valid network start \nresponse received?) then (Yes)
            :Copy the network parameters \nand wait for the network to start]
            if (Logical type End device?) then (Yes)
                :Rejoin the network]
                :A;
                :Send simple descriptor \nto establish binds]
                :Notify success/
                :End;
                detach
            else (No)
                :A;
                detach
            endif
        else (No)
            :D;
            :Notify TL_NO_NETWORK/
            :End;
            detach
        endif
    else (No)
        :D;
        detach
    endif
endif
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 65. </span><span class="caption-text">Touchlink Commissioning Procedure for an Initiator</span><a class="headerlink" href="#id33" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="touchlink-commissioning-procedure-for-a-target">
<h4>Touchlink Commissioning Procedure for a Target<a class="headerlink" href="#touchlink-commissioning-procedure-for-a-target" title="Permalink to this headline">¶</a></h4>
<p>In this procedure, the target responds to touchlink commissioning
commands from the initiator to start a new network or to join the
initiator network.</p>
<div class="figure align-center" id="id34">
<p class="plantuml">
<img src="../_images/plantuml-57c174fd5f817e337a9032ee303394377b54f67a.png" alt="&#64;startuml
skinparam defaultTextAlignment center
:Start;
if (Scan request received?) then (Yes)
    if (RSSI greater than or equal to product specific threshold?) then (Yes)
        :Start transaction timer and send scan response back to the initiator]
        :A;
        if (Touchlink Commissioning received within timeout) then (Yes)
            split
                :Other Touchlink \nCommissioning requests;
                detach
            split again
                :Network start req/
                if (Logical type Router?) then (Yes)
                    if (Start a network?) then (Yes)
                        :Determine network parameters]
                        :Send network start response success]
                        :Leave the old network in fot factory new]
                        :Start the network]
                        :Direct join the initiator]
                        :B;
                        :Setup link key information]
                        :End;
                        detach
                    else (No)
                        :Identify device]
                        :End;
                        detach
                    endif
                else (No)
                    :A;
                    detach
                endif
            split again
                :Network join reouter/end device req/
                if (Logical type is the appropriate?) then (Yes)
                    if (Join the network?) then (Yes)
                        :Send network join \nrouter/end device response]
                        :Leave old network \nif not factory new]
                        :Copy the network parameters and \nstart operating on the network]
                        :B;
                        detach
                    else (No)
                        :Identify device]
                        :End;
                        detach
                    endif
                else (No)
                    :A;
                    detach
                endif
            end split
        endif
    endif
endif
:End;
detach
:Other Touchlink \nCommissioning requests;
split
    split
        :TransID doesn't match/
    split again
        :Device information request/
        :Send device information \nresponse back to the initiator]
    split again
        :Identify request/
        :Identify device]
    split again
        :Network update request/
        :Update nwkUpdateId \nas necessary]
    end split
    :A;
    detach
split again
    :Reset to factory new request/
    :Reset the device|
    :End;
    detach
end split
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 66. </span><span class="caption-text">Touchlink Commissioning Procedure for a Target</span><a class="headerlink" href="#id34" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="reset-procedures">
<span id="sec-reset-procedures"></span><h3>Reset Procedures<a class="headerlink" href="#reset-procedures" title="Permalink to this headline">¶</a></h3>
<p>Base device behavior defines how the device must act upon reception of
reset commands over-the-air or by user interaction as follows:</p>
<div class="section" id="reset-via-basic-cluster">
<h4>Reset via Basic Cluster<a class="headerlink" href="#reset-via-basic-cluster" title="Permalink to this headline">¶</a></h4>
<p>If the application’s Basic Cluster supports reset commands,
then the application must reset all attributes in every cluster supported by the device.
This command must not affect any network parameters, binds, or groups.
The application implements this in the callback function for this command.</p>
</div>
<div class="section" id="reset-via-touchlink-commissioning-cluster">
<h4>Reset via Touchlink Commissioning Cluster<a class="headerlink" href="#reset-via-touchlink-commissioning-cluster" title="Permalink to this headline">¶</a></h4>
<p>If touchlink as target is supported, then this reset mechanism will trigger the device
to issue a leave request for itself with <em>Rejoin</em> set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> and <em>RemoveChildren</em> set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>.
See <a class="reference internal" href="#sec-leave-request"><span class="std std-ref">Reset via Network Leave Request</span></a> for further details on the leave request.</p>
</div>
<div class="section" id="reset-via-mgmt-leave-req-zdo-command">
<h4>Reset via Mgmt_leave_req ZDO command<a class="headerlink" href="#reset-via-mgmt-leave-req-zdo-command" title="Permalink to this headline">¶</a></h4>
<p>If the command is valid, then the receiving device will issue a leave request for itself
with <em>Rejoin</em> set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> and <em>RemoveChildren</em> set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>.
See <a class="reference internal" href="#sec-leave-request"><span class="std std-ref">Reset via Network Leave Request</span></a> for further details on the leave request.</p>
</div>
<div class="section" id="reset-via-local-action">
<h4>Reset via Local Action<a class="headerlink" href="#reset-via-local-action" title="Permalink to this headline">¶</a></h4>
<p>This type of reset is triggered by the user (eg. a button press).
Non-Coordinator devices will issue a network leave request for itself
with <em>Rejoin</em> set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> and <em>RemoveChildren</em> set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>.
Coordinator devices will clear persistent Zigbee data (since they cannot process network leave commands).
See <a class="reference internal" href="#sec-leave-request"><span class="std std-ref">Reset via Network Leave Request</span></a> for further details on leave requests.
The application may trigger this reset by calling <code class="code docutils literal notranslate"><span class="pre">Zstackapi_bdbResetLocalActionReq()</span></code>.</p>
</div>
<div class="section" id="reset-via-network-leave-request">
<span id="sec-leave-request"></span><h4>Reset via Network Leave Request<a class="headerlink" href="#reset-via-network-leave-request" title="Permalink to this headline">¶</a></h4>
<p>Network leave requests are processed differently across device types.
Coordinator devices ignore the command (including those it issues for itself).
Router devices process leave requests issued by itself and any other device in the network
(if <code class="code docutils literal notranslate"><span class="pre">zgNwkLeaveRequestAllowed</span></code> is enabled).
End devices only accept leave requests issued by itself and or its parent device.
A valid request will cause the device to clear all persistent Zigbee data
(bindings, network parameters, groups, attributes, etc.)
except the outgoing network frame counter for the network it is leaving.</p>
</div>
</div>
</div>
<div class="section" id="network-manager">
<span id="sec-network-manager"></span><h2>Network Manager<a class="headerlink" href="#network-manager" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id8">
<h3>Overview<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>A single routing device can become the Network Manager by defining <code class="code docutils literal notranslate"><span class="pre">NWK_MANAGER</span></code> inside the
Project Properties. This device is responsible for receiving channel interference reports
and PAN ID conflict reports. Based on these reports, the Network Manager changes the network
channel and PAN ID as needed.</p>
<p>The default address of the Network Manager is the coordinator. However,
this can be updated by sending a <code class="code docutils literal notranslate"><span class="pre">Zstackapi_ZdoMgmtNwkUpdateReq</span></code> command with a
different short address for the Network Manager. The device that is the
Network Manager sets the network manager bit in the server mask in the
node descriptor and responds to <code class="code docutils literal notranslate"><span class="pre">Zstackapi_ZdoServerDiscReq</span></code>
commands.</p>
<p>The Network Manager implementation resides in <code class="code docutils literal notranslate"><span class="pre">zd_nwk_mgr.c</span></code> and
<code class="code docutils literal notranslate"><span class="pre">zd_nwkmgr.h</span></code> files.</p>
</div>
<div class="section" id="channel-interference">
<h3>Channel Interference<a class="headerlink" href="#channel-interference" title="Permalink to this headline">¶</a></h3>
<p>The Network Manager implements frequency agility measures if interference is detected.
This section explains how the channel of a network can be changed using
<code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_req</span></code> commands and <code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_notify</span></code> events.</p>
<div class="section" id="channel-interference-detection">
<h4>Channel Interference Detection<a class="headerlink" href="#channel-interference-detection" title="Permalink to this headline">¶</a></h4>
<p>The coordinator and all routers transmit failures using the Transmit Failure field in their neighbor tables.
They also keep a NIB counter for total transmissions attempted.
If this counter exceeds <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_MIN_TRANSMISSIONS</span></code> (20)
and the number of transmit failure is greater than <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_CI_TX_FAILURE</span></code> (25) percent
of the messages sent, the device may have detected interference on the current channel.</p>
<p>The device then takes the following steps:</p>
<ol class="arabic simple">
<li><p>Conduct an energy scan on all channels. If this energy scan does not
indicate higher energy on the current channel than other channels, no
action is taken. The device should continue to operate as normal and
the message counters are not reset.</p></li>
<li><p>If the energy scan does indicate increased energy on the channel in
use, a <code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_notify</span></code> should be sent to the Network
Manager to indicate that interference is present. This report is sent as
an APS unicast with acknowledgement, and once the acknowledgment is
received, the total transmit and transmit failure counters are reset
to zero.</p></li>
<li><p>To avoid a device with communication problems from constantly sending
reports to the Network Manager, the device does not send a
<code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_notify</span></code> more than 4 times per hour.</p></li>
</ol>
</div>
<div class="section" id="channel-interference-resolution">
<h4>Channel Interference Resolution<a class="headerlink" href="#channel-interference-resolution" title="Permalink to this headline">¶</a></h4>
<p>Upon receipt of an unsolicited <code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_notify</span></code>, the Network
Manager applies different methods to best determine when a channel
change is required and how to select the most appropriate channel.</p>
<p>The Network Manger does the following:</p>
<ol class="arabic simple">
<li><p>Upon receipt of the <code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_notify</span></code>, the Network Manager
determines if a channel change is required using the following
criteria:</p>
<ol class="loweralpha simple">
<li><p>If any single device has more than <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_CC_TX_FAILURE</span></code> (50)
percent transmission failures, then a channel change should be
considered.</p></li>
<li><p>The Network Manager compares the failure rate reported on the
current channel against the stored failure rate from the last
channel change. If the current failure rate is higher than the
last failure rate, then the channel change is considered.</p></li>
</ol>
</li>
<li><p>If the above data indicate a channel change should be considered, the
Network Manager completes the following:</p>
<ol class="loweralpha simple">
<li><p>Select a single channel based on the lowest energy in the
<code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_notify</span></code> message.
This is the proposed new channel. If
this new channel does not have an energy level below an acceptable
threshold <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_ACCEPTABLE_ENERGY_LEVEL</span></code>, then a channel change
should not be considered.</p></li>
</ol>
</li>
<li><p>Prior to changing channels, the Network Manager stores the energy
scan value as the last energy scan value and the failure rate from
the existing channel as the last failure rate.</p></li>
<li><p>The Network Manager prepares to broadcast (to the coordinator and all routers) a
<code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_req</span></code>, which will notify devices of the new channel.
It increments the <code class="code docutils literal notranslate"><span class="pre">nwkUpdateId</span></code> parameter in the NIB and beacon payload,
and includes it in the <code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_req</span></code>.
After broadcasting, the Network Manager sets up a timer lasting
<code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_UPDATE_REQUEST_TIMER</span></code> seconds.
Another <code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_req</span></code> to change channels will not
be issued before this timer expires.</p></li>
<li><p>Upon issue of a <code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_req</span></code> with a change of channels,
the local Network Manager sets a timer equal to the
<code class="code docutils literal notranslate"><span class="pre">nwkNetworkBroadcastDeliveryTime</span></code> and switches channels upon
expiration of this timer.</p></li>
</ol>
<p>Upon receipt of a <code class="code docutils literal notranslate"><span class="pre">Mgmt_NWK_Update_req</span></code> with a change of channels
from the Network Manager, a device sets a timer equal to the
<code class="code docutils literal notranslate"><span class="pre">nwkNetworkBroadcastDeliveryTime</span></code> and switches channels upon expiration
of this timer. Each node stores the received <code class="code docutils literal notranslate"><span class="pre">nwkUpdateId</span></code> in the NIB and beacon payload,
and also resets the total transmit and transmit failure counters.</p>
<p>For devices with <code class="code docutils literal notranslate"><span class="pre">RxOnWhenIdle</span></code> equals <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code>, any network channel
change will not be received. On these devices or routers that have lost the
network, an active scan is conducted on the <code class="code docutils literal notranslate"><span class="pre">channelList</span></code> in the NIB
(i.e., <code class="code docutils literal notranslate"><span class="pre">apsChannelMask</span></code>) using the extended PAN ID (EPID) to find the
network. If the extended PAN ID is found on different channels, the
device selects the channel with the higher value in the <code class="code docutils literal notranslate"><span class="pre">nwkUpdateId</span></code>
parameter. If the extended PAN ID is not found using the
<code class="code docutils literal notranslate"><span class="pre">apsChannelMask</span></code> list, a scan is completed using all channels.</p>
</div>
<div class="section" id="id9">
<h4>Quick Reference<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Setting minimum transmissions attempted for Channel
Interference detection</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_MIN_TRANSMISSIONS</span></code>
(in <code class="code docutils literal notranslate"><span class="pre">zd_nwk_mgr.h</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p>Setting minimum transmit failure rate for Channel
Interference detection</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_CI_TX_FAILURE</span></code>
(in <code class="code docutils literal notranslate"><span class="pre">zd_nwk_mgr.h</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p>Setting minimum transmit failure rate for Channel
Change</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_CC_TX_FAILURE</span></code>
(in <code class="code docutils literal notranslate"><span class="pre">zd_nwk_mgr.h</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p>Setting acceptable energy level threshold for Channel
Change</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_ACCEPTABLE_ENERGY_LEVEL</span></code>
(in <code class="code docutils literal notranslate"><span class="pre">zd_nwk_mgr.h</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p>Setting APS channel timer for issuing Channel
Changes</p></td>
<td><p>Set <code class="code docutils literal notranslate"><span class="pre">ZDNWKMGR_UPDATE_REQUEST_TIMER</span></code>
(in <code class="code docutils literal notranslate"><span class="pre">zd_nwk_mgr.h</span></code>)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="pan-id-conflict">
<h3>PAN ID Conflict<a class="headerlink" href="#pan-id-conflict" title="Permalink to this headline">¶</a></h3>
<p>Since the 16-bit PAN ID is not a unique number there is a possibility of
a PAN ID conflict in the local neighborhood. The Network Manager
implements PAN ID conflict resolution.
This section explains how the PAN ID of a network can be updated
using the Network Report and Update commands.</p>
<div class="section" id="pan-id-conflict-detection">
<h4>PAN ID Conflict Detection<a class="headerlink" href="#pan-id-conflict-detection" title="Permalink to this headline">¶</a></h4>
<p>Any device that is operational on a network and receives a beacon in
which the PAN ID of the beacon matches its own PAN ID but the EPID value
contained in the beacon payload is either not present or not equal to
<code class="code docutils literal notranslate"><span class="pre">extendedPanID</span></code>, is considered to have detected a PAN ID conflict.</p>
<p>A node that has detected a PAN ID conflict sends a Network Report
command of type PAN ID conflict to the designated Network Manager
identified by the <code class="code docutils literal notranslate"><span class="pre">nwkManagerAddr</span></code> in the NIB. The Report Information
field will contain a list of all the 16-bit PAN identifiers that are
being used in the local neighborhood. The list is constructed from the
results of an ACTIVE scan.</p>
</div>
<div class="section" id="pan-id-conflict-resolution">
<h4>PAN ID Conflict Resolution<a class="headerlink" href="#pan-id-conflict-resolution" title="Permalink to this headline">¶</a></h4>
<p>The developer may choose what to do upon reception of a
<code class="code docutils literal notranslate"><span class="pre">NWKREPORT_PANID_CONFLICT</span></code> inside the <code class="code docutils literal notranslate"><span class="pre">ZDNwkMgr_ProcessNetworkReport</span></code>
function.  The decision to change PAN IDs should be based on factors
outside the scope of the stack behavior and is directly related to the
application performance.  Example code is provided to demonstrate the
correct procedure for resolving a confirmed PAN identifier conflict.
The following details its behavior as such.</p>
<p>On receipt of the Network Report command, the Network Manager selects a
new 16-bit PAN ID for the network. The new PAN ID is chosen at random,
but a check is performed to ensure that the chosen PAN ID is not
contained within the Report Information field of the network report
command.</p>
<p>Once a new PAN ID has been selected, the Network Manager first
increments the NIB attribute <code class="code docutils literal notranslate"><span class="pre">nwkUpdateID</span></code> and then constructs a Network
Update command of type PAN identifier update. The Update Information
field is set to the value of the new PAN ID. After it sends out this
command, the Network Manager starts a timer with a value equal to
<code class="code docutils literal notranslate"><span class="pre">BCAST_DELIVERY_TIME</span></code> seconds (<code class="code docutils literal notranslate"><span class="pre">zglobals.h</span></code>). When the
timer expires, it changes its current PAN ID to the newly selected one.</p>
<p>On receipt of a Network Update command of type PAN ID update from the
Network Manager, a device (in the same network) starts a timer with a
value equal to <code class="code docutils literal notranslate"><span class="pre">BroadcastDeliveryTime</span></code> seconds. When the timer
expires, the device changes its current PAN ID to the value contained
within the Update Information field. It also stores the new received
<code class="code docutils literal notranslate"><span class="pre">nwkUpdateID</span></code> in the NIB and beacon payload.</p>
</div>
</div>
</div>
<div class="section" id="green-power">
<span id="z-stack-overview-green-power"></span><h2>Green Power<a class="headerlink" href="#green-power" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id10">
<h3>Introduction<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>The Green Power Specification enables the usage of energy-harvesting devices within a Zigbee network.
Green Power Devices (GPD) have very limited energy budget, the standard association-based two-way communication
model of Zigbee is not readily applicable. To enable GPD to communicate to Zigbee network, this
specification defines a new frame format known as Green Power Device Frame (GPDF). This specification
defines the required functionality on a Zigbee device to handle, process and tunnel the GPDF which are used
to pair a GPD and perform control actions or report data.</p>
<p>The specification defines the Green Power Stub which handles the data sent from GPD to be used by the
Zigbee Stack, provides the commissioning procedures to pair green power devices with the Zigbee nodes
to be controlled, and also defines the Green Power Cluster, used to hold GPD commissioning information
and Zigbee commands used to tunnel GPDF payloads and to perform commissioning actions using Zigbee frames.</p>
<p>From the application perspective the specification defines two types of devices: The Green Power Proxy
devices, which only have to tunnel the received GPDF payloads; The Green Power Sink that manages the
paired Green Power Devices on the Zigbee network, propagates the relevant information required for tunneling,
and also able to process and execute Green Power commands tunneled by a Green Power Proxy or directly
receiver from the Stub. Proxy Basic and Combo Basic are the Zigbee Green Power implementations for Proxy
and Sink respectively that can be certified with the Proxy Basic implementation mandatory for Zigbee
3.0 routing devices (coordinators or routers).</p>
<p>A GPD has very limited power or relies on energy harvesting to function.
It cannot perform the two way communication for establishing association to a Zigbee network.
Instead, GPDs use Inter-PAN frames to commission itself into the network or to deliver commands.
The commissioning methods and the type of commands supported by the GPD depend on its capabilities and resources.
The details of those commissioning methods and commands are beyond the scope of this document.</p>
<p>The GP endpoint is implemented in the Zigbee reserved endpoint 242.</p>
</div>
<div class="section" id="green-power-data-frames-gpdf">
<span id="sec-green-power-data-frames"></span><h3>Green Power Data Frames (GPDF)<a class="headerlink" href="#green-power-data-frames-gpdf" title="Permalink to this headline">¶</a></h3>
<p>Most of the relevant information from a GPDF is contained in the NWK layer fields an no APS header
and payload is required. GPDF format is defined in the Zigbee PRO Green Power Feature Specification,
and an example of OTA GPDF is given below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> &quot;MAC Header&quot;:
    &quot;Frame Control&quot;: 0x0801
        ···· ···· ···· ·001 = &quot;Frame Type&quot;: [0x1] Data
        ···· ···· ···· 0··· = &quot;Security Enabled&quot;: [0x0] No
        ···· ···· ···0 ···· = &quot;Frame Pending&quot;: [0x0] No
        ···· ···· ··0· ···· = &quot;Acknowledgement Request&quot;: [0x0] No
        ···· ···· ·0·· ···· = &quot;Intra-PAN&quot;: [0x0] No
        ···· ··00 0··· ···· = &quot;Reserved&quot;: 0x0
        ···· 10·· ···· ···· = &quot;Destination Addr Mode&quot;: [0x2] &quot;16-bit Short Address&quot;
        ··00 ···· ···· ···· = &quot;Reserved&quot;: 0x0
        00·· ···· ···· ···· = &quot;Source Addr Mode&quot;: [0x0] No Address
&quot;Sequence Number&quot;: 1
    &quot;Destination PAN ID&quot;: 0xFFFF
    &quot;Destination Address&quot;: 0xFFFF
    &quot;NWK Header&quot;:
        &quot;Frame Control&quot;: 0x8C
            ···· ··00 = &quot;Frame Type&quot;: [0x0] Data Frame
            ··00 11·· = &quot;ZigBee Protocol Version&quot;: [0x3] Green Power
            ·0·· ···· = &quot;Auto Commissioning&quot;: [0x0] No
            1··· ···· = &quot;NWK Frame Control Extension&quot;: [0x1] Yes
        &quot;Extended NWK Frame Control&quot;: 0x10
            ···· ·000 = &quot;Application ID&quot;: [0x0] ZGP
            ···1 0··· = &quot;Security Level&quot;: [0x0] No Security
            ··0· ···· = &quot;Security Key&quot;: [0x0] Shared Key
            ·0·· ···· = &quot;Rx After TX&quot;: [0x0] No
            0··· ···· = &quot;Direction&quot;: 0x0
        &quot;ZGPD Source ID&quot;: 0x12345678
    &quot;ZGP App Payload&quot;: 0x22
        &quot;ZGPD Command ID&quot;: [0x22] Toggle
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 41%" />
<col style="width: 39%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Name</p></td>
<td><p>Description</p></td>
<td><p>Values</p></td>
</tr>
<tr class="row-even"><td><p>GPDF_FRAME_DUPLICATES</p></td>
<td><p>(uint8) Application-specific.
Number of GPDF retries per packet.</p></td>
<td><div class="line-block">
<div class="line">0x00 - 0xFF (recommended to be low, more
retries = more power consumption)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>GPD_CHANNEL</p></td>
<td><p>IEEE channel, 11 - 26 (in Hex).</p></td>
<td><div class="line-block">
<div class="line">0x0B - 0x1A</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>SEQUENCE_NUMBER_CAP</p></td>
<td><p>Defines if GPD will use incremental sequence
numbers or random sequence numbers.</p></td>
<td><div class="line-block">
<div class="line">TRUE/FALSE</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zigbee-green-power-stub">
<h3>Zigbee Green Power Stub<a class="headerlink" href="#zigbee-green-power-stub" title="Permalink to this headline">¶</a></h3>
<p>The Green Power Stub implements the communication mechanism to process GPDFs and pass them to the
Green Power EndPoint, 242. The Green Power Stub is divided in
two sections; Common Green Power Stub (cGP) that is responsible for the GPDF packet formation and
parsing, duplicate filtering, dropping of the GPDF based on addressing; Dedicated Green Power Stub
(dGP) that performs just enough processing to pass application data frames to the cGP stub for
transmission and to pass GPD commands from the cGP stub to the Green Power cluster on Green Power
EndPoint upon receipt.</p>
</div>
<div class="section" id="basic-green-power-network">
<h3>Basic Green Power Network<a class="headerlink" href="#basic-green-power-network" title="Permalink to this headline">¶</a></h3>
<p>Then most basic Green Power network consists in three application entities:</p>
<ul class="simple">
<li><p>Green Power Device (GPD).</p></li>
<li><p>Green Power Proxy (GP Proxy Basic).</p></li>
<li><p>Green Power Sink  (GP Combo Basic).</p></li>
</ul>
<div class="figure align-center" id="gp-greenpowernwk">
<img alt="../_images/GreenPowerNwk.png" src="../_images/GreenPowerNwk.png" />
</div>
<p>Frames transmitted by a GPD are received by a Proxy Basic or Combo Basic (GPB or GCB). The frame
received by a Proxy Basic is encapsulated as a standard ZCL frame and forwarded across the Zigbee network
to a Combo Basic paired with the GPD. The frames received by the Combo Basic are processed internally
by the proxy side and then passed to the sink.</p>
</div>
<div class="section" id="green-power-device">
<span id="sec-green-power-device"></span><h3>Green Power Device<a class="headerlink" href="#green-power-device" title="Permalink to this headline">¶</a></h3>
<p>Green Power Devices can be put anywhere, especially in places where wiring is expensive or not possible.
Zigbee Green Power enables a Zigbee Network to interact with smart devices that are battery-less or don’t
require maintenance. The Zigbee Network handless the complexity of routing the messages enabling this
battery-less devices to stay connected and communicate.</p>
<p>Green Power Devices are kept as simple as possible with regards to hardware, program implementation, and OTA frames.
This simplicity aims to reduce power consumption,
which further enables long battery life and introduces the possiblity of using energy harvesting as a power source.
The Green Power Specification relies on Zigbee devices with routing capabilities
to deal with the complexity of frame deliveries, network security, and maintenance;
a GPD just broadcasts GPDFs, unaware of the tunneling and processing of GPDFs performed by the proxies and sinks.</p>
<p>The GPD’s Device ID (<code class="code docutils literal notranslate"><span class="pre">DEVICE_ID</span></code>, referenced as the <em>Green Power Device Type</em>)
determines its application functionality as defined by the Green Power Specification.  Device ID type
(<code class="code docutils literal notranslate"><span class="pre">GPD_APP_ID</span></code>) can determine whether it is a configurable value (<code class="code docutils literal notranslate"><span class="pre">GPD_ID</span></code>) or uses
the device’s extended IEEE address (<code class="code docutils literal notranslate"><span class="pre">ApiMac_extAddr</span></code>).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 51%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Name</p></td>
<td><p>Description</p></td>
<td><p>Values</p></td>
</tr>
<tr class="row-even"><td><p>DEVICE_ID</p></td>
<td><p>(uint8) Green Power Device ID which indicates
the device application functionality.</p></td>
<td><div class="line-block">
<div class="line">0x00 - 0xFF, refer to GPD spec</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>GPD_APP_ID</p></td>
<td><p>Unique identifier of the GPD, either the
4-byte SrcID or the IEEE Addr.</p></td>
<td><div class="line-block">
<div class="line">0b00 GPD_APP_TYPE_SRC_ID</div>
<div class="line">0b10 GPD_APP_TYPE_IEEE_ID</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>GPD_ID</p></td>
<td><p>SrcID if GPD_APP_ID = 0b00</p></td>
<td><div class="line-block">
<div class="line">0x00000000 - 0xFFFFFFFF</div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All Green Power Device settings are configurable inside the project’s .syscfg file</p>
</div>
</div>
<div class="section" id="green-power-basic-proxy">
<h3>Green Power Basic Proxy<a class="headerlink" href="#green-power-basic-proxy" title="Permalink to this headline">¶</a></h3>
<p>As a requirement for Zigbee 3.0 certification, all Zigbee routing devices
(coordinators and routers) must support the Green Power Basic proxy, which
is an application that can relay commands from a GPD to a GPS device.</p>
<p>The Basic proxy requires the implementation of GP stub and GP cluster.
The GP stub handles the Inter-PAN commands and passes those to the GP
endpoint application. It also sends GP data frames back to the GPD for
certain commissioning methods.
The GP stub is defined in such a way that different applications can sit on top of it, such as a Sink Device.
For further details on Sink Device implementation refer to [4].</p>
<p>When a GPB receives a GPDF it looks for an entry for the GPD in the <em>Proxy Table</em>. If the entry is
found a ZCL Green Power Notification command is generated for all paired sinks. The addressing for
the Green Power Notifications is taken from the <em>Proxy Table</em> according to the pairing information
with each sink to the GPD. If no entry for the GPD is found, the GPDF is discarded.</p>
<div class="figure align-center" id="id35">
<p class="plantuml">
<img src="../_images/plantuml-afc3ba7be2e139aeb03b955e6b58cd8d570a50db.png" alt="    &#64;startuml
    participant &quot;GPD&quot;
    participant &quot;GPB&quot;
    participant &quot;GCB&quot;

    &quot;GPD&quot;-&gt;&quot;GPB&quot;: GPDF
    note over GPB
            Proxy looks for
            GPD entry on
            proxy table
    end note
    &quot;GPB&quot;-&gt;&quot;GPB&quot;: gppTunnelingDelay
    &quot;GPB&quot;-&gt;&quot;GCB&quot;: ZCL GP Notification
    &quot;GCB&quot;-&gt;&quot;GCB&quot;: The sink module processes the notification
    note over GCB
            Green Power
            command
            executed
    end note
    &#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 67. </span><span class="caption-text">GPDF tunneling</span><a class="headerlink" href="#id35" title="Permalink to this image">¶</a></p>
</div>
<p>Since the GP basic proxy is an application to relay the commands to a
Sink device, no functionality needs to be handled by the application
(e.g. light, switch, etc.) that’s running the GP basic proxy.
The only interface between them is the following:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">gp_RegisterGPChangeChannelReqCB()</span></code>: Register a callback that requests
for permission to switch the operational channel to
the GPD’s channel to perform commissioning.
The callback registered may return <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> to not allow the channel change
if an application operation cannot be interrupted.
Permission is also requested from the BDB module.
If the callback returns <code class="code docutils literal notranslate"><span class="pre">TRUE</span></code> or no callback is registered, then the GP basic
proxy application will handle the change of channels.
The channel change lasts for at most <code class="code docutils literal notranslate"><span class="pre">gpBirectionalCommissioningChangeChannelTimeout</span></code>
(5 seconds, <code class="code docutils literal notranslate"><span class="pre">gp_interface.h</span></code>).</p></li>
</ul>
</div>
<div class="section" id="green-power-sink">
<h3>Green Power Sink<a class="headerlink" href="#green-power-sink" title="Permalink to this headline">¶</a></h3>
<p>The GP Sink is a service that the device application can register for,
which allows the device to receive and process GP Data Frames.
A callback list is provided for the device application to handle GP notification commands.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span>
<span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef ZCL_IDENTIFY</span>
<span class="w">  </span><span class="n">GPDFCB_GP_identify_t</span><span class="w">                </span><span class="n">pfnGpdfIdentifyCmd</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ZCL_SCENES</span>
<span class="w">  </span><span class="n">GPDFCB_GP_RecallScene_t</span><span class="w">             </span><span class="n">pfnGpdfRecallSceneCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StoreScene_t</span><span class="w">              </span><span class="n">pfnGpdfStoreSceneCmd</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ZCL_ON_OFF</span>
<span class="w">  </span><span class="n">GPDFCB_GP_Off_t</span><span class="w">                     </span><span class="n">pfnGpdfOffCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_On_t</span><span class="w">                      </span><span class="n">pfnGpdfOnCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_Toggle_t</span><span class="w">                  </span><span class="n">pfnGpdfToggleCmd</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ZCL_LEVEL_CTRL</span>
<span class="w">  </span><span class="n">GPDFCB_GP_LevelControlStop_t</span><span class="w">        </span><span class="n">pfnGpdfLevelControlStopCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveUp_t</span><span class="w">                  </span><span class="n">pfnGpdfMoveUpCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveDown_t</span><span class="w">                </span><span class="n">pfnGpdfMoveDownCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepUp_t</span><span class="w">                  </span><span class="n">pfnGpdfStepUpCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepDown_t</span><span class="w">                </span><span class="n">pfnGpdfStepDownCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveUpWithOnOff_t</span><span class="w">         </span><span class="n">pfnGpdfMoveUpWithOnOffCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveDownWithOnOff_t</span><span class="w">       </span><span class="n">pfnGpdfMoveDownWithOnOffCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepUpWithOnOff_t</span><span class="w">         </span><span class="n">pfnGpdfStepUpWithOnOffCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepDownWithOnOff_t</span><span class="w">       </span><span class="n">pfnGpdfStepDownWithOnOffCmd</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveHueStop_t</span><span class="w">             </span><span class="n">pfnGpdfMoveHueStopCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveHueUp_t</span><span class="w">               </span><span class="n">pfnGpdfMoveHueUpCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveHueDown_t</span><span class="w">             </span><span class="n">pfnGpdfMoveHueDownCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepHueUp_t</span><span class="w">               </span><span class="n">pfnGpdfStepHueUpCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepHueDown_t</span><span class="w">             </span><span class="n">pfnGpdfStepHueDownCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveSaturationStop_t</span><span class="w">      </span><span class="n">pfnGpdfMoveSaturationStopCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveSaturationUp_t</span><span class="w">        </span><span class="n">pfnGpdfMoveSaturationUpCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveSaturationDown_t</span><span class="w">      </span><span class="n">pfnGpdfMoveSaturationDownCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepSaturationUp_t</span><span class="w">        </span><span class="n">pfnGpdfStepSaturationUpCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepSaturationDown_t</span><span class="w">      </span><span class="n">pfnGpdfStepSaturationDownCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MoveColor_t</span><span class="w">               </span><span class="n">pfnGpdfMoveColorCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_StepColor_t</span><span class="w">               </span><span class="n">pfnGpdfStepColorCmd</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifdef ZCL_DOORLOCK</span>
<span class="w">  </span><span class="n">GPDFCB_GP_LockDoor_t</span><span class="w">                </span><span class="n">pfnGpdfLockDoorCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_UnlockDoor_t</span><span class="w">              </span><span class="n">pfnGpdfUnlockDoorCmd</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="n">GPDFCB_GP_AttributeReporting_t</span><span class="w">      </span><span class="n">pfnGpdfAttributeReportingCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MfrSpecificReporting_t</span><span class="w">    </span><span class="n">pfnGpdfMfrSpecificReportingCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MultiClusterReporting_t</span><span class="w">   </span><span class="n">pfnGpdfMultiClusterReportingCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_MfrSpecificMultiReporting_t</span><span class="w"> </span><span class="n">pfnGpdfMfrSpecificMultiReportingCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_RequestAttributes_t</span><span class="w">       </span><span class="n">pfnGpdfRequestAttributesCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_ReadAttributeRsp_t</span><span class="w">        </span><span class="n">pfnGpdfReadAttributeRspCmd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">GPDFCB_GP_zclTunneling_t</span><span class="w">            </span><span class="n">pfnGpdfzclTunnelingCmd</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">GpSink_AppCallbacks_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">zclGp_RegisterCBForGPDCommand()</span></code> registers the callback list with
the user defined callback functions. When a notification for a registered
command functions arrives, the Sink will relay the frame to the application
callback.</p>
<p>The GCB maintains the proxy functionality. Additionally, it also implements the sink functionality.
This means that when a GPD is in range and there is an entry for it in the GCB’s sink table, GPDFs from this GPD are processed
directly by the GCB without need of an additional proxy.
Due to proxy functionality, the GCB will also generate ZCL Green Power notifications
in case other sinks have pairings in their proxy table.</p>
<div class="figure align-center" id="id36">
<p class="plantuml">
<img src="../_images/plantuml-23da95b0d6891631092927df420f2893127558ae.png" alt="    &#64;startuml
    participant &quot;GPD&quot;
    participant &quot;GCB&quot;

    &quot;GPD&quot;-&gt;&quot;GCB&quot;: GPDF
    &quot;GCB&quot;-&gt;&quot;GCB&quot;: The proxy processes the \nGPDF and generates a \nnotification for the sink
    note over GCB
            Green Power
            command
        executed
    end note
    &#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 68. </span><span class="caption-text">Direct GPDF</span><a class="headerlink" href="#id36" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="commissioning-a-green-power-device">
<span id="sec-green-power-commissioning"></span><h3>Commissioning a Green Power Device<a class="headerlink" href="#commissioning-a-green-power-device" title="Permalink to this headline">¶</a></h3>
<p>A GPD must be commissioned to a Zigbee Device with the Combo Basic implementation to have its GPDFs processed and executed.
It is left to the implementers of sink when to update pairings in the Sink Table and when to enter or exit commissioning mode.</p>
<p>Methods of commissioning the GPD include proximity and multi-hop commissioning, detailed below.</p>
<p><em>Proximity commissioning</em>: This procedure involves a GPD within radio range of a Combo Basic.</p>
<ol class="arabic simple">
<li><p>Combo Basic is already operating in a Zigbee network.</p></li>
<li><p>A user action on Combo Basic puts the device in commissioning mode.</p></li>
<li><p>A user action on GPD makes it send a commissioning frame.</p></li>
<li><p>Combo Basic creates an entry on the sink table for the GPD.</p></li>
<li><p>Combo Basic sends a Pairing command for the Proxy Basic(s).</p></li>
<li><p>Now the Combo Basic will execute a command frame either received directly from the GPD or tunneled by a Proxy Basic.</p></li>
</ol>
<p><em>Multi-hop commissioning</em>: This procedure involves a GPD that can be heard directly by a Proxy Basic that will
tunnel the frames to a Combo Basic.</p>
<ol class="arabic simple">
<li><p>Combo Basic and Proxy Basic are already operating in a Zigbee network.</p></li>
<li><p>A user action on Combo Basic puts the device in commissioning mode.</p></li>
<li><p>Combo Basic sends a ZCL message to Proxy Basic to put the device in commissioning mode.</p></li>
<li><p>A user action on GPD makes it send a commissioning frame.</p></li>
<li><p>Proxy Basic tunnels the commissioning frame within a ZCL frame.</p></li>
<li><p>Combo Basic creates an entry on the sink table for the GPD.</p></li>
<li><p>Combo Basic sends a Pairing command for the Proxy Basic.</p></li>
<li><p>Now the Combo Basic will execute a command frame either received directly from the GPD or tunneled by a Proxy Basic.</p></li>
</ol>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 57%" />
<col style="width: 18%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Name</p></td>
<td><p>Description</p></td>
<td><p>Values</p></td>
</tr>
<tr class="row-even"><td><p>GPD_CHANNEL</p></td>
<td><p>IEEE channel, 11 - 26 (in Hex).</p></td>
<td><div class="line-block">
<div class="line">0x0B - 0x1A</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>AUTO_COMMISSIONING</p></td>
<td><p>Defines whether or not the device will start
commissioning procedure using application
GPDF. This is for devices with limited
resources not capable of sending
commissioning frames.</p></td>
<td><div class="line-block">
<div class="line">TRUE/FALSE</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>RX_AFTER_TX</p></td>
<td><p>RxOnCapability commissioning option.
Defines whether or not GPD will turn RX
on after TXing a frame, i.e. whether or
not GPD is expecting a response.</p></td>
<td><div class="line-block">
<div class="line">TRUE/FALSE</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="green-power-security">
<span id="sec-green-power-security"></span><h3>Green Power Security<a class="headerlink" href="#green-power-security" title="Permalink to this headline">¶</a></h3>
<p>The Green Power Specification defines four levels of security for GPDF protection (summarized in table below) that is
applied to the network layer payload. Some GPD implementations are capable of exchanging the key that will be used for
frame protection while others make use of a preconfigured key. A freshness authentication for GPDF retransmission
is performed by proxies and sinks for all security levels. Security authentication is done if security level 0b10 or
0b11 is supported. The Zigbee PRO Green Power Feature Specification has more detailed information.</p>
<p>Values for Green Power Security Level</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 38%" />
<col style="width: 39%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Name</p></td>
<td><p>Description</p></td>
<td><p>Values</p></td>
</tr>
<tr class="row-even"><td><p>EXT_OPT_KEY_TYPE</p></td>
<td><p>Specifies the type of key which GPDFs are
secured with.</p></td>
<td><div class="line-block">
<div class="line">0b000 KEY_TYPE_NO_KEY</div>
<div class="line">0b001 KEY_TYPE_ZIGBEE_NWK_KEY</div>
<div class="line">0b010 KEY_TYPE_GPD_GROUP_KEY</div>
<div class="line">0b011 KEY_TYPE_NWK_KEY_DERIVED_GPD_GROUP_KEY</div>
<div class="line">0b100 KEY_TYPE_OUT_BOX_GPD_KEY</div>
<div class="line">0b111 KEY_TYPE_DERIVED_INDIVIDUAL_GPD_KEY</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>GP_SECURITY_KEY</p></td>
<td><p>The 128-bit security key used to encrypt
Green Power Data Frames.</p></td>
<td><div class="line-block">
<div class="line">8 bytes from all 0x00 to all 0xFF</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>GP_SECURITY_LEVEL</p></td>
<td><p>Defines the security level for GPDF payload.</p></td>
<td><div class="line-block">
<div class="line">0b00 GP_SECURITY_LVL_NO_SEC</div>
<div class="line">0b01 Reserved</div>
<div class="line">0b10 GP_SECURITY_LVL_4FC_4MIC</div>
<div class="line">0b11 GP_SECURITY_LVL_4FC_4MIC_ENCRYPT</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="inter-pan-transmission">
<h2>Inter-PAN Transmission<a class="headerlink" href="#inter-pan-transmission" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id11">
<h3>Overview<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>Inter-PAN transmission enables Zigbee devices to perform limited,
insecure, and possibly anonymous exchange of information with devices in
their local neighborhood without having to form or join the same Zigbee
network.</p>
<p>The Inter-PAN feature is implemented by the Stub APS layer, which can be
included in a project by defining the <code class="code docutils literal notranslate"><span class="pre">INTER_PAN</span></code> compile option and
including <code class="code docutils literal notranslate"><span class="pre">stub_aps.c</span></code> and <code class="code docutils literal notranslate"><span class="pre">stub_aps.h</span></code> files in the project.</p>
</div>
<div class="section" id="data-exchange">
<h3>Data Exchange<a class="headerlink" href="#data-exchange" title="Permalink to this headline">¶</a></h3>
<p>Inter-PAN data exchanges are handled by the Stub APS layer, which is
accessible through INTERP-SAP, parallel to the normal APSDE-SAP:</p>
<ul class="simple">
<li><p>The <code class="code docutils literal notranslate"><span class="pre">INTERP_DataReq()</span></code> and <code class="code docutils literal notranslate"><span class="pre">APSDE_DataReq()</span></code> are invoked from
<code class="code docutils literal notranslate"><span class="pre">AF_DataRequest()</span></code> to send Inter-PAN and Intra-PAN messages
respectively.</p></li>
<li><p>The <code class="code docutils literal notranslate"><span class="pre">INTERP_DataIndication()</span></code> invokes <code class="code docutils literal notranslate"><span class="pre">APSDE_DataIndication()</span></code>
to indicate the transfer of Inter-PAN data to the local application
layer entity. The application then receives Inter-PAN data as a
normal incoming data message (<code class="code docutils literal notranslate"><span class="pre">APS_INCOMING_MSG</span></code>) from the APS
sub-layer with the source address belonging to an external PAN
(verifiable by <code class="code docutils literal notranslate"><span class="pre">StubAPS_InterPan()</span></code> API) .</p></li>
<li><p>The <code class="code docutils literal notranslate"><span class="pre">INTERP_DataConfirm()</span></code> invokes <code class="code docutils literal notranslate"><span class="pre">afDataConfirm()</span></code> to send an
Inter-PAN data confirm back to the application. The application
receives a normal data confirm (<code class="code docutils literal notranslate"><span class="pre">AF_DATA_CONFIRM_CMD</span></code>) from the AF
sub-layer.</p></li>
</ul>
<p>The Stub APS layer also provides interfaces to switch channel for
Inter-PAN communication and check for Inter-PAN messages. Please refer
to the <a class="reference external" href="../../../zigbee/zstack-apis.html">Z-Stack API</a> for detailed description of the
Inter-PAN APIs.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">StubAPS_InterPan()</span></code> API is used to check for Inter-PAN messages. A
message is considered as an Inter-PAN message if it meets one the
following criteria:</p>
<ul class="simple">
<li><p>The current communication channel is different than the device’s NIB
channel.</p></li>
<li><p>The current communication channel is the same as the device’s NIB
channel but the message is destined for a PAN different than the
device’s NIB PAN ID.</p></li>
<li><p>The current communication channel is the same as the device’s NIB
channel and the message is destined for the same PAN as device’s
NIB PAN ID but the destination application endpoint is an
Inter-PAN endpoint (0xFE). This case is true for an Inter-PAN
response message that’s being sent back to a requestor.</p></li>
</ul>
<p>A typical usage scenario for Inter-PAN communication is as follows. The
initiator device:</p>
<ol class="arabic simple">
<li><p>Calls <code class="code docutils literal notranslate"><span class="pre">StubAPS_AppRegister()</span></code> API to register itself with the Stub APS
layer.</p></li>
<li><p>Calls <code class="code docutils literal notranslate"><span class="pre">StubAPS_SetInterPanChannel()</span></code> API to switch its communication
channel to the channel in use by the remote device.</p></li>
<li><p>Specifies the destination PAN ID and address for the Inter-PAN
message about to be transmitted.</p></li>
<li><p>Calls <code class="code docutils literal notranslate"><span class="pre">AF_DataRequest()</span></code> API to send the message to the remote device
through Inter-PAN channel.</p></li>
<li><p>Receives back (if required) a message from the remote device that
implements the Stub APS layer and is able to respond.</p></li>
<li><p>Calls <code class="code docutils literal notranslate"><span class="pre">StubAPS_SetIntraPanChannel()</span></code> API to switch its communication
channel back to its original channel.  This API should only be used for
devices which have already joined or formed a Zigbee network and thus been
assigned a logical channel.  It is also important that this API not be
used until after receiving <code class="code docutils literal notranslate"><span class="pre">zstackmsg_CmdIDs_AF_DATA_CONFIRM_IND</span></code> from
the transmitted Inter-PAN message.</p></li>
</ol>
<div class="section" id="id12">
<h4>Quick Reference<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Setup application as InterPAN application.</p></td>
<td><p>Call <code class="code docutils literal notranslate"><span class="pre">StubAPS_AppRegister(app_endpoint)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Set InterPAN channel.</p></td>
<td><p>Call <code class="code docutils literal notranslate"><span class="pre">StubAPS_SetInterPanChannel(channel)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Send InterPAN Message.</p></td>
<td><p>Call <code class="code docutils literal notranslate"><span class="pre">AF_DataRequest()</span></code> with:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">dstPanID</span></code> different from
<code class="code docutils literal notranslate"><span class="pre">_NIB.nwkPanId</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">dst</span> <span class="pre">address</span> <span class="pre">endpoint</span> <span class="pre">==</span> <span class="pre">STUBAPS_INTER_PAN_EP</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Receive an InterPAN message.</p></td>
<td><p>Receive an <code class="code docutils literal notranslate"><span class="pre">AF_INCOMING_MSG_CMD</span></code>
message with an incoming <code class="code docutils literal notranslate"><span class="pre">DstEndPoint</span> <span class="pre">==</span> <span class="pre">STUBAPS_INTER_PAN_EP</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>End the InterPAN session by putting back
the IntraPAN channel.</p></td>
<td><p>Call <code class="code docutils literal notranslate"><span class="pre">StubAPS_SetIntraPanChannel()</span></code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="zmac-lqi-adjustment">
<h2>ZMAC LQI Adjustment<a class="headerlink" href="#zmac-lqi-adjustment" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id13">
<h3>Overview<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>The IEEE 802.15.4 specification provides some general statements on the
subject of LQI. From section 6.7.8: “The minimum and maximum LQI values
(0x00 and 0xFF) should be associated with the lowest and highest IEEE
802.15.4 signals detectable by the receiver, and LQI values should be
uniformly distributed between these two limits.” From section E.2.3:
“The LQI (see 6.7.8) measures the received energy and/or SNR for each
received packet. When energy level and SNR information are combined,
they can indicate whether a corrupt packet resulted from low signal
strength or from high signal strength plus interference.”</p>
<p>The TI MAC computes an 8-bit “link quality index” (LQI) for each
received packet from the 2.4 GHz radio. The LQI is computed from the raw
“received signal strength index” (RSSI) by linearly scaling it between
the minimum and maximum defined RF power levels for the radio. This
provides an LQI value that is based entirely on the strength of the
received signal. This can be misleading in the case of a narrowband
interferer that is within the channel bandwidth – the RSSI may be
increased even though the true link quality decreases.</p>
<p>The TI radios also provide a “correlation value” that is a measure of
the received frame quality. Although not considered by the TI MAC in LQI
calculation, the frame correlation is passed to the ZMAC layer (along
with LQI and RSSI) in MCPS data confirm and data indication callbacks.
The <code class="code docutils literal notranslate"><span class="pre">ZMacLqiAdjust()</span></code> function in <code class="code docutils literal notranslate"><span class="pre">zmac_cb.c</span></code> provides
capability to adjust the default TI MAC value of LQI by taking the
correlation into account.</p>
</div>
<div class="section" id="lqi-adjustment-modes">
<h3>LQI Adjustment Modes<a class="headerlink" href="#lqi-adjustment-modes" title="Permalink to this headline">¶</a></h3>
<p>LQI adjustment functionality for received frames processed in <code class="code docutils literal notranslate"><span class="pre">zmac_cb.c</span></code>
has three defined modes of operation - <code class="code docutils literal notranslate"><span class="pre">OFF</span></code>, <code class="code docutils literal notranslate"><span class="pre">MODE1</span></code>, and <code class="code docutils literal notranslate"><span class="pre">MODE2</span></code>. To
maintain compatibility with previous versions of Z-Stack which do not
provide for LQI adjustment, this feature defaults to <code class="code docutils literal notranslate"><span class="pre">OFF</span></code>, as defined
by an initializer (<code class="code docutils literal notranslate"><span class="pre">lqiAdjMode</span> <span class="pre">=</span> <span class="pre">LQI_ADJ_OFF</span></code>) in <code class="code docutils literal notranslate"><span class="pre">zmac_cb.c</span></code> –
developers can select a different default state by changing this
statement.</p>
<p><code class="code docutils literal notranslate"><span class="pre">MODE1</span></code> provides a simple algorithm to use the packet correlation value
(related to SNR) to scale incoming LQI value (related to signal
strength) to ‘de-rate’ noisy packets. The incoming LQI value is linearly
scaled with a “correlation percentage” that is computed from the raw
correlation value between theoretical minimum/maximum values
(<code class="code docutils literal notranslate"><span class="pre">LQI_CORR_MIN</span></code> and <code class="code docutils literal notranslate"><span class="pre">LQI_CORR_MAX</span></code> are defined in <code class="code docutils literal notranslate"><span class="pre">ZMAC.h</span></code>).</p>
<p><code class="code docutils literal notranslate"><span class="pre">MODE2</span></code> provides a “stub” for developers to implement their own
proprietary algorithm. Code can be added after the
<code class="code docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span> <span class="pre">(lqiAdjMode</span> <span class="pre">==</span> <span class="pre">LQI_ADJ_MODE2)</span></code> statement in <code class="code docutils literal notranslate"><span class="pre">ZMacLqiAdjust()</span></code>.</p>
</div>
<div class="section" id="using-lqi-adjustment">
<h3>Using LQI Adjustment<a class="headerlink" href="#using-lqi-adjustment" title="Permalink to this headline">¶</a></h3>
<p>There are two ways to enable the LQI adjustment functionality:</p>
<ol class="arabic simple">
<li><p>Alter the initialization of the <code class="code docutils literal notranslate"><span class="pre">lqiAdjMode</span></code> variable as described in
the previous section</p></li>
<li><p>Call the function <code class="code docutils literal notranslate"><span class="pre">ZMacLqiAdjustMode()</span></code> from somewhere within the
Z-Stack application, most likely from the application’s task
initialization function. See the <a class="reference external" href="../../../zigbee/zstack-apis.html">Z-Stack API</a> on details
of this function.</p></li>
</ol>
<p>The <code class="code docutils literal notranslate"><span class="pre">ZMacLqiAdjustMode()</span></code> function can be used to change the LQI
adjustment mode as needed by the application. For example, a developer
might want to evaluate device/network operation using a proprietary
<code class="code docutils literal notranslate"><span class="pre">MODE2</span></code> compared to the default <code class="code docutils literal notranslate"><span class="pre">MODE1</span></code> or <code class="code docutils literal notranslate"><span class="pre">OFF</span></code>.</p>
<p>Tuning of <code class="code docutils literal notranslate"><span class="pre">MODE1</span></code> operation can be achieved by altering the values of
<code class="code docutils literal notranslate"><span class="pre">LQI_CORR_MIN</span></code> and/or <code class="code docutils literal notranslate"><span class="pre">LQI_CORR_MAX</span></code>. Alternate values for these
parameters can be provided as compiler
directives in the IDE project file or in one of Z-Stack’s configuration files. Refer to
the radio’s data sheet for information on the normal minimum/maximum correlation values.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="gpd_application_overview.html" class="btn btn-neutral float-left" title="Green Power Application Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="flash_memory-cc13xx_cc26xx.html" class="btn btn-neutral float-right" title="Flash" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2022, Texas Instruments.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>