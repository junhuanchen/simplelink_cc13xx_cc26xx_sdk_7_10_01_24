<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="_s_p_i_c_c26_x2_d_m_a_8h" kind="file" language="C++">
    <compoundname>SPICC26X2DMA.h</compoundname>
    <includes local="no">stdint.h</includes>
    <includes refid="_s_p_i_8h" local="no">ti/drivers/SPI.h</includes>
    <includes refid="_u_d_m_a_c_c26_x_x_8h" local="no">ti/drivers/dma/UDMACC26XX.h</includes>
    <includes refid="_power_8h" local="no">ti/drivers/Power.h</includes>
    <includes refid="_power_c_c26_x_x_8h" local="no">ti/drivers/power/PowerCC26XX.h</includes>
    <includes local="no">ti/drivers/dpl/HwiP.h</includes>
    <includes local="no">ti/drivers/dpl/SemaphoreP.h</includes>
    <includes local="no">ti/drivers/dpl/SwiP.h</includes>
    <incdepgraph>
      <node id="1359">
        <label>stdbool.h</label>
      </node>
      <node id="1357">
        <label>stdint.h</label>
      </node>
      <node id="1361">
        <label>ti/drivers/dma/UDMACC26XX.h</label>
        <link refid="_u_d_m_a_c_c26_x_x_8h"/>
        <childnode refid="1357" relation="include">
        </childnode>
        <childnode refid="1359" relation="include">
        </childnode>
        <childnode refid="1362" relation="include">
        </childnode>
        <childnode refid="1364" relation="include">
        </childnode>
        <childnode refid="1367" relation="include">
        </childnode>
        <childnode refid="1368" relation="include">
        </childnode>
        <childnode refid="1369" relation="include">
        </childnode>
      </node>
      <node id="1370">
        <label>ti/drivers/dpl/SemaphoreP.h</label>
      </node>
      <node id="1360">
        <label>stddef.h</label>
      </node>
      <node id="1358">
        <label>ti/drivers/SPI.h</label>
        <link refid="_s_p_i_8h"/>
        <childnode refid="1359" relation="include">
        </childnode>
        <childnode refid="1360" relation="include">
        </childnode>
        <childnode refid="1357" relation="include">
        </childnode>
      </node>
      <node id="1356">
        <label>SPICC26X2DMA.h</label>
        <link refid="_s_p_i_c_c26_x2_d_m_a_8h"/>
        <childnode refid="1357" relation="include">
        </childnode>
        <childnode refid="1358" relation="include">
        </childnode>
        <childnode refid="1361" relation="include">
        </childnode>
        <childnode refid="1362" relation="include">
        </childnode>
        <childnode refid="1364" relation="include">
        </childnode>
        <childnode refid="1365" relation="include">
        </childnode>
        <childnode refid="1370" relation="include">
        </childnode>
        <childnode refid="1371" relation="include">
        </childnode>
      </node>
      <node id="1367">
        <label>ti/devices/DeviceFamily.h</label>
      </node>
      <node id="1365">
        <label>ti/drivers/dpl/HwiP.h</label>
      </node>
      <node id="1366">
        <label>ti/drivers/dpl/ClockP.h</label>
      </node>
      <node id="1368">
        <label>DeviceFamily_constructPath(inc/hw_types.h)</label>
      </node>
      <node id="1369">
        <label>DeviceFamily_constructPath(driverlib/udma.h)</label>
      </node>
      <node id="1371">
        <label>ti/drivers/dpl/SwiP.h</label>
      </node>
      <node id="1362">
        <label>ti/drivers/Power.h</label>
        <link refid="_power_8h"/>
        <childnode refid="1363" relation="include">
        </childnode>
      </node>
      <node id="1363">
        <label>ti/drivers/utils/List.h</label>
        <link refid="_list_8h"/>
        <childnode refid="1357" relation="include">
        </childnode>
        <childnode refid="1359" relation="include">
        </childnode>
        <childnode refid="1360" relation="include">
        </childnode>
      </node>
      <node id="1364">
        <label>ti/drivers/power/PowerCC26XX.h</label>
        <link refid="_power_c_c26_x_x_8h"/>
        <childnode refid="1365" relation="include">
        </childnode>
        <childnode refid="1366" relation="include">
        </childnode>
        <childnode refid="1362" relation="include">
        </childnode>
        <childnode refid="1367" relation="include">
        </childnode>
      </node>
    </incdepgraph>
    <innerclass refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs" prot="public">SPICC26X2DMA_HWAttrs</innerclass>
    <innerclass refid="struct_s_p_i_c_c26_x2_d_m_a___object" prot="public">SPICC26X2DMA_Object</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="group___s_p_i___c_m_d_1ga34c49fde4df8fd436cf431b8c69e64d2" prot="public" static="no">
        <name>SPICC26X2DMA_CMD_RETURN_PARTIAL_ENABLE</name>
        <initializer>(<ref refid="group___s_p_i___c_o_n_t_r_o_l_1ga3d23d16525ee76f77276472d8dea80b0" kindref="member">SPI_CMD_RESERVED</ref> + 0)</initializer>
        <briefdescription>
<para>Command used by <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> to enable partial return. </para>        </briefdescription>
        <detaileddescription>
<para>Enabling this command allows SPI_transfer to return partial data if the controller de-asserts the CS line before the expected number of frames were received. This command <bold>arg</bold> is of type <emphasis>don&apos;t</emphasis> <emphasis>care</emphasis> and it returns SPI_STATUS_SUCCESS or SPI_STATUS_ERROR. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="731" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="731" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_p_i___c_m_d_1ga0e1ad744e41c95b652bc5c04f492d609" prot="public" static="no">
        <name>SPICC26X2DMA_CMD_RETURN_PARTIAL_DISABLE</name>
        <initializer>(<ref refid="group___s_p_i___c_o_n_t_r_o_l_1ga3d23d16525ee76f77276472d8dea80b0" kindref="member">SPI_CMD_RESERVED</ref> + 1)</initializer>
        <briefdescription>
<para>Command used by <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> to disable partial return. </para>        </briefdescription>
        <detaileddescription>
<para>Disabling this command returns the SPICC26X2DMA to the default blocking behavior where <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> blocks until all data bytes were received. With this command <bold>arg</bold> is <emphasis>don&apos;t</emphasis> <emphasis>care</emphasis> and it returns <ref refid="group___s_p_i___s_t_a_t_u_s_1gab38fa90ff62128dbc98b2ecd84ca106f" kindref="member">SPI_STATUS_SUCCESS</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="740" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="740" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_p_i___c_m_d_1ga572d479a9a8504cf5c096d16465f8e9d" prot="public" static="no">
        <name>SPICC26X2DMA_CMD_SET_CSN_PIN</name>
        <initializer>(<ref refid="group___s_p_i___c_o_n_t_r_o_l_1ga3d23d16525ee76f77276472d8dea80b0" kindref="member">SPI_CMD_RESERVED</ref> + 2)</initializer>
        <briefdescription>
<para>Command used by <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> to re-configure chip select pin. </para>        </briefdescription>
        <detaileddescription>
<para>Enables hardware control of the chip select pin <bold>arg</bold> should be a <computeroutput>uint_least8_t</computeroutput> indicating the device DIO to be used as the hardware CS pin.</para><para>Passing GPIO_INVALID_INDEX or PIN_UNASSIGNED to this command is equivalent to calling <ref refid="group___s_p_i___c_m_d_1ga21f3e5d69d096a16c9569f2615a56b0b" kindref="member">SPICC26X2DMA_CMD_CLEAR_CSN_PIN</ref>.</para><para>Always returns <ref refid="group___s_p_i___s_t_a_t_u_s_1gab38fa90ff62128dbc98b2ecd84ca106f" kindref="member">SPI_STATUS_SUCCESS</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="753" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="753" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_p_i___c_m_d_1ga21f3e5d69d096a16c9569f2615a56b0b" prot="public" static="no">
        <name>SPICC26X2DMA_CMD_CLEAR_CSN_PIN</name>
        <initializer>(<ref refid="group___s_p_i___c_o_n_t_r_o_l_1ga3d23d16525ee76f77276472d8dea80b0" kindref="member">SPI_CMD_RESERVED</ref> + 3)</initializer>
        <briefdescription>
<para>Command used by <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> to disable the hardware chip select pin. </para>        </briefdescription>
        <detaileddescription>
<para><bold>arg</bold> should be NULL. This command will disable all hardware control and muxing of the csnPin. It can then be controlled by user software using the GPIO driver, or configured later using <ref refid="group___s_p_i___c_m_d_1ga572d479a9a8504cf5c096d16465f8e9d" kindref="member">SPICC26X2DMA_CMD_SET_CSN_PIN</ref>.</para><para>Always returns <ref refid="group___s_p_i___s_t_a_t_u_s_1gab38fa90ff62128dbc98b2ecd84ca106f" kindref="member">SPI_STATUS_SUCCESS</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="764" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="764" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_p_i___c_m_d_1ga2e83f10ecd69aa4b117acb2e64565f5b" prot="public" static="no">
        <name>SPICC26X2DMA_CMD_SET_MANUAL</name>
        <initializer>(<ref refid="group___s_p_i___c_o_n_t_r_o_l_1ga3d23d16525ee76f77276472d8dea80b0" kindref="member">SPI_CMD_RESERVED</ref> + 4)</initializer>
        <briefdescription>
<para>Command used by <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> to enable manual start mode. </para>        </briefdescription>
        <detaileddescription>
<para>Manual start mode can only be used when in callback mode. In manual start mode, calls to <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> queue the transaction but does not start the transfer until another control call is made with <ref refid="group___s_p_i___c_m_d_1ga3b4361e2cabb4ae7fedda98551aee5ef" kindref="member">SPICC26X2DMA_CMD_MANUAL_START</ref>. This allows multiple transactions to be queued and executed seamlessly using the DMA&apos;s ping pong mechanism. This mode is MANDATORY for peripherals queueing multiple short transactions. Manual start mode can only be enabled or disabled when no transactions are queued.</para><para>Returns <ref refid="group___s_p_i___s_t_a_t_u_s_1gab38fa90ff62128dbc98b2ecd84ca106f" kindref="member">SPI_STATUS_SUCCESS</ref> or <ref refid="group___s_p_i___s_t_a_t_u_s_1ga2d0020dd673cc28a9e1c20b0ff101073" kindref="member">SPI_STATUS_ERROR</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="779" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="779" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_p_i___c_m_d_1ga687eef73eab3644a3000ab89b2a83cf3" prot="public" static="no">
        <name>SPICC26X2DMA_CMD_CLR_MANUAL</name>
        <initializer>(<ref refid="group___s_p_i___c_o_n_t_r_o_l_1ga3d23d16525ee76f77276472d8dea80b0" kindref="member">SPI_CMD_RESERVED</ref> + 5)</initializer>
        <briefdescription>
<para>Command used by <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> to disable manual start mode. </para>        </briefdescription>
        <detaileddescription>
<para>Manual start mode is disabled by default. Enabling and disabling manual mode can only be done if no transactions are currently queued.</para><para>Returns <ref refid="group___s_p_i___s_t_a_t_u_s_1gab38fa90ff62128dbc98b2ecd84ca106f" kindref="member">SPI_STATUS_SUCCESS</ref> or <ref refid="group___s_p_i___s_t_a_t_u_s_1ga2d0020dd673cc28a9e1c20b0ff101073" kindref="member">SPI_STATUS_ERROR</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="790" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="790" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_p_i___c_m_d_1ga3b4361e2cabb4ae7fedda98551aee5ef" prot="public" static="no">
        <name>SPICC26X2DMA_CMD_MANUAL_START</name>
        <initializer>(<ref refid="group___s_p_i___c_o_n_t_r_o_l_1ga3d23d16525ee76f77276472d8dea80b0" kindref="member">SPI_CMD_RESERVED</ref> + 6)</initializer>
        <briefdescription>
<para>Command used by <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> to enable manual start mode. </para>        </briefdescription>
        <detaileddescription>
<para>This command is used with manual start mode enabled. If transactions have been queued and the driver is in manual mode, this command will enable the SSI and DMA. For controller devices, the transfer will start. For peripheral devices, the transfer will start when the controller initiates.</para><para>Returns <ref refid="group___s_p_i___s_t_a_t_u_s_1gab38fa90ff62128dbc98b2ecd84ca106f" kindref="member">SPI_STATUS_SUCCESS</ref> or <ref refid="group___s_p_i___s_t_a_t_u_s_1ga2d0020dd673cc28a9e1c20b0ff101073" kindref="member">SPI_STATUS_ERROR</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="802" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="802" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="_s_p_i_c_c26_x2_d_m_a_8h_1aaa634f36e737f032a3965aaf1ee68861" prot="public" static="no">
        <name>SPICC26X2DMA_RETURN_PARTIAL_ENABLE</name>
        <initializer><ref refid="group___s_p_i___c_m_d_1ga34c49fde4df8fd436cf431b8c69e64d2" kindref="member">SPICC26X2DMA_CMD_RETURN_PARTIAL_ENABLE</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="807" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="807" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="_s_p_i_c_c26_x2_d_m_a_8h_1ab3d2701c77c927ce2623c6370bbc8b12" prot="public" static="no">
        <name>SPICC26X2DMA_RETURN_PARTIAL_DISABLE</name>
        <initializer><ref refid="group___s_p_i___c_m_d_1ga0e1ad744e41c95b652bc5c04f492d609" kindref="member">SPICC26X2DMA_CMD_RETURN_PARTIAL_DISABLE</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="808" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="808" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="_s_p_i_c_c26_x2_d_m_a_8h_1a4e5ef588123b8c7db018f26606fb662c" prot="public" static="no">
        <name>SPICC26X2DMA_SET_CSN_PIN</name>
        <initializer><ref refid="group___s_p_i___c_m_d_1ga572d479a9a8504cf5c096d16465f8e9d" kindref="member">SPICC26X2DMA_CMD_SET_CSN_PIN</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="809" column="9" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="809" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3" prot="public" static="no">
        <name>SPICC26X2DMA_FrameSize</name>
        <enumvalue id="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3a07a215eef0e18eb548bec7031a4a6e8f" prot="public">
          <name>SPICC26X2DMA_8bit</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3ac3bfdd18fe2cf4674a56554737b57ef3" prot="public">
          <name>SPICC26X2DMA_16bit</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="829" column="1" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="828" bodyend="832"/>
      </memberdef>
      <memberdef kind="enum" id="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4d" prot="public" static="no">
        <name>SPICC26X2DMA_ReturnPartial</name>
        <enumvalue id="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4da110eab6b38d8da801d21e3556ea1fb55" prot="public">
          <name>SPICC26X2DMA_retPartDisabled</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4dad1a937fa73857130a5cd52db13fc951d" prot="public">
          <name>SPICC26X2DMA_retPartEnabledIntNotSet</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4dae635a93b40c8dd2d5ad9a58cf3f0b2d1" prot="public">
          <name>SPICC26X2DMA_retPartEnabledIntSet</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="842" column="1" bodyfile="source/ti/drivers/spi/SPICC26X2DMA.h" bodystart="841" bodyend="846"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="_s_p_i_c_c26_x2_d_m_a_8h_1a91e8de1ee3380354aba7d286fc59c593" prot="public" static="no" mutable="no">
        <type>const <ref refid="struct_s_p_i___fxn_table" kindref="compound">SPI_FxnTable</ref></type>
        <definition>const SPI_FxnTable SPICC26X2DMA_fxnTable</definition>
        <argsstring></argsstring>
        <name>SPICC26X2DMA_fxnTable</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="source/ti/drivers/spi/SPICC26X2DMA.h" line="817" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>SPI driver implementation for a CC26XX SPI controller using the UDMA controller. </para>    </briefdescription>
    <detaileddescription>
<para><hruler/>
</para><para><heading level="1">Driver include</heading>
</para><para>The SPI header file should be included in an application as follows: <programlisting><codeline><highlight class="normal">#include<sp/>&lt;ti/drivers/SPI.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;ti/drivers/spi/SPICC26X2DMA.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;ti/drivers/dma/UDMACC26XX.h&gt;</highlight></codeline>
</programlisting></para><para>Refer to <ref refid="_s_p_i_8h" kindref="compound">SPI.h</ref> for a complete description of APIs.</para><para>Note that the user also needs to include the <ref refid="_u_d_m_a_c_c26_x_x_8h" kindref="compound">UDMACC26XX.h</ref> driver since the SPI uses uDMA in order to improve throughput.</para><para><heading level="1">Overview</heading>
</para><para>The general SPI API should be used in application code, i.e. <ref refid="_s_p_i_8h_1a9c9022decfb136991d6b53f7dd2ae2fc" kindref="member">SPI_open()</ref> should be used instead of SPICC26X2DMA_open(). The board file will define the device specific config, and casting in the general API will ensure that the correct device specific functions are called. This is also reflected in the example code in <ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASES_SPI_X2" kindref="member">Use Cases</ref>.</para><para><heading level="1">General Behavior</heading>
</para><para>Before using SPI on CC26XX:<itemizedlist>
<listitem><para>The SPI driver is initialized by calling <ref refid="_s_p_i_8h_1afd9b09f58917f0e2d14c61b956eba214" kindref="member">SPI_init()</ref>.</para></listitem><listitem><para>The SPI HW is configured and flags system dependencies (e.g. IOs, power, etc.) by calling <ref refid="_s_p_i_8h_1a9c9022decfb136991d6b53f7dd2ae2fc" kindref="member">SPI_open()</ref>.</para></listitem><listitem><para>The SPI driver makes use of DMA in order to optimize throughput. This is handled directly by the SPI driver, so the application should never to make any calls directly to the <ref refid="_u_d_m_a_c_c26_x_x_8h" kindref="compound">UDMACC26XX.h</ref> driver.</para></listitem><listitem><para>This implementation supports queueing multiple transactions in callback mode. See the <ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_QUEUE" kindref="member">queueing example.</ref></para></listitem><listitem><para>When queueing multiple transactions that should transfer one after the other, it is recommended to use the driver in &apos;manual start&apos; mode by using the <ref refid="group___s_p_i___c_m_d_1ga2e83f10ecd69aa4b117acb2e64565f5b" kindref="member">SPICC26X2DMA_CMD_SET_MANUAL</ref> command. In this mode, the driver will not start any queued transfers until <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> is called with the <ref refid="group___s_p_i___c_m_d_1ga3b4361e2cabb4ae7fedda98551aee5ef" kindref="member">SPICC26X2DMA_CMD_MANUAL_START</ref> command. This mode is off by default and can be disabled by using command <ref refid="group___s_p_i___c_m_d_1ga687eef73eab3644a3000ab89b2a83cf3" kindref="member">SPICC26X2DMA_CMD_CLR_MANUAL</ref>. See the <ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_MANUAL_START" kindref="member">Manual Start Example</ref>.</para></listitem></itemizedlist>
</para><para>The following is true for peripheral operation:<itemizedlist>
<listitem><para>RX overrun IRQ, SPI and UDMA modules are enabled by calling <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref>.</para></listitem><listitem><para>All received bytes are ignored after <ref refid="_s_p_i_8h_1a9c9022decfb136991d6b53f7dd2ae2fc" kindref="member">SPI_open()</ref> is called, until the first <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref>.</para></listitem><listitem><para>If an RX overrun occur or if <ref refid="_s_p_i_8h_1a6819f7761fc3505c4f885653ff8121f0" kindref="member">SPI_transferCancel()</ref> is called, RX overrun IRQ, SPI and UDMA modules are disabled, TX and RX FIFOs are flushed and all bytes are ignored.</para></listitem><listitem><para>After a successful transfer, RX overrun IRQ and SPI module remains enabled and UDMA module is disabled. <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> must be called again before RX FIFO goes full in order to avoid overflow. If the TX buffer is underflowed, zeros will be output. It is safe to call another <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> from the transfer callback, see <ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_CST_X2" kindref="member">Continuous Peripheral Transfer</ref> use case below.</para></listitem><listitem><para>The SPI driver supports partial return, that can be used if the transfer size is unknown. If <ref refid="group___s_p_i___c_m_d_1ga34c49fde4df8fd436cf431b8c69e64d2" kindref="member">SPICC26X2DMA_CMD_RETURN_PARTIAL_ENABLE</ref> is passed to <ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref>, the transfer will end when chip select is deasserted. The <ref refid="struct_s_p_i___transaction_1aa244504b2384411f7de17340be62128a" kindref="member">SPI_Transaction.status</ref> and the <ref refid="struct_s_p_i___transaction_1ad049d6a900c4bdb59a5ee8ce3d5bced2" kindref="member">SPI_Transaction.count</ref> will be updated to indicate whether the transfer ended due to a chip select deassertion and how many bytes were transferred. See <ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_RP_X2" kindref="member">Peripheral Mode With Return Partial</ref> use case below.</para></listitem><listitem><para>When queueing several transactions if the first is a &apos;short&apos; transaction (8 or fewer frames), it is required to use <ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_MANUAL_START" kindref="member">Manual Start mode.</ref></para></listitem></itemizedlist>
</para><para><simplesect kind="warning"><para>The SPI modules on the CC13x0, CC26x0, and CC26x0R2 devices have a bug which may result in TX data being lost when operating in SPI peripheral mode. Please refer to the device errata sheet for full details. The SPI protocol should therefore include a data integrity check, such as appending a CRC to the payload to ensure all the data was transmitted correctly by the SPI peripheral.</para></simplesect>
The following apply for controller operation:<itemizedlist>
<listitem><para>SPI and UDMA modules are enabled by calling <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref>.</para></listitem><listitem><para>If the <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> succeeds, SPI module is enabled and UDMA module is disabled.</para></listitem><listitem><para>If <ref refid="_s_p_i_8h_1a6819f7761fc3505c4f885653ff8121f0" kindref="member">SPI_transferCancel()</ref> is called, SPI and UDMA modules are disabled and TX and RX FIFOs are flushed.</para></listitem></itemizedlist>
After SPI operation has ended:<itemizedlist>
<listitem><para>Release system dependencies for SPI by calling <ref refid="_s_p_i_8h_1a0e3448b30b88609fa120915e49560601" kindref="member">SPI_close()</ref>.</para></listitem></itemizedlist>
The callback function is always called in a SWI context.</para><para><simplesect kind="warning"><para>The application should avoid transmitting data stored in flash via SPI if the application might switch to the XOSC_HF, the high frequency external oscillator, during this transfer.</para></simplesect>
<heading level="1">Error handling</heading>
</para><para>If an RX overrun occurs during peripheral operation:<itemizedlist>
<listitem><para>If a transfer is ongoing, all bytes received up until the error occurs will be returned, with the error signaled in the <ref refid="struct_s_p_i___transaction_1aa244504b2384411f7de17340be62128a" kindref="member">SPI_Transaction.status</ref> field. RX overrun IRQ, SPI and UDMA modules are then disabled, TX and RX FIFOs are flushed and all bytes will be ignored until a new transfer is issued.</para></listitem><listitem><para>If a transfer is not ongoing, RX overrun IRQ, SPI and UDMA modules are disabled, TX and RX FIFOs are flushed and all bytes will be ignored until a new transfer is issued.</para></listitem></itemizedlist>
</para><para><heading level="1">Timeout</heading>
</para><para>Timeout can occur in <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8" kindref="member">SPI_MODE_BLOCKING</ref>, there&apos;s no timeout in <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb" kindref="member">SPI_MODE_CALLBACK</ref>. When in <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb" kindref="member">SPI_MODE_CALLBACK</ref>, the transfer must be cancelled by calling <ref refid="_s_p_i_8h_1a6819f7761fc3505c4f885653ff8121f0" kindref="member">SPI_transferCancel()</ref>.<linebreak/>
If a timeout happens in either <ref refid="_s_p_i_8h_1a60a7e3d74577b38aa79ea6983362f942adf4cb39226caf2dcd726e13d39546393" kindref="member">SPI_PERIPHERAL</ref> or <ref refid="_s_p_i_8h_1a60a7e3d74577b38aa79ea6983362f942a061361eeeb9e87265edcc0c70868111a" kindref="member">SPI_CONTROLLER</ref> mode, the receive buffer will contain the bytes received up until the timeout occurred. The SPI transaction status will be set to <ref refid="_s_p_i_8h_1a913c57c335166de9caa54b7eb9ad95fbac01b83da31c34da13025a5b987ef013f" kindref="member">SPI_TRANSFER_FAILED</ref>. The SPI transaction count will be set to the number of bytes sent/received before timeout. The remaining bytes will be flushed from the TX FIFO so that the subsequent transfer can be executed correctly. Note that specifying a timeout prevents the driver from performing a polling transfer when in peripheral mode.</para><para><heading level="1">Power Management</heading>
</para><para>The TI-RTOS power management framework will try to put the device into the most power efficient mode whenever possible. Please see the technical reference manual for further details on each power mode.</para><para>The <ref refid="_s_p_i_c_c26_x2_d_m_a_8h" kindref="compound">SPICC26X2DMA.h</ref> driver is setting a power constraint during transfers to keep the device out of standby. When the transfer has finished, the power constraint is released. The following statements are valid:<itemizedlist>
<listitem><para>After <ref refid="_s_p_i_8h_1a9c9022decfb136991d6b53f7dd2ae2fc" kindref="member">SPI_open()</ref>: the device is still allowed to enter standby.</para></listitem><listitem><para>In peripheral mode:<itemizedlist>
<listitem><para>During <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref>: the device cannot enter standby, only idle.</para></listitem><listitem><para>After an RX overflow: device is allowed to enter standby.</para></listitem><listitem><para>After a successful <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref>: the device is allowed to enter standby, but SPI module remains enabled.<itemizedlist>
<listitem><para><emphasis>Note</emphasis>: In peripheral mode, the device might enter standby while a byte is being transferred if <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> is not called again after a successful transfer. This could result in corrupt data being transferred.</para></listitem></itemizedlist>
</para></listitem><listitem><para>Application thread should typically either issue another transfer after <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> completes successfully, or call <ref refid="_s_p_i_8h_1a6819f7761fc3505c4f885653ff8121f0" kindref="member">SPI_transferCancel()</ref> to disable the SPI module and thus assuring that no data is received while entering standby.</para></listitem></itemizedlist>
</para></listitem><listitem><para>In controller mode:<itemizedlist>
<listitem><para>During <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref>: the device cannot enter standby, only idle.</para></listitem><listitem><para>After <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> succeeds: the device can enter standby.</para></listitem><listitem><para>If <ref refid="_s_p_i_8h_1a6819f7761fc3505c4f885653ff8121f0" kindref="member">SPI_transferCancel()</ref> is called: the device can enter standby.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para><simplesect kind="note"><para>The external hardware connected to the SPI might have some pull configured on the SPI lines. When the SPI is inactive, this might cause leakage on the IO and the current consumption to increase. The application must configure a pull configuration that aligns with the external hardware. See <ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_LPWR_X2" kindref="member">Ensure low power during inactive periods</ref> for code example.</para></simplesect>
<heading level="1">SPI details</heading>
</para><para><heading level="2">Chip Select</heading>
</para><para>This SPI controller supports a hardware chip select pin. Refer to the user manual on how this hardware chip select pin behaves in regards to the SPI frame format.</para><para><table rows="3" cols="3"><row>
<entry thead="yes"><para>Chip select type </para></entry><entry thead="yes"><para>SPI_CONTROLLER mode </para></entry><entry thead="yes"><para>SPI_PERIPHERAL mode  </para></entry></row>
<row>
<entry thead="no"><para>Hardware chip select </para></entry><entry thead="no"><para>No action is needed by the application to select the peripheral. </para></entry><entry thead="no"><para>See the device documentation on it&apos;s chip select requirements.  </para></entry></row>
<row>
<entry thead="no"><para>Software chip select </para></entry><entry thead="no"><para>The application is responsible to ensure that correct SPI peripheral is selected before performing a <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref>. </para></entry><entry thead="no"><para>See the device documentation on it&apos;s chip select requirements.  </para></entry></row>
</table>
</para><para><heading level="3">Multiple peripherals when operating in controller mode</heading>
</para><para>In a scenario where the SPI module is operating in controller mode with multiple SPI peripherals, the chip select pin can be reallocated at runtime to select the appropriate peripheral device. See <ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_MMMS_X2" kindref="member">Controller Mode With Multiple Peripherals</ref> use case below. This is only relevant when chip select is a hardware chip select. Otherwise the application can control the chip select pins directly using the GPIO driver.</para><para><heading level="2">Data Frames</heading>
</para><para>SPI data frames can be any size from 4-bits to 16-bits. If the dataSize in <ref refid="struct_s_p_i___params" kindref="compound">SPI_Params</ref> is greater that 8-bits, then the SPICC26X2DMA driver implementation will assume that the <ref refid="struct_s_p_i___transaction" kindref="compound">SPI_Transaction</ref> txBuf and rxBuf point to an array of 16-bit uint16_t elements.</para><para><table rows="3" cols="2"><row>
<entry thead="yes"><para>dataSize </para></entry><entry thead="yes"><para>buffer element size  </para></entry></row>
<row>
<entry thead="no"><para>4-8 bits </para></entry><entry thead="no"><para>uint8_t </para></entry></row>
<row>
<entry thead="no"><para>9-16 bits </para></entry><entry thead="no"><para>uint16_t </para></entry></row>
</table>
<heading level="2">Bit Rate</heading>
</para><para>When the SPI is configured as SPI peripheral, the maximum bit rate is 4MHz.</para><para>When the SPI is configured as SPI controller, the maximum bit rate is 12MHz.</para><para><heading level="2">UDMA</heading>
</para><para><heading level="3">Interrupts</heading>
</para><para>The UDMA module generates IRQs on the SPI interrupt vector. This driver automatically installs a UDMA aware Hwi (interrupt) to service the assigned UDMA channels.</para><para><heading level="3">Transfer Size Limit</heading>
</para><para>The UDMA controller only supports data transfers of up to 1024 data frames. A transfer with more than 1024 frames will be transmitted/received in multiple 1024 sized portions until all data has been transmitted/received. A data frame can be 4 to 16 bits in length.</para><para><heading level="3">Scratch Buffers</heading>
</para><para>A uint16_t scratch buffer is used to allow SPI_transfers where txBuf or rxBuf are NULL. Rather than requiring txBuf or rxBuf to have a dummy buffer of size of the transfer count, a single-word UDMA accessible uint16_t scratch buffer is used. When rxBuf is NULL, the UDMA will transfer all the received SPI data into the scratch buffer as a &quot;bit-bucket&quot;. When txBuf is NULL, the scratch buffer is initialized to defaultTxBufValue so the uDMA will send some known value. Each SPI driver instance uses its own scratch buffer.</para><para><heading level="3">TX and RX buffers</heading>
</para><para>Before SPI_transfer, txBuf should be filled with the outgoing SPI data. These data are sent out during the transfer, while the incoming data are received into rxBuf. To save memory space, txBuf and rxBuf can be assigned to the same buffer location. At the beginning of the transfer, this buffer holds outgoing data. At the end of the transfer, the outgoing data are overwritten and the buffer holds the received SPI data.</para><para><heading level="2">Polling SPI transfers</heading>
</para><para>When used in blocking mode small SPI transfers are can be done by polling the peripheral &amp; sending data frame-by-frame. A controller device can perform the transfer immediately and return, but a peripheral will block until it receives the number of frames specified in the SPI_Transfer() call. The minDmaTransferSize field in the hardware attributes is the threshold; if the transaction count is below the threshold a polling transfer is performed; otherwise a DMA transfer is done. This is intended to reduce the overhead of setting up a DMA transfer to only send a few data frames.</para><para>Notes:<itemizedlist>
<listitem><para>Specifying a timeout prevents peripheral devices from using polling transfers.</para></listitem><listitem><para>Keep in mind that during polling transfers the current task is still being executed; there is no context switch to another task.</para></listitem></itemizedlist>
</para><para><heading level="1">Supported Functions</heading>
</para><para><table rows="7" cols="3"><row>
<entry thead="yes"><para>Generic API function </para></entry><entry thead="yes"><para>API function </para></entry><entry thead="yes"><para>Description  </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_s_p_i_8h_1afd9b09f58917f0e2d14c61b956eba214" kindref="member">SPI_init()</ref> </para></entry><entry thead="no"><para>SPICC26X2DMA_init() </para></entry><entry thead="no"><para>Initialize SPI driver </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_s_p_i_8h_1a9c9022decfb136991d6b53f7dd2ae2fc" kindref="member">SPI_open()</ref> </para></entry><entry thead="no"><para>SPICC26X2DMA_open() </para></entry><entry thead="no"><para>Initialize SPI HW and set system dependencies </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_s_p_i_8h_1a0e3448b30b88609fa120915e49560601" kindref="member">SPI_close()</ref> </para></entry><entry thead="no"><para>SPICC26X2DMA_close() </para></entry><entry thead="no"><para>Disable SPI and UDMA HW and release system dependencies </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_s_p_i_8h_1a1b3fafc9892141b7bab1bc9c19ede9ef" kindref="member">SPI_control()</ref> </para></entry><entry thead="no"><para>SPICC26X2DMA_control() </para></entry><entry thead="no"><para>Configure an already opened SPI handle </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> </para></entry><entry thead="no"><para>SPICC26X2DMA_transfer() </para></entry><entry thead="no"><para>Start transfer from SPI </para></entry></row>
<row>
<entry thead="no"><para><ref refid="_s_p_i_8h_1a6819f7761fc3505c4f885653ff8121f0" kindref="member">SPI_transferCancel()</ref> </para></entry><entry thead="no"><para>SPICC26X2DMA_transferCancel() </para></entry><entry thead="no"><para>Cancel ongoing transfer from SPI </para></entry></row>
</table>
<simplesect kind="note"><para>All calls should go through the generic API</para></simplesect>
<heading level="2">Use Cases<anchor id="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASES_SPI_X2"/></heading>
</para><para><heading level="3">Basic Peripheral Mode</heading>
</para><para>Receive 100 bytes over SPI in <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8" kindref="member">SPI_MODE_BLOCKING</ref>. <programlisting><codeline><highlight class="normal">SPI_Handle<sp/>handle;</highlight></codeline>
<codeline><highlight class="normal">SPI_Params<sp/>params;</highlight></codeline>
<codeline><highlight class="normal">SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>rxBuf[100];<sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>buffer</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal">SPI_Params_init(&amp;params);</highlight></codeline>
<codeline><highlight class="normal">params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline><highlight class="normal">params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline><highlight class="normal">params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline><highlight class="normal">transaction.count<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal">transaction.txBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal">transaction.rxBuf<sp/>=<sp/>rxBuf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>perform<sp/>the<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal">handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline><highlight class="normal">SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
</programlisting></para><para><heading level="3">Peripheral Mode With Return Partial<anchor id="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_RP_X2"/></heading>
</para><para>This use case will perform a transfer in <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8" kindref="member">SPI_MODE_BLOCKING</ref> until the wanted amount of bytes is transferred or until chip select is deasserted by the SPI controller. This <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> call can be used when unknown amount of bytes shall be transferred. <linebreak/>
 Note: Partial return is also possible in <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb" kindref="member">SPI_MODE_CALLBACK</ref> mode. In callback mode, partial transfers can be queued by calling <ref refid="_s_p_i_8h_1a989e17f96b54fcc3dc2cac5f8ac6bdb2" kindref="member">SPI_transfer()</ref> multiple times. <linebreak/>
 Note: Polling transfers are not available when using return partial mode. <programlisting><codeline><highlight class="normal">SPI_Handle<sp/>handle;</highlight></codeline>
<codeline><highlight class="normal">SPI_Params<sp/>params;</highlight></codeline>
<codeline><highlight class="normal">SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>rxBuf[100];<sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>buffer</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal">SPI_Params_init(&amp;params);</highlight></codeline>
<codeline><highlight class="normal">params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline><highlight class="normal">params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline><highlight class="normal">params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline><highlight class="normal">transaction.count<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal">transaction.txBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal">transaction.rxBuf<sp/>=<sp/>rxBuf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>initiate<sp/>the<sp/>partial<sp/>read</highlight></codeline>
<codeline><highlight class="normal">handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Enable<sp/>RETURN_PARTIAL</highlight></codeline>
<codeline><highlight class="normal">SPI_control(handle,<sp/>SPICC26X2DMA_RETURN_PARTIAL_ENABLE,<sp/>NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Begin<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal">SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
</programlisting></para><para><heading level="3">Continuous Peripheral Transfer In <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb" kindref="member">SPI_MODE_CALLBACK</ref><anchor id="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_CST_X2"/></heading>
</para><para>This use case will configure the SPI driver to transfer continuously in <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb" kindref="member">SPI_MODE_CALLBACK</ref>, 16 bytes at the time and echoing received data after every 16 bytes. <programlisting><codeline><highlight class="normal">//<sp/>Callback<sp/>function</highlight></codeline>
<codeline><highlight class="normal">static<sp/>void<sp/>transferCallback(SPI_Handle<sp/>handle,<sp/>SPI_Transaction<sp/>*transaction)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Start<sp/>another<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>transaction);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>void<sp/>taskFxn(uintptr_t<sp/>a0,<sp/>uintptr_t<sp/>a1)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Handle<sp/>handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>buf[16];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>and<sp/>transmit<sp/>buffer</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.bitRate<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.frameFormat<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.transferMode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_MODE_CALLBACK;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.transferCallbackFxn<sp/>=<sp/>transferCallback;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>transaction.count<sp/>=<sp/>16;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>transaction.txBuf<sp/>=<sp/>buf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>transaction.rxBuf<sp/>=<sp/>buf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>initiate<sp/>the<sp/>first<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Wait<sp/>forever</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while(true);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="3">Basic Controller Mode</heading>
</para><para>This use case will configure a SPI controller to send the data in txBuf while receiving data to rxBuf in BLOCKING_MODE. <programlisting><codeline><highlight class="normal">SPI_Handle<sp/>handle;</highlight></codeline>
<codeline><highlight class="normal">SPI_Params<sp/>params;</highlight></codeline>
<codeline><highlight class="normal">SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>txBuf[]<sp/>=<sp/>&quot;Hello<sp/>World&quot;;<sp/><sp/><sp/><sp/>//<sp/>Transmit<sp/>buffer</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>rxBuf[11];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>buffer</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal">SPI_Params_init(&amp;params);</highlight></codeline>
<codeline><highlight class="normal">params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline><highlight class="normal">params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline><highlight class="normal">params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_CONTROLLER;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline><highlight class="normal">transaction.count<sp/>=<sp/>sizeof(txBuf);</highlight></codeline>
<codeline><highlight class="normal">transaction.txBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline><highlight class="normal">transaction.rxBuf<sp/>=<sp/>rxBuf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>perform<sp/>the<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal">handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline><highlight class="normal">SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
</programlisting></para><para><heading level="3">Controller Mode With Multiple Peripherals<anchor id="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_MMMS_X2"/></heading>
</para><para>This use case will configure a SPI controller to send data to one peripheral and then to another in BLOCKING_MODE. It is assumed that the board file is configured so that the two chip select pins have a default setting of a high output and that the <ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs" kindref="compound">SPICC26X2DMA_HWAttrs</ref> used points to one of them since the SPI driver will revert to this default setting when switching the chip select pin.</para><para><programlisting><codeline><highlight class="normal">//<sp/>From<sp/>ti_drivers_config.c</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Use<sp/>the<sp/>sysconfig<sp/>settings<sp/>to<sp/>make<sp/>sure<sp/>both<sp/>pins<sp/>are<sp/>set<sp/>to<sp/>HIGH<sp/>when<sp/>not<sp/>in<sp/>use</highlight></codeline>
<codeline><highlight class="normal">GPIO_PinConfig<sp/>gpioPinConfigs[31]<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPIO_CFG_OUT_STD<sp/>|<sp/>GPIO_CFG_OUT_HIGH,<sp/>//<sp/>CONFIG_CSN_0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPIO_CFG_OUT_STD<sp/>|<sp/>GPIO_CFG_OUT_HIGH,<sp/>//<sp/>CONFIG_CSN_1</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">const<sp/>SPICC26X2DMA_HWAttrs<sp/>SPICC26X2DMAHWAttrs[CC2650_SPICOUNT]<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal">{<sp/><sp/><sp/>//<sp/>Use<sp/>SPI0<sp/>module<sp/>with<sp/>default<sp/>chip<sp/>select<sp/>on<sp/>CONFIG_CSN_0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.baseAddr<sp/>=<sp/>SSI0_BASE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.intNum<sp/>=<sp/>INT_SSI0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.intPriority<sp/>=<sp/>~0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.swiPriority<sp/>=<sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.defaultTxBufValue<sp/>=<sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.powerMngrId<sp/>=<sp/>PERIPH_SSI0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.rxChannelIndex<sp/>=<sp/>UDMA_CHAN_SSI0_RX,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.txChannelIndex<sp/>=<sp/>UDMA_CHAN_SSI0_TX,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.picoPin<sp/>=<sp/>CONFIG_SPI0_PICO,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.pociPin<sp/>=<sp/>CONFIG_SPI0_POCI,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.clkPin<sp/>=<sp/>CONFIG_SPI0_CLK,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.csnPin<sp/>=<sp/>CONFIG_CSN_0</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>From<sp/>your_application.c</highlight></codeline>
<codeline><highlight class="normal">static<sp/>void<sp/>taskFxn(uintptr_t<sp/>a0,<sp/>uintptr_t<sp/>a1)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Handle<sp/>handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint_least8_t<sp/>csnPin1<sp/>=<sp/>CONFIG_CSN_1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>txBuf[]<sp/>=<sp/>&quot;Hello<sp/>World&quot;;<sp/><sp/><sp/><sp/>//<sp/>Transmit<sp/>buffer</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_CONTROLLER;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>transaction.count<sp/>=<sp/>sizeof(txBuf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>transaction.txBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>transaction.rxBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>perform<sp/>transfer<sp/>to<sp/>the<sp/>first<sp/>peripheral</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Then<sp/>switch<sp/>chip<sp/>select<sp/>pin<sp/>and<sp/>perform<sp/>transfer<sp/>to<sp/>the<sp/>second<sp/>peripheral</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_control(handle,<sp/>SPICC26X2DMA_SET_CSN_PIN,<sp/>&amp;csnPin1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="3">Queueing Transactions in Callback Mode</heading>
</para><para><anchor id="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_QUEUE"/> Below is an example of queueing three transactions <programlisting><codeline><highlight class="normal">//<sp/>SPI<sp/>already<sp/>opened<sp/>in<sp/>callback<sp/>mode</highlight></codeline>
<codeline><highlight class="normal">SPI_Transaction<sp/>t0,<sp/>t1,<sp/>t2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">t0.txBuf<sp/>=<sp/>txBuff0;</highlight></codeline>
<codeline><highlight class="normal">t0.rxBuf<sp/>=<sp/>rxBuff0;</highlight></codeline>
<codeline><highlight class="normal">t0.count<sp/>=<sp/>2000;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">t1.txBuf<sp/>=<sp/>txBuff1;</highlight></codeline>
<codeline><highlight class="normal">t1.rxBuf<sp/>=<sp/>rxBuff1;</highlight></codeline>
<codeline><highlight class="normal">t1.count<sp/>=<sp/>1000;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">t2.txBuf<sp/>=<sp/>txBuff2;</highlight></codeline>
<codeline><highlight class="normal">t2.rxBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal">t2.count<sp/>=<sp/>1000;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">bool<sp/>transferOk<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(SPI_transfer(spiHandle,<sp/>&amp;t0))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(SPI_transfer(spiHandle,<sp/>&amp;t1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>transferOk<sp/>=<sp/>SPI_transfer(spiHandle,<sp/>&amp;t2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="3">Queueing in Manual Start Mode</heading>
</para><para>This example shows a peripheral device queueing two transactions that will complete one after the other. From the controller&apos;s perspective there will be one long transfer. <simplesect kind="note"><para>Manual mode also works while the device is in <ref refid="_s_p_i_8h_1a60a7e3d74577b38aa79ea6983362f942a061361eeeb9e87265edcc0c70868111a" kindref="member">SPI_CONTROLLER</ref> mode. The control call to MANUAL_START will start the transfers.</para></simplesect>
<simplesect kind="warning"><para>Manual start mode should not be enabled or disabled while a transaction is in progress.</para></simplesect>
<anchor id="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_MANUAL_START"/><programlisting><codeline><highlight class="normal">SPI_Handle<sp/>spi;</highlight></codeline>
<codeline><highlight class="normal">SPI_Params<sp/>params;</highlight></codeline>
<codeline><highlight class="normal">SPI_Transaction<sp/>t0,<sp/>t1;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>status<sp/>=<sp/>SPI_STATUS_SUCCESS;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">SPI_Params_init(&amp;params);</highlight></codeline>
<codeline><highlight class="normal">params.mode<sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline><highlight class="normal">spi<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(spi<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Enable<sp/>manual<sp/>start<sp/>mode</highlight></codeline>
<codeline><highlight class="normal">SPI_control(spi,<sp/>SPICC26X2DMA_CMD_SET_MANUAL,<sp/>NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Queue<sp/>transactions</highlight></codeline>
<codeline><highlight class="normal">t0.txBuf<sp/>=<sp/>txBuff0;</highlight></codeline>
<codeline><highlight class="normal">t0.rxBuf<sp/>=<sp/>rxBuff0;</highlight></codeline>
<codeline><highlight class="normal">t0.count<sp/>=<sp/>2000;</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(!SPI_transfer(spi,<sp/>&amp;t0))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>status<sp/>=<sp/>SPI_STATUS_FAIL;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">t1.txBuf<sp/>=<sp/>txBuff1;</highlight></codeline>
<codeline><highlight class="normal">t1.rxBuf<sp/>=<sp/>rxBuff1;</highlight></codeline>
<codeline><highlight class="normal">t1.count<sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(!SPI_transfer(spi,<sp/>&amp;t1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>status<sp/>=<sp/>SPI_STATUS_FAIL;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Enable<sp/>the<sp/>transfers</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(status<sp/>==<sp/>SPI_STATUS_SUCCESS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_control(spi,<sp/>SPICC26X2DMA_CMD_MANUAL_START,<sp/>NULL);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>status<sp/>=<sp/>SPI_STATUS_FAILURE;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>At<sp/>this<sp/>point<sp/>the<sp/>peripheral<sp/>is<sp/>ready<sp/>for<sp/>the<sp/>controller<sp/>to<sp/>start<sp/>the<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Assume<sp/>the<sp/>callback<sp/>implementation<sp/>(not<sp/>shown)<sp/>posts<sp/>a<sp/>semaphore<sp/>when</highlight></codeline>
<codeline><highlight class="normal">//<sp/>the<sp/>last<sp/>transaction<sp/>completes</highlight></codeline>
<codeline><highlight class="normal">sem_wait(&amp;spiSemaphore);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Disable<sp/>manual<sp/>start<sp/>mode</highlight></codeline>
<codeline><highlight class="normal">SPI_control(spi,<sp/>SPICC26X2DMA_CMD_CLR_MANUAL,<sp/>NULL);</highlight></codeline>
</programlisting></para><para><heading level="3">Ensure low power during inactive periods<anchor id="_s_p_i_c_c26_x2_d_m_a_8h_1USE_CASE_LPWR_X2"/></heading>
</para><para>External hardware connected on the SPI, i.e. SPI host/peripheral, might have configured a pull on one or more of the SPI lines. Dependent on the hardware, it might conflict with the pull used for the CC26XX SPI. To avoid increased leakage and ensure the lowest possible power consumption when the SPI is inactive, the application must configure a matching pull on the SPI IOs. An example of how this can be done is shown below.</para><para><programlisting><codeline><highlight class="normal">SPI_Params<sp/>params;</highlight></codeline>
<codeline><highlight class="normal">SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>txBuf[]<sp/>=<sp/>&quot;Heartbeat&quot;;<sp/><sp/><sp/><sp/>//<sp/>Transmit<sp/>buffer</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>rxBuf[9];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>buffer</highlight></codeline>
<codeline><highlight class="normal">uint32_t<sp/>standbyDurationMs<sp/>=<sp/>100;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal">SPI_Params_init(&amp;params);</highlight></codeline>
<codeline><highlight class="normal">params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline><highlight class="normal">params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline><highlight class="normal">params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_CONTROLLER;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline><highlight class="normal">transaction.count<sp/>=<sp/>sizeof(txBuf);</highlight></codeline>
<codeline><highlight class="normal">transaction.txBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline><highlight class="normal">transaction.rxBuf<sp/>=<sp/>rxBuf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>perform<sp/>the<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal">handle<sp/>=<sp/>SPI_open(CONFIG_SPI_0,<sp/>&amp;params);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Apply<sp/>low<sp/>power<sp/>sleep<sp/>pull<sp/>config<sp/>for<sp/>POCI</highlight></codeline>
<codeline><highlight class="normal">GPIO_setConfig(CONFIG_GPIO_SPI_0_POCI,<sp/>GPIO_CFG_IN_PU);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>forever</highlight></codeline>
<codeline><highlight class="normal">while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Transfer<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Sleep</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Task_sleep(standbyDurationMs*100);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="3">Wake Up On Chip Select Deassertion In Peripheral Mode Using <ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb" kindref="member">SPI_MODE_CALLBACK</ref></heading>
</para><para>This example demonstrates using a GPIO callback on Chip Select to wake up the device to allow low power modes while waiting for a chip select edge.</para><para>In sysconfig or the board file, the CSN GPIO should be configured as input/pull up with an interrupt on falling edge. Otherwise, <ref refid="_s_p_i_8h_1a0e3448b30b88609fa120915e49560601" kindref="member">SPI_close()</ref> will reset the pin to the wrong settings and you may see line glitches.</para><para>*Note: The SPI controller must allow enough time between deasserting the chip select and the start of the transaction for the SPI peripheral to wake up and open up the SPI driver.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal">SPI_Handle<sp/>spiHandle</highlight></codeline>
<codeline><highlight class="normal">SPI_Params<sp/>spiParams;</highlight></codeline>
<codeline><highlight class="normal">SPI_Transaction<sp/>spiTransaction;</highlight></codeline>
<codeline><highlight class="normal">const<sp/>uint8_t<sp/>transferSize<sp/>=<sp/>8;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>txBuf[8];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Chip<sp/>select<sp/>callback</highlight></codeline>
<codeline><highlight class="normal">static<sp/>void<sp/>chipSelectCallback(uint_least8_t)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Open<sp/>SPI<sp/>driver,<sp/>which<sp/>will<sp/>override<sp/>any<sp/>previous<sp/>GPIO<sp/>configuration</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiHandle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;spiParams);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Issue<sp/>the<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_transfer(spiHandle,<sp/>&amp;spiTransaction);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>SPI<sp/>transfer<sp/>callback</highlight></codeline>
<codeline><highlight class="normal">static<sp/>void<sp/>transferCallback(SPI_Handle<sp/>handle,<sp/>SPI_Transaction<sp/>*transaction)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Close<sp/>the<sp/>SPI<sp/>driver</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_close(handle);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Note:<sp/>SPI_close()<sp/>will<sp/>reset<sp/>the<sp/>pin<sp/>configuration,<sp/>so<sp/>it<sp/>is<sp/>important<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>set<sp/>the<sp/>default<sp/>values<sp/>correctly<sp/>in<sp/>sysconfig.<sp/>We<sp/>just<sp/>need<sp/>to<sp/>set<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>callback<sp/>and<sp/>enable<sp/>the<sp/>falling<sp/>edge<sp/>interrupt</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPIO_setCallback(CS_PIN_INDEX,<sp/>chipSelectCallback);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPIO_enableInt(CS_PIN_INDEX);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>From<sp/>your_application.c</highlight></codeline>
<codeline><highlight class="normal">static<sp/>void<sp/>taskFxn(uintptr_t<sp/>a0,<sp/>uintptr_t<sp/>a1)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>i;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Setup<sp/>SPI<sp/>params</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SPI_Params_init(&amp;spiParams);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiParams.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiParams.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiParams.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiParams.dataSize<sp/><sp/><sp/><sp/>=<sp/>transferSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiParams.transferMode<sp/>=<sp/>SPI_MODE_CALLBACK;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiParams.transferCallbackFxn<sp/>=<sp/>transferCallback;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Setup<sp/>SPI<sp/>transaction</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiTransaction.arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiTransaction.count<sp/>=<sp/>transferSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiTransaction.txBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spiTransaction.rxBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>echo<sp/>message</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>transferSize;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>txBuf[i]<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Configure<sp/>chip<sp/>select<sp/>callback</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPIO_setCallback(CS_PIN_INDEX,<sp/>chipSelectCallback);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPIO_enableInt(CS_PIN_INDEX);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Wait<sp/>forever</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while(true);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><hruler/>
 </para>    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2015-2023,<sp/>Texas<sp/>Instruments<sp/>Incorporated</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*<sp/>Redistribution<sp/>and<sp/>use<sp/>in<sp/>source<sp/>and<sp/>binary<sp/>forms,<sp/>with<sp/>or<sp/>without</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*<sp/>modification,<sp/>are<sp/>permitted<sp/>provided<sp/>that<sp/>the<sp/>following<sp/>conditions</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>*<sp/>are<sp/>met:</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Redistributions<sp/>of<sp/>source<sp/>code<sp/>must<sp/>retain<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer.</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Redistributions<sp/>in<sp/>binary<sp/>form<sp/>must<sp/>reproduce<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer<sp/>in<sp/>the</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>documentation<sp/>and/or<sp/>other<sp/>materials<sp/>provided<sp/>with<sp/>the<sp/>distribution.</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*<sp/>*<sp/><sp/>Neither<sp/>the<sp/>name<sp/>of<sp/>Texas<sp/>Instruments<sp/>Incorporated<sp/>nor<sp/>the<sp/>names<sp/>of</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>its<sp/>contributors<sp/>may<sp/>be<sp/>used<sp/>to<sp/>endorse<sp/>or<sp/>promote<sp/>products<sp/>derived</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>from<sp/>this<sp/>software<sp/>without<sp/>specific<sp/>prior<sp/>written<sp/>permission.</highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*<sp/>THIS<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>BY<sp/>THE<sp/>COPYRIGHT<sp/>HOLDERS<sp/>AND<sp/>CONTRIBUTORS<sp/>&quot;AS<sp/>IS&quot;</highlight></codeline>
<codeline lineno="21"><highlight class="comment"><sp/>*<sp/>AND<sp/>ANY<sp/>EXPRESS<sp/>OR<sp/>IMPLIED<sp/>WARRANTIES,<sp/>INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,</highlight></codeline>
<codeline lineno="22"><highlight class="comment"><sp/>*<sp/>THE<sp/>IMPLIED<sp/>WARRANTIES<sp/>OF<sp/>MERCHANTABILITY<sp/>AND<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR</highlight></codeline>
<codeline lineno="23"><highlight class="comment"><sp/>*<sp/>PURPOSE<sp/>ARE<sp/>DISCLAIMED.<sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>THE<sp/>COPYRIGHT<sp/>OWNER<sp/>OR</highlight></codeline>
<codeline lineno="24"><highlight class="comment"><sp/>*<sp/>CONTRIBUTORS<sp/>BE<sp/>LIABLE<sp/>FOR<sp/>ANY<sp/>DIRECT,<sp/>INDIRECT,<sp/>INCIDENTAL,<sp/>SPECIAL,</highlight></codeline>
<codeline lineno="25"><highlight class="comment"><sp/>*<sp/>EXEMPLARY,<sp/>OR<sp/>CONSEQUENTIAL<sp/>DAMAGES<sp/>(INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,</highlight></codeline>
<codeline lineno="26"><highlight class="comment"><sp/>*<sp/>PROCUREMENT<sp/>OF<sp/>SUBSTITUTE<sp/>GOODS<sp/>OR<sp/>SERVICES;<sp/>LOSS<sp/>OF<sp/>USE,<sp/>DATA,<sp/>OR<sp/>PROFITS;</highlight></codeline>
<codeline lineno="27"><highlight class="comment"><sp/>*<sp/>OR<sp/>BUSINESS<sp/>INTERRUPTION)<sp/>HOWEVER<sp/>CAUSED<sp/>AND<sp/>ON<sp/>ANY<sp/>THEORY<sp/>OF<sp/>LIABILITY,</highlight></codeline>
<codeline lineno="28"><highlight class="comment"><sp/>*<sp/>WHETHER<sp/>IN<sp/>CONTRACT,<sp/>STRICT<sp/>LIABILITY,<sp/>OR<sp/>TORT<sp/>(INCLUDING<sp/>NEGLIGENCE<sp/>OR</highlight></codeline>
<codeline lineno="29"><highlight class="comment"><sp/>*<sp/>OTHERWISE)<sp/>ARISING<sp/>IN<sp/>ANY<sp/>WAY<sp/>OUT<sp/>OF<sp/>THE<sp/>USE<sp/>OF<sp/>THIS<sp/>SOFTWARE,</highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/>*<sp/>EVEN<sp/>IF<sp/>ADVISED<sp/>OF<sp/>THE<sp/>POSSIBILITY<sp/>OF<sp/>SUCH<sp/>DAMAGE.</highlight></codeline>
<codeline lineno="31"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>clang-format<sp/>off<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight><highlight class="comment">/*!*****************************************************************************</highlight></codeline>
<codeline lineno="34"><highlight class="comment"><sp/>*<sp/><sp/>@file<sp/><sp/><sp/><sp/><sp/><sp/><sp/>SPICC26X2DMA.h</highlight></codeline>
<codeline lineno="35"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="36"><highlight class="comment"><sp/>*<sp/><sp/>@brief<sp/><sp/><sp/><sp/><sp/><sp/>SPI<sp/>driver<sp/>implementation<sp/>for<sp/>a<sp/>CC26XX<sp/>SPI<sp/>controller<sp/>using</highlight></codeline>
<codeline lineno="37"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>the<sp/>UDMA<sp/>controller.</highlight></codeline>
<codeline lineno="38"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="39"><highlight class="comment"><sp/>*<sp/>#<sp/>Driver<sp/>include<sp/>#</highlight></codeline>
<codeline lineno="40"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>SPI<sp/>header<sp/>file<sp/>should<sp/>be<sp/>included<sp/>in<sp/>an<sp/>application<sp/>as<sp/>follows:</highlight></codeline>
<codeline lineno="41"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="42"><highlight class="comment"><sp/>*<sp/><sp/>#include<sp/>&lt;ti/drivers/SPI.h&gt;</highlight></codeline>
<codeline lineno="43"><highlight class="comment"><sp/>*<sp/><sp/>#include<sp/>&lt;ti/drivers/spi/SPICC26X2DMA.h&gt;</highlight></codeline>
<codeline lineno="44"><highlight class="comment"><sp/>*<sp/><sp/>#include<sp/>&lt;ti/drivers/dma/UDMACC26XX.h&gt;</highlight></codeline>
<codeline lineno="45"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="46"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="47"><highlight class="comment"><sp/>*<sp/><sp/>Refer<sp/>to<sp/>@ref<sp/>SPI.h<sp/>for<sp/>a<sp/>complete<sp/>description<sp/>of<sp/>APIs.</highlight></codeline>
<codeline lineno="48"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="49"><highlight class="comment"><sp/>*<sp/>Note<sp/>that<sp/>the<sp/>user<sp/>also<sp/>needs<sp/>to<sp/>include<sp/>the<sp/>UDMACC26XX.h<sp/>driver<sp/>since<sp/>the</highlight></codeline>
<codeline lineno="50"><highlight class="comment"><sp/>*<sp/>SPI<sp/>uses<sp/>uDMA<sp/>in<sp/>order<sp/>to<sp/>improve<sp/>throughput.</highlight></codeline>
<codeline lineno="51"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="52"><highlight class="comment"><sp/>*<sp/>#<sp/>Overview<sp/>#</highlight></codeline>
<codeline lineno="53"><highlight class="comment"><sp/>*<sp/>The<sp/>general<sp/>SPI<sp/>API<sp/>should<sp/>be<sp/>used<sp/>in<sp/>application<sp/>code,<sp/>i.e.<sp/>SPI_open()</highlight></codeline>
<codeline lineno="54"><highlight class="comment"><sp/>*<sp/>should<sp/>be<sp/>used<sp/>instead<sp/>of<sp/>SPICC26X2DMA_open().<sp/>The<sp/>board<sp/>file<sp/>will<sp/>define<sp/>the<sp/>device</highlight></codeline>
<codeline lineno="55"><highlight class="comment"><sp/>*<sp/>specific<sp/>config,<sp/>and<sp/>casting<sp/>in<sp/>the<sp/>general<sp/>API<sp/>will<sp/>ensure<sp/>that<sp/>the<sp/>correct</highlight></codeline>
<codeline lineno="56"><highlight class="comment"><sp/>*<sp/>device<sp/>specific<sp/>functions<sp/>are<sp/>called.</highlight></codeline>
<codeline lineno="57"><highlight class="comment"><sp/>*<sp/>This<sp/>is<sp/>also<sp/>reflected<sp/>in<sp/>the<sp/>example<sp/>code<sp/>in<sp/>[Use<sp/>Cases](@ref<sp/>USE_CASES_SPI_X2).</highlight></codeline>
<codeline lineno="58"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="59"><highlight class="comment"><sp/>*<sp/>#<sp/>General<sp/>Behavior<sp/>#</highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/>*<sp/>Before<sp/>using<sp/>SPI<sp/>on<sp/>CC26XX:</highlight></codeline>
<codeline lineno="61"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>The<sp/>SPI<sp/>driver<sp/>is<sp/>initialized<sp/>by<sp/>calling<sp/>SPI_init().</highlight></codeline>
<codeline lineno="62"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>The<sp/>SPI<sp/>HW<sp/>is<sp/>configured<sp/>and<sp/>flags<sp/>system<sp/>dependencies<sp/>(e.g.<sp/>IOs,</highlight></codeline>
<codeline lineno="63"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>power,<sp/>etc.)<sp/>by<sp/>calling<sp/>SPI_open().</highlight></codeline>
<codeline lineno="64"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>The<sp/>SPI<sp/>driver<sp/>makes<sp/>use<sp/>of<sp/>DMA<sp/>in<sp/>order<sp/>to<sp/>optimize<sp/>throughput.</highlight></codeline>
<codeline lineno="65"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>This<sp/>is<sp/>handled<sp/>directly<sp/>by<sp/>the<sp/>SPI<sp/>driver,<sp/>so<sp/>the<sp/>application<sp/>should<sp/>never</highlight></codeline>
<codeline lineno="66"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>to<sp/>make<sp/>any<sp/>calls<sp/>directly<sp/>to<sp/>the<sp/>UDMACC26XX.h<sp/>driver.</highlight></codeline>
<codeline lineno="67"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>This<sp/>implementation<sp/>supports<sp/>queueing<sp/>multiple<sp/>transactions<sp/>in<sp/>callback</highlight></codeline>
<codeline lineno="68"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>mode.<sp/>See<sp/>the<sp/>@ref<sp/>USE_CASE_QUEUE<sp/>&quot;queueing<sp/>example.&quot;</highlight></codeline>
<codeline lineno="69"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>When<sp/>queueing<sp/>multiple<sp/>transactions<sp/>that<sp/>should<sp/>transfer<sp/>one<sp/>after<sp/>the</highlight></codeline>
<codeline lineno="70"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>other,<sp/>it<sp/>is<sp/>recommended<sp/>to<sp/>use<sp/>the<sp/>driver<sp/>in<sp/>&apos;manual<sp/>start&apos;<sp/>mode<sp/>by<sp/>using</highlight></codeline>
<codeline lineno="71"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>the<sp/>#SPICC26X2DMA_CMD_SET_MANUAL<sp/>command.<sp/>In<sp/>this<sp/>mode,<sp/>the<sp/>driver<sp/>will</highlight></codeline>
<codeline lineno="72"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>not<sp/>start<sp/>any<sp/>queued<sp/>transfers<sp/>until<sp/>SPI_control()<sp/>is<sp/>called<sp/>with<sp/>the</highlight></codeline>
<codeline lineno="73"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#SPICC26X2DMA_CMD_MANUAL_START<sp/>command.<sp/>This<sp/>mode<sp/>is<sp/>off<sp/>by<sp/>default<sp/>and</highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>can<sp/>be<sp/>disabled<sp/>by<sp/>using<sp/>command<sp/>#SPICC26X2DMA_CMD_CLR_MANUAL.<sp/>See<sp/>the</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>@ref<sp/>USE_CASE_MANUAL_START<sp/>&quot;Manual<sp/>Start<sp/>Example&quot;.</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/>*<sp/>The<sp/>following<sp/>is<sp/>true<sp/>for<sp/>peripheral<sp/>operation:</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>RX<sp/>overrun<sp/>IRQ,<sp/>SPI<sp/>and<sp/>UDMA<sp/>modules<sp/>are<sp/>enabled<sp/>by<sp/>calling<sp/>SPI_transfer().</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>All<sp/>received<sp/>bytes<sp/>are<sp/>ignored<sp/>after<sp/>SPI_open()<sp/>is<sp/>called,<sp/>until</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>the<sp/>first<sp/>SPI_transfer().</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>If<sp/>an<sp/>RX<sp/>overrun<sp/>occur<sp/>or<sp/>if<sp/>SPI_transferCancel()<sp/>is<sp/>called,<sp/>RX<sp/>overrun<sp/>IRQ,<sp/>SPI<sp/>and<sp/>UDMA</highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>modules<sp/>are<sp/>disabled,<sp/>TX<sp/>and<sp/>RX<sp/>FIFOs<sp/>are<sp/>flushed<sp/>and<sp/>all<sp/>bytes<sp/>are<sp/>ignored.</highlight></codeline>
<codeline lineno="83"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>After<sp/>a<sp/>successful<sp/>transfer,<sp/>RX<sp/>overrun<sp/>IRQ<sp/>and<sp/>SPI<sp/>module<sp/>remains<sp/>enabled<sp/>and<sp/>UDMA<sp/>module<sp/>is<sp/>disabled.</highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>SPI_transfer()<sp/>must<sp/>be<sp/>called<sp/>again<sp/>before<sp/>RX<sp/>FIFO<sp/>goes<sp/>full<sp/>in<sp/>order<sp/>to</highlight></codeline>
<codeline lineno="85"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>avoid<sp/>overflow.<sp/>If<sp/>the<sp/>TX<sp/>buffer<sp/>is<sp/>underflowed,<sp/>zeros<sp/>will<sp/>be<sp/>output.</highlight></codeline>
<codeline lineno="86"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>It<sp/>is<sp/>safe<sp/>to<sp/>call<sp/>another<sp/>SPI_transfer()<sp/>from<sp/>the<sp/>transfer<sp/>callback,</highlight></codeline>
<codeline lineno="87"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>see<sp/>[Continuous<sp/>Peripheral<sp/>Transfer]<sp/>(@ref<sp/>USE_CASE_CST_X2)<sp/>use<sp/>case<sp/>below.</highlight></codeline>
<codeline lineno="88"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>The<sp/>SPI<sp/>driver<sp/>supports<sp/>partial<sp/>return,<sp/>that<sp/>can<sp/>be<sp/>used<sp/>if<sp/>the</highlight></codeline>
<codeline lineno="89"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>transfer<sp/>size<sp/>is<sp/>unknown.<sp/>If<sp/>#SPICC26X2DMA_CMD_RETURN_PARTIAL_ENABLE<sp/>is</highlight></codeline>
<codeline lineno="90"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>passed<sp/>to<sp/>SPI_control(),<sp/>the<sp/>transfer<sp/>will<sp/>end<sp/>when<sp/>chip<sp/>select<sp/>is</highlight></codeline>
<codeline lineno="91"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>deasserted.<sp/>The<sp/>#SPI_Transaction.status<sp/>and<sp/>the<sp/>#SPI_Transaction.count</highlight></codeline>
<codeline lineno="92"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>will<sp/>be<sp/>updated<sp/>to<sp/>indicate<sp/>whether<sp/>the<sp/>transfer<sp/>ended<sp/>due<sp/>to<sp/>a<sp/>chip</highlight></codeline>
<codeline lineno="93"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>select<sp/>deassertion<sp/>and<sp/>how<sp/>many<sp/>bytes<sp/>were<sp/>transferred.<sp/>See</highlight></codeline>
<codeline lineno="94"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>[Peripheral<sp/>Mode<sp/>With<sp/>Return<sp/>Partial]<sp/>(@ref<sp/>USE_CASE_RP_X2)<sp/>use<sp/>case<sp/>below.</highlight></codeline>
<codeline lineno="95"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>When<sp/>queueing<sp/>several<sp/>transactions<sp/>if<sp/>the<sp/>first<sp/>is<sp/>a<sp/>&apos;short&apos;</highlight></codeline>
<codeline lineno="96"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>transaction<sp/>(8<sp/>or<sp/>fewer<sp/>frames),<sp/>it<sp/>is<sp/>required<sp/>to<sp/>use</highlight></codeline>
<codeline lineno="97"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>@ref<sp/>USE_CASE_MANUAL_START<sp/>&quot;Manual<sp/>Start<sp/>mode.&quot;</highlight></codeline>
<codeline lineno="98"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="99"><highlight class="comment"><sp/>*<sp/>@warning<sp/>The<sp/>SPI<sp/>modules<sp/>on<sp/>the<sp/>CC13x0,<sp/>CC26x0,<sp/>and<sp/>CC26x0R2<sp/>devices<sp/>have<sp/>a</highlight></codeline>
<codeline lineno="100"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>bug<sp/>which<sp/>may<sp/>result<sp/>in<sp/>TX<sp/>data<sp/>being<sp/>lost<sp/>when<sp/>operating<sp/>in<sp/>SPI<sp/>peripheral</highlight></codeline>
<codeline lineno="101"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>mode.<sp/>Please<sp/>refer<sp/>to<sp/>the<sp/>device<sp/>errata<sp/>sheet<sp/>for<sp/>full<sp/>details.<sp/>The<sp/>SPI</highlight></codeline>
<codeline lineno="102"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>protocol<sp/>should<sp/>therefore<sp/>include<sp/>a<sp/>data<sp/>integrity<sp/>check,<sp/>such<sp/>as</highlight></codeline>
<codeline lineno="103"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>appending<sp/>a<sp/>CRC<sp/>to<sp/>the<sp/>payload<sp/>to<sp/>ensure<sp/>all<sp/>the<sp/>data<sp/>was<sp/>transmitted</highlight></codeline>
<codeline lineno="104"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>correctly<sp/>by<sp/>the<sp/>SPI<sp/>peripheral.</highlight></codeline>
<codeline lineno="105"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="106"><highlight class="comment"><sp/>*<sp/>The<sp/>following<sp/>apply<sp/>for<sp/>controller<sp/>operation:</highlight></codeline>
<codeline lineno="107"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>SPI<sp/>and<sp/>UDMA<sp/>modules<sp/>are<sp/>enabled<sp/>by<sp/>calling<sp/>SPI_transfer().</highlight></codeline>
<codeline lineno="108"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>If<sp/>the<sp/>SPI_transfer()<sp/>succeeds,<sp/>SPI<sp/>module<sp/>is<sp/>enabled<sp/>and<sp/>UDMA<sp/>module<sp/>is<sp/>disabled.</highlight></codeline>
<codeline lineno="109"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>If<sp/>SPI_transferCancel()<sp/>is<sp/>called,<sp/>SPI<sp/>and<sp/>UDMA<sp/>modules<sp/>are<sp/>disabled<sp/>and</highlight></codeline>
<codeline lineno="110"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>TX<sp/>and<sp/>RX<sp/>FIFOs<sp/>are<sp/>flushed.</highlight></codeline>
<codeline lineno="111"><highlight class="comment"><sp/>*<sp/><sp/><sp/>.</highlight></codeline>
<codeline lineno="112"><highlight class="comment"><sp/>*<sp/>After<sp/>SPI<sp/>operation<sp/>has<sp/>ended:</highlight></codeline>
<codeline lineno="113"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>Release<sp/>system<sp/>dependencies<sp/>for<sp/>SPI<sp/>by<sp/>calling<sp/>SPI_close().</highlight></codeline>
<codeline lineno="114"><highlight class="comment"><sp/>*<sp/><sp/><sp/>.</highlight></codeline>
<codeline lineno="115"><highlight class="comment"><sp/>*<sp/>The<sp/>callback<sp/>function<sp/>is<sp/>always<sp/>called<sp/>in<sp/>a<sp/>SWI<sp/>context.</highlight></codeline>
<codeline lineno="116"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="117"><highlight class="comment"><sp/>*<sp/>@warning<sp/><sp/><sp/><sp/><sp/>The<sp/>application<sp/>should<sp/>avoid<sp/>transmitting<sp/>data<sp/>stored<sp/>in<sp/>flash<sp/>via<sp/>SPI<sp/>if<sp/>the<sp/>application</highlight></codeline>
<codeline lineno="118"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>might<sp/>switch<sp/>to<sp/>the<sp/>XOSC_HF,<sp/>the<sp/>high<sp/>frequency<sp/>external<sp/>oscillator,<sp/>during<sp/>this<sp/>transfer.</highlight></codeline>
<codeline lineno="119"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="120"><highlight class="comment"><sp/>*<sp/>#<sp/>Error<sp/>handling<sp/>#</highlight></codeline>
<codeline lineno="121"><highlight class="comment"><sp/>*<sp/>If<sp/>an<sp/>RX<sp/>overrun<sp/>occurs<sp/>during<sp/>peripheral<sp/>operation:</highlight></codeline>
<codeline lineno="122"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>If<sp/>a<sp/>transfer<sp/>is<sp/>ongoing,<sp/>all<sp/>bytes<sp/>received<sp/>up<sp/>until<sp/>the<sp/>error<sp/>occurs<sp/>will<sp/>be<sp/>returned,<sp/>with<sp/>the</highlight></codeline>
<codeline lineno="123"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>error<sp/>signaled<sp/>in<sp/>the<sp/>#SPI_Transaction.status<sp/>field.<sp/>RX<sp/>overrun<sp/>IRQ,<sp/>SPI<sp/>and<sp/>UDMA<sp/>modules<sp/>are<sp/>then<sp/>disabled,</highlight></codeline>
<codeline lineno="124"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>TX<sp/>and<sp/>RX<sp/>FIFOs<sp/>are<sp/>flushed<sp/>and<sp/>all<sp/>bytes<sp/>will<sp/>be<sp/>ignored<sp/>until<sp/>a<sp/>new<sp/>transfer<sp/>is<sp/>issued.</highlight></codeline>
<codeline lineno="125"><highlight class="comment"><sp/>*<sp/><sp/><sp/>-<sp/>If<sp/>a<sp/>transfer<sp/>is<sp/>not<sp/>ongoing,<sp/>RX<sp/>overrun<sp/>IRQ,<sp/>SPI<sp/>and<sp/>UDMA<sp/>modules<sp/>are<sp/>disabled,</highlight></codeline>
<codeline lineno="126"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>TX<sp/>and<sp/>RX<sp/>FIFOs<sp/>are<sp/>flushed<sp/>and<sp/>all<sp/>bytes<sp/>will<sp/>be<sp/>ignored<sp/>until<sp/>a<sp/>new<sp/>transfer<sp/>is<sp/>issued.</highlight></codeline>
<codeline lineno="127"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="128"><highlight class="comment"><sp/>*<sp/>#<sp/>Timeout<sp/>#</highlight></codeline>
<codeline lineno="129"><highlight class="comment"><sp/>*<sp/>Timeout<sp/>can<sp/>occur<sp/>in<sp/>#SPI_MODE_BLOCKING,<sp/>there&apos;s<sp/>no<sp/>timeout<sp/>in<sp/>#SPI_MODE_CALLBACK.</highlight></codeline>
<codeline lineno="130"><highlight class="comment"><sp/>*<sp/>When<sp/>in<sp/>#SPI_MODE_CALLBACK,<sp/>the<sp/>transfer<sp/>must<sp/>be<sp/>cancelled<sp/>by<sp/>calling<sp/>SPI_transferCancel().@n</highlight></codeline>
<codeline lineno="131"><highlight class="comment"><sp/>*<sp/>If<sp/>a<sp/>timeout<sp/>happens<sp/>in<sp/>either<sp/><sp/>#SPI_PERIPHERAL<sp/>or<sp/>#SPI_CONTROLLER<sp/>mode,</highlight></codeline>
<codeline lineno="132"><highlight class="comment"><sp/>*<sp/>the<sp/>receive<sp/>buffer<sp/>will<sp/>contain<sp/>the<sp/>bytes<sp/>received<sp/>up<sp/>until<sp/>the<sp/>timeout<sp/>occurred.</highlight></codeline>
<codeline lineno="133"><highlight class="comment"><sp/>*<sp/>The<sp/>SPI<sp/>transaction<sp/>status<sp/>will<sp/>be<sp/>set<sp/>to<sp/>#SPI_TRANSFER_FAILED.</highlight></codeline>
<codeline lineno="134"><highlight class="comment"><sp/>*<sp/>The<sp/>SPI<sp/>transaction<sp/>count<sp/>will<sp/>be<sp/>set<sp/>to<sp/>the<sp/>number<sp/>of<sp/>bytes<sp/>sent/received<sp/>before<sp/>timeout.</highlight></codeline>
<codeline lineno="135"><highlight class="comment"><sp/>*<sp/>The<sp/>remaining<sp/>bytes<sp/>will<sp/>be<sp/>flushed<sp/>from<sp/>the<sp/>TX<sp/>FIFO<sp/>so<sp/>that<sp/>the<sp/>subsequent<sp/>transfer</highlight></codeline>
<codeline lineno="136"><highlight class="comment"><sp/>*<sp/>can<sp/>be<sp/>executed<sp/>correctly.<sp/>Note<sp/>that<sp/>specifying<sp/>a<sp/>timeout<sp/>prevents<sp/>the</highlight></codeline>
<codeline lineno="137"><highlight class="comment"><sp/>*<sp/>driver<sp/>from<sp/>performing<sp/>a<sp/>polling<sp/>transfer<sp/>when<sp/>in<sp/>peripheral<sp/>mode.</highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/>*<sp/>#<sp/>Power<sp/>Management<sp/>#</highlight></codeline>
<codeline lineno="140"><highlight class="comment"><sp/>*<sp/>The<sp/>TI-RTOS<sp/>power<sp/>management<sp/>framework<sp/>will<sp/>try<sp/>to<sp/>put<sp/>the<sp/>device<sp/>into<sp/>the<sp/>most</highlight></codeline>
<codeline lineno="141"><highlight class="comment"><sp/>*<sp/>power<sp/>efficient<sp/>mode<sp/>whenever<sp/>possible.<sp/>Please<sp/>see<sp/>the<sp/>technical<sp/>reference</highlight></codeline>
<codeline lineno="142"><highlight class="comment"><sp/>*<sp/>manual<sp/>for<sp/>further<sp/>details<sp/>on<sp/>each<sp/>power<sp/>mode.</highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>SPICC26X2DMA.h<sp/>driver<sp/>is<sp/>setting<sp/>a<sp/>power<sp/>constraint<sp/>during<sp/>transfers<sp/>to<sp/>keep</highlight></codeline>
<codeline lineno="145"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>device<sp/>out<sp/>of<sp/>standby.<sp/>When<sp/>the<sp/>transfer<sp/>has<sp/>finished,<sp/>the<sp/>power</highlight></codeline>
<codeline lineno="146"><highlight class="comment"><sp/>*<sp/><sp/>constraint<sp/>is<sp/>released.</highlight></codeline>
<codeline lineno="147"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>following<sp/>statements<sp/>are<sp/>valid:</highlight></codeline>
<codeline lineno="148"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>-<sp/>After<sp/>SPI_open():<sp/>the<sp/>device<sp/>is<sp/>still<sp/>allowed<sp/>to<sp/>enter<sp/>standby.</highlight></codeline>
<codeline lineno="149"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>-<sp/>In<sp/>peripheral<sp/>mode:</highlight></codeline>
<codeline lineno="150"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>During<sp/>SPI_transfer():<sp/>the<sp/>device<sp/>cannot<sp/>enter<sp/>standby,<sp/>only<sp/>idle.</highlight></codeline>
<codeline lineno="151"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>After<sp/>an<sp/>RX<sp/>overflow:<sp/>device<sp/>is<sp/>allowed<sp/>to<sp/>enter<sp/>standby.</highlight></codeline>
<codeline lineno="152"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>After<sp/>a<sp/>successful<sp/>SPI_transfer():<sp/>the<sp/>device<sp/>is<sp/>allowed</highlight></codeline>
<codeline lineno="153"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to<sp/>enter<sp/>standby,<sp/>but<sp/>SPI<sp/>module<sp/>remains<sp/>enabled.</highlight></codeline>
<codeline lineno="154"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>_Note_:<sp/>In<sp/>peripheral<sp/>mode,<sp/>the<sp/>device<sp/>might<sp/>enter<sp/>standby<sp/>while<sp/>a<sp/>byte<sp/>is<sp/>being</highlight></codeline>
<codeline lineno="155"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>transferred<sp/>if<sp/>SPI_transfer()<sp/>is<sp/>not<sp/>called<sp/>again<sp/>after<sp/>a<sp/>successful</highlight></codeline>
<codeline lineno="156"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>transfer.<sp/>This<sp/>could<sp/>result<sp/>in<sp/>corrupt<sp/>data<sp/>being<sp/>transferred.</highlight></codeline>
<codeline lineno="157"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>Application<sp/>thread<sp/>should<sp/>typically<sp/>either<sp/>issue<sp/>another<sp/>transfer<sp/>after</highlight></codeline>
<codeline lineno="158"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SPI_transfer()<sp/>completes<sp/>successfully,<sp/>or<sp/>call</highlight></codeline>
<codeline lineno="159"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SPI_transferCancel()<sp/>to<sp/>disable<sp/>the<sp/>SPI<sp/>module<sp/>and<sp/>thus<sp/>assuring<sp/>that<sp/>no<sp/>data</highlight></codeline>
<codeline lineno="160"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>is<sp/>received<sp/>while<sp/>entering<sp/>standby.</highlight></codeline>
<codeline lineno="161"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.</highlight></codeline>
<codeline lineno="162"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>-<sp/>In<sp/>controller<sp/>mode:</highlight></codeline>
<codeline lineno="163"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>During<sp/>SPI_transfer():<sp/>the<sp/>device<sp/>cannot<sp/>enter<sp/>standby,<sp/>only<sp/>idle.</highlight></codeline>
<codeline lineno="164"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>After<sp/>SPI_transfer()<sp/>succeeds:<sp/>the<sp/>device<sp/>can<sp/>enter<sp/>standby.</highlight></codeline>
<codeline lineno="165"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>If<sp/>SPI_transferCancel()<sp/>is<sp/>called:<sp/>the<sp/>device<sp/>can<sp/>enter<sp/>standby.</highlight></codeline>
<codeline lineno="166"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="167"><highlight class="comment"><sp/>*<sp/><sp/>@note<sp/>The<sp/>external<sp/>hardware<sp/>connected<sp/>to<sp/>the<sp/>SPI<sp/>might<sp/>have<sp/>some<sp/>pull<sp/>configured<sp/>on<sp/>the</highlight></codeline>
<codeline lineno="168"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SPI<sp/>lines.<sp/>When<sp/>the<sp/>SPI<sp/>is<sp/>inactive,<sp/>this<sp/>might<sp/>cause<sp/>leakage<sp/>on<sp/>the<sp/>IO<sp/>and<sp/>the</highlight></codeline>
<codeline lineno="169"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>consumption<sp/>to<sp/>increase.<sp/>The<sp/>application<sp/>must<sp/>configure<sp/>a<sp/>pull<sp/>configuration</highlight></codeline>
<codeline lineno="170"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>that<sp/>aligns<sp/>with<sp/>the<sp/>external<sp/>hardware.</highlight></codeline>
<codeline lineno="171"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>See<sp/>[Ensure<sp/>low<sp/>power<sp/>during<sp/>inactive<sp/>periods]<sp/>(@ref<sp/>USE_CASE_LPWR_X2)<sp/>for<sp/>code<sp/>example.</highlight></codeline>
<codeline lineno="172"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="173"><highlight class="comment"><sp/>*<sp/><sp/>#<sp/>SPI<sp/>details<sp/>#</highlight></codeline>
<codeline lineno="174"><highlight class="comment"><sp/>*<sp/><sp/>##<sp/>Chip<sp/>Select<sp/>#</highlight></codeline>
<codeline lineno="175"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>SPI<sp/>controller<sp/>supports<sp/>a<sp/>hardware<sp/>chip<sp/>select<sp/>pin.<sp/>Refer<sp/>to<sp/>the</highlight></codeline>
<codeline lineno="176"><highlight class="comment"><sp/>*<sp/><sp/>user<sp/>manual<sp/>on<sp/>how<sp/>this<sp/>hardware<sp/>chip<sp/>select<sp/>pin<sp/>behaves<sp/>in<sp/>regards</highlight></codeline>
<codeline lineno="177"><highlight class="comment"><sp/>*<sp/><sp/>to<sp/>the<sp/>SPI<sp/>frame<sp/>format.</highlight></codeline>
<codeline lineno="178"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="179"><highlight class="comment"><sp/>*<sp/><sp/>&lt;table&gt;</highlight></codeline>
<codeline lineno="180"><highlight class="comment"><sp/>*<sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline lineno="181"><highlight class="comment"><sp/>*<sp/><sp/>&lt;th&gt;Chip<sp/>select<sp/>type&lt;/th&gt;</highlight></codeline>
<codeline lineno="182"><highlight class="comment"><sp/>*<sp/><sp/>&lt;th&gt;SPI_CONTROLLER<sp/>mode&lt;/th&gt;</highlight></codeline>
<codeline lineno="183"><highlight class="comment"><sp/>*<sp/><sp/>&lt;th&gt;SPI_PERIPHERAL<sp/>mode&lt;/th&gt;</highlight></codeline>
<codeline lineno="184"><highlight class="comment"><sp/>*<sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline lineno="185"><highlight class="comment"><sp/>*<sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline lineno="186"><highlight class="comment"><sp/>*<sp/><sp/>&lt;td&gt;Hardware<sp/>chip<sp/>select&lt;/td&gt;</highlight></codeline>
<codeline lineno="187"><highlight class="comment"><sp/>*<sp/><sp/>&lt;td&gt;No<sp/>action<sp/>is<sp/>needed<sp/>by<sp/>the<sp/>application<sp/>to<sp/>select<sp/>the<sp/>peripheral.&lt;/td&gt;</highlight></codeline>
<codeline lineno="188"><highlight class="comment"><sp/>*<sp/><sp/>&lt;td&gt;See<sp/>the<sp/>device<sp/>documentation<sp/>on<sp/>it&apos;s<sp/>chip<sp/>select<sp/>requirements.&lt;/td&gt;</highlight></codeline>
<codeline lineno="189"><highlight class="comment"><sp/>*<sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline lineno="190"><highlight class="comment"><sp/>*<sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline lineno="191"><highlight class="comment"><sp/>*<sp/><sp/>&lt;td&gt;Software<sp/>chip<sp/>select&lt;/td&gt;</highlight></codeline>
<codeline lineno="192"><highlight class="comment"><sp/>*<sp/><sp/>&lt;td&gt;The<sp/>application<sp/>is<sp/>responsible<sp/>to<sp/>ensure<sp/>that<sp/>correct<sp/>SPI<sp/>peripheral<sp/>is</highlight></codeline>
<codeline lineno="193"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>selected<sp/>before<sp/>performing<sp/>a<sp/>SPI_transfer().&lt;/td&gt;</highlight></codeline>
<codeline lineno="194"><highlight class="comment"><sp/>*<sp/><sp/>&lt;td&gt;See<sp/>the<sp/>device<sp/>documentation<sp/>on<sp/>it&apos;s<sp/>chip<sp/>select<sp/>requirements.&lt;/td&gt;</highlight></codeline>
<codeline lineno="195"><highlight class="comment"><sp/>*<sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline lineno="196"><highlight class="comment"><sp/>*<sp/><sp/>&lt;/table&gt;</highlight></codeline>
<codeline lineno="197"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="198"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Multiple<sp/>peripherals<sp/>when<sp/>operating<sp/>in<sp/>controller<sp/>mode<sp/>#</highlight></codeline>
<codeline lineno="199"><highlight class="comment"><sp/>*<sp/><sp/>In<sp/>a<sp/>scenario<sp/>where<sp/>the<sp/>SPI<sp/>module<sp/>is<sp/>operating<sp/>in<sp/>controller<sp/>mode<sp/>with<sp/>multiple</highlight></codeline>
<codeline lineno="200"><highlight class="comment"><sp/>*<sp/><sp/>SPI<sp/>peripherals,<sp/>the<sp/>chip<sp/>select<sp/>pin<sp/>can<sp/>be<sp/>reallocated<sp/>at<sp/>runtime<sp/>to<sp/>select<sp/>the</highlight></codeline>
<codeline lineno="201"><highlight class="comment"><sp/>*<sp/><sp/>appropriate<sp/>peripheral<sp/>device.<sp/>See<sp/>[Controller<sp/>Mode<sp/>With<sp/>Multiple<sp/>Peripherals](@ref<sp/>USE_CASE_MMMS_X2)<sp/>use<sp/>case<sp/>below.</highlight></codeline>
<codeline lineno="202"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>is<sp/>only<sp/>relevant<sp/>when<sp/>chip<sp/>select<sp/>is<sp/>a<sp/>hardware<sp/>chip<sp/>select.<sp/>Otherwise<sp/>the<sp/>application</highlight></codeline>
<codeline lineno="203"><highlight class="comment"><sp/>*<sp/><sp/>can<sp/>control<sp/>the<sp/>chip<sp/>select<sp/>pins<sp/>directly<sp/>using<sp/>the<sp/>GPIO<sp/>driver.</highlight></codeline>
<codeline lineno="204"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="205"><highlight class="comment"><sp/>*<sp/><sp/>##<sp/>Data<sp/>Frames<sp/>#</highlight></codeline>
<codeline lineno="206"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="207"><highlight class="comment"><sp/>*<sp/><sp/>SPI<sp/>data<sp/>frames<sp/>can<sp/>be<sp/>any<sp/>size<sp/>from<sp/>4-bits<sp/>to<sp/>16-bits.<sp/>If<sp/>the<sp/>dataSize<sp/>in</highlight></codeline>
<codeline lineno="208"><highlight class="comment"><sp/>*<sp/><sp/>#SPI_Params<sp/>is<sp/>greater<sp/>that<sp/>8-bits,<sp/>then<sp/>the<sp/>SPICC26X2DMA<sp/>driver</highlight></codeline>
<codeline lineno="209"><highlight class="comment"><sp/>*<sp/><sp/>implementation<sp/>will<sp/>assume<sp/>that<sp/>the<sp/>#SPI_Transaction<sp/>txBuf<sp/>and<sp/>rxBuf</highlight></codeline>
<codeline lineno="210"><highlight class="comment"><sp/>*<sp/><sp/>point<sp/>to<sp/>an<sp/>array<sp/>of<sp/>16-bit<sp/>uint16_t<sp/>elements.</highlight></codeline>
<codeline lineno="211"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="212"><highlight class="comment"><sp/>*<sp/><sp/>dataSize<sp/><sp/>|<sp/>buffer<sp/>element<sp/>size<sp/>|</highlight></codeline>
<codeline lineno="213"><highlight class="comment"><sp/>*<sp/><sp/>--------<sp/><sp/>|<sp/>-------------------<sp/>|</highlight></codeline>
<codeline lineno="214"><highlight class="comment"><sp/>*<sp/><sp/>4-8<sp/>bits<sp/><sp/>|<sp/>uint8_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="215"><highlight class="comment"><sp/>*<sp/><sp/>9-16<sp/>bits<sp/>|<sp/>uint16_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="216"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="217"><highlight class="comment"><sp/>*<sp/><sp/>##<sp/>Bit<sp/>Rate<sp/>##</highlight></codeline>
<codeline lineno="218"><highlight class="comment"><sp/>*<sp/><sp/>When<sp/>the<sp/>SPI<sp/>is<sp/>configured<sp/>as<sp/>SPI<sp/>peripheral,<sp/>the<sp/>maximum<sp/>bit<sp/>rate<sp/>is<sp/>4MHz.</highlight></codeline>
<codeline lineno="219"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="220"><highlight class="comment"><sp/>*<sp/><sp/>When<sp/>the<sp/>SPI<sp/>is<sp/>configured<sp/>as<sp/>SPI<sp/>controller,<sp/>the<sp/>maximum<sp/>bit<sp/>rate<sp/>is<sp/>12MHz.</highlight></codeline>
<codeline lineno="221"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="222"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="223"><highlight class="comment"><sp/>*<sp/><sp/>##<sp/>UDMA<sp/>#</highlight></codeline>
<codeline lineno="224"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Interrupts<sp/>#</highlight></codeline>
<codeline lineno="225"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UDMA<sp/>module<sp/>generates<sp/>IRQs<sp/>on<sp/>the<sp/>SPI<sp/>interrupt<sp/>vector.<sp/>This<sp/>driver<sp/>automatically</highlight></codeline>
<codeline lineno="226"><highlight class="comment"><sp/>*<sp/><sp/>installs<sp/>a<sp/>UDMA<sp/>aware<sp/>Hwi<sp/>(interrupt)<sp/>to<sp/>service<sp/>the<sp/>assigned<sp/>UDMA<sp/>channels.</highlight></codeline>
<codeline lineno="227"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="228"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Transfer<sp/>Size<sp/>Limit<sp/>#</highlight></codeline>
<codeline lineno="229"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="230"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>UDMA<sp/>controller<sp/>only<sp/>supports<sp/>data<sp/>transfers<sp/>of<sp/>up<sp/>to<sp/>1024<sp/>data<sp/>frames.</highlight></codeline>
<codeline lineno="231"><highlight class="comment"><sp/>*<sp/><sp/>A<sp/>transfer<sp/>with<sp/>more<sp/>than<sp/>1024<sp/>frames<sp/>will<sp/>be<sp/>transmitted/received<sp/>in</highlight></codeline>
<codeline lineno="232"><highlight class="comment"><sp/>*<sp/><sp/>multiple<sp/>1024<sp/>sized<sp/>portions<sp/>until<sp/>all<sp/>data<sp/>has<sp/>been<sp/>transmitted/received.</highlight></codeline>
<codeline lineno="233"><highlight class="comment"><sp/>*<sp/><sp/>A<sp/>data<sp/>frame<sp/>can<sp/>be<sp/>4<sp/>to<sp/>16<sp/>bits<sp/>in<sp/>length.</highlight></codeline>
<codeline lineno="234"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="235"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Scratch<sp/>Buffers<sp/>#</highlight></codeline>
<codeline lineno="236"><highlight class="comment"><sp/>*<sp/><sp/>A<sp/>uint16_t<sp/>scratch<sp/>buffer<sp/>is<sp/>used<sp/>to<sp/>allow<sp/>SPI_transfers<sp/>where<sp/>txBuf<sp/>or<sp/>rxBuf</highlight></codeline>
<codeline lineno="237"><highlight class="comment"><sp/>*<sp/><sp/>are<sp/>NULL.<sp/>Rather<sp/>than<sp/>requiring<sp/>txBuf<sp/>or<sp/>rxBuf<sp/>to<sp/>have<sp/>a<sp/>dummy<sp/>buffer<sp/>of<sp/>size</highlight></codeline>
<codeline lineno="238"><highlight class="comment"><sp/>*<sp/><sp/>of<sp/>the<sp/>transfer<sp/>count,<sp/>a<sp/>single-word<sp/>UDMA<sp/>accessible<sp/>uint16_t<sp/>scratch<sp/>buffer<sp/>is<sp/>used.</highlight></codeline>
<codeline lineno="239"><highlight class="comment"><sp/>*<sp/><sp/>When<sp/>rxBuf<sp/>is<sp/>NULL,<sp/>the<sp/>UDMA<sp/>will<sp/>transfer<sp/>all<sp/>the<sp/>received<sp/>SPI<sp/>data<sp/>into<sp/>the</highlight></codeline>
<codeline lineno="240"><highlight class="comment"><sp/>*<sp/><sp/>scratch<sp/>buffer<sp/>as<sp/>a<sp/>&quot;bit-bucket&quot;.</highlight></codeline>
<codeline lineno="241"><highlight class="comment"><sp/>*<sp/><sp/>When<sp/>txBuf<sp/>is<sp/>NULL,<sp/>the<sp/>scratch<sp/>buffer<sp/>is<sp/>initialized<sp/>to<sp/>defaultTxBufValue</highlight></codeline>
<codeline lineno="242"><highlight class="comment"><sp/>*<sp/><sp/>so<sp/>the<sp/>uDMA<sp/>will<sp/>send<sp/>some<sp/>known<sp/>value.</highlight></codeline>
<codeline lineno="243"><highlight class="comment"><sp/>*<sp/><sp/>Each<sp/>SPI<sp/>driver<sp/>instance<sp/>uses<sp/>its<sp/>own<sp/>scratch<sp/>buffer.</highlight></codeline>
<codeline lineno="244"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="245"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>TX<sp/>and<sp/>RX<sp/>buffers<sp/>#</highlight></codeline>
<codeline lineno="246"><highlight class="comment"><sp/>*<sp/><sp/>Before<sp/>SPI_transfer,<sp/>txBuf<sp/>should<sp/>be<sp/>filled<sp/>with<sp/>the<sp/>outgoing<sp/>SPI<sp/>data.<sp/>These</highlight></codeline>
<codeline lineno="247"><highlight class="comment"><sp/>*<sp/><sp/>data<sp/>are<sp/>sent<sp/>out<sp/>during<sp/>the<sp/>transfer,<sp/>while<sp/>the<sp/>incoming<sp/>data<sp/>are<sp/>received</highlight></codeline>
<codeline lineno="248"><highlight class="comment"><sp/>*<sp/><sp/>into<sp/>rxBuf.<sp/>To<sp/>save<sp/>memory<sp/>space,<sp/>txBuf<sp/>and<sp/>rxBuf<sp/>can<sp/>be<sp/>assigned<sp/>to<sp/>the<sp/>same</highlight></codeline>
<codeline lineno="249"><highlight class="comment"><sp/>*<sp/><sp/>buffer<sp/>location.<sp/>At<sp/>the<sp/>beginning<sp/>of<sp/>the<sp/>transfer,<sp/>this<sp/>buffer<sp/>holds<sp/>outgoing</highlight></codeline>
<codeline lineno="250"><highlight class="comment"><sp/>*<sp/><sp/>data.<sp/>At<sp/>the<sp/>end<sp/>of<sp/>the<sp/>transfer,<sp/>the<sp/>outgoing<sp/>data<sp/>are<sp/>overwritten<sp/>and</highlight></codeline>
<codeline lineno="251"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>buffer<sp/>holds<sp/>the<sp/>received<sp/>SPI<sp/>data.</highlight></codeline>
<codeline lineno="252"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="253"><highlight class="comment"><sp/>*<sp/><sp/>##<sp/>Polling<sp/>SPI<sp/>transfers<sp/>#</highlight></codeline>
<codeline lineno="254"><highlight class="comment"><sp/>*<sp/><sp/>When<sp/>used<sp/>in<sp/>blocking<sp/>mode<sp/>small<sp/>SPI<sp/>transfers<sp/>are<sp/>can<sp/>be<sp/>done<sp/>by<sp/>polling</highlight></codeline>
<codeline lineno="255"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>peripheral<sp/>&amp;<sp/>sending<sp/>data<sp/>frame-by-frame.<sp/>A<sp/>controller<sp/>device<sp/>can<sp/>perform</highlight></codeline>
<codeline lineno="256"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>transfer<sp/>immediately<sp/>and<sp/>return,<sp/>but<sp/>a<sp/>peripheral<sp/>will<sp/>block<sp/>until<sp/>it</highlight></codeline>
<codeline lineno="257"><highlight class="comment"><sp/>*<sp/><sp/>receives<sp/>the<sp/>number<sp/>of<sp/>frames<sp/>specified<sp/>in<sp/>the<sp/>SPI_Transfer()<sp/>call.</highlight></codeline>
<codeline lineno="258"><highlight class="comment"><sp/>*<sp/><sp/>The<sp/>minDmaTransferSize<sp/>field<sp/>in<sp/>the<sp/>hardware<sp/>attributes<sp/>is</highlight></codeline>
<codeline lineno="259"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>threshold;<sp/>if<sp/>the<sp/>transaction<sp/>count<sp/>is<sp/>below<sp/>the<sp/>threshold<sp/>a<sp/>polling</highlight></codeline>
<codeline lineno="260"><highlight class="comment"><sp/>*<sp/><sp/>transfer<sp/>is<sp/>performed;<sp/>otherwise<sp/>a<sp/>DMA<sp/>transfer<sp/>is<sp/>done.<sp/><sp/>This<sp/>is<sp/>intended</highlight></codeline>
<codeline lineno="261"><highlight class="comment"><sp/>*<sp/><sp/>to<sp/>reduce<sp/>the<sp/>overhead<sp/>of<sp/>setting<sp/>up<sp/>a<sp/>DMA<sp/>transfer<sp/>to<sp/>only<sp/>send<sp/>a<sp/>few</highlight></codeline>
<codeline lineno="262"><highlight class="comment"><sp/>*<sp/><sp/>data<sp/>frames.</highlight></codeline>
<codeline lineno="263"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="264"><highlight class="comment"><sp/>*<sp/><sp/>Notes:</highlight></codeline>
<codeline lineno="265"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>Specifying<sp/>a<sp/>timeout<sp/>prevents<sp/>peripheral<sp/>devices<sp/>from<sp/>using<sp/>polling<sp/>transfers.</highlight></codeline>
<codeline lineno="266"><highlight class="comment"><sp/>*<sp/><sp/>-<sp/>Keep<sp/>in<sp/>mind<sp/>that<sp/>during<sp/>polling<sp/>transfers<sp/>the<sp/>current<sp/>task</highlight></codeline>
<codeline lineno="267"><highlight class="comment"><sp/>*<sp/><sp/>is<sp/>still<sp/>being<sp/>executed;<sp/>there<sp/>is<sp/>no<sp/>context<sp/>switch<sp/>to<sp/>another<sp/>task.</highlight></codeline>
<codeline lineno="268"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="269"><highlight class="comment"><sp/>*<sp/>#<sp/>Supported<sp/>Functions<sp/>#</highlight></codeline>
<codeline lineno="270"><highlight class="comment"><sp/>*<sp/><sp/>Generic<sp/>API<sp/>function<sp/><sp/>|<sp/>API<sp/>function<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Description</highlight></codeline>
<codeline lineno="271"><highlight class="comment"><sp/>*<sp/><sp/>----------------------|-------------------------------<sp/>|-------------------------------------------------------------</highlight></codeline>
<codeline lineno="272"><highlight class="comment"><sp/>*<sp/><sp/>SPI_init()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>SPICC26X2DMA_init()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Initialize<sp/>SPI<sp/>driver</highlight></codeline>
<codeline lineno="273"><highlight class="comment"><sp/>*<sp/><sp/>SPI_open()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>SPICC26X2DMA_open()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Initialize<sp/>SPI<sp/>HW<sp/>and<sp/>set<sp/>system<sp/>dependencies</highlight></codeline>
<codeline lineno="274"><highlight class="comment"><sp/>*<sp/><sp/>SPI_close()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>SPICC26X2DMA_close()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Disable<sp/>SPI<sp/>and<sp/>UDMA<sp/>HW<sp/>and<sp/>release<sp/>system<sp/>dependencies</highlight></codeline>
<codeline lineno="275"><highlight class="comment"><sp/>*<sp/><sp/>SPI_control()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>SPICC26X2DMA_control()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Configure<sp/>an<sp/>already<sp/>opened<sp/>SPI<sp/>handle</highlight></codeline>
<codeline lineno="276"><highlight class="comment"><sp/>*<sp/><sp/>SPI_transfer()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>SPICC26X2DMA_transfer()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Start<sp/>transfer<sp/>from<sp/>SPI</highlight></codeline>
<codeline lineno="277"><highlight class="comment"><sp/>*<sp/><sp/>SPI_transferCancel()<sp/><sp/>|<sp/>SPICC26X2DMA_transferCancel()<sp/><sp/>|<sp/>Cancel<sp/>ongoing<sp/>transfer<sp/>from<sp/>SPI</highlight></codeline>
<codeline lineno="278"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="279"><highlight class="comment"><sp/>*<sp/><sp/>@note<sp/>All<sp/>calls<sp/>should<sp/>go<sp/>through<sp/>the<sp/>generic<sp/>API</highlight></codeline>
<codeline lineno="280"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="281"><highlight class="comment"><sp/>*<sp/>##<sp/>Use<sp/>Cases<sp/>@anchor<sp/>USE_CASES_SPI_X2<sp/>##</highlight></codeline>
<codeline lineno="282"><highlight class="comment"><sp/>*<sp/>###<sp/>Basic<sp/>Peripheral<sp/>Mode<sp/>#</highlight></codeline>
<codeline lineno="283"><highlight class="comment"><sp/>*<sp/><sp/>Receive<sp/>100<sp/>bytes<sp/>over<sp/>SPI<sp/>in<sp/>#SPI_MODE_BLOCKING.</highlight></codeline>
<codeline lineno="284"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="285"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Handle<sp/>handle;</highlight></codeline>
<codeline lineno="286"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline lineno="287"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline lineno="288"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>rxBuf[100];<sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>buffer</highlight></codeline>
<codeline lineno="289"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="290"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline lineno="291"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline lineno="292"><highlight class="comment"><sp/>*<sp/><sp/>params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline lineno="293"><highlight class="comment"><sp/>*<sp/><sp/>params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline lineno="294"><highlight class="comment"><sp/>*<sp/><sp/>params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline lineno="295"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="296"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline lineno="297"><highlight class="comment"><sp/>*<sp/><sp/>transaction.count<sp/>=<sp/>100;</highlight></codeline>
<codeline lineno="298"><highlight class="comment"><sp/>*<sp/><sp/>transaction.txBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="299"><highlight class="comment"><sp/>*<sp/><sp/>transaction.rxBuf<sp/>=<sp/>rxBuf;</highlight></codeline>
<codeline lineno="300"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="301"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>perform<sp/>the<sp/>transfer</highlight></codeline>
<codeline lineno="302"><highlight class="comment"><sp/>*<sp/><sp/>handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline lineno="303"><highlight class="comment"><sp/>*<sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline lineno="304"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="305"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="306"><highlight class="comment"><sp/>*<sp/>###<sp/>Peripheral<sp/>Mode<sp/>With<sp/>Return<sp/>Partial<sp/>@anchor<sp/>USE_CASE_RP_X2<sp/>#</highlight></codeline>
<codeline lineno="307"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>use<sp/>case<sp/>will<sp/>perform<sp/>a<sp/>transfer<sp/>in<sp/>#SPI_MODE_BLOCKING<sp/>until<sp/>the<sp/>wanted</highlight></codeline>
<codeline lineno="308"><highlight class="comment"><sp/>*<sp/><sp/>amount<sp/>of<sp/>bytes<sp/>is<sp/>transferred<sp/>or<sp/>until<sp/>chip<sp/>select<sp/>is<sp/>deasserted<sp/>by<sp/>the<sp/>SPI</highlight></codeline>
<codeline lineno="309"><highlight class="comment"><sp/>*<sp/><sp/>controller.</highlight></codeline>
<codeline lineno="310"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>SPI_transfer()<sp/>call<sp/>can<sp/>be<sp/>used<sp/>when<sp/>unknown<sp/>amount<sp/>of<sp/>bytes<sp/>shall</highlight></codeline>
<codeline lineno="311"><highlight class="comment"><sp/>*<sp/><sp/>be<sp/>transferred.</highlight></codeline>
<codeline lineno="312"><highlight class="comment"><sp/>*<sp/><sp/>&lt;br&gt;<sp/>Note:<sp/>Partial<sp/>return<sp/>is<sp/>also<sp/>possible<sp/>in<sp/>#SPI_MODE_CALLBACK<sp/>mode.</highlight></codeline>
<codeline lineno="313"><highlight class="comment"><sp/>*<sp/><sp/>In<sp/>callback<sp/>mode,<sp/>partial<sp/>transfers<sp/>can<sp/>be<sp/>queued<sp/>by<sp/>calling<sp/>SPI_transfer()</highlight></codeline>
<codeline lineno="314"><highlight class="comment"><sp/>*<sp/><sp/>multiple<sp/>times.</highlight></codeline>
<codeline lineno="315"><highlight class="comment"><sp/>*<sp/><sp/>&lt;br&gt;<sp/>Note:<sp/>Polling<sp/>transfers<sp/>are<sp/>not<sp/>available<sp/>when<sp/>using<sp/>return<sp/>partial<sp/>mode.</highlight></codeline>
<codeline lineno="316"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="317"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Handle<sp/>handle;</highlight></codeline>
<codeline lineno="318"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline lineno="319"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline lineno="320"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>rxBuf[100];<sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>buffer</highlight></codeline>
<codeline lineno="321"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="322"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline lineno="323"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline lineno="324"><highlight class="comment"><sp/>*<sp/><sp/>params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline lineno="325"><highlight class="comment"><sp/>*<sp/><sp/>params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline lineno="326"><highlight class="comment"><sp/>*<sp/><sp/>params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline lineno="327"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="328"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline lineno="329"><highlight class="comment"><sp/>*<sp/><sp/>transaction.count<sp/>=<sp/>100;</highlight></codeline>
<codeline lineno="330"><highlight class="comment"><sp/>*<sp/><sp/>transaction.txBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="331"><highlight class="comment"><sp/>*<sp/><sp/>transaction.rxBuf<sp/>=<sp/>rxBuf;</highlight></codeline>
<codeline lineno="332"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="333"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>initiate<sp/>the<sp/>partial<sp/>read</highlight></codeline>
<codeline lineno="334"><highlight class="comment"><sp/>*<sp/><sp/>handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline lineno="335"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="336"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Enable<sp/>RETURN_PARTIAL</highlight></codeline>
<codeline lineno="337"><highlight class="comment"><sp/>*<sp/><sp/>SPI_control(handle,<sp/>SPICC26X2DMA_RETURN_PARTIAL_ENABLE,<sp/>NULL);</highlight></codeline>
<codeline lineno="338"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="339"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Begin<sp/>transfer</highlight></codeline>
<codeline lineno="340"><highlight class="comment"><sp/>*<sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline lineno="341"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="342"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="343"><highlight class="comment"><sp/>*<sp/>###<sp/>Continuous<sp/>Peripheral<sp/>Transfer<sp/>In<sp/>#SPI_MODE_CALLBACK<sp/>@anchor<sp/>USE_CASE_CST_X2<sp/>#</highlight></codeline>
<codeline lineno="344"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>use<sp/>case<sp/>will<sp/>configure<sp/>the<sp/>SPI<sp/>driver<sp/>to<sp/>transfer<sp/>continuously<sp/>in</highlight></codeline>
<codeline lineno="345"><highlight class="comment"><sp/>*<sp/><sp/>#SPI_MODE_CALLBACK,<sp/>16<sp/>bytes<sp/>at<sp/>the<sp/>time<sp/>and<sp/>echoing<sp/>received<sp/>data<sp/>after<sp/>every</highlight></codeline>
<codeline lineno="346"><highlight class="comment"><sp/>*<sp/><sp/>16<sp/>bytes.</highlight></codeline>
<codeline lineno="347"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="348"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Callback<sp/>function</highlight></codeline>
<codeline lineno="349"><highlight class="comment"><sp/>*<sp/><sp/>static<sp/>void<sp/>transferCallback(SPI_Handle<sp/>handle,<sp/>SPI_Transaction<sp/>*transaction)</highlight></codeline>
<codeline lineno="350"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="351"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Start<sp/>another<sp/>transfer</highlight></codeline>
<codeline lineno="352"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>transaction);</highlight></codeline>
<codeline lineno="353"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="354"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="355"><highlight class="comment"><sp/>*<sp/><sp/>static<sp/>void<sp/>taskFxn(uintptr_t<sp/>a0,<sp/>uintptr_t<sp/>a1)</highlight></codeline>
<codeline lineno="356"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="357"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Handle<sp/>handle;</highlight></codeline>
<codeline lineno="358"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline lineno="359"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline lineno="360"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>uint8_t<sp/>buf[16];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>and<sp/>transmit<sp/>buffer</highlight></codeline>
<codeline lineno="361"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="362"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline lineno="363"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline lineno="364"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>params.bitRate<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline lineno="365"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>params.frameFormat<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline lineno="366"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline lineno="367"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>params.transferMode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_MODE_CALLBACK;</highlight></codeline>
<codeline lineno="368"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>params.transferCallbackFxn<sp/>=<sp/>transferCallback;</highlight></codeline>
<codeline lineno="369"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="370"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline lineno="371"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>transaction.count<sp/>=<sp/>16;</highlight></codeline>
<codeline lineno="372"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>transaction.txBuf<sp/>=<sp/>buf;</highlight></codeline>
<codeline lineno="373"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>transaction.rxBuf<sp/>=<sp/>buf;</highlight></codeline>
<codeline lineno="374"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="375"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>initiate<sp/>the<sp/>first<sp/>transfer</highlight></codeline>
<codeline lineno="376"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline lineno="377"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline lineno="378"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="379"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Wait<sp/>forever</highlight></codeline>
<codeline lineno="380"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>while(true);</highlight></codeline>
<codeline lineno="381"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="382"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="383"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="384"><highlight class="comment"><sp/>*<sp/>###<sp/>Basic<sp/>Controller<sp/>Mode<sp/>#</highlight></codeline>
<codeline lineno="385"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>use<sp/>case<sp/>will<sp/>configure<sp/>a<sp/>SPI<sp/>controller<sp/>to<sp/>send<sp/>the<sp/>data<sp/>in<sp/>txBuf<sp/>while<sp/>receiving<sp/>data<sp/>to<sp/>rxBuf<sp/>in</highlight></codeline>
<codeline lineno="386"><highlight class="comment"><sp/>*<sp/><sp/>BLOCKING_MODE.</highlight></codeline>
<codeline lineno="387"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="388"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Handle<sp/>handle;</highlight></codeline>
<codeline lineno="389"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline lineno="390"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline lineno="391"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>txBuf[]<sp/>=<sp/>&quot;Hello<sp/>World&quot;;<sp/><sp/><sp/><sp/>//<sp/>Transmit<sp/>buffer</highlight></codeline>
<codeline lineno="392"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>rxBuf[11];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>buffer</highlight></codeline>
<codeline lineno="393"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="394"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline lineno="395"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline lineno="396"><highlight class="comment"><sp/>*<sp/><sp/>params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline lineno="397"><highlight class="comment"><sp/>*<sp/><sp/>params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline lineno="398"><highlight class="comment"><sp/>*<sp/><sp/>params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_CONTROLLER;</highlight></codeline>
<codeline lineno="399"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="400"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline lineno="401"><highlight class="comment"><sp/>*<sp/><sp/>transaction.count<sp/>=<sp/>sizeof(txBuf);</highlight></codeline>
<codeline lineno="402"><highlight class="comment"><sp/>*<sp/><sp/>transaction.txBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline lineno="403"><highlight class="comment"><sp/>*<sp/><sp/>transaction.rxBuf<sp/>=<sp/>rxBuf;</highlight></codeline>
<codeline lineno="404"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="405"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>perform<sp/>the<sp/>transfer</highlight></codeline>
<codeline lineno="406"><highlight class="comment"><sp/>*<sp/><sp/>handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline lineno="407"><highlight class="comment"><sp/>*<sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline lineno="408"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="409"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="410"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Controller<sp/>Mode<sp/>With<sp/>Multiple<sp/>Peripherals<sp/>@anchor<sp/>USE_CASE_MMMS_X2<sp/>#</highlight></codeline>
<codeline lineno="411"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>use<sp/>case<sp/>will<sp/>configure<sp/>a<sp/>SPI<sp/>controller<sp/>to<sp/>send<sp/>data<sp/>to<sp/>one<sp/>peripheral<sp/>and<sp/>then<sp/>to<sp/>another<sp/>in</highlight></codeline>
<codeline lineno="412"><highlight class="comment"><sp/>*<sp/><sp/>BLOCKING_MODE.<sp/>It<sp/>is<sp/>assumed<sp/>that<sp/>the<sp/>board<sp/>file<sp/>is<sp/>configured<sp/>so<sp/>that<sp/>the<sp/>two<sp/>chip<sp/>select</highlight></codeline>
<codeline lineno="413"><highlight class="comment"><sp/>*<sp/><sp/>pins<sp/>have<sp/>a<sp/>default<sp/>setting<sp/>of<sp/>a<sp/>high<sp/>output<sp/>and<sp/>that<sp/>the<sp/>#SPICC26X2DMA_HWAttrs<sp/>used<sp/>points</highlight></codeline>
<codeline lineno="414"><highlight class="comment"><sp/>*<sp/><sp/>to<sp/>one<sp/>of<sp/>them<sp/>since<sp/>the<sp/>SPI<sp/>driver<sp/>will<sp/>revert<sp/>to<sp/>this<sp/>default<sp/>setting<sp/>when<sp/>switching<sp/>the</highlight></codeline>
<codeline lineno="415"><highlight class="comment"><sp/>*<sp/><sp/>chip<sp/>select<sp/>pin.</highlight></codeline>
<codeline lineno="416"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="417"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="418"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>From<sp/>ti_drivers_config.c</highlight></codeline>
<codeline lineno="419"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Use<sp/>the<sp/>sysconfig<sp/>settings<sp/>to<sp/>make<sp/>sure<sp/>both<sp/>pins<sp/>are<sp/>set<sp/>to<sp/>HIGH<sp/>when<sp/>not<sp/>in<sp/>use</highlight></codeline>
<codeline lineno="420"><highlight class="comment"><sp/>*<sp/><sp/>GPIO_PinConfig<sp/>gpioPinConfigs[31]<sp/>=<sp/>{</highlight></codeline>
<codeline lineno="421"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline lineno="422"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>GPIO_CFG_OUT_STD<sp/>|<sp/>GPIO_CFG_OUT_HIGH,<sp/>//<sp/>CONFIG_CSN_0</highlight></codeline>
<codeline lineno="423"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline lineno="424"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>GPIO_CFG_OUT_STD<sp/>|<sp/>GPIO_CFG_OUT_HIGH,<sp/>//<sp/>CONFIG_CSN_1</highlight></codeline>
<codeline lineno="425"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="426"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="427"><highlight class="comment"><sp/>*<sp/><sp/>const<sp/>SPICC26X2DMA_HWAttrs<sp/>SPICC26X2DMAHWAttrs[CC2650_SPICOUNT]<sp/>=<sp/>{</highlight></codeline>
<codeline lineno="428"><highlight class="comment"><sp/>*<sp/><sp/>{<sp/><sp/><sp/>//<sp/>Use<sp/>SPI0<sp/>module<sp/>with<sp/>default<sp/>chip<sp/>select<sp/>on<sp/>CONFIG_CSN_0</highlight></codeline>
<codeline lineno="429"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.baseAddr<sp/>=<sp/>SSI0_BASE,</highlight></codeline>
<codeline lineno="430"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.intNum<sp/>=<sp/>INT_SSI0,</highlight></codeline>
<codeline lineno="431"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.intPriority<sp/>=<sp/>~0,</highlight></codeline>
<codeline lineno="432"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.swiPriority<sp/>=<sp/>0,</highlight></codeline>
<codeline lineno="433"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.defaultTxBufValue<sp/>=<sp/>0,</highlight></codeline>
<codeline lineno="434"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.powerMngrId<sp/>=<sp/>PERIPH_SSI0,</highlight></codeline>
<codeline lineno="435"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.rxChannelIndex<sp/>=<sp/>UDMA_CHAN_SSI0_RX,</highlight></codeline>
<codeline lineno="436"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.txChannelIndex<sp/>=<sp/>UDMA_CHAN_SSI0_TX,</highlight></codeline>
<codeline lineno="437"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.picoPin<sp/>=<sp/>CONFIG_SPI0_PICO,</highlight></codeline>
<codeline lineno="438"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.pociPin<sp/>=<sp/>CONFIG_SPI0_POCI,</highlight></codeline>
<codeline lineno="439"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.clkPin<sp/>=<sp/>CONFIG_SPI0_CLK,</highlight></codeline>
<codeline lineno="440"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>.csnPin<sp/>=<sp/>CONFIG_CSN_0</highlight></codeline>
<codeline lineno="441"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="442"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="443"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>From<sp/>your_application.c</highlight></codeline>
<codeline lineno="444"><highlight class="comment"><sp/>*<sp/><sp/>static<sp/>void<sp/>taskFxn(uintptr_t<sp/>a0,<sp/>uintptr_t<sp/>a1)</highlight></codeline>
<codeline lineno="445"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="446"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Handle<sp/>handle;</highlight></codeline>
<codeline lineno="447"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline lineno="448"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline lineno="449"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>uint_least8_t<sp/>csnPin1<sp/>=<sp/>CONFIG_CSN_1;</highlight></codeline>
<codeline lineno="450"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>uint8_t<sp/>txBuf[]<sp/>=<sp/>&quot;Hello<sp/>World&quot;;<sp/><sp/><sp/><sp/>//<sp/>Transmit<sp/>buffer</highlight></codeline>
<codeline lineno="451"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="452"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline lineno="453"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline lineno="454"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline lineno="455"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline lineno="456"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_CONTROLLER;</highlight></codeline>
<codeline lineno="457"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="458"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline lineno="459"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>transaction.count<sp/>=<sp/>sizeof(txBuf);</highlight></codeline>
<codeline lineno="460"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>transaction.txBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline lineno="461"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>transaction.rxBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="462"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="463"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>perform<sp/>transfer<sp/>to<sp/>the<sp/>first<sp/>peripheral</highlight></codeline>
<codeline lineno="464"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline lineno="465"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline lineno="466"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="467"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Then<sp/>switch<sp/>chip<sp/>select<sp/>pin<sp/>and<sp/>perform<sp/>transfer<sp/>to<sp/>the<sp/>second<sp/>peripheral</highlight></codeline>
<codeline lineno="468"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_control(handle,<sp/>SPICC26X2DMA_SET_CSN_PIN,<sp/>&amp;csnPin1);</highlight></codeline>
<codeline lineno="469"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline lineno="470"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="471"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="472"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="473"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Queueing<sp/>Transactions<sp/>in<sp/>Callback<sp/>Mode<sp/>#</highlight></codeline>
<codeline lineno="474"><highlight class="comment"><sp/>*<sp/><sp/>@anchor<sp/>USE_CASE_QUEUE</highlight></codeline>
<codeline lineno="475"><highlight class="comment"><sp/>*<sp/><sp/>Below<sp/>is<sp/>an<sp/>example<sp/>of<sp/>queueing<sp/>three<sp/>transactions</highlight></codeline>
<codeline lineno="476"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="477"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>SPI<sp/>already<sp/>opened<sp/>in<sp/>callback<sp/>mode</highlight></codeline>
<codeline lineno="478"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Transaction<sp/>t0,<sp/>t1,<sp/>t2;</highlight></codeline>
<codeline lineno="479"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="480"><highlight class="comment"><sp/>*<sp/><sp/>t0.txBuf<sp/>=<sp/>txBuff0;</highlight></codeline>
<codeline lineno="481"><highlight class="comment"><sp/>*<sp/><sp/>t0.rxBuf<sp/>=<sp/>rxBuff0;</highlight></codeline>
<codeline lineno="482"><highlight class="comment"><sp/>*<sp/><sp/>t0.count<sp/>=<sp/>2000;</highlight></codeline>
<codeline lineno="483"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="484"><highlight class="comment"><sp/>*<sp/><sp/>t1.txBuf<sp/>=<sp/>txBuff1;</highlight></codeline>
<codeline lineno="485"><highlight class="comment"><sp/>*<sp/><sp/>t1.rxBuf<sp/>=<sp/>rxBuff1;</highlight></codeline>
<codeline lineno="486"><highlight class="comment"><sp/>*<sp/><sp/>t1.count<sp/>=<sp/>1000;</highlight></codeline>
<codeline lineno="487"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="488"><highlight class="comment"><sp/>*<sp/><sp/>t2.txBuf<sp/>=<sp/>txBuff2;</highlight></codeline>
<codeline lineno="489"><highlight class="comment"><sp/>*<sp/><sp/>t2.rxBuf<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="490"><highlight class="comment"><sp/>*<sp/><sp/>t2.count<sp/>=<sp/>1000;</highlight></codeline>
<codeline lineno="491"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="492"><highlight class="comment"><sp/>*<sp/><sp/>bool<sp/>transferOk<sp/>=<sp/>false;</highlight></codeline>
<codeline lineno="493"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="494"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(SPI_transfer(spiHandle,<sp/>&amp;t0))<sp/>{</highlight></codeline>
<codeline lineno="495"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(SPI_transfer(spiHandle,<sp/>&amp;t1))<sp/>{</highlight></codeline>
<codeline lineno="496"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>transferOk<sp/>=<sp/>SPI_transfer(spiHandle,<sp/>&amp;t2);</highlight></codeline>
<codeline lineno="497"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="498"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="499"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="500"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="501"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="502"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Queueing<sp/>in<sp/>Manual<sp/>Start<sp/>Mode#</highlight></codeline>
<codeline lineno="503"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>example<sp/>shows<sp/>a<sp/>peripheral<sp/>device<sp/>queueing<sp/>two<sp/>transactions<sp/>that<sp/>will</highlight></codeline>
<codeline lineno="504"><highlight class="comment"><sp/>*<sp/><sp/>complete<sp/>one<sp/>after<sp/>the<sp/>other.<sp/>From<sp/>the<sp/>controller&apos;s<sp/>perspective<sp/>there<sp/>will<sp/>be</highlight></codeline>
<codeline lineno="505"><highlight class="comment"><sp/>*<sp/><sp/>one<sp/>long<sp/>transfer.</highlight></codeline>
<codeline lineno="506"><highlight class="comment"><sp/>*<sp/><sp/>@note<sp/>Manual<sp/>mode<sp/>also<sp/>works<sp/>while<sp/>the<sp/>device<sp/>is<sp/>in<sp/>#SPI_CONTROLLER<sp/>mode.<sp/>The</highlight></codeline>
<codeline lineno="507"><highlight class="comment"><sp/>*<sp/><sp/>control<sp/>call<sp/>to<sp/>MANUAL_START<sp/>will<sp/>start<sp/>the<sp/>transfers.</highlight></codeline>
<codeline lineno="508"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="509"><highlight class="comment"><sp/>*<sp/><sp/>@warning<sp/>Manual<sp/>start<sp/>mode<sp/>should<sp/>not<sp/>be<sp/>enabled<sp/>or<sp/>disabled<sp/>while<sp/>a</highlight></codeline>
<codeline lineno="510"><highlight class="comment"><sp/>*<sp/><sp/>transaction<sp/>is<sp/>in<sp/>progress.</highlight></codeline>
<codeline lineno="511"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="512"><highlight class="comment"><sp/>*<sp/><sp/>@anchor<sp/>USE_CASE_MANUAL_START</highlight></codeline>
<codeline lineno="513"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="514"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Handle<sp/>spi;</highlight></codeline>
<codeline lineno="515"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline lineno="516"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Transaction<sp/>t0,<sp/>t1;</highlight></codeline>
<codeline lineno="517"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>status<sp/>=<sp/>SPI_STATUS_SUCCESS;</highlight></codeline>
<codeline lineno="518"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="519"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline lineno="520"><highlight class="comment"><sp/>*<sp/><sp/>params.mode<sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline lineno="521"><highlight class="comment"><sp/>*<sp/><sp/>spi<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;params);</highlight></codeline>
<codeline lineno="522"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="523"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(spi<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="524"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>exit(0);</highlight></codeline>
<codeline lineno="525"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="526"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="527"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Enable<sp/>manual<sp/>start<sp/>mode</highlight></codeline>
<codeline lineno="528"><highlight class="comment"><sp/>*<sp/><sp/>SPI_control(spi,<sp/>SPICC26X2DMA_CMD_SET_MANUAL,<sp/>NULL);</highlight></codeline>
<codeline lineno="529"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="530"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Queue<sp/>transactions</highlight></codeline>
<codeline lineno="531"><highlight class="comment"><sp/>*<sp/><sp/>t0.txBuf<sp/>=<sp/>txBuff0;</highlight></codeline>
<codeline lineno="532"><highlight class="comment"><sp/>*<sp/><sp/>t0.rxBuf<sp/>=<sp/>rxBuff0;</highlight></codeline>
<codeline lineno="533"><highlight class="comment"><sp/>*<sp/><sp/>t0.count<sp/>=<sp/>2000;</highlight></codeline>
<codeline lineno="534"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(!SPI_transfer(spi,<sp/>&amp;t0))<sp/>{</highlight></codeline>
<codeline lineno="535"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>status<sp/>=<sp/>SPI_STATUS_FAIL;</highlight></codeline>
<codeline lineno="536"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="537"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="538"><highlight class="comment"><sp/>*<sp/><sp/>t1.txBuf<sp/>=<sp/>txBuff1;</highlight></codeline>
<codeline lineno="539"><highlight class="comment"><sp/>*<sp/><sp/>t1.rxBuf<sp/>=<sp/>rxBuff1;</highlight></codeline>
<codeline lineno="540"><highlight class="comment"><sp/>*<sp/><sp/>t1.count<sp/>=<sp/>1000;</highlight></codeline>
<codeline lineno="541"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(!SPI_transfer(spi,<sp/>&amp;t1))<sp/>{</highlight></codeline>
<codeline lineno="542"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>status<sp/>=<sp/>SPI_STATUS_FAIL;</highlight></codeline>
<codeline lineno="543"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="544"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="545"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Enable<sp/>the<sp/>transfers</highlight></codeline>
<codeline lineno="546"><highlight class="comment"><sp/>*<sp/><sp/>if<sp/>(status<sp/>==<sp/>SPI_STATUS_SUCCESS)<sp/>{</highlight></codeline>
<codeline lineno="547"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_control(spi,<sp/>SPICC26X2DMA_CMD_MANUAL_START,<sp/>NULL);</highlight></codeline>
<codeline lineno="548"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="549"><highlight class="comment"><sp/>*<sp/><sp/>else<sp/>{</highlight></codeline>
<codeline lineno="550"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>status<sp/>=<sp/>SPI_STATUS_FAILURE;</highlight></codeline>
<codeline lineno="551"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="552"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="553"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>At<sp/>this<sp/>point<sp/>the<sp/>peripheral<sp/>is<sp/>ready<sp/>for<sp/>the<sp/>controller<sp/>to<sp/>start<sp/>the<sp/>transfer</highlight></codeline>
<codeline lineno="554"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Assume<sp/>the<sp/>callback<sp/>implementation<sp/>(not<sp/>shown)<sp/>posts<sp/>a<sp/>semaphore<sp/>when</highlight></codeline>
<codeline lineno="555"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>the<sp/>last<sp/>transaction<sp/>completes</highlight></codeline>
<codeline lineno="556"><highlight class="comment"><sp/>*<sp/><sp/>sem_wait(&amp;spiSemaphore);</highlight></codeline>
<codeline lineno="557"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="558"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Disable<sp/>manual<sp/>start<sp/>mode</highlight></codeline>
<codeline lineno="559"><highlight class="comment"><sp/>*<sp/><sp/>SPI_control(spi,<sp/>SPICC26X2DMA_CMD_CLR_MANUAL,<sp/>NULL);</highlight></codeline>
<codeline lineno="560"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="561"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="562"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="563"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Ensure<sp/>low<sp/>power<sp/>during<sp/>inactive<sp/>periods<sp/>@anchor<sp/>USE_CASE_LPWR_X2<sp/>#</highlight></codeline>
<codeline lineno="564"><highlight class="comment"><sp/>*<sp/><sp/>External<sp/>hardware<sp/>connected<sp/>on<sp/>the<sp/>SPI,<sp/>i.e.<sp/>SPI<sp/>host/peripheral,<sp/>might<sp/>have<sp/>configured</highlight></codeline>
<codeline lineno="565"><highlight class="comment"><sp/>*<sp/><sp/>a<sp/>pull<sp/>on<sp/>one<sp/>or<sp/>more<sp/>of<sp/>the<sp/>SPI<sp/>lines.<sp/>Dependent<sp/>on<sp/>the<sp/>hardware,<sp/>it<sp/>might<sp/>conflict</highlight></codeline>
<codeline lineno="566"><highlight class="comment"><sp/>*<sp/><sp/>with<sp/>the<sp/>pull<sp/>used<sp/>for<sp/>the<sp/>CC26XX<sp/>SPI.<sp/>To<sp/>avoid<sp/>increased<sp/>leakage<sp/>and<sp/>ensure<sp/>the<sp/>lowest</highlight></codeline>
<codeline lineno="567"><highlight class="comment"><sp/>*<sp/><sp/>possible<sp/>power<sp/>consumption<sp/>when<sp/>the<sp/>SPI<sp/>is<sp/>inactive,<sp/>the<sp/>application<sp/>must<sp/>configure<sp/>a</highlight></codeline>
<codeline lineno="568"><highlight class="comment"><sp/>*<sp/><sp/>matching<sp/>pull<sp/>on<sp/>the<sp/>SPI<sp/>IOs.<sp/>An<sp/>example<sp/>of<sp/>how<sp/>this<sp/>can<sp/>be<sp/>done<sp/>is<sp/>shown<sp/>below.</highlight></codeline>
<codeline lineno="569"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="570"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="571"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params<sp/>params;</highlight></codeline>
<codeline lineno="572"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Transaction<sp/>transaction;</highlight></codeline>
<codeline lineno="573"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>txBuf[]<sp/>=<sp/>&quot;Heartbeat&quot;;<sp/><sp/><sp/><sp/>//<sp/>Transmit<sp/>buffer</highlight></codeline>
<codeline lineno="574"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>rxBuf[9];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Receive<sp/>buffer</highlight></codeline>
<codeline lineno="575"><highlight class="comment"><sp/>*<sp/><sp/>uint32_t<sp/>standbyDurationMs<sp/>=<sp/>100;</highlight></codeline>
<codeline lineno="576"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="577"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Init<sp/>SPI<sp/>and<sp/>specify<sp/>non-default<sp/>parameters</highlight></codeline>
<codeline lineno="578"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params_init(&amp;params);</highlight></codeline>
<codeline lineno="579"><highlight class="comment"><sp/>*<sp/><sp/>params.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline lineno="580"><highlight class="comment"><sp/>*<sp/><sp/>params.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline lineno="581"><highlight class="comment"><sp/>*<sp/><sp/>params.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_CONTROLLER;</highlight></codeline>
<codeline lineno="582"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="583"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Configure<sp/>the<sp/>transaction</highlight></codeline>
<codeline lineno="584"><highlight class="comment"><sp/>*<sp/><sp/>transaction.count<sp/>=<sp/>sizeof(txBuf);</highlight></codeline>
<codeline lineno="585"><highlight class="comment"><sp/>*<sp/><sp/>transaction.txBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline lineno="586"><highlight class="comment"><sp/>*<sp/><sp/>transaction.rxBuf<sp/>=<sp/>rxBuf;</highlight></codeline>
<codeline lineno="587"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="588"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Open<sp/>the<sp/>SPI<sp/>and<sp/>perform<sp/>the<sp/>transfer</highlight></codeline>
<codeline lineno="589"><highlight class="comment"><sp/>*<sp/><sp/>handle<sp/>=<sp/>SPI_open(CONFIG_SPI_0,<sp/>&amp;params);</highlight></codeline>
<codeline lineno="590"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="591"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Apply<sp/>low<sp/>power<sp/>sleep<sp/>pull<sp/>config<sp/>for<sp/>POCI</highlight></codeline>
<codeline lineno="592"><highlight class="comment"><sp/>*<sp/><sp/>GPIO_setConfig(CONFIG_GPIO_SPI_0_POCI,<sp/>GPIO_CFG_IN_PU);</highlight></codeline>
<codeline lineno="593"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="594"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Do<sp/>forever</highlight></codeline>
<codeline lineno="595"><highlight class="comment"><sp/>*<sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline lineno="596"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>//<sp/>Transfer<sp/>data</highlight></codeline>
<codeline lineno="597"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>SPI_transfer(handle,<sp/>&amp;transaction);</highlight></codeline>
<codeline lineno="598"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>//<sp/>Sleep</highlight></codeline>
<codeline lineno="599"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>Task_sleep(standbyDurationMs*100);</highlight></codeline>
<codeline lineno="600"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="601"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="602"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="603"><highlight class="comment"><sp/>*<sp/><sp/>###<sp/>Wake<sp/>Up<sp/>On<sp/>Chip<sp/>Select<sp/>Deassertion<sp/>In<sp/>Peripheral<sp/>Mode<sp/>Using<sp/>#SPI_MODE_CALLBACK<sp/>#</highlight></codeline>
<codeline lineno="604"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>example<sp/>demonstrates<sp/>using<sp/>a<sp/>GPIO<sp/>callback<sp/>on<sp/>Chip<sp/>Select<sp/>to<sp/>wake<sp/>up<sp/>the<sp/>device</highlight></codeline>
<codeline lineno="605"><highlight class="comment"><sp/>*<sp/><sp/>to<sp/>allow<sp/>low<sp/>power<sp/>modes<sp/>while<sp/>waiting<sp/>for<sp/>a<sp/>chip<sp/>select<sp/>edge.</highlight></codeline>
<codeline lineno="606"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="607"><highlight class="comment"><sp/>*<sp/><sp/>In<sp/>sysconfig<sp/>or<sp/>the<sp/>board<sp/>file,<sp/>the<sp/>CSN<sp/>GPIO<sp/>should<sp/>be<sp/>configured</highlight></codeline>
<codeline lineno="608"><highlight class="comment"><sp/>*<sp/><sp/>as<sp/>input/pull<sp/>up<sp/>with<sp/>an<sp/>interrupt<sp/>on<sp/>falling<sp/>edge.<sp/>Otherwise,<sp/>SPI_close()</highlight></codeline>
<codeline lineno="609"><highlight class="comment"><sp/>*<sp/><sp/>will<sp/>reset<sp/>the<sp/>pin<sp/>to<sp/>the<sp/>wrong<sp/>settings<sp/>and<sp/>you<sp/>may<sp/>see<sp/>line<sp/>glitches.</highlight></codeline>
<codeline lineno="610"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="611"><highlight class="comment"><sp/>*<sp/><sp/>*Note:<sp/>The<sp/>SPI<sp/>controller<sp/>must<sp/>allow<sp/>enough<sp/>time<sp/>between<sp/>deasserting<sp/>the<sp/>chip<sp/>select<sp/>and<sp/>the</highlight></codeline>
<codeline lineno="612"><highlight class="comment"><sp/>*<sp/><sp/>start<sp/>of<sp/>the<sp/>transaction<sp/>for<sp/>the<sp/>SPI<sp/>peripheral<sp/>to<sp/>wake<sp/>up<sp/>and<sp/>open<sp/>up<sp/>the<sp/>SPI<sp/>driver.</highlight></codeline>
<codeline lineno="613"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="614"><highlight class="comment"><sp/>*<sp/><sp/>@code</highlight></codeline>
<codeline lineno="615"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Global<sp/>variables</highlight></codeline>
<codeline lineno="616"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Handle<sp/>spiHandle</highlight></codeline>
<codeline lineno="617"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Params<sp/>spiParams;</highlight></codeline>
<codeline lineno="618"><highlight class="comment"><sp/>*<sp/><sp/>SPI_Transaction<sp/>spiTransaction;</highlight></codeline>
<codeline lineno="619"><highlight class="comment"><sp/>*<sp/><sp/>const<sp/>uint8_t<sp/>transferSize<sp/>=<sp/>8;</highlight></codeline>
<codeline lineno="620"><highlight class="comment"><sp/>*<sp/><sp/>uint8_t<sp/>txBuf[8];</highlight></codeline>
<codeline lineno="621"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="622"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>Chip<sp/>select<sp/>callback</highlight></codeline>
<codeline lineno="623"><highlight class="comment"><sp/>*<sp/><sp/>static<sp/>void<sp/>chipSelectCallback(uint_least8_t)</highlight></codeline>
<codeline lineno="624"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="625"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Open<sp/>SPI<sp/>driver,<sp/>which<sp/>will<sp/>override<sp/>any<sp/>previous<sp/>GPIO<sp/>configuration</highlight></codeline>
<codeline lineno="626"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiHandle<sp/>=<sp/>SPI_open(CONFIG_SPI,<sp/>&amp;spiParams);</highlight></codeline>
<codeline lineno="627"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Issue<sp/>the<sp/>transfer</highlight></codeline>
<codeline lineno="628"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_transfer(spiHandle,<sp/>&amp;spiTransaction);</highlight></codeline>
<codeline lineno="629"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="630"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="631"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>SPI<sp/>transfer<sp/>callback</highlight></codeline>
<codeline lineno="632"><highlight class="comment"><sp/>*<sp/><sp/>static<sp/>void<sp/>transferCallback(SPI_Handle<sp/>handle,<sp/>SPI_Transaction<sp/>*transaction)</highlight></codeline>
<codeline lineno="633"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="634"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Close<sp/>the<sp/>SPI<sp/>driver</highlight></codeline>
<codeline lineno="635"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_close(handle);</highlight></codeline>
<codeline lineno="636"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="637"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Note:<sp/>SPI_close()<sp/>will<sp/>reset<sp/>the<sp/>pin<sp/>configuration,<sp/>so<sp/>it<sp/>is<sp/>important<sp/>to</highlight></codeline>
<codeline lineno="638"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>set<sp/>the<sp/>default<sp/>values<sp/>correctly<sp/>in<sp/>sysconfig.<sp/>We<sp/>just<sp/>need<sp/>to<sp/>set<sp/>the</highlight></codeline>
<codeline lineno="639"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>callback<sp/>and<sp/>enable<sp/>the<sp/>falling<sp/>edge<sp/>interrupt</highlight></codeline>
<codeline lineno="640"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="641"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>GPIO_setCallback(CS_PIN_INDEX,<sp/>chipSelectCallback);</highlight></codeline>
<codeline lineno="642"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>GPIO_enableInt(CS_PIN_INDEX);</highlight></codeline>
<codeline lineno="643"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="644"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="645"><highlight class="comment"><sp/>*<sp/><sp/>//<sp/>From<sp/>your_application.c</highlight></codeline>
<codeline lineno="646"><highlight class="comment"><sp/>*<sp/><sp/>static<sp/>void<sp/>taskFxn(uintptr_t<sp/>a0,<sp/>uintptr_t<sp/>a1)</highlight></codeline>
<codeline lineno="647"><highlight class="comment"><sp/>*<sp/><sp/>{</highlight></codeline>
<codeline lineno="648"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>uint8_t<sp/>i;</highlight></codeline>
<codeline lineno="649"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="650"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Setup<sp/>SPI<sp/>params</highlight></codeline>
<codeline lineno="651"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>SPI_Params_init(&amp;spiParams);</highlight></codeline>
<codeline lineno="652"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiParams.bitRate<sp/><sp/><sp/><sp/><sp/>=<sp/>1000000;</highlight></codeline>
<codeline lineno="653"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiParams.frameFormat<sp/>=<sp/>SPI_POL1_PHA1;</highlight></codeline>
<codeline lineno="654"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiParams.mode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>SPI_PERIPHERAL;</highlight></codeline>
<codeline lineno="655"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiParams.dataSize<sp/><sp/><sp/><sp/>=<sp/>transferSize;</highlight></codeline>
<codeline lineno="656"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiParams.transferMode<sp/>=<sp/>SPI_MODE_CALLBACK;</highlight></codeline>
<codeline lineno="657"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiParams.transferCallbackFxn<sp/>=<sp/>transferCallback;</highlight></codeline>
<codeline lineno="658"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="659"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Setup<sp/>SPI<sp/>transaction</highlight></codeline>
<codeline lineno="660"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiTransaction.arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="661"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiTransaction.count<sp/>=<sp/>transferSize;</highlight></codeline>
<codeline lineno="662"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiTransaction.txBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline lineno="663"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>spiTransaction.rxBuf<sp/>=<sp/>txBuf;</highlight></codeline>
<codeline lineno="664"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="665"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>First<sp/>echo<sp/>message</highlight></codeline>
<codeline lineno="666"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>transferSize;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="667"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>txBuf[i]<sp/>=<sp/>i;</highlight></codeline>
<codeline lineno="668"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="669"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="670"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Configure<sp/>chip<sp/>select<sp/>callback</highlight></codeline>
<codeline lineno="671"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>GPIO_setCallback(CS_PIN_INDEX,<sp/>chipSelectCallback);</highlight></codeline>
<codeline lineno="672"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>GPIO_enableInt(CS_PIN_INDEX);</highlight></codeline>
<codeline lineno="673"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="674"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Wait<sp/>forever</highlight></codeline>
<codeline lineno="675"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>while(true);</highlight></codeline>
<codeline lineno="676"><highlight class="comment"><sp/>*<sp/><sp/>}</highlight></codeline>
<codeline lineno="677"><highlight class="comment"><sp/>*<sp/><sp/>@endcode</highlight></codeline>
<codeline lineno="678"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="679"><highlight class="comment"><sp/>*<sp/><sp/>&lt;hr&gt;</highlight></codeline>
<codeline lineno="680"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="681"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>clang-format<sp/>on<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="682"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>ti_drivers_spi_SPICC26X2DMA__include</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="683"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ti_drivers_spi_SPICC26X2DMA__include</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="684"><highlight class="normal"></highlight></codeline>
<codeline lineno="685"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdint.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="686"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="_s_p_i_8h" kindref="compound">ti/drivers/SPI.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="687"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="_u_d_m_a_c_c26_x_x_8h" kindref="compound">ti/drivers/dma/UDMACC26XX.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="688"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="_power_8h" kindref="compound">ti/drivers/Power.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="689"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="_power_c_c26_x_x_8h" kindref="compound">ti/drivers/power/PowerCC26XX.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="690"><highlight class="normal"></highlight></codeline>
<codeline lineno="691"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;ti/drivers/dpl/HwiP.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="692"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;ti/drivers/dpl/SemaphoreP.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="693"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;ti/drivers/dpl/SwiP.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="694"><highlight class="normal"></highlight></codeline>
<codeline lineno="695"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="696"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="697"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="698"><highlight class="normal"></highlight></codeline>
<codeline lineno="709"><highlight class="comment">/*<sp/>Add<sp/>SPICC26X2DMA_STATUS_*<sp/>macros<sp/>here<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="710"><highlight class="normal"></highlight></codeline>
<codeline lineno="731" refid="group___s_p_i___c_m_d_1ga34c49fde4df8fd436cf431b8c69e64d2" refkind="member"><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_CMD_RETURN_PARTIAL_ENABLE<sp/>(SPI_CMD_RESERVED<sp/>+<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="732"><highlight class="normal"></highlight></codeline>
<codeline lineno="740" refid="group___s_p_i___c_m_d_1ga0e1ad744e41c95b652bc5c04f492d609" refkind="member"><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_CMD_RETURN_PARTIAL_DISABLE<sp/>(SPI_CMD_RESERVED<sp/>+<sp/>1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="741"><highlight class="normal"></highlight></codeline>
<codeline lineno="753" refid="group___s_p_i___c_m_d_1ga572d479a9a8504cf5c096d16465f8e9d" refkind="member"><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_CMD_SET_CSN_PIN<sp/>(SPI_CMD_RESERVED<sp/>+<sp/>2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="754"><highlight class="normal"></highlight></codeline>
<codeline lineno="764" refid="group___s_p_i___c_m_d_1ga21f3e5d69d096a16c9569f2615a56b0b" refkind="member"><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_CMD_CLEAR_CSN_PIN<sp/>(SPI_CMD_RESERVED<sp/>+<sp/>3)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="765"><highlight class="normal"></highlight></codeline>
<codeline lineno="779" refid="group___s_p_i___c_m_d_1ga2e83f10ecd69aa4b117acb2e64565f5b" refkind="member"><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_CMD_SET_MANUAL<sp/>(SPI_CMD_RESERVED<sp/>+<sp/>4)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="780"><highlight class="normal"></highlight></codeline>
<codeline lineno="790" refid="group___s_p_i___c_m_d_1ga687eef73eab3644a3000ab89b2a83cf3" refkind="member"><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_CMD_CLR_MANUAL<sp/>(SPI_CMD_RESERVED<sp/>+<sp/>5)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="791"><highlight class="normal"></highlight></codeline>
<codeline lineno="802" refid="group___s_p_i___c_m_d_1ga3b4361e2cabb4ae7fedda98551aee5ef" refkind="member"><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_CMD_MANUAL_START<sp/>(SPI_CMD_RESERVED<sp/>+<sp/>6)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="803"><highlight class="normal"></highlight></codeline>
<codeline lineno="806"><highlight class="comment">/*<sp/>BACKWARDS<sp/>COMPATIBILITY<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="807" refid="_s_p_i_c_c26_x2_d_m_a_8h_1aaa634f36e737f032a3965aaf1ee68861" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_RETURN_PARTIAL_ENABLE<sp/><sp/>SPICC26X2DMA_CMD_RETURN_PARTIAL_ENABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="808" refid="_s_p_i_c_c26_x2_d_m_a_8h_1ab3d2701c77c927ce2623c6370bbc8b12" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_RETURN_PARTIAL_DISABLE<sp/>SPICC26X2DMA_CMD_RETURN_PARTIAL_DISABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="809" refid="_s_p_i_c_c26_x2_d_m_a_8h_1a4e5ef588123b8c7db018f26606fb662c" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SPICC26X2DMA_SET_CSN_PIN<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SPICC26X2DMA_CMD_SET_CSN_PIN</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="810"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>END<sp/>BACKWARDS<sp/>COMPATIBILITY<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="811"><highlight class="normal"></highlight></codeline>
<codeline lineno="817"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_s_p_i___fxn_table" kindref="compound">SPI_FxnTable</ref><sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1a91e8de1ee3380354aba7d286fc59c593" kindref="member">SPICC26X2DMA_fxnTable</ref>;</highlight></codeline>
<codeline lineno="818"><highlight class="normal"></highlight></codeline>
<codeline lineno="828" refid="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="829"><highlight class="normal">{</highlight></codeline>
<codeline lineno="830" refid="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3a07a215eef0e18eb548bec7031a4a6e8f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3a07a215eef0e18eb548bec7031a4a6e8f" kindref="member">SPICC26X2DMA_8bit</ref><sp/><sp/>=<sp/>0,</highlight></codeline>
<codeline lineno="831" refid="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3ac3bfdd18fe2cf4674a56554737b57ef3" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3ac3bfdd18fe2cf4674a56554737b57ef3" kindref="member">SPICC26X2DMA_16bit</ref><sp/>=<sp/>1</highlight></codeline>
<codeline lineno="832"><highlight class="normal">}<sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1af00bbb5d6f695caee4c24f57ac7236d3" kindref="member">SPICC26X2DMA_FrameSize</ref>;</highlight></codeline>
<codeline lineno="833"><highlight class="normal"></highlight></codeline>
<codeline lineno="841" refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4d" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="842"><highlight class="normal">{</highlight></codeline>
<codeline lineno="843" refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4da110eab6b38d8da801d21e3556ea1fb55" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4da110eab6b38d8da801d21e3556ea1fb55" kindref="member">SPICC26X2DMA_retPartDisabled</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0,</highlight></codeline>
<codeline lineno="844" refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4dad1a937fa73857130a5cd52db13fc951d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4dad1a937fa73857130a5cd52db13fc951d" kindref="member">SPICC26X2DMA_retPartEnabledIntNotSet</ref><sp/>=<sp/>1,</highlight></codeline>
<codeline lineno="845" refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4dae635a93b40c8dd2d5ad9a58cf3f0b2d1" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4dae635a93b40c8dd2d5ad9a58cf3f0b2d1" kindref="member">SPICC26X2DMA_retPartEnabledIntSet</ref><sp/><sp/><sp/><sp/>=<sp/>2</highlight></codeline>
<codeline lineno="846"><highlight class="normal">}<sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4d" kindref="member">SPICC26X2DMA_ReturnPartial</ref>;</highlight></codeline>
<codeline lineno="847"><highlight class="normal"></highlight></codeline>
<codeline lineno="902" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="903"><highlight class="normal">{</highlight></codeline>
<codeline lineno="905" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a6ffb243ce20d6ea290c7bcbb3112ebec" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a6ffb243ce20d6ea290c7bcbb3112ebec" kindref="member">baseAddr</ref>;</highlight></codeline>
<codeline lineno="907" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1acb8a020b5721b1057ac20ea52d1e8d9e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1acb8a020b5721b1057ac20ea52d1e8d9e" kindref="member">intNum</ref>;</highlight></codeline>
<codeline lineno="922" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a9b90725d7784136be4bfa7bf94be3a3d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a9b90725d7784136be4bfa7bf94be3a3d" kindref="member">intPriority</ref>;</highlight></codeline>
<codeline lineno="929" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a72cbd5d379f1e808dbdec750d66ddfb0" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a72cbd5d379f1e808dbdec750d66ddfb0" kindref="member">swiPriority</ref>;</highlight></codeline>
<codeline lineno="931" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a384d17cbbda7262b259f705f7c988a95" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PowerCC26XX_Resource<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a384d17cbbda7262b259f705f7c988a95" kindref="member">powerMngrId</ref>;</highlight></codeline>
<codeline lineno="933" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ad21e0894d771e9c9a0b78ac739543a68" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint16_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ad21e0894d771e9c9a0b78ac739543a68" kindref="member">defaultTxBufValue</ref>;</highlight></codeline>
<codeline lineno="935" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ac60297b47b15ead053d01d00e2964c94" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ac60297b47b15ead053d01d00e2964c94" kindref="member">rxChannelBitMask</ref>;</highlight></codeline>
<codeline lineno="937" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ab389acc2cea2c998c4c04f72bc48c82e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ab389acc2cea2c998c4c04f72bc48c82e" kindref="member">txChannelBitMask</ref>;</highlight></codeline>
<codeline lineno="939" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a53bfd10c35ac66bfa84011cd22f39011" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>tDMAControlTable<sp/>*<ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a53bfd10c35ac66bfa84011cd22f39011" kindref="member">dmaTxTableEntryPri</ref>;</highlight></codeline>
<codeline lineno="941" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ab34d58bbf42e9c845bff9fdeba7e663f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>tDMAControlTable<sp/>*<ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ab34d58bbf42e9c845bff9fdeba7e663f" kindref="member">dmaRxTableEntryPri</ref>;</highlight></codeline>
<codeline lineno="943" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ae3133d72b63fc6f3fa72c968ebe31254" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>tDMAControlTable<sp/>*<ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ae3133d72b63fc6f3fa72c968ebe31254" kindref="member">dmaTxTableEntryAlt</ref>;</highlight></codeline>
<codeline lineno="945" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a44ca8faa45ad7651713673f8eef62322" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>tDMAControlTable<sp/>*<ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a44ca8faa45ad7651713673f8eef62322" kindref="member">dmaRxTableEntryAlt</ref>;</highlight></codeline>
<codeline lineno="947" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a3c5b4e6fe0d534b4b13268da6cb5d4be" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a3c5b4e6fe0d534b4b13268da6cb5d4be" kindref="member">txPinMux</ref>;</highlight></codeline>
<codeline lineno="949" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a8eeaf4ccec7e6d8383c64e39cb33728c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a8eeaf4ccec7e6d8383c64e39cb33728c" kindref="member">rxPinMux</ref>;</highlight></codeline>
<codeline lineno="951" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a5d7e21b99d27ac171ede6793605ab854" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a5d7e21b99d27ac171ede6793605ab854" kindref="member">clkPinMux</ref>;</highlight></codeline>
<codeline lineno="953" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1aed8fdbed5bac9d49eebbfb708f8064b3" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1aed8fdbed5bac9d49eebbfb708f8064b3" kindref="member">csnPinMux</ref>;</highlight></codeline>
<codeline lineno="955" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ab2a2e2615ed0ebd8c0df06ca7e6d43e0" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint_least8_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ab2a2e2615ed0ebd8c0df06ca7e6d43e0" kindref="member">picoPin</ref>;</highlight></codeline>
<codeline lineno="957" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a173aed4e9fed2aa9c88e127e6a7760e3" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint_least8_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a173aed4e9fed2aa9c88e127e6a7760e3" kindref="member">pociPin</ref>;</highlight></codeline>
<codeline lineno="959" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ab1fc58a8e39c7f8fabcb02019c0772c5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint_least8_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1ab1fc58a8e39c7f8fabcb02019c0772c5" kindref="member">clkPin</ref>;</highlight></codeline>
<codeline lineno="961" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a0d29d12b3471833d53d6499af2382e6c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint_least8_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1a0d29d12b3471833d53d6499af2382e6c" kindref="member">csnPin</ref>;</highlight></codeline>
<codeline lineno="962"><highlight class="normal"></highlight></codeline>
<codeline lineno="964" refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1aafcf5e92ef5b7cbd9fb857b43b2f4cee" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs_1aafcf5e92ef5b7cbd9fb857b43b2f4cee" kindref="member">minDmaTransferSize</ref>;</highlight></codeline>
<codeline lineno="965"><highlight class="normal">}<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___h_w_attrs" kindref="compound">SPICC26X2DMA_HWAttrs</ref>;</highlight></codeline>
<codeline lineno="966"><highlight class="normal"></highlight></codeline>
<codeline lineno="972" refid="struct_s_p_i_c_c26_x2_d_m_a___object" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="973"><highlight class="normal">{</highlight></codeline>
<codeline lineno="974" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a7f3edd58588d88e22dbd6fc0e7516d5b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>HwiP_Struct<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a7f3edd58588d88e22dbd6fc0e7516d5b" kindref="member">hwi</ref>;</highlight></codeline>
<codeline lineno="975" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a147b4acc503950aab4c92647b882fdc2" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_power___notify_obj" kindref="compound">Power_NotifyObj</ref><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a147b4acc503950aab4c92647b882fdc2" kindref="member">spiPostObj</ref>;</highlight></codeline>
<codeline lineno="976" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a3a511419c06d5f07e66e58bec1201828" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>SwiP_Struct<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a3a511419c06d5f07e66e58bec1201828" kindref="member">swi</ref>;</highlight></codeline>
<codeline lineno="977" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ab224c283780f21b6fd20b9446980d49f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>SemaphoreP_Struct<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ab224c283780f21b6fd20b9446980d49f" kindref="member">transferComplete</ref>;</highlight></codeline>
<codeline lineno="978"><highlight class="normal"></highlight></codeline>
<codeline lineno="979" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a4cc56d1ddc40e385d0e30162e3a97671" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_8h_1a207e2d5a7e7ea5606b6995b6485ca015" kindref="member">SPI_CallbackFxn</ref><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a4cc56d1ddc40e385d0e30162e3a97671" kindref="member">transferCallbackFxn</ref>;</highlight></codeline>
<codeline lineno="980" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a1299c9e4339c672ec81cb5e01520c77c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_s_p_i___transaction" kindref="compound">SPI_Transaction</ref><sp/>*<ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a1299c9e4339c672ec81cb5e01520c77c" kindref="member">headPtr</ref>;</highlight></codeline>
<codeline lineno="981" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a9d6a1de968cf6a397a73cdc9c5d1162c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_s_p_i___transaction" kindref="compound">SPI_Transaction</ref><sp/>*<ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a9d6a1de968cf6a397a73cdc9c5d1162c" kindref="member">tailPtr</ref>;</highlight></codeline>
<codeline lineno="982" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1aabdb2381fa725d487c3d811e6bc4784d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_s_p_i___transaction" kindref="compound">SPI_Transaction</ref><sp/>*<ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1aabdb2381fa725d487c3d811e6bc4784d" kindref="member">completedTransfers</ref>;</highlight></codeline>
<codeline lineno="983" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a5908f8b17f72efa4e6b479731d2a351e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_u_d_m_a_c_c26_x_x___config" kindref="compound">UDMACC26XX_Handle</ref><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a5908f8b17f72efa4e6b479731d2a351e" kindref="member">udmaHandle</ref>;</highlight></codeline>
<codeline lineno="984"><highlight class="normal"></highlight></codeline>
<codeline lineno="985" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ad3dba2e9a489559415448a419ffc19f5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ad3dba2e9a489559415448a419ffc19f5" kindref="member">framesQueued</ref>;</highlight></codeline>
<codeline lineno="986" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a3282855d1f11eab3559a04c02d2a1d9f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a3282855d1f11eab3559a04c02d2a1d9f" kindref="member">framesTransferred</ref>;</highlight></codeline>
<codeline lineno="987" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a1424887f888234122a90807b43562a25" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a1424887f888234122a90807b43562a25" kindref="member">priTransferSize</ref>;</highlight></codeline>
<codeline lineno="988" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a9eed065474de19726bf6a4b499b28b86" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a9eed065474de19726bf6a4b499b28b86" kindref="member">altTransferSize</ref>;</highlight></codeline>
<codeline lineno="989"><highlight class="normal"></highlight></codeline>
<codeline lineno="990" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1af7807d7f05996354fde2c98da2d180ad" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1af7807d7f05996354fde2c98da2d180ad" kindref="member">activeChannel</ref>;</highlight></codeline>
<codeline lineno="991" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a0b4ae4efb52aec9e80ce17e94aa3beea" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a0b4ae4efb52aec9e80ce17e94aa3beea" kindref="member">bitRate</ref>;</highlight></codeline>
<codeline lineno="992" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1af59f74596d22143b292558aefc1e5bb0" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1af59f74596d22143b292558aefc1e5bb0" kindref="member">dataSize</ref>;</highlight></codeline>
<codeline lineno="993" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a7cf8cb062e9430c90312fc57945799fc" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a7cf8cb062e9430c90312fc57945799fc" kindref="member">transferTimeout</ref>;</highlight></codeline>
<codeline lineno="994" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1acf714c9e6b4287145bdcc725dace6ce4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1acf714c9e6b4287145bdcc725dace6ce4" kindref="member">busyBit</ref>;</highlight></codeline>
<codeline lineno="995"><highlight class="normal"></highlight></codeline>
<codeline lineno="996" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1add5356db32d00e7b0e4668700010d6dc" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint16_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1add5356db32d00e7b0e4668700010d6dc" kindref="member">rxScratchBuf</ref>;</highlight></codeline>
<codeline lineno="997" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ada37b2ae0b867564c635d4b2a09afe5a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint16_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ada37b2ae0b867564c635d4b2a09afe5a" kindref="member">txScratchBuf</ref>;</highlight></codeline>
<codeline lineno="998"><highlight class="normal"></highlight></codeline>
<codeline lineno="999" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a9e8761b56588b9d24397cfaa6543a9a5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_8h_1ab9ea76c6529d6076eee5e1c4a5a92c6f" kindref="member">SPI_TransferMode</ref><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a9e8761b56588b9d24397cfaa6543a9a5" kindref="member">transferMode</ref>;</highlight></codeline>
<codeline lineno="1000" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ae0c98fa3c42e354ee3aafffd85c4177f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_8h_1a60a7e3d74577b38aa79ea6983362f942" kindref="member">SPI_Mode</ref><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ae0c98fa3c42e354ee3aafffd85c4177f" kindref="member">mode</ref>;</highlight></codeline>
<codeline lineno="1001" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ad8caf96a11276521ec251a25c1b3bd16" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1ad8caf96a11276521ec251a25c1b3bd16" kindref="member">format</ref>;</highlight></codeline>
<codeline lineno="1002" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a6478611664db0675b6aaf64acb712a78" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint_least8_t<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a6478611664db0675b6aaf64acb712a78" kindref="member">csnPin</ref>;</highlight></codeline>
<codeline lineno="1003" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a7f47f8cfe6f2b3aeec12734417be66c3" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="_s_p_i_c_c26_x2_d_m_a_8h_1a15ad0a779d60692ec97e106cd602cd4d" kindref="member">SPICC26X2DMA_ReturnPartial</ref><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a7f47f8cfe6f2b3aeec12734417be66c3" kindref="member">returnPartial</ref>;</highlight></codeline>
<codeline lineno="1004" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a325d43423ec5cd191e1f5c8d4ff3c4ed" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1a325d43423ec5cd191e1f5c8d4ff3c4ed" kindref="member">isOpen</ref>;</highlight></codeline>
<codeline lineno="1005" refid="struct_s_p_i_c_c26_x2_d_m_a___object_1aa26588bfa54c3062ecc6d99e20410aab" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object_1aa26588bfa54c3062ecc6d99e20410aab" kindref="member">manualStart</ref>;</highlight></codeline>
<codeline lineno="1006"><highlight class="normal">}<sp/><ref refid="struct_s_p_i_c_c26_x2_d_m_a___object" kindref="compound">SPICC26X2DMA_Object</ref>;</highlight></codeline>
<codeline lineno="1007"><highlight class="normal"></highlight></codeline>
<codeline lineno="1008"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1009"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1010"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1011"><highlight class="normal"></highlight></codeline>
<codeline lineno="1012"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>ti_drivers_spi_SPICC26X2DMA__include<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="source/ti/drivers/spi/SPICC26X2DMA.h"/>
  </compounddef>
</doxygen>
