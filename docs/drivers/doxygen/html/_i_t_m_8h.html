<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>ITM.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_15fb9a92674a5e15cac1f3112cfb19ae.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ITM.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ITM driver header. </p>
<hr/>
<p><a class="anchor" id="ti_drivers_ITM_Overview"></a> </p><h3>Overview </h3>
<p>This driver implements APIs to configure and control the ARM Instrumentation Trace Macrocell (ITM), Debug Watchpoint and Trace (DWT), and Trace Port Instrumentation Unit (TPIU) IPs to realize non-intrusive software logging and runtime trace.</p>
<h1>Overview <a class="anchor" id="overview"></a></h1>
<p>The ITM software module provides application level APIs for the non-invasive debug capabilities of the ARM Cortex-M family. This includes the following hardware modules:</p>
<ul>
<li>Instrumentation Trace Macrocell (ITM)</li>
<li>Debug Watchpoint and Trace (DWT)</li>
<li>Trace Port Instrumentation Unit (TPIU)</li>
</ul>
<p>At a high level, the DWT provides watchpoint, data trace, and program counter sampling. The ITM provides memory mapped registers for low-intrusion software profiling. The TPIU provides an external interface for the ITM and DWT. Further details can be found in the <a href="https://static.docs.arm.com/ddi0403/e/DDI0403E_d_armv7m_arm.pdf">ARMv7-M Architecture Reference Manual</a></p>
<h3>Limitations and Constraints </h3>
<p>The driver is is designed with the following constraints in mind:</p><ul>
<li>ITM is designed as a singleton. This means that a single instance is shared across all clients</li>
<li>The parallel TracePort mode of the TPIU is not supported, only serial protocols are considered</li>
<li>The ITM hardware is configured via firmware on the DUT. Log records can be read independent of any IDE or debugger configuration. This means that if the IDE debug system configures the ITM, it should be turned off.</li>
<li>In Code Composer Studio, it is not currently possible to disable the debugger configuration mentioned above. No ITM output will be visible while the IDE's debugger is connected. Please flash your firmware, then disconnect and reset the device to see ITM data on the serial port.</li>
</ul>
<p><a class="anchor" id="ti_drivers_ITM_Setup"></a> </p><h3>Setup </h3>
<p>The ITM is configured via hardware attributes stored in the hardware attributes structure. This structure contains a common portion that is used for all drivers. This structure may be extended for some devices such as CC26XX.</p>
<h3>Opening the driver </h3>
<p>Unlike other drivers, the ITM is intended to be a singleton. This means that <a class="el" href="_i_t_m_8h.html#a16102d41c7954c97735e43377beb7963">ITM_open</a> can be called multiple times. The ITM will only be configured the first time open is called.</p>
<p>Furthermore, helper functions for features such as PC sampling must coherent across clients. The driver offers no protection against mismatched configuration.</p>
<p>The open call will enable ITM as well as the necessary stimulus ports. It will setup the TPIU for necessary baudrate and serial format.</p>
<p><a class="anchor" id="ti_drivers_ITM_PinMux"></a> </p><h3>Pin Muxing </h3>
<p>As the ITM driver is primarily interfacing to ARM defined IP, it is almost entirely common across all supported devices. The only specifics are pin muxing of the SWO pin. See the table below for some notes</p>
<table class="doxtable">
<tr>
<th>Device Family </th><th>Debug Protocol </th><th>Muxing </th><th>Configurable?  </th></tr>
<tr>
<td>CC32XX </td><td>SWD </td><td>Shared with TDO </td><td>N </td></tr>
<tr>
<td>CC13XX/CC26XX </td><td>JTAG/cJTAG </td><td>Any pin </td><td>Y </td></tr>
</table>
<p>Device specific pin muxing is done by the device specific ITM backend implementation.</p>
<p><a class="anchor" id="ti_drivers_ITM_SwMessages"></a> </p><h3>Software Messages </h3>
<p>The ITM stimulus ports enable serialization of application data with low overhead. There are multiple ports available, they are selectable via software.</p>
<p>Data written to the software stimulus ports is serialized by the TPIU and wrapped in the SWIT packet format. This packet format is standardized by ARM and described in <a href="https://static.docs.arm.com/ddi0403/e/DDI0403E_d_armv7m_arm.pdf">ARMv7-M Architecture Reference Manual</a></p>
<p>There are three tiers of access to the stimulus ports. In the table below, polled access means that the API/macro will poll the port's busy flag before writing. This is done to prevent silent data loss that occurs when writing to a port that is not ready. Actual serialization of the data will occur later inside the TPIU.</p>
<ul>
<li>ITM_PortX - Macro to write or read to the port, doesn't poll before</li>
<li>ITM_sendXPolling - Macro that polls and writes to the port</li>
<li>ITM_sendXAtomic - Function that calls ITM_sendXPolling with interrupts disabled</li>
</ul>
<p>It is up the the application writer to understand the tradeoff associated with each of these and select the correct one.</p>
<h3>DWT Features </h3>
<p>The Data Watchpoint and Trace (DWT) module is capable of many instrumentation features such as</p>
<table class="doxtable">
<tr>
<th>Feature </th><th>ITM API  </th></tr>
<tr>
<td>Exception trace </td><td><a class="el" href="_i_t_m_8h.html#ac4f3f408f8babda3e63b15b2fcd7048d">ITM_enableExceptionTrace</a> </td></tr>
<tr>
<td>Program Counter sampling </td><td><a class="el" href="_i_t_m_8h.html#addbcfd1a2a6bc70194a83556d311fcbd">ITM_enablePCSampling</a> </td></tr>
<tr>
<td>Event counting </td><td><a class="el" href="_i_t_m_8h.html#a2f591d52bf64a2f6d65106bd58634ea5">ITM_enableEventCounter</a> </td></tr>
<tr>
<td>Synchronization packets </td><td><a class="el" href="_i_t_m_8h.html#a1b84f05e89bdb205c6f1ae8c9b3222de">ITM_enableSyncPackets</a> </td></tr>
</table>
<p>Data generated by the DWT is serialized via the TPIU. DWT packet formats are defined in the ARMv7-M Architecture Reference Manual referenced above</p>
<h3>Flush </h3>
<p>The ITM/DWT/TPIU hardware resides in the CPU power domain. This means that whenever the CPU domain is powered down, ITM will power down. Powering down when data is inside in the TPIU can result in lost data. In order to prevent dataloss, the device's power policy will flush the ITM before powering down the CPU domain. When returning from sleep, the power policy will restore the ITM. This is achieved using the <a class="el" href="_i_t_m_8h.html#aa685bcffb779886b550614e50df79405">ITM_flush</a> and <a class="el" href="_i_t_m_8h.html#a787885218450bd7680840f00098f46c1">ITM_restore</a>.</p>
<p>These functions are weakly defined as empty functions. This reduces the overhead in the power policy when ITM is not enabled. These weak functions are overridden by syscfg when ITM is enabled. </p>
</div><div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;ti/devices/DeviceFamily.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ITM.h:</div>
<div class="dyncontent">
<div class="center"><img src="_i_t_m_8h__incl.png" border="0" usemap="#_i_t_m_8h" alt=""/></div>
<map name="_i_t_m_8h" id="_i_t_m_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_i_t_m_8h__dep__incl.png" border="0" usemap="#_i_t_m_8hdep" alt=""/></div>
<map name="_i_t_m_8hdep" id="_i_t_m_8hdep">
<area shape="rect" id="node2" href="_i_t_m_c_c26_x_x_8h.html" title="CC26XX specific ITM implementation. " alt="" coords="5,80,116,107"/>
</map>
</div>
</div>
<p><a href="_i_t_m_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_t_m___h_w_attrs.html">ITM_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ITM Hardware Attributes.  <a href="struct_i_t_m___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a17b8fe92bb0a90af0c2bb841edb45c42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a17b8fe92bb0a90af0c2bb841edb45c42">ITM_BASE_ADDR</a>&#160;&#160;&#160;(0xE0000000)</td></tr>
<tr class="memdesc:a17b8fe92bb0a90af0c2bb841edb45c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the Instrumentation Trace Macrocell (ITM) module.  <a href="#a17b8fe92bb0a90af0c2bb841edb45c42">More...</a><br /></td></tr>
<tr class="separator:a17b8fe92bb0a90af0c2bb841edb45c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119b6e75428fdd7c6e21450a8bab3343"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a119b6e75428fdd7c6e21450a8bab3343">ITM_DWT_BASE_ADDR</a>&#160;&#160;&#160;(0xE0001000)</td></tr>
<tr class="memdesc:a119b6e75428fdd7c6e21450a8bab3343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the Debug Watchpoint and Trace (DWT) module.  <a href="#a119b6e75428fdd7c6e21450a8bab3343">More...</a><br /></td></tr>
<tr class="separator:a119b6e75428fdd7c6e21450a8bab3343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75b2f8a45f18b9d3123aa3abd85355"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a5f75b2f8a45f18b9d3123aa3abd85355">ITM_SCS_BASE_ADDR</a>&#160;&#160;&#160;(0xE000E000)</td></tr>
<tr class="memdesc:a5f75b2f8a45f18b9d3123aa3abd85355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the CPU_SCS module.  <a href="#a5f75b2f8a45f18b9d3123aa3abd85355">More...</a><br /></td></tr>
<tr class="separator:a5f75b2f8a45f18b9d3123aa3abd85355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c4b373d205eb9153065ae6ea4f7491"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a25c4b373d205eb9153065ae6ea4f7491">ITM_TPIU_BASE_ADDR</a>&#160;&#160;&#160;(0xE0040000)</td></tr>
<tr class="memdesc:a25c4b373d205eb9153065ae6ea4f7491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the Trace Port Instrumentation Unit (TPIU) module.  <a href="#a25c4b373d205eb9153065ae6ea4f7491">More...</a><br /></td></tr>
<tr class="separator:a25c4b373d205eb9153065ae6ea4f7491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ff30b7cbbbdeaf30f97ed5a211aeac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a82ff30b7cbbbdeaf30f97ed5a211aeac">ITM_LAR_UNLOCK</a>&#160;&#160;&#160;(0xC5ACCE55)</td></tr>
<tr class="memdesc:a82ff30b7cbbbdeaf30f97ed5a211aeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to unlock ARM debug modules. This value should be written to the Lock Access Registers (LAR) in order to enable their configuration and use.  <a href="#a82ff30b7cbbbdeaf30f97ed5a211aeac">More...</a><br /></td></tr>
<tr class="separator:a82ff30b7cbbbdeaf30f97ed5a211aeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefb788de5bc8c66593b709298d9cde4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#aaefb788de5bc8c66593b709298d9cde4">ITM_FUNCTION_DISABLED</a>&#160;&#160;&#160;(0x00)</td></tr>
<tr class="memdesc:aaefb788de5bc8c66593b709298d9cde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device-specific values that implement the generic ITM-functions in ITM_WatchpointAction.  <a href="#aaefb788de5bc8c66593b709298d9cde4">More...</a><br /></td></tr>
<tr class="separator:aaefb788de5bc8c66593b709298d9cde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5dd1af973cc317aa60de9aceb43e6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#afa5dd1af973cc317aa60de9aceb43e6c">ITM_FUNCTION_EMIT_PC</a>&#160;&#160;&#160;(0x30 | 0x4)</td></tr>
<tr class="separator:afa5dd1af973cc317aa60de9aceb43e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ba960d5ed2582664e27d6f16fdb67a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a17ba960d5ed2582664e27d6f16fdb67a">ITM_FUNCTION_EMIT_DATA_ON_READ_WRITE</a>&#160;&#160;&#160;(0x800 | 0x20 | 0xc)</td></tr>
<tr class="separator:a17ba960d5ed2582664e27d6f16fdb67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a2f43443471885317352216c2845cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#ae2a2f43443471885317352216c2845cb">ITM_FUNCTION_EMIT_PC_ON_READ_WRITE</a>&#160;&#160;&#160;(0x800 | 0x30 | 0x2)</td></tr>
<tr class="separator:ae2a2f43443471885317352216c2845cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c5ee16d4d377fe6d3f1bacf73958a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#ab3c5ee16d4d377fe6d3f1bacf73958a7">ITM_FUNCTION_EMIT_DATA_ON_READ</a>&#160;&#160;&#160;(0x800 | 0x20 | 0xe)</td></tr>
<tr class="separator:ab3c5ee16d4d377fe6d3f1bacf73958a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114abc7c9d00929b6e145b69253c7a93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a114abc7c9d00929b6e145b69253c7a93">ITM_FUNCTION_EMIT_DATA_ON_WRITE</a>&#160;&#160;&#160;(0x800 | 0x20 | 0xd)</td></tr>
<tr class="separator:a114abc7c9d00929b6e145b69253c7a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bf0b66e22e01e5453710a0309a8277"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a79bf0b66e22e01e5453710a0309a8277">ITM_FUNCTION_EMIT_PC_AND_DATA_ON_READ</a>&#160;&#160;&#160;(0x800 | 0x30 | 0xe)</td></tr>
<tr class="separator:a79bf0b66e22e01e5453710a0309a8277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d6154950d6996ba6507a75ca44865d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a97d6154950d6996ba6507a75ca44865d">ITM_FUNCTION_EMIT_PC_AND_DATA_ON_WRITE</a>&#160;&#160;&#160;(0x800 | 0x30 | 0xd)</td></tr>
<tr class="separator:a97d6154950d6996ba6507a75ca44865d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42097c7b552905d45be6f672b36609cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a42097c7b552905d45be6f672b36609cf">ITM_port32</a>(n)&#160;&#160;&#160;(*((volatile unsigned int *)(<a class="el" href="_i_t_m_8h.html#a17b8fe92bb0a90af0c2bb841edb45c42">ITM_BASE_ADDR</a> + 4 * n)))</td></tr>
<tr class="memdesc:a42097c7b552905d45be6f672b36609cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 32-bit word to stimulus port n.  <a href="#a42097c7b552905d45be6f672b36609cf">More...</a><br /></td></tr>
<tr class="separator:a42097c7b552905d45be6f672b36609cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5d0a92dbae07a856534e154489634e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#adf5d0a92dbae07a856534e154489634e">ITM_send32Polling</a>(n,  x)</td></tr>
<tr class="memdesc:adf5d0a92dbae07a856534e154489634e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 32-bit word to stimulus port n with polling.  <a href="#adf5d0a92dbae07a856534e154489634e">More...</a><br /></td></tr>
<tr class="separator:adf5d0a92dbae07a856534e154489634e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb14735a7e440e12c1601a80afc412b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#aecb14735a7e440e12c1601a80afc412b">ITM_port16</a>(n)&#160;&#160;&#160;(*((volatile unsigned short *)(<a class="el" href="_i_t_m_8h.html#a17b8fe92bb0a90af0c2bb841edb45c42">ITM_BASE_ADDR</a> + 4 * n)))</td></tr>
<tr class="memdesc:aecb14735a7e440e12c1601a80afc412b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 16-bit half word to stimulus port n.  <a href="#aecb14735a7e440e12c1601a80afc412b">More...</a><br /></td></tr>
<tr class="separator:aecb14735a7e440e12c1601a80afc412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e05582b2936451bc63fb963467315c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a77e05582b2936451bc63fb963467315c">ITM_send16Polling</a>(n,  x)</td></tr>
<tr class="memdesc:a77e05582b2936451bc63fb963467315c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 16-bit word to stimulus port n with polling.  <a href="#a77e05582b2936451bc63fb963467315c">More...</a><br /></td></tr>
<tr class="separator:a77e05582b2936451bc63fb963467315c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff85e0d732215d06f483a798a8d9a47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a1ff85e0d732215d06f483a798a8d9a47">ITM_port8</a>(n)&#160;&#160;&#160;(*((volatile unsigned char *)(<a class="el" href="_i_t_m_8h.html#a17b8fe92bb0a90af0c2bb841edb45c42">ITM_BASE_ADDR</a> + 4 * n)))</td></tr>
<tr class="memdesc:a1ff85e0d732215d06f483a798a8d9a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to stimulus port n.  <a href="#a1ff85e0d732215d06f483a798a8d9a47">More...</a><br /></td></tr>
<tr class="separator:a1ff85e0d732215d06f483a798a8d9a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76f9d46e6391b7e2321b8a28e4665b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#ab76f9d46e6391b7e2321b8a28e4665b7">ITM_send8Polling</a>(n,  x)</td></tr>
<tr class="memdesc:ab76f9d46e6391b7e2321b8a28e4665b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 8-bit word to stimulus port n with polling.  <a href="#ab76f9d46e6391b7e2321b8a28e4665b7">More...</a><br /></td></tr>
<tr class="separator:ab76f9d46e6391b7e2321b8a28e4665b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a92abaf1991f9421d7b642ca5489c9897"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a92abaf1991f9421d7b642ca5489c9897">ITM_TPIU_PortFormat</a> { <a class="el" href="_i_t_m_8h.html#a92abaf1991f9421d7b642ca5489c9897a9dbe5b7df6645097a4364d02c20d2a7d">ITM_TPIU_SWO_MANCHESTER</a> = 0x00000001, 
<a class="el" href="_i_t_m_8h.html#a92abaf1991f9421d7b642ca5489c9897a98249a1e3b05e6ec7e0789ea266ec772">ITM_TPIU_SWO_UART</a> = 0x00000002
 }</td></tr>
<tr class="separator:a92abaf1991f9421d7b642ca5489c9897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937373a3916f1a55a63934bdfd597fa4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4">ITM_WatchpointAction</a> { <br />
&#160;&#160;<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4ac20ba9c59b1ca0a2a66e2b18f6c25349">ITM_Disabled</a> = (0x00), 
<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4a6f5267917ea1c22c57fe8f9241a673c2">ITM_EmitPc</a> = (0x30 | 0x4), 
<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4ac8faf039ac05913295c9287771215b36">ITM_EmitDataOnReadWrite</a> = (0x800 | 0x20 | 0xc), 
<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4a9899de123384ddcdecc5ed21bbf9a74a">ITM_SamplePcAndEmitDataOnReadWrite</a> = (0x800 | 0x30 | 0x2), 
<br />
&#160;&#160;<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4acde111ce38aab3f613515bb99a701f6c">ITM_SampleDataOnRead</a> = (0x800 | 0x20 | 0xe), 
<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4aeb081e179c18b20dae2b0711e3545081">ITM_SampleDataOnWrite</a> = (0x800 | 0x20 | 0xd), 
<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4a112139dac6393353ee5ee2d6a94fb146">ITM_SamplePcAndDataOnRead</a> = (0x800 | 0x30 | 0xe), 
<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4a81dbb9db3d688f562c620600305bdcca">ITM_SamplePcAndDataOnWrite</a> = (0x800 | 0x30 | 0xd)
<br />
 }<tr class="memdesc:a937373a3916f1a55a63934bdfd597fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the action taken by the DWT on comparator match.  <a href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a937373a3916f1a55a63934bdfd597fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e174adf98212ca856d623dffe7b99f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99f">ITM_TimeStampPrescaler</a> { <a class="el" href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99fa0fa092f567f9f125de7722c7054e9762">ITM_TS_DIV_NONE</a> = 0, 
<a class="el" href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99fad256c4024037e331b872b8fd34c53100">ITM_TS_DIV_4</a> = 1, 
<a class="el" href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99fa9f7d7dff34e8a89bc945e2aa0976c325">ITM_TS_DIV_16</a> = 2, 
<a class="el" href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99fa15f4f6ba80c96a58b130bdb9c1a1b364">ITM_TS_DIV_64</a> = 3
 }<tr class="memdesc:a20e174adf98212ca856d623dffe7b99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prescaler for ITM timestamp generation based on the trace packet reference clock.  <a href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a20e174adf98212ca856d623dffe7b99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acb6d4f9ecbfe6d47c322f895c22804"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804">ITM_SyncPacketRate</a> { <a class="el" href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804afdd102cd9b084b1bcae53d08fa793838">ITM_SYNC_NONE</a> = 0, 
<a class="el" href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804afbaf2621e1a000f97c8543e4fedc1513">ITM_SYNC_TAP_BIT24</a> = 1, 
<a class="el" href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804ae0321eaecee40a16fe4700ab07c5f9bc">ITM_SYNC_TAP_BIT26</a> = 2, 
<a class="el" href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804a55c57e386b43a03439333391796cde3b">ITM_SYNC_TAP_BIT28</a> = 3
 }<tr class="memdesc:a8acb6d4f9ecbfe6d47c322f895c22804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous packet generation rate based on cycles of CYCCNT This controls how often sync packets will be generated. The tap controls which bit transition in the counter triggers a packet.  <a href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8acb6d4f9ecbfe6d47c322f895c22804"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a16102d41c7954c97735e43377beb7963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a16102d41c7954c97735e43377beb7963">ITM_open</a> (void)</td></tr>
<tr class="memdesc:a16102d41c7954c97735e43377beb7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open and configure the ITM, DWT, and TPIU. This includes muxing pins as needed.  <a href="#a16102d41c7954c97735e43377beb7963">More...</a><br /></td></tr>
<tr class="separator:a16102d41c7954c97735e43377beb7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc95beb9b7eb30359f9202f7d252fb11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#abc95beb9b7eb30359f9202f7d252fb11">ITM_close</a> (void)</td></tr>
<tr class="separator:abc95beb9b7eb30359f9202f7d252fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86439fd4831a7bfcee88c341d76c354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#aa86439fd4831a7bfcee88c341d76c354">ITM_sendBufferAtomic</a> (const uint8_t port, const char *msg, size_t length)</td></tr>
<tr class="memdesc:aa86439fd4831a7bfcee88c341d76c354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of a buffer to the stimulus port, polling to ensure the port is available.  <a href="#aa86439fd4831a7bfcee88c341d76c354">More...</a><br /></td></tr>
<tr class="separator:aa86439fd4831a7bfcee88c341d76c354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17c6a93828bd7f15d26ae2e9067240b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#aa17c6a93828bd7f15d26ae2e9067240b">ITM_send32Atomic</a> (uint8_t port, uint32_t value)</td></tr>
<tr class="memdesc:aa17c6a93828bd7f15d26ae2e9067240b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 32-bit word to the given stimulus port, polling to ensure the port is available.  <a href="#aa17c6a93828bd7f15d26ae2e9067240b">More...</a><br /></td></tr>
<tr class="separator:aa17c6a93828bd7f15d26ae2e9067240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bf5a0c94dc37972c94b13bb89f35e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#ac5bf5a0c94dc37972c94b13bb89f35e5">ITM_send16Atomic</a> (uint8_t port, uint16_t value)</td></tr>
<tr class="memdesc:ac5bf5a0c94dc37972c94b13bb89f35e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 16-bit short to the given stimulus port, polling to ensure the port is available.  <a href="#ac5bf5a0c94dc37972c94b13bb89f35e5">More...</a><br /></td></tr>
<tr class="separator:ac5bf5a0c94dc37972c94b13bb89f35e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c081b5f0d2b0cb665ba357c65e4531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a24c081b5f0d2b0cb665ba357c65e4531">ITM_send8Atomic</a> (uint8_t port, uint8_t value)</td></tr>
<tr class="memdesc:a24c081b5f0d2b0cb665ba357c65e4531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an 8-bit byte to the given stimulus port, polling to ensure the port is available.  <a href="#a24c081b5f0d2b0cb665ba357c65e4531">More...</a><br /></td></tr>
<tr class="separator:a24c081b5f0d2b0cb665ba357c65e4531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f3f408f8babda3e63b15b2fcd7048d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#ac4f3f408f8babda3e63b15b2fcd7048d">ITM_enableExceptionTrace</a> (void)</td></tr>
<tr class="memdesc:ac4f3f408f8babda3e63b15b2fcd7048d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable exception tracing This will trigger the DWT to generate packets when the device enters or leaves an exception. The ITM will forward these packets to the TPIU to be sent to the debugger.  <a href="#ac4f3f408f8babda3e63b15b2fcd7048d">More...</a><br /></td></tr>
<tr class="separator:ac4f3f408f8babda3e63b15b2fcd7048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754aef7b79fc0b3cbe6ca530ab3f6ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a754aef7b79fc0b3cbe6ca530ab3f6ee9">ITM_disableExceptionTrace</a> (void)</td></tr>
<tr class="memdesc:a754aef7b79fc0b3cbe6ca530ab3f6ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable exception tracing.  <a href="#a754aef7b79fc0b3cbe6ca530ab3f6ee9">More...</a><br /></td></tr>
<tr class="separator:a754aef7b79fc0b3cbe6ca530ab3f6ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbcfd1a2a6bc70194a83556d311fcbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#addbcfd1a2a6bc70194a83556d311fcbd">ITM_enablePCSampling</a> (bool prescale1024, uint8_t postReset)</td></tr>
<tr class="memdesc:addbcfd1a2a6bc70194a83556d311fcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable periodic sampling of the program counter using the DWT POSTCNT timer.  <a href="#addbcfd1a2a6bc70194a83556d311fcbd">More...</a><br /></td></tr>
<tr class="separator:addbcfd1a2a6bc70194a83556d311fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f591d52bf64a2f6d65106bd58634ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a2f591d52bf64a2f6d65106bd58634ea5">ITM_enableEventCounter</a> (bool prescale1024, uint8_t postReset)</td></tr>
<tr class="memdesc:a2f591d52bf64a2f6d65106bd58634ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable generation of event counter packets using the DWT POSTCNT timer.  <a href="#a2f591d52bf64a2f6d65106bd58634ea5">More...</a><br /></td></tr>
<tr class="separator:a2f591d52bf64a2f6d65106bd58634ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615f7f8d141705531fd7a5870f15d4fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a615f7f8d141705531fd7a5870f15d4fe">ITM_disablePCAndEventSampling</a> (void)</td></tr>
<tr class="memdesc:a615f7f8d141705531fd7a5870f15d4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable program counter and event sampling in the DWT.  <a href="#a615f7f8d141705531fd7a5870f15d4fe">More...</a><br /></td></tr>
<tr class="separator:a615f7f8d141705531fd7a5870f15d4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56cc8b6bba01270b080a9111e3002c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#ab56cc8b6bba01270b080a9111e3002c1">ITM_enableTimestamps</a> (<a class="el" href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99f">ITM_TimeStampPrescaler</a> tsPrescale, bool asyncMode)</td></tr>
<tr class="memdesc:ab56cc8b6bba01270b080a9111e3002c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the generation of local timestamp packets from the ITM module These are packets sent form the ITM that measure how long it has been since the previous timestamp.  <a href="#ab56cc8b6bba01270b080a9111e3002c1">More...</a><br /></td></tr>
<tr class="separator:ab56cc8b6bba01270b080a9111e3002c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b84f05e89bdb205c6f1ae8c9b3222de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a1b84f05e89bdb205c6f1ae8c9b3222de">ITM_enableSyncPackets</a> (<a class="el" href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804">ITM_SyncPacketRate</a> syncPacketRate)</td></tr>
<tr class="memdesc:a1b84f05e89bdb205c6f1ae8c9b3222de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the generation of synchronization packets from the ITM based on the CYCCNT counter. Synchronization packets can be used to recover bit-to-byte alignment information in a serial data stream.  <a href="#a1b84f05e89bdb205c6f1ae8c9b3222de">More...</a><br /></td></tr>
<tr class="separator:a1b84f05e89bdb205c6f1ae8c9b3222de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6e1ab7b441c982fee9d4d6fa5f287f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a2e6e1ab7b441c982fee9d4d6fa5f287f">ITM_enableWatchpoint</a> (<a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4">ITM_WatchpointAction</a> <a class="el" href="doxygen__drivers_8txt.html#af2a708cd58d191b2a04f35b77c7f6440">function</a>, const uintptr_t address)</td></tr>
<tr class="memdesc:a2e6e1ab7b441c982fee9d4d6fa5f287f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the watchpoint functionality using a DWT comparator.  <a href="#a2e6e1ab7b441c982fee9d4d6fa5f287f">More...</a><br /></td></tr>
<tr class="separator:a2e6e1ab7b441c982fee9d4d6fa5f287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa685bcffb779886b550614e50df79405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#aa685bcffb779886b550614e50df79405">ITM_flush</a> (void)</td></tr>
<tr class="memdesc:aa685bcffb779886b550614e50df79405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the ITM in preparation for power off of CPU domain.  <a href="#aa685bcffb779886b550614e50df79405">More...</a><br /></td></tr>
<tr class="separator:aa685bcffb779886b550614e50df79405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787885218450bd7680840f00098f46c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_t_m_8h.html#a787885218450bd7680840f00098f46c1">ITM_restore</a> (void)</td></tr>
<tr class="memdesc:a787885218450bd7680840f00098f46c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the ITM hardware to return from power off of CPU domain This will reenable DWT features, re apply the ITM pin mux.  <a href="#a787885218450bd7680840f00098f46c1">More...</a><br /></td></tr>
<tr class="separator:a787885218450bd7680840f00098f46c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a17b8fe92bb0a90af0c2bb841edb45c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b8fe92bb0a90af0c2bb841edb45c42">&sect;&nbsp;</a></span>ITM_BASE_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_BASE_ADDR&#160;&#160;&#160;(0xE0000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base address of the Instrumentation Trace Macrocell (ITM) module. </p>

</div>
</div>
<a id="a119b6e75428fdd7c6e21450a8bab3343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119b6e75428fdd7c6e21450a8bab3343">&sect;&nbsp;</a></span>ITM_DWT_BASE_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_DWT_BASE_ADDR&#160;&#160;&#160;(0xE0001000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base address of the Debug Watchpoint and Trace (DWT) module. </p>

</div>
</div>
<a id="a5f75b2f8a45f18b9d3123aa3abd85355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75b2f8a45f18b9d3123aa3abd85355">&sect;&nbsp;</a></span>ITM_SCS_BASE_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_SCS_BASE_ADDR&#160;&#160;&#160;(0xE000E000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base address of the CPU_SCS module. </p>

</div>
</div>
<a id="a25c4b373d205eb9153065ae6ea4f7491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c4b373d205eb9153065ae6ea4f7491">&sect;&nbsp;</a></span>ITM_TPIU_BASE_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_TPIU_BASE_ADDR&#160;&#160;&#160;(0xE0040000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base address of the Trace Port Instrumentation Unit (TPIU) module. </p>

</div>
</div>
<a id="a82ff30b7cbbbdeaf30f97ed5a211aeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ff30b7cbbbdeaf30f97ed5a211aeac">&sect;&nbsp;</a></span>ITM_LAR_UNLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_LAR_UNLOCK&#160;&#160;&#160;(0xC5ACCE55)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value to unlock ARM debug modules. This value should be written to the Lock Access Registers (LAR) in order to enable their configuration and use. </p>

</div>
</div>
<a id="aaefb788de5bc8c66593b709298d9cde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefb788de5bc8c66593b709298d9cde4">&sect;&nbsp;</a></span>ITM_FUNCTION_DISABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_FUNCTION_DISABLED&#160;&#160;&#160;(0x00)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device-specific values that implement the generic ITM-functions in ITM_WatchpointAction. </p>

</div>
</div>
<a id="afa5dd1af973cc317aa60de9aceb43e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5dd1af973cc317aa60de9aceb43e6c">&sect;&nbsp;</a></span>ITM_FUNCTION_EMIT_PC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_FUNCTION_EMIT_PC&#160;&#160;&#160;(0x30 | 0x4)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17ba960d5ed2582664e27d6f16fdb67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ba960d5ed2582664e27d6f16fdb67a">&sect;&nbsp;</a></span>ITM_FUNCTION_EMIT_DATA_ON_READ_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_FUNCTION_EMIT_DATA_ON_READ_WRITE&#160;&#160;&#160;(0x800 | 0x20 | 0xc)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2a2f43443471885317352216c2845cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a2f43443471885317352216c2845cb">&sect;&nbsp;</a></span>ITM_FUNCTION_EMIT_PC_ON_READ_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_FUNCTION_EMIT_PC_ON_READ_WRITE&#160;&#160;&#160;(0x800 | 0x30 | 0x2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3c5ee16d4d377fe6d3f1bacf73958a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c5ee16d4d377fe6d3f1bacf73958a7">&sect;&nbsp;</a></span>ITM_FUNCTION_EMIT_DATA_ON_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_FUNCTION_EMIT_DATA_ON_READ&#160;&#160;&#160;(0x800 | 0x20 | 0xe)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a114abc7c9d00929b6e145b69253c7a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114abc7c9d00929b6e145b69253c7a93">&sect;&nbsp;</a></span>ITM_FUNCTION_EMIT_DATA_ON_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_FUNCTION_EMIT_DATA_ON_WRITE&#160;&#160;&#160;(0x800 | 0x20 | 0xd)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79bf0b66e22e01e5453710a0309a8277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bf0b66e22e01e5453710a0309a8277">&sect;&nbsp;</a></span>ITM_FUNCTION_EMIT_PC_AND_DATA_ON_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_FUNCTION_EMIT_PC_AND_DATA_ON_READ&#160;&#160;&#160;(0x800 | 0x30 | 0xe)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97d6154950d6996ba6507a75ca44865d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d6154950d6996ba6507a75ca44865d">&sect;&nbsp;</a></span>ITM_FUNCTION_EMIT_PC_AND_DATA_ON_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_FUNCTION_EMIT_PC_AND_DATA_ON_WRITE&#160;&#160;&#160;(0x800 | 0x30 | 0xd)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42097c7b552905d45be6f672b36609cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42097c7b552905d45be6f672b36609cf">&sect;&nbsp;</a></span>ITM_port32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_port32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;(*((volatile unsigned int *)(<a class="el" href="_i_t_m_8h.html#a17b8fe92bb0a90af0c2bb841edb45c42">ITM_BASE_ADDR</a> + 4 * n)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 32-bit word to stimulus port n. </p>
<dl class="section warning"><dt>Warning</dt><dd>This does not does not first poll the port for availability. </dd></dl>

</div>
</div>
<a id="adf5d0a92dbae07a856534e154489634e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5d0a92dbae07a856534e154489634e">&sect;&nbsp;</a></span>ITM_send32Polling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_send32Polling</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span>                             \</div><div class="line">    {                              \</div><div class="line">        while (0 == <a class="code" href="_i_t_m_8h.html#a42097c7b552905d45be6f672b36609cf">ITM_port32</a>(n)) \</div><div class="line">            ;                      \</div><div class="line">        ITM_port32(n) = x;         \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="_i_t_m_8h_html_a42097c7b552905d45be6f672b36609cf"><div class="ttname"><a href="_i_t_m_8h.html#a42097c7b552905d45be6f672b36609cf">ITM_port32</a></div><div class="ttdeci">#define ITM_port32(n)</div><div class="ttdoc">Write a 32-bit word to stimulus port n. </div><div class="ttdef"><b>Definition:</b> ITM.h:237</div></div>
</div><!-- fragment -->
<p>Write a 32-bit word to stimulus port n with polling. </p>
<dl class="section warning"><dt>Warning</dt><dd>This macro does not guarantee atomic access between poll and write </dd></dl>

</div>
</div>
<a id="aecb14735a7e440e12c1601a80afc412b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb14735a7e440e12c1601a80afc412b">&sect;&nbsp;</a></span>ITM_port16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_port16</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;(*((volatile unsigned short *)(<a class="el" href="_i_t_m_8h.html#a17b8fe92bb0a90af0c2bb841edb45c42">ITM_BASE_ADDR</a> + 4 * n)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 16-bit half word to stimulus port n. </p>
<dl class="section warning"><dt>Warning</dt><dd>This does not does not first poll the port for availability. </dd></dl>

</div>
</div>
<a id="a77e05582b2936451bc63fb963467315c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e05582b2936451bc63fb963467315c">&sect;&nbsp;</a></span>ITM_send16Polling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_send16Polling</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span>                             \</div><div class="line">    {                              \</div><div class="line">        while (0 == <a class="code" href="_i_t_m_8h.html#aecb14735a7e440e12c1601a80afc412b">ITM_port16</a>(n)) \</div><div class="line">            ;                      \</div><div class="line">        ITM_port16(n) = x;         \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="_i_t_m_8h_html_aecb14735a7e440e12c1601a80afc412b"><div class="ttname"><a href="_i_t_m_8h.html#aecb14735a7e440e12c1601a80afc412b">ITM_port16</a></div><div class="ttdeci">#define ITM_port16(n)</div><div class="ttdoc">Write a 16-bit half word to stimulus port n. </div><div class="ttdef"><b>Definition:</b> ITM.h:263</div></div>
</div><!-- fragment -->
<p>Write a 16-bit word to stimulus port n with polling. </p>
<dl class="section warning"><dt>Warning</dt><dd>This macro does not guarantee atomic access between poll and write </dd></dl>

</div>
</div>
<a id="a1ff85e0d732215d06f483a798a8d9a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff85e0d732215d06f483a798a8d9a47">&sect;&nbsp;</a></span>ITM_port8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_port8</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;(*((volatile unsigned char *)(<a class="el" href="_i_t_m_8h.html#a17b8fe92bb0a90af0c2bb841edb45c42">ITM_BASE_ADDR</a> + 4 * n)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a byte to stimulus port n. </p>
<dl class="section warning"><dt>Warning</dt><dd>This does not does not first poll the port for availability. </dd></dl>

</div>
</div>
<a id="ab76f9d46e6391b7e2321b8a28e4665b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76f9d46e6391b7e2321b8a28e4665b7">&sect;&nbsp;</a></span>ITM_send8Polling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITM_send8Polling</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span>                            \</div><div class="line">    {                             \</div><div class="line">        while (0 == <a class="code" href="_i_t_m_8h.html#a1ff85e0d732215d06f483a798a8d9a47">ITM_port8</a>(n)) \</div><div class="line">            ;                     \</div><div class="line">        ITM_port8(n) = x;         \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="_i_t_m_8h_html_a1ff85e0d732215d06f483a798a8d9a47"><div class="ttname"><a href="_i_t_m_8h.html#a1ff85e0d732215d06f483a798a8d9a47">ITM_port8</a></div><div class="ttdeci">#define ITM_port8(n)</div><div class="ttdoc">Write a byte to stimulus port n. </div><div class="ttdef"><b>Definition:</b> ITM.h:284</div></div>
</div><!-- fragment -->
<p>Write a 8-bit word to stimulus port n with polling. </p>
<dl class="section warning"><dt>Warning</dt><dd>This macro does not guarantee atomic access between poll and write </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a92abaf1991f9421d7b642ca5489c9897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92abaf1991f9421d7b642ca5489c9897">&sect;&nbsp;</a></span>ITM_TPIU_PortFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i_t_m_8h.html#a92abaf1991f9421d7b642ca5489c9897">ITM_TPIU_PortFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a92abaf1991f9421d7b642ca5489c9897a9dbe5b7df6645097a4364d02c20d2a7d"></a>ITM_TPIU_SWO_MANCHESTER&#160;</td><td class="fielddoc"><p>Serial format is manchester </p>
</td></tr>
<tr><td class="fieldname"><a id="a92abaf1991f9421d7b642ca5489c9897a98249a1e3b05e6ec7e0789ea266ec772"></a>ITM_TPIU_SWO_UART&#160;</td><td class="fielddoc"><p>Serial format is UART </p>
</td></tr>
</table>

</div>
</div>
<a id="a937373a3916f1a55a63934bdfd597fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937373a3916f1a55a63934bdfd597fa4">&sect;&nbsp;</a></span>ITM_WatchpointAction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4">ITM_WatchpointAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the action taken by the DWT on comparator match. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a937373a3916f1a55a63934bdfd597fa4ac20ba9c59b1ca0a2a66e2b18f6c25349"></a>ITM_Disabled&#160;</td><td class="fielddoc"><p>Disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="a937373a3916f1a55a63934bdfd597fa4a6f5267917ea1c22c57fe8f9241a673c2"></a>ITM_EmitPc&#160;</td><td class="fielddoc"><p>Emit Program Counter </p>
</td></tr>
<tr><td class="fieldname"><a id="a937373a3916f1a55a63934bdfd597fa4ac8faf039ac05913295c9287771215b36"></a>ITM_EmitDataOnReadWrite&#160;</td><td class="fielddoc"><p>Emit Data on Read or Write </p>
</td></tr>
<tr><td class="fieldname"><a id="a937373a3916f1a55a63934bdfd597fa4a9899de123384ddcdecc5ed21bbf9a74a"></a>ITM_SamplePcAndEmitDataOnReadWrite&#160;</td><td class="fielddoc"><p>Emit Program Counter on Read or Write </p>
</td></tr>
<tr><td class="fieldname"><a id="a937373a3916f1a55a63934bdfd597fa4acde111ce38aab3f613515bb99a701f6c"></a>ITM_SampleDataOnRead&#160;</td><td class="fielddoc"><p>Sample Data on Read </p>
</td></tr>
<tr><td class="fieldname"><a id="a937373a3916f1a55a63934bdfd597fa4aeb081e179c18b20dae2b0711e3545081"></a>ITM_SampleDataOnWrite&#160;</td><td class="fielddoc"><p>Sample Data on Write </p>
</td></tr>
<tr><td class="fieldname"><a id="a937373a3916f1a55a63934bdfd597fa4a112139dac6393353ee5ee2d6a94fb146"></a>ITM_SamplePcAndDataOnRead&#160;</td><td class="fielddoc"><p>Sample PC and Data on Read </p>
</td></tr>
<tr><td class="fieldname"><a id="a937373a3916f1a55a63934bdfd597fa4a81dbb9db3d688f562c620600305bdcca"></a>ITM_SamplePcAndDataOnWrite&#160;</td><td class="fielddoc"><p>Sample PC and Data on Write </p>
</td></tr>
</table>

</div>
</div>
<a id="a20e174adf98212ca856d623dffe7b99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e174adf98212ca856d623dffe7b99f">&sect;&nbsp;</a></span>ITM_TimeStampPrescaler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99f">ITM_TimeStampPrescaler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prescaler for ITM timestamp generation based on the trace packet reference clock. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a20e174adf98212ca856d623dffe7b99fa0fa092f567f9f125de7722c7054e9762"></a>ITM_TS_DIV_NONE&#160;</td><td class="fielddoc"><p>No division </p>
</td></tr>
<tr><td class="fieldname"><a id="a20e174adf98212ca856d623dffe7b99fad256c4024037e331b872b8fd34c53100"></a>ITM_TS_DIV_4&#160;</td><td class="fielddoc"><p>Divide by 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="a20e174adf98212ca856d623dffe7b99fa9f7d7dff34e8a89bc945e2aa0976c325"></a>ITM_TS_DIV_16&#160;</td><td class="fielddoc"><p>Divide by 16 </p>
</td></tr>
<tr><td class="fieldname"><a id="a20e174adf98212ca856d623dffe7b99fa15f4f6ba80c96a58b130bdb9c1a1b364"></a>ITM_TS_DIV_64&#160;</td><td class="fielddoc"><p>Divide by 64 </p>
</td></tr>
</table>

</div>
</div>
<a id="a8acb6d4f9ecbfe6d47c322f895c22804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acb6d4f9ecbfe6d47c322f895c22804">&sect;&nbsp;</a></span>ITM_SyncPacketRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804">ITM_SyncPacketRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous packet generation rate based on cycles of CYCCNT This controls how often sync packets will be generated. The tap controls which bit transition in the counter triggers a packet. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8acb6d4f9ecbfe6d47c322f895c22804afdd102cd9b084b1bcae53d08fa793838"></a>ITM_SYNC_NONE&#160;</td><td class="fielddoc"><p>Disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="a8acb6d4f9ecbfe6d47c322f895c22804afbaf2621e1a000f97c8543e4fedc1513"></a>ITM_SYNC_TAP_BIT24&#160;</td><td class="fielddoc"><p>Tap the CYCCNT register at bit 24 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8acb6d4f9ecbfe6d47c322f895c22804ae0321eaecee40a16fe4700ab07c5f9bc"></a>ITM_SYNC_TAP_BIT26&#160;</td><td class="fielddoc"><p>Tap the CYCCNT register at bit 26 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8acb6d4f9ecbfe6d47c322f895c22804a55c57e386b43a03439333391796cde3b"></a>ITM_SYNC_TAP_BIT28&#160;</td><td class="fielddoc"><p>Tap the CYCCNT register at bit 28 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a16102d41c7954c97735e43377beb7963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16102d41c7954c97735e43377beb7963">&sect;&nbsp;</a></span>ITM_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ITM_open </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open and configure the ITM, DWT, and TPIU. This includes muxing pins as needed. </p>
<dl class="section return"><dt>Returns</dt><dd>true - The ITM was successfully configured and the pins were acquired </dd>
<dd>
false - Pin muxing failed and the ITM was not configured </dd></dl>

</div>
</div>
<a id="abc95beb9b7eb30359f9202f7d252fb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc95beb9b7eb30359f9202f7d252fb11">&sect;&nbsp;</a></span>ITM_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the ITM, when it is no longer in use, it will be shutdown. This will also turn off any additional features that were enabled such as PC sampling or interrupt tracing</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i_t_m_8h.html#a16102d41c7954c97735e43377beb7963" title="Open and configure the ITM, DWT, and TPIU. This includes muxing pins as needed. ">ITM_open()</a> </dd></dl>

</div>
</div>
<a id="aa86439fd4831a7bfcee88c341d76c354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86439fd4831a7bfcee88c341d76c354">&sect;&nbsp;</a></span>ITM_sendBufferAtomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_sendBufferAtomic </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the contents of a buffer to the stimulus port, polling to ensure the port is available. </p>
<dl class="section warning"><dt>Warning</dt><dd>This API will disable interrupts for the entire buffer duration Use it cautiously to prevent negatively impacting interrupt latency</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The stimulus port to use </td></tr>
    <tr><td class="paramname">msg</td><td>Data to send. </td></tr>
    <tr><td class="paramname">length</td><td>length of buffer in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa17c6a93828bd7f15d26ae2e9067240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17c6a93828bd7f15d26ae2e9067240b">&sect;&nbsp;</a></span>ITM_send32Atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_send32Atomic </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 32-bit word to the given stimulus port, polling to ensure the port is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The stimulus port to use </td></tr>
    <tr><td class="paramname">value</td><td>The 32-bit value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5bf5a0c94dc37972c94b13bb89f35e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bf5a0c94dc37972c94b13bb89f35e5">&sect;&nbsp;</a></span>ITM_send16Atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_send16Atomic </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 16-bit short to the given stimulus port, polling to ensure the port is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The stimulus port to use </td></tr>
    <tr><td class="paramname">value</td><td>The 16-bit value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24c081b5f0d2b0cb665ba357c65e4531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c081b5f0d2b0cb665ba357c65e4531">&sect;&nbsp;</a></span>ITM_send8Atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_send8Atomic </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an 8-bit byte to the given stimulus port, polling to ensure the port is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The stimulus port to use </td></tr>
    <tr><td class="paramname">value</td><td>The 8-bit value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4f3f408f8babda3e63b15b2fcd7048d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f3f408f8babda3e63b15b2fcd7048d">&sect;&nbsp;</a></span>ITM_enableExceptionTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_enableExceptionTrace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable exception tracing This will trigger the DWT to generate packets when the device enters or leaves an exception. The ITM will forward these packets to the TPIU to be sent to the debugger. </p>

</div>
</div>
<a id="a754aef7b79fc0b3cbe6ca530ab3f6ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754aef7b79fc0b3cbe6ca530ab3f6ee9">&sect;&nbsp;</a></span>ITM_disableExceptionTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_disableExceptionTrace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable exception tracing. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i_t_m_8h.html#ac4f3f408f8babda3e63b15b2fcd7048d" title="Enable exception tracing This will trigger the DWT to generate packets when the device enters or leav...">ITM_enableExceptionTrace()</a> </dd></dl>

</div>
</div>
<a id="addbcfd1a2a6bc70194a83556d311fcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbcfd1a2a6bc70194a83556d311fcbd">&sect;&nbsp;</a></span>ITM_enablePCSampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_enablePCSampling </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prescale1024</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>postReset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable periodic sampling of the program counter using the DWT POSTCNT timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prescale1024</td><td>true: divide system clock by 1024 to generate POSTCNT false: divide system clock by 64 to generate POSTCNT </td></tr>
    <tr><td class="paramname">postReset</td><td>4-bit downcounter that is reloaded on POSTCNT expiration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>PC sampling and event counting are mutally exclusive. It is not recommended to call <a class="el" href="_i_t_m_8h.html#a2f591d52bf64a2f6d65106bd58634ea5">ITM_enableEventCounter()</a> after this API has been called </dd></dl>

</div>
</div>
<a id="a2f591d52bf64a2f6d65106bd58634ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f591d52bf64a2f6d65106bd58634ea5">&sect;&nbsp;</a></span>ITM_enableEventCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_enableEventCounter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prescale1024</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>postReset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable generation of event counter packets using the DWT POSTCNT timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prescale1024</td><td>true: divide system clock by 1024 to generate POSTCNT false: divide system clock by 64 to generate POSTCNT </td></tr>
    <tr><td class="paramname">postReset</td><td>4-bit downcounter that is reloaded on POSTCNT expiration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>PC sampling and event counting are mutally exclusive. It is not recommended to call <a class="el" href="_i_t_m_8h.html#addbcfd1a2a6bc70194a83556d311fcbd">ITM_enablePCSampling()</a> after this API has been called </dd></dl>

</div>
</div>
<a id="a615f7f8d141705531fd7a5870f15d4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615f7f8d141705531fd7a5870f15d4fe">&sect;&nbsp;</a></span>ITM_disablePCAndEventSampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_disablePCAndEventSampling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable program counter and event sampling in the DWT. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i_t_m_8h.html#addbcfd1a2a6bc70194a83556d311fcbd" title="Enable periodic sampling of the program counter using the DWT POSTCNT timer. ">ITM_enablePCSampling()</a>, <a class="el" href="_i_t_m_8h.html#a2f591d52bf64a2f6d65106bd58634ea5" title="Enable generation of event counter packets using the DWT POSTCNT timer. ">ITM_enableEventCounter</a> </dd></dl>

</div>
</div>
<a id="ab56cc8b6bba01270b080a9111e3002c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56cc8b6bba01270b080a9111e3002c1">&sect;&nbsp;</a></span>ITM_enableTimestamps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_enableTimestamps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i_t_m_8h.html#a20e174adf98212ca856d623dffe7b99f">ITM_TimeStampPrescaler</a>&#160;</td>
          <td class="paramname"><em>tsPrescale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asyncMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the generation of local timestamp packets from the ITM module These are packets sent form the ITM that measure how long it has been since the previous timestamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tsPrescale</td><td>Prescaler value for the timestamp clock. </td></tr>
    <tr><td class="paramname">asyncMode</td><td>true: Synchronous mode - generate timestamps by dividing the system clock. false: Asynchronous mode - generate timestamps by dividing the TPIU clock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b84f05e89bdb205c6f1ae8c9b3222de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b84f05e89bdb205c6f1ae8c9b3222de">&sect;&nbsp;</a></span>ITM_enableSyncPackets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_enableSyncPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i_t_m_8h.html#a8acb6d4f9ecbfe6d47c322f895c22804">ITM_SyncPacketRate</a>&#160;</td>
          <td class="paramname"><em>syncPacketRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the generation of synchronization packets from the ITM based on the CYCCNT counter. Synchronization packets can be used to recover bit-to-byte alignment information in a serial data stream. </p>
<dl class="section warning"><dt>Warning</dt><dd>When using the TPIU as a asynchronous serial trace port ARM recommends disabling these packets to reduce stream bandwith.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncPacketRate</td><td>Tap for CYCCNT. Controls the frequency of sync packets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e6e1ab7b441c982fee9d4d6fa5f287f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6e1ab7b441c982fee9d4d6fa5f287f">&sect;&nbsp;</a></span>ITM_enableWatchpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ITM_enableWatchpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4">ITM_WatchpointAction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the watchpoint functionality using a DWT comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The DWT_FUNCTION field to be programmed. This controls what data is emitted on comparator match see <a class="el" href="_i_t_m_8h.html#a937373a3916f1a55a63934bdfd597fa4">ITM_WatchpointAction</a> for possible values </td></tr>
    <tr><td class="paramname">address</td><td>The address for the comparator to match on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The watchpoint was successfully set </dd>
<dd>
false There was no watchpoint available (all are in use) </dd></dl>

</div>
</div>
<a id="aa685bcffb779886b550614e50df79405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa685bcffb779886b550614e50df79405">&sect;&nbsp;</a></span>ITM_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the ITM in preparation for power off of CPU domain. </p>
<p>This will disable PC sampling, and other DWT features, flush the fifo and (if applicable) setup the PIN as a GPIO.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be called from ISR context</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is invoked by the DPL power policy right before entering IDLE/DEEPSLEEP. By default it is an empty stub so that the power policy doesn't incur the flush overhead when ITM isn't used. When ITM is enabled this function will be strongly defined by SYSCFG. </dd></dl>

</div>
</div>
<a id="a787885218450bd7680840f00098f46c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787885218450bd7680840f00098f46c1">&sect;&nbsp;</a></span>ITM_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ITM_restore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the ITM hardware to return from power off of CPU domain This will reenable DWT features, re apply the ITM pin mux. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be called from ISR context</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is invoked by the DPL power policy right after leaving IDLE/DEEPSLEEP. By default it is an empty stub so that the power policy doesn't incur the flush overhead when ITM isn't used. When ITM is enabled this function will be strongly defined by SYSCFG. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
