<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>CryptoUtils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_15fb9a92674a5e15cac1f3112cfb19ae.html">drivers</a></li><li class="navelem"><a class="el" href="dir_b052a18d625aa9eac33fab32980dea61.html">cryptoutils</a></li><li class="navelem"><a class="el" href="dir_51218169917087e50c64785603cb6b50.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CryptoUtils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of utility functions for cryptographic purposes. </p>
<p>============================================================================ </p>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for CryptoUtils.h:</div>
<div class="dyncontent">
<div class="center"><img src="_crypto_utils_8h__incl.png" border="0" usemap="#_crypto_utils_8h" alt=""/></div>
<map name="_crypto_utils_8h" id="_crypto_utils_8h">
</map>
</div>
</div>
<p><a href="_crypto_utils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa8886027241f60fc9b0df815586fb480"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#aa8886027241f60fc9b0df815586fb480">CryptoUtils_Endianess</a> { <a class="el" href="_crypto_utils_8h.html#aa8886027241f60fc9b0df815586fb480aacbef4afb276f3f188b38efdf7b6bb67">CryptoUtils_ENDIANESS_BIG</a> = 0u, 
<a class="el" href="_crypto_utils_8h.html#aa8886027241f60fc9b0df815586fb480a2f4ec9eb053da51fe070d81e99ca926c">CryptoUtils_ENDIANESS_LITTLE</a> = 1u
 }<tr class="memdesc:aa8886027241f60fc9b0df815586fb480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the endianess (byte order) of a multi-byte value.  <a href="_crypto_utils_8h.html#aa8886027241f60fc9b0df815586fb480">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa8886027241f60fc9b0df815586fb480"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a129318383b475594fd17cf1f1d0a04b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#a129318383b475594fd17cf1f1d0a04b3">CryptoUtils_buffersMatch</a> (const volatile void *volatile buffer0, const volatile void *volatile buffer1, size_t bufferByteLength)</td></tr>
<tr class="memdesc:a129318383b475594fd17cf1f1d0a04b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two buffers for equality without branching.  <a href="#a129318383b475594fd17cf1f1d0a04b3">More...</a><br /></td></tr>
<tr class="separator:a129318383b475594fd17cf1f1d0a04b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3615e127059d7e2049421d81c47cd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#aae3615e127059d7e2049421d81c47cd1">CryptoUtils_buffersMatchWordAligned</a> (const volatile uint32_t *volatile buffer0, const volatile uint32_t *volatile buffer1, size_t bufferByteLength)</td></tr>
<tr class="memdesc:aae3615e127059d7e2049421d81c47cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two buffers for equality word-by-word without branching.  <a href="#aae3615e127059d7e2049421d81c47cd1">More...</a><br /></td></tr>
<tr class="separator:aae3615e127059d7e2049421d81c47cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46b40dca481aa47aa00867c625e29ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#ad46b40dca481aa47aa00867c625e29ec">CryptoUtils_isBufferAllZeros</a> (const void *buffer, size_t bufferByteLength)</td></tr>
<tr class="memdesc:ad46b40dca481aa47aa00867c625e29ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the provided buffer only contains 0x00 bytes.  <a href="#ad46b40dca481aa47aa00867c625e29ec">More...</a><br /></td></tr>
<tr class="separator:ad46b40dca481aa47aa00867c625e29ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb9c9d2e060a8e5d35bdbf26e005e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#aeeb9c9d2e060a8e5d35bdbf26e005e14">CryptoUtils_memset</a> (void *dest, size_t destSize, uint8_t val, size_t count)</td></tr>
<tr class="memdesc:aeeb9c9d2e060a8e5d35bdbf26e005e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>val</code> into the first <code>count</code> bytes of the buffer pointed to by <code>dest</code>.  <a href="#aeeb9c9d2e060a8e5d35bdbf26e005e14">More...</a><br /></td></tr>
<tr class="separator:aeeb9c9d2e060a8e5d35bdbf26e005e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5272fb483ed7d4851fb80c75262b0ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#a5272fb483ed7d4851fb80c75262b0ed8">CryptoUtils_reverseBufferBytewise</a> (void *buffer, size_t bufferByteLength)</td></tr>
<tr class="memdesc:a5272fb483ed7d4851fb80c75262b0ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the byte order in a buffer of a given length.  <a href="#a5272fb483ed7d4851fb80c75262b0ed8">More...</a><br /></td></tr>
<tr class="separator:a5272fb483ed7d4851fb80c75262b0ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30cb9ca38ce2e29fa6278d594803304"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#ab30cb9ca38ce2e29fa6278d594803304">CryptoUtils_copyPad</a> (const void *source, uint32_t *destination, size_t sourceLength)</td></tr>
<tr class="memdesc:ab30cb9ca38ce2e29fa6278d594803304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies and pads an array of words.  <a href="#ab30cb9ca38ce2e29fa6278d594803304">More...</a><br /></td></tr>
<tr class="separator:ab30cb9ca38ce2e29fa6278d594803304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dec0653eaff204ac209fbde7c8dfa1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#a1dec0653eaff204ac209fbde7c8dfa1f">CryptoUtils_reverseCopyPad</a> (const void *source, uint32_t *destination, size_t sourceLength)</td></tr>
<tr class="memdesc:a1dec0653eaff204ac209fbde7c8dfa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses, copies, and pads an array of words.  <a href="#a1dec0653eaff204ac209fbde7c8dfa1f">More...</a><br /></td></tr>
<tr class="separator:a1dec0653eaff204ac209fbde7c8dfa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3473aead5a4596fee8c38431f56bfbc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#a3473aead5a4596fee8c38431f56bfbc2">CryptoUtils_reverseCopy</a> (const void *source, void *destination, size_t sourceLength)</td></tr>
<tr class="memdesc:a3473aead5a4596fee8c38431f56bfbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses and copies an array of bytes.  <a href="#a3473aead5a4596fee8c38431f56bfbc2">More...</a><br /></td></tr>
<tr class="separator:a3473aead5a4596fee8c38431f56bfbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834df5fd62ca6fd298d471127147f91e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#a834df5fd62ca6fd298d471127147f91e">CryptoUtils_isNumberInRange</a> (const void *number, size_t bitLength, <a class="el" href="_crypto_utils_8h.html#aa8886027241f60fc9b0df815586fb480">CryptoUtils_Endianess</a> endianess, const void *lowerLimit, const void *upperLimit)</td></tr>
<tr class="memdesc:a834df5fd62ca6fd298d471127147f91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if number is within the range [lowerLimit, upperLimit)  <a href="#a834df5fd62ca6fd298d471127147f91e">More...</a><br /></td></tr>
<tr class="separator:a834df5fd62ca6fd298d471127147f91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad691f4762b00aaabe9b624d01f45a131"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#ad691f4762b00aaabe9b624d01f45a131">CryptoUtils_limitZero</a></td></tr>
<tr class="memdesc:ad691f4762b00aaabe9b624d01f45a131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit value of 0.  <a href="#ad691f4762b00aaabe9b624d01f45a131">More...</a><br /></td></tr>
<tr class="separator:ad691f4762b00aaabe9b624d01f45a131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e03f3453ad6a977d9db6117f04ff525"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_crypto_utils_8h.html#a2e03f3453ad6a977d9db6117f04ff525">CryptoUtils_limitOne</a></td></tr>
<tr class="memdesc:a2e03f3453ad6a977d9db6117f04ff525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit value of 1.  <a href="#a2e03f3453ad6a977d9db6117f04ff525">More...</a><br /></td></tr>
<tr class="separator:a2e03f3453ad6a977d9db6117f04ff525"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa8886027241f60fc9b0df815586fb480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8886027241f60fc9b0df815586fb480">&sect;&nbsp;</a></span>CryptoUtils_Endianess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_crypto_utils_8h.html#aa8886027241f60fc9b0df815586fb480">CryptoUtils_Endianess</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the endianess (byte order) of a multi-byte value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa8886027241f60fc9b0df815586fb480aacbef4afb276f3f188b38efdf7b6bb67"></a>CryptoUtils_ENDIANESS_BIG&#160;</td><td class="fielddoc"><p>MSB at lowest address. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa8886027241f60fc9b0df815586fb480a2f4ec9eb053da51fe070d81e99ca926c"></a>CryptoUtils_ENDIANESS_LITTLE&#160;</td><td class="fielddoc"><p>LSB at highest address. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a129318383b475594fd17cf1f1d0a04b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129318383b475594fd17cf1f1d0a04b3">&sect;&nbsp;</a></span>CryptoUtils_buffersMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CryptoUtils_buffersMatch </td>
          <td>(</td>
          <td class="paramtype">const volatile void *volatile&#160;</td>
          <td class="paramname"><em>buffer0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile void *volatile&#160;</td>
          <td class="paramname"><em>buffer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferByteLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two buffers for equality without branching. </p>
<dl class="section note"><dt>Note</dt><dd>This is not a drop-in replacement for memcmp!</dd></dl>
<p>Most memcmp implementations break out of their comparison loop immediately once a mismatch is detected to save execution time. For cryptographic purposes, this is a flaw.</p>
<p>This function compares two buffers without branching thus requiring a an amount of time that does not vary with the content of <code>buffer0</code> and <code>buffer1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer0</td><td>Buffer to compare against <code>buffer1</code>. </td></tr>
    <tr><td class="paramname">buffer1</td><td>Buffer tp compare against <code>buffer0</code> </td></tr>
    <tr><td class="paramname">bufferByteLength</td><td>Length in bytes of <code>buffer0</code> and <code>buffer1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The contents of the buffers match. </td></tr>
    <tr><td class="paramname">false</td><td>The contents of the buffers do not match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae3615e127059d7e2049421d81c47cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3615e127059d7e2049421d81c47cd1">&sect;&nbsp;</a></span>CryptoUtils_buffersMatchWordAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CryptoUtils_buffersMatchWordAligned </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t *volatile&#160;</td>
          <td class="paramname"><em>buffer0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile uint32_t *volatile&#160;</td>
          <td class="paramname"><em>buffer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferByteLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two buffers for equality word-by-word without branching. </p>
<dl class="section note"><dt>Note</dt><dd>This is not a drop-in replacement for memcmp!</dd></dl>
<p>Most memcmp implementations break out of their comparison loop immediately once a mismatch is detected to save execution time. For cryptographic purposes, this is a flaw.</p>
<p>This function compares two buffers without branching thus requiring a an amount of time that does not vary with the content of <code>buffer0</code> and <code>buffer1</code>.</p>
<p>Unlike <a class="el" href="_crypto_utils_8h.html#a129318383b475594fd17cf1f1d0a04b3" title="Compares two buffers for equality without branching. ">CryptoUtils_buffersMatch()</a>, this function expects <code>buffer0</code> and <code>buffer1</code> to be 32-bit aligned. It will only perform 32-bit aligned accesses to memory. This is needed to access the registers of certain peripherals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer0</td><td>Buffer to compare against <code>buffer1</code>. </td></tr>
    <tr><td class="paramname">buffer1</td><td>Buffer tp compare against <code>buffer0</code> </td></tr>
    <tr><td class="paramname">bufferByteLength</td><td>Length in bytes of <code>buffer0</code> and <code>buffer1</code>. Must be evenly divisible by sizeof(uint32_t). This function will return false if <code>bufferByteLength</code> is not evenly divisible by sizeof(uin32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The contents of the buffers match. </td></tr>
    <tr><td class="paramname">false</td><td>The contents of the buffers do not match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad46b40dca481aa47aa00867c625e29ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46b40dca481aa47aa00867c625e29ec">&sect;&nbsp;</a></span>CryptoUtils_isBufferAllZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CryptoUtils_isBufferAllZeros </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferByteLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the provided buffer only contains 0x00 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to search for non-zero bytes </td></tr>
    <tr><td class="paramname">bufferByteLength</td><td>Length of <code>buffer</code> in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The buffer contained only bytes with value 0x00 </td></tr>
    <tr><td class="paramname">false</td><td>The buffer contained at least on non-zero byte </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeb9c9d2e060a8e5d35bdbf26e005e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb9c9d2e060a8e5d35bdbf26e005e14">&sect;&nbsp;</a></span>CryptoUtils_memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CryptoUtils_memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies <code>val</code> into the first <code>count</code> bytes of the buffer pointed to by <code>dest</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer </td></tr>
    <tr><td class="paramname">destSize</td><td>Size of destination buffer in bytes </td></tr>
    <tr><td class="paramname">val</td><td>Fill byte value </td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5272fb483ed7d4851fb80c75262b0ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5272fb483ed7d4851fb80c75262b0ed8">&sect;&nbsp;</a></span>CryptoUtils_reverseBufferBytewise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CryptoUtils_reverseBufferBytewise </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferByteLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the byte order in a buffer of a given length. </p>
<p>The left-most byte will become the right-most byte and vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer containing the data to be reversed. </td></tr>
    <tr><td class="paramname">bufferByteLength</td><td>Length in bytes of <code>buffer</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab30cb9ca38ce2e29fa6278d594803304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30cb9ca38ce2e29fa6278d594803304">&sect;&nbsp;</a></span>CryptoUtils_copyPad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CryptoUtils_copyPad </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sourceLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies and pads an array of words. </p>
<p>The <code>source</code> array is copied into the <code>destination</code> array. Writes are done word-wise. If <code>sourceLength</code> is not a multiple of 4, any remaining bytes up to the next word boundary are padded with 0.</p>
<p>The length of the destination array must be a multiple of 4, rounded up to the padded <code>sourceLength</code> if required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source array</td></tr>
    <tr><td class="paramname">destination</td><td>Destination array</td></tr>
    <tr><td class="paramname">sourceLength</td><td>Length of the source array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dec0653eaff204ac209fbde7c8dfa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dec0653eaff204ac209fbde7c8dfa1f">&sect;&nbsp;</a></span>CryptoUtils_reverseCopyPad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CryptoUtils_reverseCopyPad </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sourceLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses, copies, and pads an array of words. </p>
<p>The <code>source</code> array is reversed byte-wise and copied into the <code>destination</code> array. Writes are done word-wise. If <code>sourceLength</code> is not a multiple of 4, any remaining bytes up to the next word boundary are padded with 0.</p>
<p>The length of the destination array must be a multiple of 4, rounded up to the padded <code>sourceLength</code> if required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source array</td></tr>
    <tr><td class="paramname">destination</td><td>Destination array</td></tr>
    <tr><td class="paramname">sourceLength</td><td>Length of the source array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3473aead5a4596fee8c38431f56bfbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3473aead5a4596fee8c38431f56bfbc2">&sect;&nbsp;</a></span>CryptoUtils_reverseCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CryptoUtils_reverseCopy </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sourceLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses and copies an array of bytes. </p>
<p>The <code>source</code> array is reversed byte-wise and copied into the <code>destination</code> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source array</td></tr>
    <tr><td class="paramname">destination</td><td>Destination array</td></tr>
    <tr><td class="paramname">sourceLength</td><td>Length of the source array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a834df5fd62ca6fd298d471127147f91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834df5fd62ca6fd298d471127147f91e">&sect;&nbsp;</a></span>CryptoUtils_isNumberInRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CryptoUtils_isNumberInRange </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_crypto_utils_8h.html#aa8886027241f60fc9b0df815586fb480">CryptoUtils_Endianess</a>&#160;</td>
          <td class="paramname"><em>endianess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>lowerLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>upperLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if number is within the range [lowerLimit, upperLimit) </p>
<p>Checks if the specified number is at greater than or equal to the lower limit and less than the upper limit. Note that the boundary set by the upper limit is not inclusive.</p>
<p>Note that the special values of <a class="el" href="_crypto_utils_8h.html#ad691f4762b00aaabe9b624d01f45a131" title="Limit value of 0. ">CryptoUtils_limitZero</a> and <a class="el" href="_crypto_utils_8h.html#a2e03f3453ad6a977d9db6117f04ff525" title="Limit value of 1. ">CryptoUtils_limitOne</a> are available to pass in for the <code>lowerLimit</code>. (These values can also be used for the <code>upperLimit</code> but their use for the upperLimit has no practical use.)</p>
<p>If <code>lowerLimit</code> is NULL then the lower limit is taken as 0. If <code>upperLimit</code> is NULL then the upper limit is taken as 2<sup>(<code>bitLength</code> + 1)</sup>.</p>
<p>The implemented algorithm is timing-constant when the following parameters are held constant: <code>lowerLimit</code>, <code>upperLimit</code>, <code>bitLength</code>, and <code>endianess</code>. Thus, the <code>number</code> being checked may change and timing will not leak its relation to the limits. However, timing may leak the bitLength, the endianess, and the use of <a class="el" href="_crypto_utils_8h.html#ad691f4762b00aaabe9b624d01f45a131" title="Limit value of 0. ">CryptoUtils_limitZero</a>, <a class="el" href="_crypto_utils_8h.html#a2e03f3453ad6a977d9db6117f04ff525" title="Limit value of 1. ">CryptoUtils_limitOne</a>, and NULL for the limit values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Pointer to number to check </td></tr>
    <tr><td class="paramname">bitLength</td><td>Length in bits of <code>number</code>, <code>lowerLimit</code>, and <code>upperLimit</code>. </td></tr>
    <tr><td class="paramname">endianess</td><td>The endianess of <code>number</code>, <code>lowerLimit</code>, and <code>upperLimit</code>. </td></tr>
    <tr><td class="paramname">lowerLimit</td><td>Pointer to lower limit value. </td></tr>
    <tr><td class="paramname">upperLimit</td><td>Pointer to upper limit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The randomNumber is within [<code>lowerLimit</code>, <code>upperLimit</code>). </td></tr>
    <tr><td class="paramname">false</td><td>The randomNumber is not within [<code>lowerLimit</code>, <code>upperLimit</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad691f4762b00aaabe9b624d01f45a131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad691f4762b00aaabe9b624d01f45a131">&sect;&nbsp;</a></span>CryptoUtils_limitZero</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* CryptoUtils_limitZero</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limit value of 0. </p>
<p>This is a value provided for convenience when checking a value against a range.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_crypto_utils_8h.html#a2e03f3453ad6a977d9db6117f04ff525" title="Limit value of 1. ">CryptoUtils_limitOne</a> </dd>
<dd>
<a class="el" href="_crypto_utils_8h.html#a834df5fd62ca6fd298d471127147f91e" title="Checks if number is within the range [lowerLimit, upperLimit) ">CryptoUtils_isNumberInRange</a> </dd></dl>

</div>
</div>
<a id="a2e03f3453ad6a977d9db6117f04ff525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e03f3453ad6a977d9db6117f04ff525">&sect;&nbsp;</a></span>CryptoUtils_limitOne</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* CryptoUtils_limitOne</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limit value of 1. </p>
<p>This is a value provided for convenience when checking a value against a range.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_crypto_utils_8h.html#ad691f4762b00aaabe9b624d01f45a131" title="Limit value of 0. ">CryptoUtils_limitZero</a> </dd>
<dd>
<a class="el" href="_crypto_utils_8h.html#a834df5fd62ca6fd298d471127147f91e" title="Checks if number is within the range [lowerLimit, upperLimit) ">CryptoUtils_isNumberInRange</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">Â© Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
