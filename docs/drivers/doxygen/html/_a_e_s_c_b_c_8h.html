<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>AESCBC.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_15fb9a92674a5e15cac1f3112cfb19ae.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">AESCBC.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>AESCBC driver header. </p>
<hr/>
<p><a class="anchor" id="ti_drivers_AESCBC_Overview"></a></p><h1>Overview</h1>
<p>The Cipher Block Chaining (CBC) mode of operation is a generic block cipher mode of operation. It can be used with any block cipher including AES.</p>
<p>CBC mode encrypts messages of any practical length that have a length evenly divisible by the block size. Unlike ECB, it guarantees confidentiality of the entire message when the message is larger than one block.</p>
<h2>Operation</h2>
<p>In CBC encryption, the initialization vector (IV) is XOR'd with a block of plaintext and then encrypted. The output ciphertext block is then XOR'd with the next plaintext block and the result is encrypted. This process is repeated until the final block of plaintext has been encrypted.</p>
<p>To decrypt the message, decrypt the first block of ciphertext and XOR the result with the IV. The result is the first plaintext block. For subsequent ciphertext blocks, decrypt each block and XOR the previous block of the encrypted message into the result.</p>
<h2>Padding</h2>
<p>CBC operates on entire blocks of ciphertext and plaintext at a time. This means that message lengths must be a multiple of the block cipher block size. AES has a block size of 16 bytes no matter the key size. Since messages do not necessarily always have a length that is a multiple of 16 bytes, it may be necessary to pad the message to a 16-byte boundary. Padding requires the sender and receiver to implicitly agree on the padding convention. Improperly designed or implemented padding schemes may leak information to an attacker through a padding oracle attack for example.</p>
<h2>Initialization Vectors</h2>
<p>The IV is generated by the party performing the encryption operation. Within the scope of any encryption key, the IV value must be unique. The IV does not need to be kept secret and is usually transmitted together with the ciphertext to the decrypting party. In CBC mode, the IVs must not be predictable. Two recommended ways to generate IVs is to either:</p>
<ul>
<li>Apply the block cipher (AESCBC), using the same key used with CBC, to a nonce. This nonce must be unique for each key-message pair. A counter will usually suffice. If the same symmetric key is used by both parties to encrypt messages, they should agree to use a nonce scheme that avoids generating the same nonce and thus IV twice. Incrementing the counter by two and making one party use even numbers and the other odd numbers is a common method to avoid such collisions.</li>
<li>Use a TRNG (True Random Number Generator) or PRNG (Pseudo-Random Number Generator) to generate a random number for use as IV.</li>
</ul>
<h2>Drawbacks</h2>
<p>CBC mode has several drawbacks. Unless interfacing with legacy devices, it is recommended to use an AEAD (Authenticated Encryption with Associated Data) mode such as CCM or GCM. Below is a non-exhaustive list of reasons to use a different block cipher mode of operation.</p>
<ul>
<li>CBC mode does not offer authentication or integrity guarantees. In practice, this means that attackers can intercept the encrypted message and manipulate the ciphertext before sending the message on to the receiver. While this does not break confidentiality and reveal the plaintext, it has enabled several attacks in the past. This is especially problematic given that changing the ciphertext of a block will only corrupt the block itself and the subsequent block of resultant plaintext. This property may be used to manipulate only certain parts of the message.</li>
<li>CBC mode requires message lengths to be evenly divisible by the block size. This necessitates a padding scheme. Improperly implemented padding schemes may lead to vulnerabilities that can be exploited by attackers. It often makes more sense to use a dedicated stream cipher such as CTR (Counter) that does not have this restriction. CCM and GCM both use CTR for encryption.</li>
</ul>
<p><a class="anchor" id="ti_drivers_AESCBC_Usage"></a></p><h1>Usage</h1>
<h2>Before starting a CBC operation</h2>
<p>Before starting a CBC operation, the application must do the following:</p><ul>
<li>Call <a class="el" href="_a_e_s_c_b_c_8h.html#a72ae710de057086ca1d4e96f1a92a9a1" title="This function initializes the CBC module. ">AESCBC_init()</a> to initialize the driver</li>
<li>Call <a class="el" href="_a_e_s_c_b_c_8h.html#a3c0ff1f31e58390f960f927f12756a98" title="Function to initialize the AESCBC_Params struct to its defaults. ">AESCBC_Params_init()</a> to initialize the <a class="el" href="struct_a_e_s_c_b_c___params.html" title="CBC Parameters. ">AESCBC_Params</a> to default values.</li>
<li>Modify the <a class="el" href="struct_a_e_s_c_b_c___params.html" title="CBC Parameters. ">AESCBC_Params</a> as desired</li>
<li>Call <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> to open an instance of the driver</li>
<li>Initialize a <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a>. These opaque data structures are representations of keying material and its storage. Depending on how the keying material is stored (RAM or flash, key store), the <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a> must be initialized differently. The AESCBC API can handle all types of <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a>. However, not all device-specific implementations support all types of <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a>. Devices without a key store will not support CryptoKeys with keying material stored in a key store for example. All devices support plaintext CryptoKeys.</li>
<li>Initialize the appropriate AESCBC operation struct using the relevant operation init functions and set all fields. For example, one-step (one-shot or single call) operations should initialize AESCBC_Operation or <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a single-step operat...">AESCBC_OneStepOperation</a> using <a class="el" href="_a_e_s_c_b_c_8h.html#a0864488e0826602937308930ab60e200" title="Function to initialize an AESCBC_Operation struct to its defaults. ">AESCBC_Operation_init()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a6715fbb822cc1ef0b60869588f60f7e2" title="Function to initialize an AESCBC_OneStepOperation struct to its defaults. ">AESCBC_OneStepOperation_init()</a>. For multi-step (segmented or multiple call) operations, <a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a segmented operatio...">AESCBC_SegmentedOperation</a> must be initialized and set.</li>
</ul>
<h2>Starting a CBC operation</h2>
<p>The <a class="el" href="_a_e_s_c_b_c_8h.html#af3cf6e72eacee43c28450dad9dc3f046" title="Function to perform an AESCBC encryption operation in one call. ">AESCBC_oneStepEncrypt</a> and <a class="el" href="_a_e_s_c_b_c_8h.html#a3e603f77710ad26615805f9bb27672d3" title="Function to perform an AESCBC decryption operation in one call. ">AESCBC_oneStepDecrypt</a> functions perform a CBC operation in a single call. They will always be the most highly optimized routines with the least overhead and the fastest runtime. However, they require all plaintext or ciphertext to be available to the function at the start of the call. All devices support single call operations.</p>
<h2>After the CBC operation completes</h2>
<p>After the CBC operation completes, the application should either start another operation or close the driver by calling <a class="el" href="_a_e_s_c_b_c_8h.html#a3189993c935516a40c09110092e6ef19" title="Function to close a CBC peripheral specified by the CBC handle. ">AESCBC_close()</a>.</p>
<p><a class="anchor" id="ti_drivers_AESCBC_Synopsis"></a></p><h2>Synopsis</h2>
<p><a class="anchor" id="ti_drivers_AESCBC_Synopsis_Code"></a></p><div class="fragment"><div class="line"><span class="comment">// Import AESCBC Driver definitions</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_e_s_c_b_c_8h.html">ti/drivers/AESCBC.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define name for AESCBC channel index</span></div><div class="line"><span class="preprocessor">#define AESCBC_INSTANCE 0</span></div><div class="line"></div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a72ae710de057086ca1d4e96f1a92a9a1">AESCBC_init</a>();</div><div class="line"></div><div class="line">handle = <a class="code" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f">AESCBC_open</a>(AESCBC_INSTANCE, NULL);</div><div class="line"></div><div class="line"><span class="comment">// Initialize symmetric key</span></div><div class="line"><a class="code" href="_crypto_key_plaintext_8h.html#ace81a1078fd0befbde3f44a9d9d58cc4">CryptoKeyPlaintext_initKey</a>(&amp;cryptoKey, keyingMaterial, <span class="keyword">sizeof</span>(keyingMaterial));</div><div class="line"></div><div class="line"><span class="comment">// Set up AESCBC_Operation</span></div><div class="line"><a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> operation;</div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a6715fbb822cc1ef0b60869588f60f7e2">AESCBC_OneStepOperation_init</a>(&amp;operation);</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a6518aed6d5da1e00d44d65287a57f034">key</a>               = &amp;cryptoKey;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a1a1180919f9129c518d0084caf0a4fe1">input</a>             = plaintext;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a30277677266cfe2d47c5552aa68be2a4">output</a>            = ciphertext;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a9c2335b721113543e47347afb0664ecd">inputLength</a>       = <span class="keyword">sizeof</span>(plaintext);</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#ab1fde4ea69a4a3d3f9e3a5bb96c29704">iv</a>                = iv;</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#af3cf6e72eacee43c28450dad9dc3f046">AESCBC_oneStepEncrypt</a>(handle, &amp;operation);</div><div class="line"></div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a3189993c935516a40c09110092e6ef19">AESCBC_close</a>(handle);</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_AESCBC_Examples"></a></p><h2>Examples</h2>
<p>### Single call CBC encryption with plaintext <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a> in blocking return mode # </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_e_s_c_b_c_8h.html">ti/drivers/AESCBC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_crypto_key_plaintext_8h.html">ti/drivers/cryptoutils/cryptokey/CryptoKeyPlaintext.h</a>&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">AESCBC_Handle handle;</div><div class="line"><a class="code" href="struct_crypto_key.html">CryptoKey</a> cryptoKey;</div><div class="line">int_fast16_t encryptionResult;</div><div class="line"></div><div class="line"><span class="comment">// For example purposes only. Generate IVs in a non-static way in practice.</span></div><div class="line"><span class="comment">// Test vector 0 from NIST CAPV set CBCMMT128</span></div><div class="line">uint8_t iv[16] =                {0x2f, 0xe2, 0xb3, 0x33, 0xce, 0xda, 0x8f, 0x98,</div><div class="line">                                 0xf4, 0xa9, 0x9b, 0x40, 0xd2, 0xcd, 0x34, 0xa8};</div><div class="line">uint8_t plaintext[16] =         {0x45, 0xcf, 0x12, 0x96, 0x4f, 0xc8, 0x24, 0xab,</div><div class="line">                                 0x76, 0x61, 0x6a, 0xe2, 0xf4, 0xbf, 0x08, 0x22};</div><div class="line">uint8_t ciphertext[<span class="keyword">sizeof</span>(plaintext)];</div><div class="line">uint8_t keyingMaterial[16] =    {0x1f, 0x8e, 0x49, 0x73, 0x95, 0x3f, 0x3f, 0xb0,</div><div class="line">                                 0xbd, 0x6b, 0x16, 0x66, 0x2e, 0x9a, 0x3c, 0x17};</div><div class="line"></div><div class="line"><span class="comment">// The ciphertext should be the following after the encryption operation:</span></div><div class="line"><span class="comment">//  0x0f, 0x61, 0xc4, 0xd4, 0x4c, 0x51, 0x47, 0xc0</span></div><div class="line"><span class="comment">//  0x3c, 0x19, 0x5a, 0xd7, 0xe2, 0xcc, 0x12, 0xb2</span></div><div class="line"></div><div class="line"></div><div class="line">handle = <a class="code" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f">AESCBC_open</a>(0, NULL);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (handle == NULL) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="_crypto_key_plaintext_8h.html#ace81a1078fd0befbde3f44a9d9d58cc4">CryptoKeyPlaintext_initKey</a>(&amp;cryptoKey, keyingMaterial, <span class="keyword">sizeof</span>(keyingMaterial));</div><div class="line"></div><div class="line"><a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> operation;</div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a6715fbb822cc1ef0b60869588f60f7e2">AESCBC_OneStepOperation_init</a>(&amp;operation);</div><div class="line"></div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a6518aed6d5da1e00d44d65287a57f034">key</a>               = &amp;cryptoKey;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a1a1180919f9129c518d0084caf0a4fe1">input</a>             = plaintext;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a30277677266cfe2d47c5552aa68be2a4">output</a>            = ciphertext;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a9c2335b721113543e47347afb0664ecd">inputLength</a>       = <span class="keyword">sizeof</span>(plaintext);</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#ab1fde4ea69a4a3d3f9e3a5bb96c29704">iv</a>                = iv;</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#af3cf6e72eacee43c28450dad9dc3f046">AESCBC_oneStepEncrypt</a>(handle, &amp;operation);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a3189993c935516a40c09110092e6ef19">AESCBC_close</a>(handle);</div></div><!-- fragment --><h3>Single call CBC decryption with plaintext <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a> in callback return mode</h3>
<dl class="section note"><dt>Note</dt><dd>The following code example presented uses a 256-bit key. However, CC13x1/CC26x1 and CC23x0 only support a maximum key size of 128-bits, so reduction of keyingMaterial would be required.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_e_s_c_b_c_8h.html">ti/drivers/AESCBC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_crypto_key_plaintext_8h.html">ti/drivers/cryptoutils/cryptokey/CryptoKeyPlaintext.h</a>&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Test vector 0 from NIST CAPV set CBCMMT256</span></div><div class="line"></div><div class="line">uint8_t iv[16] =                {0xdd, 0xbb, 0xb0, 0x17, 0x3f, 0x1e, 0x2d, 0xeb,</div><div class="line">                                 0x23, 0x94, 0xa6, 0x2a, 0xa2, 0xa0, 0x24, 0x0e};</div><div class="line">uint8_t ciphertext[16] =        {0xd5, 0x1d, 0x19, 0xde, 0xd5, 0xca, 0x4a, 0xe1,</div><div class="line">                                 0x4b, 0x2b, 0x20, 0xb0, 0x27, 0xff, 0xb0, 0x20};</div><div class="line">uint8_t keyingMaterial[32] =    {0x43, 0xe9, 0x53, 0xb2, 0xae, 0xa0, 0x8a, 0x3a,</div><div class="line">                                 0xd5, 0x2d, 0x18, 0x2f, 0x58, 0xc7, 0x2b, 0x9c,</div><div class="line">                                 0x60, 0xfb, 0xe4, 0xa9, 0xca, 0x46, 0xa3, 0xcb,</div><div class="line">                                 0x89, 0xe3, 0x86, 0x38, 0x45, 0xe2, 0x2c, 0x9e};</div><div class="line">uint8_t plaintext[<span class="keyword">sizeof</span>(ciphertext)];</div><div class="line"></div><div class="line"><span class="comment">// The plaintext should be the following after the decryption operation:</span></div><div class="line"><span class="comment">//  0x07, 0x27, 0x0d, 0x0e, 0x63, 0xaa, 0x36, 0xda</span></div><div class="line"><span class="comment">//  0xed, 0x8c, 0x6a, 0xde, 0x13, 0xac, 0x1a, 0xf1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> cbcCallback(<a class="code" href="struct_a_e_s_common___config.html">AESCBC_Handle</a> handle,</div><div class="line">                 int_fast16_t returnValue,</div><div class="line">                 <a class="code" href="union_a_e_s_c_b_c___operation_union.html">AESCBC_OperationUnion</a> *operation,</div><div class="line">                 <a class="code" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959">AESCBC_OperationType</a> operationType) {</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (returnValue != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (operationType == <a class="code" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959a9c63c1a604a8ef68797d84bed9cf20a5">AESCBC_OPERATION_TYPE_DECRYPT</a> ||</div><div class="line">        operationType == <a class="code" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959ae9f86ebbb5b543515e8cf4b63d533924">AESCBC_OPERATION_TYPE_ENCRYPT</a>) {</div><div class="line">        <span class="comment">// do something with operation-&gt;oneStepOperation</span></div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// do something with operation-&gt;segmentedOperation</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> operation;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> cbcStartFunction(<span class="keywordtype">void</span>) {</div><div class="line">    <a class="code" href="struct_a_e_s_common___config.html">AESCBC_Handle</a> handle;</div><div class="line">    <a class="code" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> <a class="code" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>;</div><div class="line">    <a class="code" href="struct_crypto_key.html">CryptoKey</a> cryptoKey;</div><div class="line">    int_fast16_t decryptionResult;</div><div class="line"></div><div class="line">    <a class="code" href="_a_e_s_c_b_c_8h.html#a3c0ff1f31e58390f960f927f12756a98">AESCBC_Params_init</a>(&amp;params);</div><div class="line">    params.<a class="code" href="struct_a_e_s_c_b_c___params.html#aaf9f67c02267e03a5ffbc5ccb4e7580a">returnBehavior</a> = <a class="code" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5acedc995468fd1ad451c6aa24f56d456d">AESCBC_RETURN_BEHAVIOR_CALLBACK</a>;</div><div class="line">    params.<a class="code" href="struct_a_e_s_c_b_c___params.html#a57b3ac8537584ca0bc3ed743792df321">callbackFxn</a> = cbcCallback;</div><div class="line"></div><div class="line">    handle = <a class="code" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f">AESCBC_open</a>(0, &amp;params);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (handle == NULL) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="_crypto_key_plaintext_8h.html#ace81a1078fd0befbde3f44a9d9d58cc4">CryptoKeyPlaintext_initKey</a>(&amp;cryptoKey, keyingMaterial, <span class="keyword">sizeof</span>(keyingMaterial));</div><div class="line"></div><div class="line">    <a class="code" href="_a_e_s_c_b_c_8h.html#a6715fbb822cc1ef0b60869588f60f7e2">AESCBC_OneStepOperation_init</a>(&amp;operation);</div><div class="line"></div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a6518aed6d5da1e00d44d65287a57f034">key</a>               = &amp;cryptoKey;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a1a1180919f9129c518d0084caf0a4fe1">input</a>             = ciphertext;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a30277677266cfe2d47c5552aa68be2a4">output</a>            = plaintext;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#a9c2335b721113543e47347afb0664ecd">inputLength</a>       = <span class="keyword">sizeof</span>(ciphertext);</div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___one_step_operation.html#ab1fde4ea69a4a3d3f9e3a5bb96c29704">iv</a>                = iv;</div><div class="line"></div><div class="line">    decryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a3e603f77710ad26615805f9bb27672d3">AESCBC_oneStepDecrypt</a>(handle, &amp;operation);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (decryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// do other things while CBC operation completes in the background</span></div><div class="line">}</div></div><!-- fragment --><p>### Multi-step CBC encryption with plaintext <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a> in blocking return mode # </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_e_s_c_b_c_8h.html">ti/drivers/AESCBC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_crypto_key_plaintext_8h.html">ti/drivers/cryptoutils/cryptokey/CryptoKeyPlaintext.h</a>&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">#define AES_BLOCK_SIZE      16 <span class="comment">// bytes</span></div><div class="line"></div><div class="line"><a class="code" href="struct_a_e_s_common___config.html">AESCBC_Handle</a> handle;</div><div class="line"><a class="code" href="struct_crypto_key.html">CryptoKey</a> cryptoKey;</div><div class="line">int_fast16_t encryptionResult;</div><div class="line"></div><div class="line"><span class="comment">// For example purposes only. Generate IVs in a non-static way in practice.</span></div><div class="line"><span class="comment">// Test vector 0 from NIST CAPV set CBCMMT128</span></div><div class="line">uint8_t iv[16] =                {0x2f, 0xe2, 0xb3, 0x33, 0xce, 0xda, 0x8f, 0x98,</div><div class="line">                                 0xf4, 0xa9, 0x9b, 0x40, 0xd2, 0xcd, 0x34, 0xa8};</div><div class="line">uint8_t plaintext[16] =         {0x45, 0xcf, 0x12, 0x96, 0x4f, 0xc8, 0x24, 0xab,</div><div class="line">                                 0x76, 0x61, 0x6a, 0xe2, 0xf4, 0xbf, 0x08, 0x22};</div><div class="line">uint8_t ciphertext[<span class="keyword">sizeof</span>(plaintext)];</div><div class="line">uint8_t keyingMaterial[16] =    {0x1f, 0x8e, 0x49, 0x73, 0x95, 0x3f, 0x3f, 0xb0,</div><div class="line">                                 0xbd, 0x6b, 0x16, 0x66, 0x2e, 0x9a, 0x3c, 0x17};</div><div class="line"></div><div class="line"><span class="comment">// The ciphertext should be the following after the encryption operation:</span></div><div class="line"><span class="comment">//  0x0f, 0x61, 0xc4, 0xd4, 0x4c, 0x51, 0x47, 0xc0</span></div><div class="line"><span class="comment">//  0x3c, 0x19, 0x5a, 0xd7, 0xe2, 0xcc, 0x12, 0xb2</span></div><div class="line"></div><div class="line"></div><div class="line">handle = <a class="code" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f">AESCBC_open</a>(0, NULL);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (handle == NULL) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="_crypto_key_plaintext_8h.html#ace81a1078fd0befbde3f44a9d9d58cc4">CryptoKeyPlaintext_initKey</a>(&amp;cryptoKey, keyingMaterial, <span class="keyword">sizeof</span>(keyingMaterial));</div><div class="line"></div><div class="line"><a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> operation;</div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a6b97cc99a27c2c2f20defb663d6eca26">AESCBC_SegmentedOperation_init</a>(&amp;operation);</div><div class="line"></div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#ad3cd2fd51a7ccf0c8259b17491c449a3">input</a>             = plaintext;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a6446fd7e04dfcfa648c90f6340acb41b">output</a>            = ciphertext;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a916fa6f486eccadc0addf6d0fc66ef4a">inputLength</a>       = <span class="keyword">sizeof</span>(plaintext);</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a5e3356cffdfd0671cdefb1aa11a97bca">AESCBC_setupEncrypt</a>(handle, &amp;cryptoKey);</div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a1a32ec040a89052bf3f6e08ddb5657e2">AESCBC_setIV</a>(handle, iv, AES_BLOCK_SIZE);</div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8">AESCBC_addData</a>(handle, &amp;operation);</div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a916fa6f486eccadc0addf6d0fc66ef4a">inputLength</a> = 0;</div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a2e0e343511ed0d1ca298b22a09fc36a6">AESCBC_finalize</a>(handle, &amp;operation);</div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a3189993c935516a40c09110092e6ef19">AESCBC_close</a>(handle);</div></div><!-- fragment --><h3>Multi-step CBC decryption with plaintext <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a> in callback return mode</h3>
<dl class="section note"><dt>Note</dt><dd>The following code example presented uses a 256-bit key. However, CC13x1/CC26x1 and CC23x0 only support a maximum key size of 128-bits, so reduction of keyingMaterial would be required.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_e_s_c_b_c_8h.html">ti/drivers/AESCBC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_crypto_key_plaintext_8h.html">ti/drivers/cryptoutils/cryptokey/CryptoKeyPlaintext.h</a>&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">#define AES_BLOCK_SIZE      16 <span class="comment">// bytes</span></div><div class="line"></div><div class="line"><span class="comment">// Test vector 0 from NIST CAPV set CBCMMT256</span></div><div class="line"></div><div class="line">uint8_t iv[16] =                {0xdd, 0xbb, 0xb0, 0x17, 0x3f, 0x1e, 0x2d, 0xeb,</div><div class="line">                                 0x23, 0x94, 0xa6, 0x2a, 0xa2, 0xa0, 0x24, 0x0e};</div><div class="line">uint8_t ciphertext[16] =        {0xd5, 0x1d, 0x19, 0xde, 0xd5, 0xca, 0x4a, 0xe1,</div><div class="line">                                 0x4b, 0x2b, 0x20, 0xb0, 0x27, 0xff, 0xb0, 0x20};</div><div class="line">uint8_t keyingMaterial[32] =    {0x43, 0xe9, 0x53, 0xb2, 0xae, 0xa0, 0x8a, 0x3a,</div><div class="line">                                 0xd5, 0x2d, 0x18, 0x2f, 0x58, 0xc7, 0x2b, 0x9c,</div><div class="line">                                 0x60, 0xfb, 0xe4, 0xa9, 0xca, 0x46, 0xa3, 0xcb,</div><div class="line">                                 0x89, 0xe3, 0x86, 0x38, 0x45, 0xe2, 0x2c, 0x9e};</div><div class="line">uint8_t plaintext[<span class="keyword">sizeof</span>(ciphertext)];</div><div class="line"></div><div class="line"><span class="comment">// The plaintext should be the following after the decryption operation:</span></div><div class="line"><span class="comment">//  0x07, 0x27, 0x0d, 0x0e, 0x63, 0xaa, 0x36, 0xda</span></div><div class="line"><span class="comment">//  0xed, 0x8c, 0x6a, 0xde, 0x13, 0xac, 0x1a, 0xf1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> cbcCallback(<a class="code" href="struct_a_e_s_common___config.html">AESCBC_Handle</a> handle,</div><div class="line">                 int_fast16_t returnValue,</div><div class="line">                 <a class="code" href="union_a_e_s_c_b_c___operation_union.html">AESCBC_OperationUnion</a> *operation,</div><div class="line">                 <a class="code" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959">AESCBC_OperationType</a> operationType) {</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (returnValue != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (operationType == <a class="code" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959a9c63c1a604a8ef68797d84bed9cf20a5">AESCBC_OPERATION_TYPE_DECRYPT</a> ||</div><div class="line">        operationType == <a class="code" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959ae9f86ebbb5b543515e8cf4b63d533924">AESCBC_OPERATION_TYPE_ENCRYPT</a>) {</div><div class="line">        <span class="comment">// do something with operation-&gt;oneStepOperation</span></div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// do something with operation-&gt;segmentedOperation</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> operation;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> cbcStartFunction(<span class="keywordtype">void</span>) {</div><div class="line">    <a class="code" href="struct_a_e_s_common___config.html">AESCBC_Handle</a> handle;</div><div class="line">    <a class="code" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> <a class="code" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>;</div><div class="line">    <a class="code" href="struct_crypto_key.html">CryptoKey</a> cryptoKey;</div><div class="line">    int_fast16_t decryptionResult;</div><div class="line"></div><div class="line">    <a class="code" href="_a_e_s_c_b_c_8h.html#a3c0ff1f31e58390f960f927f12756a98">AESCBC_Params_init</a>(&amp;params);</div><div class="line">    params.<a class="code" href="struct_a_e_s_c_b_c___params.html#aaf9f67c02267e03a5ffbc5ccb4e7580a">returnBehavior</a> = <a class="code" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5acedc995468fd1ad451c6aa24f56d456d">AESCBC_RETURN_BEHAVIOR_CALLBACK</a>;</div><div class="line">    params.<a class="code" href="struct_a_e_s_c_b_c___params.html#a57b3ac8537584ca0bc3ed743792df321">callbackFxn</a> = cbcCallback;</div><div class="line"></div><div class="line">    handle = <a class="code" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f">AESCBC_open</a>(0, &amp;params);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (handle == NULL) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="_crypto_key_plaintext_8h.html#ace81a1078fd0befbde3f44a9d9d58cc4">CryptoKeyPlaintext_initKey</a>(&amp;cryptoKey, keyingMaterial, <span class="keyword">sizeof</span>(keyingMaterial));</div><div class="line"></div><div class="line">    <a class="code" href="_a_e_s_c_b_c_8h.html#a6b97cc99a27c2c2f20defb663d6eca26">AESCBC_SegmentedOperation_init</a>(&amp;operation);</div><div class="line"></div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#ad3cd2fd51a7ccf0c8259b17491c449a3">input</a>             = ciphertext;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a6446fd7e04dfcfa648c90f6340acb41b">output</a>            = plaintext;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a916fa6f486eccadc0addf6d0fc66ef4a">inputLength</a>       = <span class="keyword">sizeof</span>(ciphertext);</div><div class="line"></div><div class="line">    decryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a144ccb3985ceeee03b370d68dd1ea4b2">AESCBC_setupDecrypt</a>(handle, &amp;cryptoKey);</div><div class="line">    <span class="keywordflow">if</span> (decryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    decryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a1a32ec040a89052bf3f6e08ddb5657e2">AESCBC_setIV</a>(handle, iv, AES_BLOCK_SIZE);</div><div class="line">    <span class="keywordflow">if</span> (decryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    decryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8">AESCBC_addData</a>(handle, &amp;operation);</div><div class="line">    <span class="keywordflow">if</span> (decryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// do other things while CBC operation completes in the background</span></div><div class="line"></div><div class="line">    operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a916fa6f486eccadc0addf6d0fc66ef4a">inputLength</a> = 0;</div><div class="line">    decryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a2e0e343511ed0d1ca298b22a09fc36a6">AESCBC_finalize</a>(handle, &amp;operation);</div><div class="line">    <span class="keywordflow">if</span> (decryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>Multi-step CBC encryption with plaintext <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a> and non-empty finalize in blocking return mode</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_e_s_c_b_c_8h.html">ti/drivers/AESCBC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_crypto_key_plaintext_8h.html">ti/drivers/cryptoutils/cryptokey/CryptoKeyPlaintext.h</a>&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">#define AES_BLOCK_SIZE      16 <span class="comment">// bytes</span></div><div class="line"></div><div class="line"><a class="code" href="struct_a_e_s_common___config.html">AESCBC_Handle</a> handle;</div><div class="line"><a class="code" href="struct_crypto_key.html">CryptoKey</a> cryptoKey;</div><div class="line">int_fast16_t encryptionResult;</div><div class="line"></div><div class="line"><span class="comment">// For example purposes only. Generate IVs in a non-static way in practice.</span></div><div class="line"><span class="comment">// Test vector 1 from NIST CAPV set CBCMMT128</span></div><div class="line">uint8_t iv[16] =                {0xaa, 0xd1, 0x58, 0x3c, 0xd9, 0x13, 0x65, 0xe3,</div><div class="line">                                 0xbb, 0x2f, 0x0c, 0x34, 0x30, 0xd0, 0x65, 0xbb};</div><div class="line">uint8_t plaintext[32] =         {0x06, 0x8b, 0x25, 0xc7, 0xbf, 0xb1, 0xf8, 0xbd,</div><div class="line">                                 0xd4, 0xcf, 0xc9, 0x08, 0xf6, 0x9d, 0xff, 0xc5,</div><div class="line">                                 0xdd, 0xc7, 0x26, 0xa1, 0x97, 0xf0, 0xe5, 0xf7,</div><div class="line">                                 0x20, 0xf7, 0x30, 0x39, 0x32, 0x79, 0xbe, 0x91};</div><div class="line">uint8_t ciphertext[<span class="keyword">sizeof</span>(plaintext)];</div><div class="line">uint8_t keyingMaterial[16] =    {0x07, 0x00, 0xd6, 0x03, 0xa1, 0xc5, 0x14, 0xe4,</div><div class="line">                                 0x6b, 0x61, 0x91, 0xba, 0x43, 0x0a, 0x3a, 0x0c};</div><div class="line"></div><div class="line"><span class="comment">// The ciphertext should be the following after the encryption operation:</span></div><div class="line"><span class="comment">//  0xc4, 0xdc, 0x61, 0xd9, 0x72, 0x59, 0x67, 0xa3</span></div><div class="line"><span class="comment">//  0x02, 0x01, 0x04, 0xa9, 0x73, 0x8f, 0x23, 0x86</span></div><div class="line"><span class="comment">//  0x85, 0x27, 0xce, 0x83, 0x9a, 0xab, 0x17, 0x52</span></div><div class="line"><span class="comment">//  0xfd, 0x8b, 0xdb, 0x95, 0xa8, 0x2c, 0x4d, 0x00</span></div><div class="line"></div><div class="line"></div><div class="line">handle = <a class="code" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f">AESCBC_open</a>(0, NULL);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (handle == NULL) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="_crypto_key_plaintext_8h.html#ace81a1078fd0befbde3f44a9d9d58cc4">CryptoKeyPlaintext_initKey</a>(&amp;cryptoKey, keyingMaterial, <span class="keyword">sizeof</span>(keyingMaterial));</div><div class="line"></div><div class="line"><a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> operation;</div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a6b97cc99a27c2c2f20defb663d6eca26">AESCBC_SegmentedOperation_init</a>(&amp;operation);</div><div class="line"></div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#ad3cd2fd51a7ccf0c8259b17491c449a3">input</a>             = plaintext;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a6446fd7e04dfcfa648c90f6340acb41b">output</a>            = ciphertext;</div><div class="line"><span class="comment">// One should pass in data that is a block-sized multiple length (16 bytes)</span></div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a916fa6f486eccadc0addf6d0fc66ef4a">inputLength</a>       = AES_BLOCK_SIZE;</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a5e3356cffdfd0671cdefb1aa11a97bca">AESCBC_setupEncrypt</a>(handle, &amp;cryptoKey);</div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a1a32ec040a89052bf3f6e08ddb5657e2">AESCBC_setIV</a>(handle, iv, AES_BLOCK_SIZE);</div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8">AESCBC_addData</a>(handle, &amp;operation);</div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#ad3cd2fd51a7ccf0c8259b17491c449a3">input</a>             = plaintext + AES_BLOCK_SIZE;</div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a6446fd7e04dfcfa648c90f6340acb41b">output</a>            = ciphertext + AES_BLOCK_SIZE;</div><div class="line"></div><div class="line"><span class="comment">// You can also finalize with more data (non-zero inputLength)</span></div><div class="line">operation.<a class="code" href="struct_a_e_s_c_b_c___segmented_operation.html#a916fa6f486eccadc0addf6d0fc66ef4a">inputLength</a>       = <span class="keyword">sizeof</span>(plaintext) - AES_BLOCK_SIZE;</div><div class="line">encryptionResult = <a class="code" href="_a_e_s_c_b_c_8h.html#a2e0e343511ed0d1ca298b22a09fc36a6">AESCBC_finalize</a>(handle, &amp;operation);</div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="_a_e_s_c_b_c_8h.html#a3189993c935516a40c09110092e6ef19">AESCBC_close</a>(handle);</div></div><!-- fragment --> </div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_a_e_s_common_8h_source.html">ti/drivers/AESCommon.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_crypto_key_8h_source.html">ti/drivers/cryptoutils/cryptokey/CryptoKey.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for AESCBC.h:</div>
<div class="dyncontent">
<div class="center"><img src="_a_e_s_c_b_c_8h__incl.png" border="0" usemap="#_a_e_s_c_b_c_8h" alt=""/></div>
<map name="_a_e_s_c_b_c_8h" id="_a_e_s_c_b_c_8h">
<area shape="rect" id="node5" href="_a_e_s_common_8h.html" title="AES common module header for all devices. " alt="" coords="271,87,451,114"/>
<area shape="rect" id="node6" href="_crypto_key_8h.html" title="The CryptoKey type is an opaque representation of a cryptographic key. " alt="" coords="25,80,196,121"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_a_e_s_c_b_c_8h__dep__incl.png" border="0" usemap="#_a_e_s_c_b_c_8hdep" alt=""/></div>
<map name="_a_e_s_c_b_c_8hdep" id="_a_e_s_c_b_c_8hdep">
<area shape="rect" id="node2" href="_a_e_s_c_b_c_c_c26_x4__ns_8h.html" title="AESCBC Nonsecure driver implementation for the CC26X4 family. " alt="" coords="5,80,164,107"/>
<area shape="rect" id="node3" href="_a_e_s_c_b_c_c_c26_x4__s_8h.html" title="AESCBCCC26X4_s.h" alt="" coords="188,80,339,107"/>
<area shape="rect" id="node4" href="_a_e_s_c_b_c_c_c26_x_x_8h.html" title="AESCBC driver implementation for the CC26XX family. " alt="" coords="363,80,502,107"/>
</map>
</div>
</div>
<p><a href="_a_e_s_c_b_c_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the parameters required for encrypting/decrypting a message in a single-step operation.  <a href="struct_a_e_s_c_b_c___one_step_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the parameters required for encrypting/decrypting a message in a segmented operation. Must be updated for steps of a segmented operation where data is processed (addData() and finalize()).  <a href="struct_a_e_s_c_b_c___segmented_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_a_e_s_c_b_c___operation_union.html">AESCBC_OperationUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union containing a reference to a one step or segmented operation.  <a href="union_a_e_s_c_b_c___operation_union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBC Parameters.  <a href="struct_a_e_s_c_b_c___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3cd55c1962740cbb6e3217d49ddb8cc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a3cd55c1962740cbb6e3217d49ddb8cc6">AESCBC_STATUS_RESERVED</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a4896831b1a3a4ead39a3c58eb13a05f5">AES_STATUS_RESERVED</a></td></tr>
<tr class="separator:a3cd55c1962740cbb6e3217d49ddb8cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcb271aa7f9aee37469d242670b6d9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d">AESCBC_STATUS_SUCCESS</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a40238be3b30c09acbb966b8cf64d8db6">AES_STATUS_SUCCESS</a></td></tr>
<tr class="memdesc:a0bcb271aa7f9aee37469d242670b6d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code.  <a href="#a0bcb271aa7f9aee37469d242670b6d9d">More...</a><br /></td></tr>
<tr class="separator:a0bcb271aa7f9aee37469d242670b6d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114c760826307af69a93538773a58185"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185">AESCBC_STATUS_ERROR</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#ac6963a06e1923ad116a23c0e1a17dba8">AES_STATUS_ERROR</a></td></tr>
<tr class="memdesc:a114c760826307af69a93538773a58185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code.  <a href="#a114c760826307af69a93538773a58185">More...</a><br /></td></tr>
<tr class="separator:a114c760826307af69a93538773a58185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92a5502a5a56aaf28b7d930be275271"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#ad92a5502a5a56aaf28b7d930be275271">AESCBC_STATUS_RESOURCE_UNAVAILABLE</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a4720c275153144c20096dc2d85f93889">AES_STATUS_RESOURCE_UNAVAILABLE</a></td></tr>
<tr class="memdesc:ad92a5502a5a56aaf28b7d930be275271"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned if the hardware or software resource is currently unavailable.  <a href="#ad92a5502a5a56aaf28b7d930be275271">More...</a><br /></td></tr>
<tr class="separator:ad92a5502a5a56aaf28b7d930be275271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ff5d2f23cdceb6652dbe490c6ec93f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#aa3ff5d2f23cdceb6652dbe490c6ec93f">AESCBC_STATUS_CANCELED</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#aa8d5ff0dd5cde60089ac5d84cfb4a702">AES_STATUS_CANCELED</a></td></tr>
<tr class="memdesc:aa3ff5d2f23cdceb6652dbe490c6ec93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ongoing operation was canceled.  <a href="#aa3ff5d2f23cdceb6652dbe490c6ec93f">More...</a><br /></td></tr>
<tr class="separator:aa3ff5d2f23cdceb6652dbe490c6ec93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fee21f079588cba1b516720b553f1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a75fee21f079588cba1b516720b553f1a">AESCBC_STATUS_FEATURE_NOT_SUPPORTED</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a671e5331015411e6db491d8eee23732c">AES_STATUS_FEATURE_NOT_SUPPORTED</a></td></tr>
<tr class="memdesc:a75fee21f079588cba1b516720b553f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation requested is not supported for now.  <a href="#a75fee21f079588cba1b516720b553f1a">More...</a><br /></td></tr>
<tr class="separator:a75fee21f079588cba1b516720b553f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad2a122e8b54e8c2e0d1563ac1095a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#adad2a122e8b54e8c2e0d1563ac1095a7">AESCBC_STATUS_KEYSTORE_INVALID_ID</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#aeaab212abda07968840db525e114d1ae">AES_STATUS_KEYSTORE_INVALID_ID</a></td></tr>
<tr class="memdesc:adad2a122e8b54e8c2e0d1563ac1095a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation tried to load a key from the keystore using an invalid key ID.  <a href="#adad2a122e8b54e8c2e0d1563ac1095a7">More...</a><br /></td></tr>
<tr class="separator:adad2a122e8b54e8c2e0d1563ac1095a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65047ed053730a6dee6332cd98fc377c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a65047ed053730a6dee6332cd98fc377c">AESCBC_STATUS_KEYSTORE_GENERIC_ERROR</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a89e9ed71ffb10f4f6d5b52b8afbd4389">AES_STATUS_KEYSTORE_GENERIC_ERROR</a></td></tr>
<tr class="memdesc:a65047ed053730a6dee6332cd98fc377c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key store module returned a generic error. See key store documentation for additional details.  <a href="#a65047ed053730a6dee6332cd98fc377c">More...</a><br /></td></tr>
<tr class="separator:a65047ed053730a6dee6332cd98fc377c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf65612b9131789ae5db3e3151473bbc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#adf65612b9131789ae5db3e3151473bbc">AESCBC_STATUS_UNALIGNED_IO_NOT_SUPPORTED</a>&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#ab367c0137dd8d9bda4107b1545bfdb12">AES_STATUS_UNALIGNED_IO_NOT_SUPPORTED</a></td></tr>
<tr class="memdesc:adf65612b9131789ae5db3e3151473bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation does not support non-word-aligned input and/or output.  <a href="#adf65612b9131789ae5db3e3151473bbc">More...</a><br /></td></tr>
<tr class="separator:adf65612b9131789ae5db3e3151473bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af5f0c2913e25511cc73288b1db71d6e7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_a_e_s_common___config.html">AESCommon_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7">AESCBC_Config</a></td></tr>
<tr class="memdesc:af5f0c2913e25511cc73288b1db71d6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">AESCBC Global configuration.  <a href="#af5f0c2913e25511cc73288b1db71d6e7">More...</a><br /></td></tr>
<tr class="separator:af5f0c2913e25511cc73288b1db71d6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4222a78a8c695fc2c97bbef11d28f04e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7">AESCBC_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a></td></tr>
<tr class="memdesc:a4222a78a8c695fc2c97bbef11d28f04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from an <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> call.  <a href="#a4222a78a8c695fc2c97bbef11d28f04e">More...</a><br /></td></tr>
<tr class="separator:a4222a78a8c695fc2c97bbef11d28f04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f412502b110e7046c203e23722aaa89"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a4f412502b110e7046c203e23722aaa89">AESCBC_Operation</a></td></tr>
<tr class="separator:a4f412502b110e7046c203e23722aaa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bc486e0f51737928f21514715a537c"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_a_e_s_c_b_c___operation_union.html">AESCBC_OperationUnion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#aa2bc486e0f51737928f21514715a537c">AESCBC_OperationUnion</a></td></tr>
<tr class="memdesc:aa2bc486e0f51737928f21514715a537c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union containing a reference to a one step or segmented operation.  <a href="#aa2bc486e0f51737928f21514715a537c">More...</a><br /></td></tr>
<tr class="separator:aa2bc486e0f51737928f21514715a537c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c538c1ce2d9aa37bd538a90f278b45"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#ad3c538c1ce2d9aa37bd538a90f278b45">AESCBC_CallbackFxn</a>) (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, int_fast16_t returnValue, <a class="el" href="union_a_e_s_c_b_c___operation_union.html">AESCBC_OperationUnion</a> *operation, <a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959">AESCBC_OperationType</a> operationType)</td></tr>
<tr class="memdesc:ad3c538c1ce2d9aa37bd538a90f278b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the AESCBC driver when used in <a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5acedc995468fd1ad451c6aa24f56d456d">AESCBC_RETURN_BEHAVIOR_CALLBACK</a>.  <a href="#ad3c538c1ce2d9aa37bd538a90f278b45">More...</a><br /></td></tr>
<tr class="separator:ad3c538c1ce2d9aa37bd538a90f278b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a34f3e7f586935c9328167d1e03973af5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5">AESCBC_ReturnBehavior</a> { <a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5acedc995468fd1ad451c6aa24f56d456d">AESCBC_RETURN_BEHAVIOR_CALLBACK</a> = AES_RETURN_BEHAVIOR_CALLBACK, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5ad4cf399115e78f5253b12f88605d212e">AESCBC_RETURN_BEHAVIOR_BLOCKING</a> = AES_RETURN_BEHAVIOR_BLOCKING, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5aeccf5cad47aac1edcef820125f7c361d">AESCBC_RETURN_BEHAVIOR_POLLING</a> = AES_RETURN_BEHAVIOR_POLLING
 }<tr class="memdesc:a34f3e7f586935c9328167d1e03973af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The way in which CBC function calls return after performing an encryption or decryption operation.  <a href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a34f3e7f586935c9328167d1e03973af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0b3dbc7f859b9d0c6acf102adb4d39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a3d0b3dbc7f859b9d0c6acf102adb4d39">AESCBC_Mode</a> { <a class="el" href="_a_e_s_c_b_c_8h.html#a3d0b3dbc7f859b9d0c6acf102adb4d39a6937032fe648623f9b9a5f7b4dcce26a">AESCBC_MODE_ENCRYPT</a> = 1, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a3d0b3dbc7f859b9d0c6acf102adb4d39afacbd481470a984c92878b82c17a825c">AESCBC_MODE_DECRYPT</a> = 2
 }<tr class="memdesc:a3d0b3dbc7f859b9d0c6acf102adb4d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for the direction of the CBC operation.  <a href="_a_e_s_c_b_c_8h.html#a3d0b3dbc7f859b9d0c6acf102adb4d39">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3d0b3dbc7f859b9d0c6acf102adb4d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498551584800977637726dde45cd9959"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959">AESCBC_OperationType</a> { <br />
&#160;&#160;<a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959ae9f86ebbb5b543515e8cf4b63d533924">AESCBC_OPERATION_TYPE_ENCRYPT</a> = 1, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959a9c63c1a604a8ef68797d84bed9cf20a5">AESCBC_OPERATION_TYPE_DECRYPT</a> = 2, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959a28e1fd2ea29d9c7cdd2534686f50ec5b">AESCBC_OP_TYPE_ONESTEP_ENCRYPT</a> = 1, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959ad06b3a66a8906cbcdb2f21cb6ea57e89">AESCBC_OP_TYPE_ONESTEP_DECRYPT</a> = 2, 
<br />
&#160;&#160;<a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959a4d9d7bab075783ce371f817a1b4c0a37">AESCBC_OP_TYPE_ENCRYPT_SEGMENTED</a> = 3, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959aa8e0e67a9f80b534073fc07030415085">AESCBC_OP_TYPE_DECRYPT_SEGMENTED</a> = 4, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959a15314c3bc0356e0a1cea870ffc2f5075">AESCBC_OP_TYPE_FINALIZE_ENCRYPT_SEGMENTED</a> = 5, 
<a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959a9fcc96b5e73a699498f3627085aa02cf">AESCBC_OP_TYPE_FINALIZE_DECRYPT_SEGMENTED</a> = 6
<br />
 }<tr class="memdesc:a498551584800977637726dde45cd9959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for the operation types supported by the driver.  <a href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a498551584800977637726dde45cd9959"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a72ae710de057086ca1d4e96f1a92a9a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a72ae710de057086ca1d4e96f1a92a9a1">AESCBC_init</a> (void)</td></tr>
<tr class="memdesc:a72ae710de057086ca1d4e96f1a92a9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the CBC module.  <a href="#a72ae710de057086ca1d4e96f1a92a9a1">More...</a><br /></td></tr>
<tr class="separator:a72ae710de057086ca1d4e96f1a92a9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0ff1f31e58390f960f927f12756a98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a3c0ff1f31e58390f960f927f12756a98">AESCBC_Params_init</a> (<a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:a3c0ff1f31e58390f960f927f12756a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="struct_a_e_s_c_b_c___params.html" title="CBC Parameters. ">AESCBC_Params</a> struct to its defaults.  <a href="#a3c0ff1f31e58390f960f927f12756a98">More...</a><br /></td></tr>
<tr class="separator:a3c0ff1f31e58390f960f927f12756a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e418c0f71f339935513126d37fbc9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f">AESCBC_open</a> (uint_least8_t index, const <a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:ac4e418c0f71f339935513126d37fbc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function opens a given CBC peripheral.  <a href="#ac4e418c0f71f339935513126d37fbc9f">More...</a><br /></td></tr>
<tr class="separator:ac4e418c0f71f339935513126d37fbc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189993c935516a40c09110092e6ef19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a3189993c935516a40c09110092e6ef19">AESCBC_close</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle)</td></tr>
<tr class="memdesc:a3189993c935516a40c09110092e6ef19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a CBC peripheral specified by the CBC handle.  <a href="#a3189993c935516a40c09110092e6ef19">More...</a><br /></td></tr>
<tr class="separator:a3189993c935516a40c09110092e6ef19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864488e0826602937308930ab60e200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a0864488e0826602937308930ab60e200">AESCBC_Operation_init</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4f412502b110e7046c203e23722aaa89">AESCBC_Operation</a> *operationStruct)</td></tr>
<tr class="memdesc:a0864488e0826602937308930ab60e200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize an <a class="el" href="_a_e_s_c_b_c_8h.html#a4f412502b110e7046c203e23722aaa89">AESCBC_Operation</a> struct to its defaults.  <a href="#a0864488e0826602937308930ab60e200">More...</a><br /></td></tr>
<tr class="separator:a0864488e0826602937308930ab60e200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6715fbb822cc1ef0b60869588f60f7e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a6715fbb822cc1ef0b60869588f60f7e2">AESCBC_OneStepOperation_init</a> (<a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> *operationStruct)</td></tr>
<tr class="memdesc:a6715fbb822cc1ef0b60869588f60f7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize an <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a single-step operat...">AESCBC_OneStepOperation</a> struct to its defaults.  <a href="#a6715fbb822cc1ef0b60869588f60f7e2">More...</a><br /></td></tr>
<tr class="separator:a6715fbb822cc1ef0b60869588f60f7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b97cc99a27c2c2f20defb663d6eca26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a6b97cc99a27c2c2f20defb663d6eca26">AESCBC_SegmentedOperation_init</a> (<a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> *operationStruct)</td></tr>
<tr class="memdesc:a6b97cc99a27c2c2f20defb663d6eca26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize an <a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a segmented operatio...">AESCBC_SegmentedOperation</a> struct to its defaults.  <a href="#a6b97cc99a27c2c2f20defb663d6eca26">More...</a><br /></td></tr>
<tr class="separator:a6b97cc99a27c2c2f20defb663d6eca26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf6e72eacee43c28450dad9dc3f046"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#af3cf6e72eacee43c28450dad9dc3f046">AESCBC_oneStepEncrypt</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> *operationStruct)</td></tr>
<tr class="memdesc:af3cf6e72eacee43c28450dad9dc3f046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform an AESCBC encryption operation in one call.  <a href="#af3cf6e72eacee43c28450dad9dc3f046">More...</a><br /></td></tr>
<tr class="separator:af3cf6e72eacee43c28450dad9dc3f046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e603f77710ad26615805f9bb27672d3"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a3e603f77710ad26615805f9bb27672d3">AESCBC_oneStepDecrypt</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> *operationStruct)</td></tr>
<tr class="memdesc:a3e603f77710ad26615805f9bb27672d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform an AESCBC decryption operation in one call.  <a href="#a3e603f77710ad26615805f9bb27672d3">More...</a><br /></td></tr>
<tr class="separator:a3e603f77710ad26615805f9bb27672d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3356cffdfd0671cdefb1aa11a97bca"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a5e3356cffdfd0671cdefb1aa11a97bca">AESCBC_setupEncrypt</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, const <a class="el" href="struct_crypto_key.html">CryptoKey</a> *key)</td></tr>
<tr class="memdesc:a5e3356cffdfd0671cdefb1aa11a97bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to prepare a segmented AESCBC encryption operation.  <a href="#a5e3356cffdfd0671cdefb1aa11a97bca">More...</a><br /></td></tr>
<tr class="separator:a5e3356cffdfd0671cdefb1aa11a97bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ccb3985ceeee03b370d68dd1ea4b2"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a144ccb3985ceeee03b370d68dd1ea4b2">AESCBC_setupDecrypt</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, const <a class="el" href="struct_crypto_key.html">CryptoKey</a> *key)</td></tr>
<tr class="memdesc:a144ccb3985ceeee03b370d68dd1ea4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to prepare a segmented AESCBC decryption operation.  <a href="#a144ccb3985ceeee03b370d68dd1ea4b2">More...</a><br /></td></tr>
<tr class="separator:a144ccb3985ceeee03b370d68dd1ea4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a32ec040a89052bf3f6e08ddb5657e2"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a1a32ec040a89052bf3f6e08ddb5657e2">AESCBC_setIV</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, const uint8_t *iv, size_t ivLength)</td></tr>
<tr class="memdesc:a1a32ec040a89052bf3f6e08ddb5657e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set an initialization vector for an AES CBC segmented operation.  <a href="#a1a32ec040a89052bf3f6e08ddb5657e2">More...</a><br /></td></tr>
<tr class="separator:a1a32ec040a89052bf3f6e08ddb5657e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e25f2268d83629d9799a165bc7683c"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#af8e25f2268d83629d9799a165bc7683c">AESCBC_generateIV</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, uint8_t *iv, size_t ivSize, size_t *ivLength)</td></tr>
<tr class="memdesc:af8e25f2268d83629d9799a165bc7683c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate an initialization vector for an AES CBC segmented encryption operation.  <a href="#af8e25f2268d83629d9799a165bc7683c">More...</a><br /></td></tr>
<tr class="separator:af8e25f2268d83629d9799a165bc7683c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6ed48e40f396b1f99f071d74652c8"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8">AESCBC_addData</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, <a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> *operation)</td></tr>
<tr class="memdesc:ab3f6ed48e40f396b1f99f071d74652c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts or decrypts a segment of data defined by the <a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a segmented operatio...">AESCBC_SegmentedOperation</a> struct.  <a href="#ab3f6ed48e40f396b1f99f071d74652c8">More...</a><br /></td></tr>
<tr class="separator:ab3f6ed48e40f396b1f99f071d74652c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0e343511ed0d1ca298b22a09fc36a6"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a2e0e343511ed0d1ca298b22a09fc36a6">AESCBC_finalize</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, <a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> *operation)</td></tr>
<tr class="memdesc:a2e0e343511ed0d1ca298b22a09fc36a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the AES operation. If new data needs to be added, <code>inputLength</code> will be used to govern how many bytes will be written. New data must be a multiple of a block length, 16 bytes, or 0 if no new data needs to be added.  <a href="#a2e0e343511ed0d1ca298b22a09fc36a6">More...</a><br /></td></tr>
<tr class="separator:a2e0e343511ed0d1ca298b22a09fc36a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807f254a97d04e2b8e2c73d026d3c81a"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a807f254a97d04e2b8e2c73d026d3c81a">AESCBC_cancelOperation</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle)</td></tr>
<tr class="memdesc:a807f254a97d04e2b8e2c73d026d3c81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels an ongoing AESCBC operation.  <a href="#a807f254a97d04e2b8e2c73d026d3c81a">More...</a><br /></td></tr>
<tr class="separator:a807f254a97d04e2b8e2c73d026d3c81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab3841802fa8f8cb8d19993d25e88d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d">AESCBC_construct</a> (<a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7">AESCBC_Config</a> *config, const <a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:a0cab3841802fa8f8cb8d19993d25e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new AESCBC object.  <a href="#a0cab3841802fa8f8cb8d19993d25e88d">More...</a><br /></td></tr>
<tr class="separator:a0cab3841802fa8f8cb8d19993d25e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a65d438667291f32d79714a3b24b7e9bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_c_b_c_8h.html#a65d438667291f32d79714a3b24b7e9bb">AESCBC_defaultParams</a></td></tr>
<tr class="memdesc:a65d438667291f32d79714a3b24b7e9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="struct_a_e_s_c_b_c___params.html" title="CBC Parameters. ">AESCBC_Params</a> structure.  <a href="#a65d438667291f32d79714a3b24b7e9bb">More...</a><br /></td></tr>
<tr class="separator:a65d438667291f32d79714a3b24b7e9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3cd55c1962740cbb6e3217d49ddb8cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd55c1962740cbb6e3217d49ddb8cc6">&sect;&nbsp;</a></span>AESCBC_STATUS_RESERVED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_RESERVED&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a4896831b1a3a4ead39a3c58eb13a05f5">AES_STATUS_RESERVED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common AESCBC status code reservation offset. AESCBC driver implementations should offset status codes with <a class="el" href="_a_e_s_c_b_c_8h.html#a3cd55c1962740cbb6e3217d49ddb8cc6">AESCBC_STATUS_RESERVED</a> growing negatively.</p>
<p>Example implementation specific status codes: </p><div class="fragment"><div class="line"><span class="preprocessor">#define AESCBCXYZ_STATUS_ERROR0    AESCBC_STATUS_RESERVED - 0</span></div><div class="line"><span class="preprocessor">#define AESCBCXYZ_STATUS_ERROR1    AESCBC_STATUS_RESERVED - 1</span></div><div class="line"><span class="preprocessor">#define AESCBCXYZ_STATUS_ERROR2    AESCBC_STATUS_RESERVED - 2</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a0bcb271aa7f9aee37469d242670b6d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcb271aa7f9aee37469d242670b6d9d">&sect;&nbsp;</a></span>AESCBC_STATUS_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_SUCCESS&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a40238be3b30c09acbb966b8cf64d8db6">AES_STATUS_SUCCESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Successful status code. </p>
<p>Functions return <a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a> if the function was executed successfully. </p>

</div>
</div>
<a id="a114c760826307af69a93538773a58185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114c760826307af69a93538773a58185">&sect;&nbsp;</a></span>AESCBC_STATUS_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_ERROR&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#ac6963a06e1923ad116a23c0e1a17dba8">AES_STATUS_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic error status code. </p>
<p>Functions return <a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a> if the function was not executed successfully and no more pertinent error code could be returned. </p>

</div>
</div>
<a id="ad92a5502a5a56aaf28b7d930be275271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92a5502a5a56aaf28b7d930be275271">&sect;&nbsp;</a></span>AESCBC_STATUS_RESOURCE_UNAVAILABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_RESOURCE_UNAVAILABLE&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a4720c275153144c20096dc2d85f93889">AES_STATUS_RESOURCE_UNAVAILABLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An error status code returned if the hardware or software resource is currently unavailable. </p>
<p>AESCBC driver implementations may have hardware or software limitations on how many clients can simultaneously perform operations. This status code is returned if the mutual exclusion mechanism signals that an operation cannot currently be performed. </p>

</div>
</div>
<a id="aa3ff5d2f23cdceb6652dbe490c6ec93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ff5d2f23cdceb6652dbe490c6ec93f">&sect;&nbsp;</a></span>AESCBC_STATUS_CANCELED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_CANCELED&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#aa8d5ff0dd5cde60089ac5d84cfb4a702">AES_STATUS_CANCELED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ongoing operation was canceled. </p>

</div>
</div>
<a id="a75fee21f079588cba1b516720b553f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fee21f079588cba1b516720b553f1a">&sect;&nbsp;</a></span>AESCBC_STATUS_FEATURE_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_FEATURE_NOT_SUPPORTED&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a671e5331015411e6db491d8eee23732c">AES_STATUS_FEATURE_NOT_SUPPORTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operation requested is not supported for now. </p>
<p>This code is returned by <a class="el" href="_a_e_s_c_b_c_8h.html#af8e25f2268d83629d9799a165bc7683c" title="Function to generate an initialization vector for an AES CBC segmented encryption operation...">AESCBC_generateIV()</a>, and internal generation of IVs isn't supported for now. Eventually, this function will make the TRNG generate the IV. </p>

</div>
</div>
<a id="adad2a122e8b54e8c2e0d1563ac1095a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad2a122e8b54e8c2e0d1563ac1095a7">&sect;&nbsp;</a></span>AESCBC_STATUS_KEYSTORE_INVALID_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_KEYSTORE_INVALID_ID&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#aeaab212abda07968840db525e114d1ae">AES_STATUS_KEYSTORE_INVALID_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operation tried to load a key from the keystore using an invalid key ID. </p>

</div>
</div>
<a id="a65047ed053730a6dee6332cd98fc377c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65047ed053730a6dee6332cd98fc377c">&sect;&nbsp;</a></span>AESCBC_STATUS_KEYSTORE_GENERIC_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_KEYSTORE_GENERIC_ERROR&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#a89e9ed71ffb10f4f6d5b52b8afbd4389">AES_STATUS_KEYSTORE_GENERIC_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The key store module returned a generic error. See key store documentation for additional details. </p>

</div>
</div>
<a id="adf65612b9131789ae5db3e3151473bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf65612b9131789ae5db3e3151473bbc">&sect;&nbsp;</a></span>AESCBC_STATUS_UNALIGNED_IO_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AESCBC_STATUS_UNALIGNED_IO_NOT_SUPPORTED&#160;&#160;&#160;<a class="el" href="_a_e_s_common_8h.html#ab367c0137dd8d9bda4107b1545bfdb12">AES_STATUS_UNALIGNED_IO_NOT_SUPPORTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operation does not support non-word-aligned input and/or output. </p>
<p>AESCBC driver implementations may have restrictions on the alignment of input/output data due to performance limitations of the hardware. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af5f0c2913e25511cc73288b1db71d6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f0c2913e25511cc73288b1db71d6e7">&sect;&nbsp;</a></span>AESCBC_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_a_e_s_common___config.html">AESCommon_Config</a> <a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7">AESCBC_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AESCBC Global configuration. </p>
<p>The <a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7" title="AESCBC Global configuration. ">AESCBC_Config</a> structure contains a set of pointers used to characterize the AESCBC driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="_a_e_s_c_b_c_8h.html#a72ae710de057086ca1d4e96f1a92a9a1" title="This function initializes the CBC module. ">AESCBC_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a72ae710de057086ca1d4e96f1a92a9a1" title="This function initializes the CBC module. ">AESCBC_init()</a> </dd></dl>

</div>
</div>
<a id="a4222a78a8c695fc2c97bbef11d28f04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4222a78a8c695fc2c97bbef11d28f04e">&sect;&nbsp;</a></span>AESCBC_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7">AESCBC_Config</a>* <a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from an <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> call. </p>

</div>
</div>
<a id="a4f412502b110e7046c203e23722aaa89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f412502b110e7046c203e23722aaa89">&sect;&nbsp;</a></span>AESCBC_Operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> <a class="el" href="_a_e_s_c_b_c_8h.html#a4f412502b110e7046c203e23722aaa89">AESCBC_Operation</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Define a typedef for deprecated operation AESCBC_Operation. Existing code should be refactored to use <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a single-step operat...">AESCBC_OneStepOperation</a>. This reference may be removed at some point in the future</dd></dl>

</div>
</div>
<a id="aa2bc486e0f51737928f21514715a537c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bc486e0f51737928f21514715a537c">&sect;&nbsp;</a></span>AESCBC_OperationUnion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_a_e_s_c_b_c___operation_union.html">AESCBC_OperationUnion</a>  <a class="el" href="union_a_e_s_c_b_c___operation_union.html">AESCBC_OperationUnion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union containing a reference to a one step or segmented operation. </p>

</div>
</div>
<a id="ad3c538c1ce2d9aa37bd538a90f278b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c538c1ce2d9aa37bd538a90f278b45">&sect;&nbsp;</a></span>AESCBC_CallbackFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* AESCBC_CallbackFxn) (<a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> handle, int_fast16_t returnValue, <a class="el" href="union_a_e_s_c_b_c___operation_union.html">AESCBC_OperationUnion</a> *operation, <a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959">AESCBC_OperationType</a> operationType)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the AESCBC driver when used in <a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5acedc995468fd1ad451c6aa24f56d456d">AESCBC_RETURN_BEHAVIOR_CALLBACK</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle of the client that started the CBC operation.</td></tr>
    <tr><td class="paramname">returnValue</td><td>The result of the CBC operation. May contain an error code. Informs the application of why the callback function was called.</td></tr>
    <tr><td class="paramname">operation</td><td>A pointer to an operation union.</td></tr>
    <tr><td class="paramname">operationType</td><td>This parameter determines which operation the callback refers to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a34f3e7f586935c9328167d1e03973af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f3e7f586935c9328167d1e03973af5">&sect;&nbsp;</a></span>AESCBC_ReturnBehavior</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5">AESCBC_ReturnBehavior</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The way in which CBC function calls return after performing an encryption or decryption operation. </p>
<p>Not all CBC operations exhibit the specified return behavior. Functions that do not require significant computation and cannot offload that computation to a background thread behave like regular functions. Which functions exhibit the specified return behavior is not implementation dependent. Specifically, a software-backed implementation run on the same CPU as the application will emulate the return behavior while not actually offloading the computation to the background thread.</p>
<p>AESCBC functions exhibiting the specified return behavior have restrictions on the context from which they may be called.</p>
<table class="doxtable">
<tr>
<th></th><th>Task </th><th>Hwi </th><th>Swi  </th></tr>
<tr>
<td>AESCBC_RETURN_BEHAVIOR_CALLBACK </td><td>X </td><td>X </td><td>X </td></tr>
<tr>
<td>AESCBC_RETURN_BEHAVIOR_BLOCKING </td><td>X </td><td></td><td></td></tr>
<tr>
<td>AESCBC_RETURN_BEHAVIOR_POLLING </td><td>X </td><td>X </td><td>X </td></tr>
</table>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34f3e7f586935c9328167d1e03973af5acedc995468fd1ad451c6aa24f56d456d"></a>AESCBC_RETURN_BEHAVIOR_CALLBACK&#160;</td><td class="fielddoc"><p>The function call will return immediately while the CBC operation goes on in the background. The registered callback function is called after the operation completes. The context the callback function is called (task, HWI, SWI) is implementation-dependent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34f3e7f586935c9328167d1e03973af5ad4cf399115e78f5253b12f88605d212e"></a>AESCBC_RETURN_BEHAVIOR_BLOCKING&#160;</td><td class="fielddoc"><p>The function call will block while the CBC operation goes on in the background. CBC operation results are available after the function returns. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34f3e7f586935c9328167d1e03973af5aeccf5cad47aac1edcef820125f7c361d"></a>AESCBC_RETURN_BEHAVIOR_POLLING&#160;</td><td class="fielddoc"><p>The function call will continuously poll a flag while CBC operation goes on in the background. CBC operation results are available after the function returns. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3d0b3dbc7f859b9d0c6acf102adb4d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0b3dbc7f859b9d0c6acf102adb4d39">&sect;&nbsp;</a></span>AESCBC_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_e_s_c_b_c_8h.html#a3d0b3dbc7f859b9d0c6acf102adb4d39">AESCBC_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for the direction of the CBC operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3d0b3dbc7f859b9d0c6acf102adb4d39a6937032fe648623f9b9a5f7b4dcce26a"></a>AESCBC_MODE_ENCRYPT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d0b3dbc7f859b9d0c6acf102adb4d39afacbd481470a984c92878b82c17a825c"></a>AESCBC_MODE_DECRYPT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a498551584800977637726dde45cd9959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498551584800977637726dde45cd9959">&sect;&nbsp;</a></span>AESCBC_OperationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_e_s_c_b_c_8h.html#a498551584800977637726dde45cd9959">AESCBC_OperationType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for the operation types supported by the driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a498551584800977637726dde45cd9959ae9f86ebbb5b543515e8cf4b63d533924"></a>AESCBC_OPERATION_TYPE_ENCRYPT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a498551584800977637726dde45cd9959a9c63c1a604a8ef68797d84bed9cf20a5"></a>AESCBC_OPERATION_TYPE_DECRYPT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a498551584800977637726dde45cd9959a28e1fd2ea29d9c7cdd2534686f50ec5b"></a>AESCBC_OP_TYPE_ONESTEP_ENCRYPT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a498551584800977637726dde45cd9959ad06b3a66a8906cbcdb2f21cb6ea57e89"></a>AESCBC_OP_TYPE_ONESTEP_DECRYPT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a498551584800977637726dde45cd9959a4d9d7bab075783ce371f817a1b4c0a37"></a>AESCBC_OP_TYPE_ENCRYPT_SEGMENTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a498551584800977637726dde45cd9959aa8e0e67a9f80b534073fc07030415085"></a>AESCBC_OP_TYPE_DECRYPT_SEGMENTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a498551584800977637726dde45cd9959a15314c3bc0356e0a1cea870ffc2f5075"></a>AESCBC_OP_TYPE_FINALIZE_ENCRYPT_SEGMENTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a498551584800977637726dde45cd9959a9fcc96b5e73a699498f3627085aa02cf"></a>AESCBC_OP_TYPE_FINALIZE_DECRYPT_SEGMENTED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a72ae710de057086ca1d4e96f1a92a9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ae710de057086ca1d4e96f1a92a9a1">&sect;&nbsp;</a></span>AESCBC_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESCBC_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the CBC module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The AESCBC_config structure must exist and be persistent before this function can be called. This function must also be called before any other CBC driver APIs. This function call does not modify any peripheral registers. </dd></dl>

</div>
</div>
<a id="a3c0ff1f31e58390f960f927f12756a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0ff1f31e58390f960f927f12756a98">&sect;&nbsp;</a></span>AESCBC_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESCBC_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="struct_a_e_s_c_b_c___params.html" title="CBC Parameters. ">AESCBC_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to <a class="el" href="struct_a_e_s_c_b_c___params.html" title="CBC Parameters. ">AESCBC_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: returnBehavior = AESCBC_RETURN_BEHAVIOR_BLOCKING callbackFxn = NULL timeout = SemaphoreP_WAIT_FOREVER custom = NULL </p>

</div>
</div>
<a id="ac4e418c0f71f339935513126d37fbc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e418c0f71f339935513126d37fbc9f">&sect;&nbsp;</a></span>AESCBC_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> AESCBC_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function opens a given CBC peripheral. </p>
<dl class="section pre"><dt>Precondition</dt><dd>CBC controller has been initialized using <a class="el" href="_a_e_s_c_b_c_8h.html#a72ae710de057086ca1d4e96f1a92a9a1" title="This function initializes the CBC module. ">AESCBC_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Logical peripheral number for the CBC indexed into the AESCBC_config table</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to an parameter block, if NULL it will use default values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e" title="A handle that is returned from an AESCBC_open() call. ">AESCBC_Handle</a> on success or a NULL on an error or if it has been opened already.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a72ae710de057086ca1d4e96f1a92a9a1" title="This function initializes the CBC module. ">AESCBC_init()</a> </dd>
<dd>
<a class="el" href="_a_e_s_c_b_c_8h.html#a3189993c935516a40c09110092e6ef19" title="Function to close a CBC peripheral specified by the CBC handle. ">AESCBC_close()</a> </dd></dl>

</div>
</div>
<a id="a3189993c935516a40c09110092e6ef19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3189993c935516a40c09110092e6ef19">&sect;&nbsp;</a></span>AESCBC_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESCBC_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a CBC peripheral specified by the CBC handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> </dd></dl>

</div>
</div>
<a id="a0864488e0826602937308930ab60e200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0864488e0826602937308930ab60e200">&sect;&nbsp;</a></span>AESCBC_Operation_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESCBC_Operation_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4f412502b110e7046c203e23722aaa89">AESCBC_Operation</a> *&#160;</td>
          <td class="paramname"><em>operationStruct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize an <a class="el" href="_a_e_s_c_b_c_8h.html#a4f412502b110e7046c203e23722aaa89">AESCBC_Operation</a> struct to its defaults. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This function should be replaced by calls to operation-specific init functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operationStruct</td><td>A pointer to an <a class="el" href="_a_e_s_c_b_c_8h.html#a4f412502b110e7046c203e23722aaa89">AESCBC_Operation</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are all zeros. </p>

</div>
</div>
<a id="a6715fbb822cc1ef0b60869588f60f7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6715fbb822cc1ef0b60869588f60f7e2">&sect;&nbsp;</a></span>AESCBC_OneStepOperation_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESCBC_OneStepOperation_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> *&#160;</td>
          <td class="paramname"><em>operationStruct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize an <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a single-step operat...">AESCBC_OneStepOperation</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operationStruct</td><td>A pointer to an <a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a single-step operat...">AESCBC_OneStepOperation</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are all zeros. </p>

</div>
</div>
<a id="a6b97cc99a27c2c2f20defb663d6eca26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b97cc99a27c2c2f20defb663d6eca26">&sect;&nbsp;</a></span>AESCBC_SegmentedOperation_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESCBC_SegmentedOperation_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> *&#160;</td>
          <td class="paramname"><em>operationStruct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize an <a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a segmented operatio...">AESCBC_SegmentedOperation</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operationStruct</td><td>A pointer to an <a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a segmented operatio...">AESCBC_SegmentedOperation</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are all zeros. </p>

</div>
</div>
<a id="af3cf6e72eacee43c28450dad9dc3f046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cf6e72eacee43c28450dad9dc3f046">&sect;&nbsp;</a></span>AESCBC_oneStepEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_oneStepEncrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> *&#160;</td>
          <td class="paramname"><em>operationStruct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to perform an AESCBC encryption operation in one call. </p>
<dl class="section note"><dt>Note</dt><dd>None of the buffers provided as arguments may be altered by the application during an ongoing operation. Doing so can yield corrupted ciphertext.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a>, and <a class="el" href="_a_e_s_c_b_c_8h.html#a6715fbb822cc1ef0b60869588f60f7e2" title="Function to initialize an AESCBC_OneStepOperation struct to its defaults. ">AESCBC_OneStepOperation_init()</a> must be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle returned from <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operationStruct</td><td>A pointer to a struct containing the parameters required to perform the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>The operation succeeded. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The operation failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#ad92a5502a5a56aaf28b7d930be275271" title="An error status code returned if the hardware or software resource is currently unavailable. ">AESCBC_STATUS_RESOURCE_UNAVAILABLE</a></td><td>The required hardware resource was not available. Try again later. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#adf65612b9131789ae5db3e3151473bbc" title="The operation does not support non-word-aligned input and/or output. ">AESCBC_STATUS_UNALIGNED_IO_NOT_SUPPORTED</a></td><td>The input and/or output buffer were not word-aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a3e603f77710ad26615805f9bb27672d3" title="Function to perform an AESCBC decryption operation in one call. ">AESCBC_oneStepDecrypt()</a> </dd></dl>

</div>
</div>
<a id="a3e603f77710ad26615805f9bb27672d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e603f77710ad26615805f9bb27672d3">&sect;&nbsp;</a></span>AESCBC_oneStepDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_oneStepDecrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_e_s_c_b_c___one_step_operation.html">AESCBC_OneStepOperation</a> *&#160;</td>
          <td class="paramname"><em>operationStruct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to perform an AESCBC decryption operation in one call. </p>
<dl class="section note"><dt>Note</dt><dd>None of the buffers provided as arguments may be altered by the application during an ongoing operation. Doing so can yield corrupted plaintext.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a>, and <a class="el" href="_a_e_s_c_b_c_8h.html#a6715fbb822cc1ef0b60869588f60f7e2" title="Function to initialize an AESCBC_OneStepOperation struct to its defaults. ">AESCBC_OneStepOperation_init()</a> must be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle returned from <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operationStruct</td><td>A pointer to a struct containing the parameters required to perform the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>The operation succeeded. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The operation failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#ad92a5502a5a56aaf28b7d930be275271" title="An error status code returned if the hardware or software resource is currently unavailable. ">AESCBC_STATUS_RESOURCE_UNAVAILABLE</a></td><td>The required hardware resource was not available. Try again later. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#adf65612b9131789ae5db3e3151473bbc" title="The operation does not support non-word-aligned input and/or output. ">AESCBC_STATUS_UNALIGNED_IO_NOT_SUPPORTED</a></td><td>The input and/or output buffer were not word-aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#af3cf6e72eacee43c28450dad9dc3f046" title="Function to perform an AESCBC encryption operation in one call. ">AESCBC_oneStepEncrypt()</a> </dd></dl>

</div>
</div>
<a id="a5e3356cffdfd0671cdefb1aa11a97bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3356cffdfd0671cdefb1aa11a97bca">&sect;&nbsp;</a></span>AESCBC_setupEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_setupEncrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_crypto_key.html">CryptoKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to prepare a segmented AESCBC encryption operation. </p>
<p>This function sets up a segmented AESCBC encryption operation.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle returned from <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a previously initialized <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>The operation succeeded. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a1a32ec040a89052bf3f6e08ddb5657e2" title="Function to set an initialization vector for an AES CBC segmented operation. ">AESCBC_setIV()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#af8e25f2268d83629d9799a165bc7683c" title="Function to generate an initialization vector for an AES CBC segmented encryption operation...">AESCBC_generateIV()</a> </dd></dl>

</div>
</div>
<a id="a144ccb3985ceeee03b370d68dd1ea4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ccb3985ceeee03b370d68dd1ea4b2">&sect;&nbsp;</a></span>AESCBC_setupDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_setupDecrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_crypto_key.html">CryptoKey</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to prepare a segmented AESCBC decryption operation. </p>
<p>This function sets up a segmented AESCBC decryption operation.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle returned from <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a previously initialized <a class="el" href="struct_crypto_key.html" title="CryptoKey datastructure. ">CryptoKey</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>The operation succeeded. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a1a32ec040a89052bf3f6e08ddb5657e2" title="Function to set an initialization vector for an AES CBC segmented operation. ">AESCBC_setIV()</a> </dd></dl>

</div>
</div>
<a id="a1a32ec040a89052bf3f6e08ddb5657e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a32ec040a89052bf3f6e08ddb5657e2">&sect;&nbsp;</a></span>AESCBC_setIV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_setIV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ivLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set an initialization vector for an AES CBC segmented operation. </p>
<p>This function sets up a segmented AESCBC encryption or decryption operation.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a5e3356cffdfd0671cdefb1aa11a97bca" title="Function to prepare a segmented AESCBC encryption operation. ">AESCBC_setupEncrypt()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a144ccb3985ceeee03b370d68dd1ea4b2" title="Function to prepare a segmented AESCBC decryption operation. ">AESCBC_setupDecrypt()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle returned from <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Pointer to the buffer containing the initialization vector</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ivLength</td><td>The length of the initialization vector. The length of the IV buffer must be 16 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>The operation succeeded. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8" title="Encrypts or decrypts a segment of data defined by the AESCBC_SegmentedOperation struct. ">AESCBC_addData()</a> </dd></dl>

</div>
</div>
<a id="af8e25f2268d83629d9799a165bc7683c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e25f2268d83629d9799a165bc7683c">&sect;&nbsp;</a></span>AESCBC_generateIV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_generateIV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ivSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ivLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to generate an initialization vector for an AES CBC segmented encryption operation. </p>
<p>This function sets up a segmented AESCBC encryption operation.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a5e3356cffdfd0671cdefb1aa11a97bca" title="Function to prepare a segmented AESCBC encryption operation. ">AESCBC_setupEncrypt()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle returned from <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Pointer to a buffer to write the generated initialization vector to</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ivSize</td><td>Size of the buffer pointed to by iv. This buffer must be 16 bytes long for AES CBC mode.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ivLength</td><td>The length of the initialization vector actually written if the operation was successful.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>The operation succeeded. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The operation failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a75fee21f079588cba1b516720b553f1a" title="The operation requested is not supported for now. ">AESCBC_STATUS_FEATURE_NOT_SUPPORTED</a></td><td>The operation is not supported in this device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8" title="Encrypts or decrypts a segment of data defined by the AESCBC_SegmentedOperation struct. ">AESCBC_addData()</a> </dd></dl>

</div>
</div>
<a id="ab3f6ed48e40f396b1f99f071d74652c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6ed48e40f396b1f99f071d74652c8">&sect;&nbsp;</a></span>AESCBC_addData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_addData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypts or decrypts a segment of data defined by the <a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html" title="Struct containing the parameters required for encrypting/decrypting a message in a segmented operatio...">AESCBC_SegmentedOperation</a> struct. </p>
<p><a class="el" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8" title="Encrypts or decrypts a segment of data defined by the AESCBC_SegmentedOperation struct. ">AESCBC_addData()</a> may be called an arbitrary number times before finishing the operation with <a class="el" href="_a_e_s_c_b_c_8h.html#a2e0e343511ed0d1ca298b22a09fc36a6" title="Finalize the AES operation. If new data needs to be added, inputLength will be used to govern how man...">AESCBC_finalize()</a>.</p>
<p>This function returns according to the return behavior set when opening the driver.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a5e3356cffdfd0671cdefb1aa11a97bca" title="Function to prepare a segmented AESCBC encryption operation. ">AESCBC_setupEncrypt()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a144ccb3985ceeee03b370d68dd1ea4b2" title="Function to prepare a segmented AESCBC decryption operation. ">AESCBC_setupDecrypt()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle returned from <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operation</td><td>Pointer to a segmented CBC operation structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>The operation succeeded. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The operation failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#ad92a5502a5a56aaf28b7d930be275271" title="An error status code returned if the hardware or software resource is currently unavailable. ">AESCBC_STATUS_RESOURCE_UNAVAILABLE</a></td><td>The required hardware resource was not available. Try again later. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#adf65612b9131789ae5db3e3151473bbc" title="The operation does not support non-word-aligned input and/or output. ">AESCBC_STATUS_UNALIGNED_IO_NOT_SUPPORTED</a></td><td>The input and/or output buffer were not word-aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8" title="Encrypts or decrypts a segment of data defined by the AESCBC_SegmentedOperation struct. ">AESCBC_addData()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a2e0e343511ed0d1ca298b22a09fc36a6" title="Finalize the AES operation. If new data needs to be added, inputLength will be used to govern how man...">AESCBC_finalize()</a> </dd></dl>

</div>
</div>
<a id="a2e0e343511ed0d1ca298b22a09fc36a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0e343511ed0d1ca298b22a09fc36a6">&sect;&nbsp;</a></span>AESCBC_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_e_s_c_b_c___segmented_operation.html">AESCBC_SegmentedOperation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize the AES operation. If new data needs to be added, <code>inputLength</code> will be used to govern how many bytes will be written. New data must be a multiple of a block length, 16 bytes, or 0 if no new data needs to be added. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#ab3f6ed48e40f396b1f99f071d74652c8" title="Encrypts or decrypts a segment of data defined by the AESCBC_SegmentedOperation struct. ">AESCBC_addData()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A CBC handle returned from <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a> or <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operation</td><td>Pointer to a segmented CBC operation structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>In <a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5ad4cf399115e78f5253b12f88605d212e">AESCBC_RETURN_BEHAVIOR_BLOCKING</a> and <a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5aeccf5cad47aac1edcef820125f7c361d">AESCBC_RETURN_BEHAVIOR_POLLING</a>, this means the CBC was generated successfully. In <a class="el" href="_a_e_s_c_b_c_8h.html#a34f3e7f586935c9328167d1e03973af5acedc995468fd1ad451c6aa24f56d456d">AESCBC_RETURN_BEHAVIOR_CALLBACK</a>, this means the operation started successfully. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The operation failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#ad92a5502a5a56aaf28b7d930be275271" title="An error status code returned if the hardware or software resource is currently unavailable. ">AESCBC_STATUS_RESOURCE_UNAVAILABLE</a></td><td>The required hardware resource was not available. Try again later. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#adf65612b9131789ae5db3e3151473bbc" title="The operation does not support non-word-aligned input and/or output. ">AESCBC_STATUS_UNALIGNED_IO_NOT_SUPPORTED</a></td><td>The input and/or output buffer were not word-aligned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a807f254a97d04e2b8e2c73d026d3c81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807f254a97d04e2b8e2c73d026d3c81a">&sect;&nbsp;</a></span>AESCBC_cancelOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESCBC_cancelOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels an ongoing AESCBC operation. </p>
<p>Asynchronously cancels an AESCBC operation. Only available when using AESCBC_RETURN_BEHAVIOR_CALLBACK. The operation will terminate as though an error occurred. The return status code of the operation will be AESCBC_STATUS_CANCELED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle of the operation to cancel</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a0bcb271aa7f9aee37469d242670b6d9d" title="Successful status code. ">AESCBC_STATUS_SUCCESS</a></td><td>The operation was canceled or the operation had already completed. </td></tr>
    <tr><td class="paramname"><a class="el" href="_a_e_s_c_b_c_8h.html#a114c760826307af69a93538773a58185" title="Generic error status code. ">AESCBC_STATUS_ERROR</a></td><td>The IV buffer was not properly cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cab3841802fa8f8cb8d19993d25e88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cab3841802fa8f8cb8d19993d25e88d">&sect;&nbsp;</a></span>AESCBC_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e">AESCBC_Handle</a> AESCBC_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7">AESCBC_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new AESCBC object. </p>
<p>Unlike <a class="el" href="_a_e_s_c_b_c_8h.html#ac4e418c0f71f339935513126d37fbc9f" title="This function opens a given CBC peripheral. ">AESCBC_open()</a>, <a class="el" href="_a_e_s_c_b_c_8h.html#a0cab3841802fa8f8cb8d19993d25e88d" title="Constructs a new AESCBC object. ">AESCBC_construct()</a> does not require the hwAttrs and object to be allocated in a <a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7" title="AESCBC Global configuration. ">AESCBC_Config</a> array that is indexed into. Instead, the <a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7" title="AESCBC Global configuration. ">AESCBC_Config</a>, hwAttrs, and object can be allocated at any location. This allows for relatively simple run-time allocation of temporary driver instances on the stack or the heap. The drawback is that this makes it more difficult to write device-agnostic code. If you use an ifdef with DeviceFamily, you can choose the correct object and hwAttrs to allocate. That compilation unit will be tied to the device it was compiled for at this point. To change devices, recompilation of the application with a different DeviceFamily setting is necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td><a class="el" href="_a_e_s_c_b_c_8h.html#af5f0c2913e25511cc73288b1db71d6e7" title="AESCBC Global configuration. ">AESCBC_Config</a> describing the location of the object and hwAttrs.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td><a class="el" href="struct_a_e_s_c_b_c___params.html" title="CBC Parameters. ">AESCBC_Params</a> to configure the driver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="_a_e_s_c_b_c_8h.html#a4222a78a8c695fc2c97bbef11d28f04e" title="A handle that is returned from an AESCBC_open() call. ">AESCBC_Handle</a> on success or NULL on failure.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The object struct <code>config</code> points to must be zeroed out prior to calling this function. Otherwise, unexpected behavior may ensue. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a65d438667291f32d79714a3b24b7e9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d438667291f32d79714a3b24b7e9bb">&sect;&nbsp;</a></span>AESCBC_defaultParams</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_e_s_c_b_c___params.html">AESCBC_Params</a> AESCBC_defaultParams</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default <a class="el" href="struct_a_e_s_c_b_c___params.html" title="CBC Parameters. ">AESCBC_Params</a> structure. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_c_b_c_8h.html#a3c0ff1f31e58390f960f927f12756a98" title="Function to initialize the AESCBC_Params struct to its defaults. ">AESCBC_Params_init()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
