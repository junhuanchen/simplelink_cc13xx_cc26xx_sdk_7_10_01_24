<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>WatchdogCC26XX.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_15fb9a92674a5e15cac1f3112cfb19ae.html">drivers</a></li><li class="navelem"><a class="el" href="dir_54075f58727e0bc55072f0189f7b8fda.html">watchdog</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">WatchdogCC26XX.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Watchdog driver implementation for CC13XX/CC26XX. </p>
<hr/>
<h1>Driver include</h1>
<p>The Watchdog header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_watchdog_8h.html">ti/drivers/Watchdog.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_watchdog_c_c26_x_x_8h.html">ti/drivers/watchdog/WatchdogCC26XX.h</a>&gt;</span></div></div><!-- fragment --><p>Refer to <a class="el" href="_watchdog_8h.html">Watchdog.h</a> for a complete description of APIs.</p>
<h1>Overview</h1>
<p>The general Watchdog API should be used in application code, i.e. <a class="el" href="_watchdog_8h.html#a26795f67f599b74de830ca7bf36bdced" title="Opens a Watchdog. ">Watchdog_open()</a> should be used instead of WatchdogCC26XX_open(). The board file will define the device specific config, and casting in the general API will ensure that the correct device specific functions are called.</p>
<h1>General Behavior</h1>
<p>This Watchdog driver implementation is designed to operate on a CC13XX/CC26XX device. Before using the Watchdog in CC13XX/CC26XX, the Watchdog driver is initialized by calling <a class="el" href="_watchdog_8h.html#afaadfb59be17661ae95562f2081355e7" title="Initializes the Watchdog module. ">Watchdog_init()</a>. The Watchdog HW is configured by calling <a class="el" href="_watchdog_8h.html#a26795f67f599b74de830ca7bf36bdced" title="Opens a Watchdog. ">Watchdog_open()</a>. Once opened, the Watchdog will count down from the reload value specified in <a class="el" href="struct_watchdog_c_c26_x_x___h_w_attrs.html" title="Watchdog hardware attributes for CC26XX. ">WatchdogCC26XX_HWAttrs</a>. If it times out, a non-maskable interrupt will be triggered, the Watchdog interrupt flag will be set, and a user-provided callback function will be called. If reset is enabled in the <a class="el" href="struct_watchdog___params.html" title="Watchdog Parameters. ">Watchdog_Params</a> and the Watchdog timer is allowed to time out again while the interrupt flag is still pending, a reset signal will be generated. To prevent a reset, <a class="el" href="_watchdog_8h.html#a396decd6b1807db10c636f9987c3be4c" title="Clears the Watchdog. ">Watchdog_clear()</a> must be called to clear the interrupt flag and to reload the timer.</p>
<p>The Watchdog counts down at a rate of the device clock SCLK_HF (48 MHz) divided by a fixed-division ratio of 32, which equals to 1.5 MHz. The Watchdog rate will change if SCLK_HF deviates from 48 MHz.</p>
<dl class="section note"><dt>Note</dt><dd>The Watchdog interrupt is configured as a non-maskable interrupt (NMI) and the user-defined callback function is called in the context of NMI. Because the Watchdog interrupt is non-maskable, it is not safe to call any BIOS APIs from the Watchdog callback function. Calls to DPL and TIDRIVERS APIs should also be avoided given that they may indirectly make calls to BIOS APIs. Furthermore, the watchdog callback should only be reached if the watchdog times out. This should indicate an error event and allow logging or other housekeeping before resetting the device. Clearing of the watchdog and checking alive signals should be done in another execution context.</dd></dl>
<p>The reload value from which the Watchdog timer counts down may be changed during runtime using <a class="el" href="_watchdog_8h.html#a63ea82dda83e42e236578b9810e56880" title="Sets the Watchdog reload value. ">Watchdog_setReload()</a>. This value should be specified in Watchdog clock ticks and should not exceed the maximum value of 32 bits, which corresponds to a timeout period of 2863.3 seconds at the Watchdog rate of 1.5 MHz. If the reload value is set to zero, the Watchdog interrupt is immediately generated.</p>
<p>Since the device is not reset on the first Watchdog timeout, the maximum time lapse between the time when the device gets locked up and the time when it is reset can be up to <b>two</b> Watchdog timeout periods.</p>
<p><a class="el" href="_watchdog_8h.html#a1c0dfea7011b06f303d01afb631ffbdd" title="Function to close a Watchdog peripheral specified by the Watchdog handle.It stops (holds) the Watchdo...">Watchdog_close()</a> is <b>not</b> supported by this driver implementation. Once started, the Watchdog timer can only be stopped by a hardware reset.</p>
<p><b>No</b> CC13XX/CC26XX specific command has been implemented. Any call to <a class="el" href="_watchdog_8h.html#a513c121c62f277318a7c35b0b2bdc869" title="Function performs implementation specific features on a given Watchdog_Handle. ">Watchdog_control()</a> will receive the return code Watchdog_STATUS_UNDEFINEDCMD.</p>
<p>By default the Watchdog driver has reset enabled. However, it may be disabled in the <a class="el" href="struct_watchdog___params.html" title="Watchdog Parameters. ">Watchdog_Params</a> which allows the Watchdog Timer to be used like another timer interrupt. This functionality is <b>not</b> supported by all platforms, refer to device specific documentation for details.</p>
<h1>Power Management</h1>
<p>Once started, the Watchdog will keep running in Active or Idle mode. When the device enters Standby mode, the Watchdog timer will stop counting down but the counter value will be preserved. When the device wakes up from Standby, the Watchdog timer will continue to count down from the previous counter value.</p>
<p>This means that if a system goes into Standby 50% of the time and the Watchdog reload value is set to 1 second, the Watchdog timer will actually time out in 2 seconds. A system which is only in Active/Idle mode for 1% of the time, the Watchdog timer will time out in 100 seconds. However, if a bug locks up the application in Active mode, the Watchdog timer will time out in the configured time.</p>
<h1>Supported Functions</h1>
<p>| Generic API Function | API Function | Description | |---------------------------&mdash; |-------------------------------&mdash; |------------------------------------------------&mdash;| | <a class="el" href="_watchdog_8h.html#afaadfb59be17661ae95562f2081355e7" title="Initializes the Watchdog module. ">Watchdog_init()</a> | WatchdogCC26XX_init() | Initialize Watchdog driver | | <a class="el" href="_watchdog_8h.html#a26795f67f599b74de830ca7bf36bdced" title="Opens a Watchdog. ">Watchdog_open()</a> | WatchdogCC26XX_open() | Initialize Watchdog HW and set system dependencies| | <a class="el" href="_watchdog_8h.html#a396decd6b1807db10c636f9987c3be4c" title="Clears the Watchdog. ">Watchdog_clear()</a> | WatchdogCC26XX_clear() | Clear Watchdog interrupt flag and reload counter | | <a class="el" href="_watchdog_8h.html#a63ea82dda83e42e236578b9810e56880" title="Sets the Watchdog reload value. ">Watchdog_setReload()</a> | WatchdogCC26XX_setReload() | Set Watchdog timer reload value in clock ticnks | | <a class="el" href="_watchdog_8h.html#a7b93cd0bd3a6f11aa28b0c7219755979" title="Converts milliseconds to Watchdog clock ticks. ">Watchdog_convertMsToTicks()</a> | WatchdogCC26XX_convertMsToTicks() | Converts milliseconds to clock ticks |</p>
<dl class="section note"><dt>Note</dt><dd>All calls should go through the generic API. Please refer to <a class="el" href="_watchdog_8h.html">Watchdog.h</a> for a complete description of the generic APIs.</dd></dl>
<h1>Use Cases</h1>
<h2>Basic Watchdog</h2>
<p>In this basic watchdog example, the application is expected to define a Watchdog callback function and start the Watchdog timer by calling <a class="el" href="_watchdog_8h.html#a26795f67f599b74de830ca7bf36bdced" title="Opens a Watchdog. ">Watchdog_open()</a>. If needed, <a class="el" href="_watchdog_8h.html#a63ea82dda83e42e236578b9810e56880" title="Sets the Watchdog reload value. ">Watchdog_setReload()</a> may be called to change the timeout period. If all monitored tasks are doing alright, <a class="el" href="_watchdog_8h.html#a396decd6b1807db10c636f9987c3be4c" title="Clears the Watchdog. ">Watchdog_clear()</a> should be called regularly to reload the counter so as to restart the timeout period and to avoid the Watchdog interrupt being triggered. If the <a class="el" href="_watchdog_8h.html#a396decd6b1807db10c636f9987c3be4c" title="Clears the Watchdog. ">Watchdog_clear()</a> is missed and the Watchdog timer is allowed to timeout, the user-defined callback function is called. In this function, the user may do whatever is appropriate for the application. Here are some suggestions:</p><ul>
<li>do nothing so that the timer will timeout again and trigger the reset</li>
<li>immediately reset the device</li>
<li>do self-test to check the integrity of the application</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The Watchdog interrupt is configured as a non-maskable interrupt (NMI) and the user-defined callback function is called in NMI context. Therefore it is not safe to call any OS APIs from the Watchdog callback function. This includes any driver calls that rely on OS APIs.</dd></dl>
<p>The following code example shows how to define the callback function and to start the Watchdog timer. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> watchdogCallback(uintptr_t handle);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Watchdog_Handle handle;</div><div class="line"><a class="code" href="struct_watchdog___params.html">Watchdog_Params</a> <a class="code" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>;</div><div class="line">uint32_t tickValue;</div><div class="line"></div><div class="line"><a class="code" href="_watchdog_8h.html#a6a6f54cfdac33d3bf33464a212262afc">Watchdog_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_watchdog___params.html#a710aaa2504356ab3d3f9a27ac19ddb85">callbackFxn</a> = watchdogCallback;</div><div class="line">handle = <a class="code" href="_watchdog_8h.html#a26795f67f599b74de830ca7bf36bdced">Watchdog_open</a>(Watchdog_configIndex, &amp;params);</div><div class="line"><span class="comment">// set timeout period to 100 ms</span></div><div class="line">tickValue = <a class="code" href="_watchdog_8h.html#a7b93cd0bd3a6f11aa28b0c7219755979">Watchdog_convertMsToTicks</a>(handle, 100);</div><div class="line"><a class="code" href="_watchdog_8h.html#a63ea82dda83e42e236578b9810e56880">Watchdog_setReload</a>(handle, tickValue);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">void watchdogCallback(uintptr_t handle)</div><div class="line">{</div><div class="line">    <span class="comment">// User-defined code here</span></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --> </div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_watchdog_8h_source.html">ti/drivers/Watchdog.h</a>&gt;</code><br />
<code>#include &lt;ti/drivers/dpl/HwiP.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for WatchdogCC26XX.h:</div>
<div class="dyncontent">
<div class="center"><img src="_watchdog_c_c26_x_x_8h__incl.png" border="0" usemap="#_watchdog_c_c26_x_x_8h" alt=""/></div>
<map name="_watchdog_c_c26_x_x_8h" id="_watchdog_c_c26_x_x_8h">
<area shape="rect" id="node4" href="_watchdog_8h.html" title="Watchdog driver interface. " alt="" coords="129,80,289,107"/>
</map>
</div>
</div>
<p><a href="_watchdog_c_c26_x_x_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_watchdog_c_c26_x_x___h_w_attrs.html">WatchdogCC26XX_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog hardware attributes for CC26XX.  <a href="struct_watchdog_c_c26_x_x___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_watchdog_c_c26_x_x___object.html">WatchdogCC26XX_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog Object for CC26XX.  <a href="struct_watchdog_c_c26_x_x___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1f60b940055d37c5bf8545499e948ca3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_watchdog___fxn_table.html">Watchdog_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_watchdog_c_c26_x_x_8h.html#a1f60b940055d37c5bf8545499e948ca3">WatchdogCC26XX_fxnTable</a></td></tr>
<tr class="memdesc:a1f60b940055d37c5bf8545499e948ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog function table for CC26XX.  <a href="#a1f60b940055d37c5bf8545499e948ca3">More...</a><br /></td></tr>
<tr class="separator:a1f60b940055d37c5bf8545499e948ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1f60b940055d37c5bf8545499e948ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f60b940055d37c5bf8545499e948ca3">&sect;&nbsp;</a></span>WatchdogCC26XX_fxnTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_watchdog___fxn_table.html">Watchdog_FxnTable</a> WatchdogCC26XX_fxnTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Watchdog function table for CC26XX. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2023</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
